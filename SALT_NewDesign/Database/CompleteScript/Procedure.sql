SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[GetNextReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [GetNextReport]

AS
BEGIN

SET NOCOUNT ON
DECLARE @ScheduleID int
SELECT @ScheduleID = MIN (ScheduleID)
  FROM tblReportSchedule
  WHERE ((LastRun IS NULL) AND ReportStartDate < GETUTCDATE())
  OR ((ReportFrequencyPeriod=''Y'') AND (GETUTCDATE() < DATEADD(YEAR,ReportFrequency,LastRun)))
  OR  ((ReportFrequencyPeriod=''M'') AND (GETUTCDATE() < DATEADD(MONTH,ReportFrequency,LastRun)))
  OR  ((ReportFrequencyPeriod=''W'') AND (GETUTCDATE() < DATEADD(WEEK,ReportFrequency,LastRun)))
  OR  ((ReportFrequencyPeriod=''D'') AND (GETUTCDATE() < DATEADD(DAY,ReportFrequency,LastRun)))
  
UPDATE tblReportSchedule SET LastRun = GETUTCDATE() WHERE ScheduleID = @ScheduleID 
  
SET NOCOUNT OFF
SELECT TOP (1) [ScheduleID]
      ,[UserID]
      ,[ReportID]
      ,[LastRun]
      ,[ReportDuration]
      ,[ReportDurationPeriod]
      ,[ReportStartDate]
      ,[ReportFrequency]
      ,[ReportFrequencyPeriod]
      ,[DocumentType]
      ,[ParamOrganisationID]
      ,[ParamCompleted]
      ,[ParamStatus]
      ,[ParamFailCount]
      ,[ParamCourseIDs]
      ,[ParamHistoricCourseIDs]
      ,[ParamAllUnits]
      ,[ParamTimeExpired]
      ,[ParamTimeExpiredPeriod]
      ,[ParamQuizStatus]
      ,[ParamGroupBy]
      ,[ParamGroupingOption]
      ,[ParamFirstName]
      ,[ParamLastName]
      ,[ParamUserName]
      ,[ParamEmail]
      ,[ParamIncludeInactive]
      ,[ParamSubject]
      ,[ParamBody]
      ,[ParamProfileID]
      ,[ParamOnlyUsersWithShortfall]
      ,[ParamEffectiveDate]
      ,[ParamSortBy]
      ,[ParamClassificationID]
  FROM tblReportSchedule
  WHERE ScheduleID = @ScheduleID 
  
  END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[GetPoliciesAssignedToUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary:		Compiles a %POLICY_NAMES% block and returns it with a bunch of user info for sending email to that user
				(Mainly just returns a list of users and the policies that they are assigned to (that meet the flagged conditions))

Parameters:		Comma separated list of userID:courseID
Returns:		table (lastname nvarchar(50), firstname nvarchar(50), userid int, email nvarchar(100), policy_name varchar(8000))
		
Called By:		BusinessServices.{Policy.prcPolicy_GetUsersByPolicyAndUnit in Policy.cs
Calls:			None

Remarks:		None

Author:			Mark Donald (John R copied prcCourse_UserMashup - no optimising attempted as execution time expected to be small)
Date Created:	13 Nov 2009 (copied 18/05/2010)

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	
*/

CREATE PROCEDURE [GetPoliciesAssignedToUsers]
	@policy_ids varchar(8000),
	@user_ids varchar(8000),
	@accepted varchar (20)
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @policies TABLE (policyid int)
	DECLARE @selected_units TABLE (unitid int)
	DECLARE @result TABLE (firstname nvarchar(50), lastname nvarchar(50), userid int, email nvarchar(100), new_policy_names varchar(8000), modified_policy_names varchar(8000), HierarchyName nvarchar(500))
	DECLARE
		@pos int,
		@colon_pos int,
		@temp varchar(50),
		@userid int,
		@new_policy_names varchar(8000),
		@modified_policy_names varchar(8000),
		@strAccepted varchar(5)



	IF @accepted = ''0''
	BEGIN
		SELECT @strAccepted = ''True''
	END
	ELSE
	BEGIN
		SELECT @strAccepted = ''False''
	END

	
	
	-- rip the user selection
	INSERT INTO @selected_units
		SELECT
			*
			FROM
				dbo.udfCsvToInt(@user_ids)

	-- clean up the input so it resembles ''userid:policyid,userid:policyid,''
	SELECT @policy_ids = replace(rtrim(ltrim(replace(replace(replace(@policy_ids,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''

	-- rip the policies into a table
	INSERT INTO @policies
		SELECT
			*
			FROM
				dbo.udfCsvToInt(@policy_ids)
	-- Note to self: String operations take hundreds of times longer than cursor operations so first think of a way to limit the number of string operations, then get rid of the cursors.
	SELECT @new_policy_names = ''''
	SELECT @modified_policy_names = ''''
	DECLARE concatenator CURSOR READ_ONLY FOR
		SELECT DISTINCT
			usr.userid
			FROM
				@policies pols 
				INNER JOIN tblUserPolicyAccess polacs ON polacs.policyid = pols.policyid AND polacs.granted = ''True''
				INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
				INNER JOIN tblUser usr ON usr.userid = polacs.userid AND usr.userid = polacd.userid AND usr.active = ''True'' 
				INNER JOIN @selected_units su ON usr.unitid = su.unitid 
	OPEN concatenator
	FETCH NEXT FROM concatenator INTO @userid
	WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT
				@new_policy_names = @new_policy_names + [PolicyName] + char(13) + char(10) + char(9)
				FROM
					tblpolicy pol 
					INNER JOIN @policies pols ON	pol.policyid = pols.policyid
					INNER JOIN tblUserPolicyAccess polacc ON polacc.policyid = pol.policyid AND polacc.granted = ''True''
					INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
					INNER JOIN tblUser usr ON usr.userid = polacc.userid AND usr.active = ''True'' AND usr.userid = @userid

			SELECT @new_policy_names = substring(@new_policy_names, 1, len(@new_policy_names) - 3)

			INSERT INTO
				@result
				SELECT
					usr.lastname, usr.firstname, usr.userid, usr.email, @new_policy_names, @modified_policy_names, hier.HierarchyName
					FROM
						tbluser usr
						INNER JOIN tblUnitHierarchy hier ON hier.UnitID = usr.UnitID 
					WHERE
						userid = @userid
			SELECT @new_policy_names = ''''
			SELECT @modified_policy_names = ''''
			FETCH NEXT FROM concatenator INTO @userid
		END
	CLOSE concatenator
	DEALLOCATE concatenator


	--Get Data in report format
	SELECT 
		DISTINCT UserID, HierarchyName, LastName, FirstName,  email, new_policy_names, modified_policy_names 

 FROM @result
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAppConfig_GetList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Get a list of application configuration
Parameters:
Returns:

Called By:
Calls:

Remarks:

Author: Jack Liu
Date Created: 24th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcAppConfig_GetList]
As

Set Nocount On

Select
Name,
Value
From
tblAppConfig
order by Name





' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAppConfig_GetMailServices]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Get mail services 
Parameters:
Returns:

Called By:
Calls:

Remarks:

Author: VDL
Date Created: 04 Jan 2012

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

create Procedure [prcAppConfig_GetMailServices]
As
begin 

	Set Nocount On

	Select
		Name,
		Value
	From
		tblAppConfig
	where 
		Name like ''MailService_%''

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAppConfig_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Updates configuration details.

Parameters:


Returns:
None

Called By:
AppConfig.cs

Calls:
None

Remarks:
Exception:
0. Succeed
1. RecordNotFoundException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Jack Liu
Date Created: 24th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcAppConfig_Update]
(
@name nVarchar(50),
@value nvarchar(4000)
)

As
if (not exists(select name
from tblAppConfig
where name=@name))
begin
Select
1 As ''ErrorNumber'',
''Record not found'' As ''ErrorMessage''
end
else
begin
Update tblAppConfig
set value =@value
where name=@name

select	0 As ''ErrorNumber'',
'''' As ''ErrorMessage''

end




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcApplication_GetDatabaseVersion]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Gets SQL Server version

Called By: Dependency
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 23/02/2004

prcApplication_GetDatabaseVersion

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcApplication_GetDatabaseVersion]
as
set nocount on
select @@version
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_MailServerURL]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcAutomatedEmails_MailServerURL]

AS
BEGIN
SELECT Value FROM tblAppConfig WHERE Name = ''MailServer''
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_ManagersToNotifyIndividually]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE PROCEDURE [prcAutomatedEmails_ManagersToNotifyIndividually]
(
@OrganisationID int
)


AS

BEGIN


--                    S E L E C T    T H E    R E S U L T S

--declare @OrganisationID int
--set @OrganisationID = 68

	;with UsersToNotify (userid,DelinquentCourse,username,uFirstname,uLastname) as 
	(
		SELECT distinct UsersToNotify.userid , UsersToNotify.DelinquentCourse,username,uFirstname,uLastname FROM
		(
			-- delinquent users
			SELECT DISTINCT CD.UserCourseStatusID as UserCourseStatusID, CS.userID , u.username, C.Name     as DelinquentCourse, u.FirstName as uFirstname, u.LastName as uLastname
			FROM tblUserCourseStatus CS
			INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
			INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
			INNER JOIN tblUser U On U.UserID = CS.UserID
			INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
			INNER JOIN tblUserCourseDetails UCD ON (UCD.UserID = u.UserID AND UCD.CourseID = C.CourseID)
			INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID)  AND (RemEsc.IndividualNotification=1) AND (RemEsc.NotifyMgr = 1) AND (RemEsc.DaysToCompleteCourse>0)
			INNER JOIN 
			(
			Select 
			DISTINCT
			tU.UserID
			--, tU.UnitID
			--, tU.OrganisationID
			--, tM.ModuleID
			,tC.CourseID

			From
			dbo.tblUser tU
			--< get the courses a user has access to >--
			Inner Join dbo.tblOrganisationCourseAccess tOCA
			On  tOCA.OrganisationID = tU.OrganisationID
			--< get the course details >--
			Inner join dbo.tblCourse tC
			On tC.CourseID = tOCA.GrantedCourseID
			--< get the Active modules in a course >--
			inner join dbo.tblModule tM
			On tM.CourseID = tC.CourseID
			and tM.Active = 1
			--< get the details on which modules a user is configured to access >--
			Left Outer join dbo.tblUserModuleAccess tUsrMA
			On  tUsrMA.UserID = tU.UserID
			And tUsrMA.ModuleID = tM.ModuleID
			--< get the details on which modules a user''s Unit is excluded from  >--
			Left Outer Join dbo.tblUnitModuleAccess tUnitMA
			On  tUnitMA.UnitID = tU.UnitID
			And tUnitMA.DeniedModuleID = tM.ModuleID
			Where
			tU.OrganisationID = @OrganisationID AND
			tU.Active = 1
			--< Active users only >--
			and tu.UnitID is not null
			--< Get the modules that the user''s Unit is not denied >--
			and (tUnitMA.DeniedModuleID  is null
			--<  and the user does not have special access to  it>--
			And tUsrMA.ModuleID is null)
			--< or Get modules that the user has been specially  granted
			or tUsrMA.Granted=1
			) um on um.UserID = U.UserID and um.CourseID = C.CourseID
			where (coursestatusid = 1) 
			AND (o.OrganisationID = @OrganisationID) 
			AND (GETUTCDATE() > DATEADD(d,RemEsc.DaysToCompleteCourse+1, CS.DateCreated)) -- Is Overdue
			AND (CS.DateCreated >= (SELECT MAX(DateCreated) FROM tblUserCourseStatus Expired where expired.CourseStatusID in (0,2) and Expired.CourseID = CS.CourseID and Expired.UserID =CS.UserID ) )
			AND (U.active = 1) 
			AND (UCD.LastDelNoteToMgr = 0)
			AND (GETUTCDATE() < DATEADD(m,6,DATEADD(d,RemEsc.DaysToCompleteCourse, CS.DateCreated))) -- Business Rule = If Course is more than 6 months overdue stop notifying managers

		)  UsersToNotify
	)

	, UsersToNotifyList(numb, userid,DelinquentCourse,username,uFirstname,uLastname) as
	(
		select 1,null,CAST('''' AS NVARCHAR(max)),CAST('''' AS NVARCHAR(max)),CAST('''' AS NVARCHAR(max)),CAST('''' AS NVARCHAR(max))
		UNION ALL

		--SELECT cte.numb + 1,pl.userid,CAST(cte.DelinquentCourse + (case when cte.DelinquentCourse = '''' or pl.DelinquentCourse = '''' then '''' else ''<BR>'' end ) + pl.DelinquentCourse AS NVARCHAR(max))
		SELECT cte.numb + 1,pl.userid,CAST(    cte.DelinquentCourse +  ''<BR>&nbsp;&nbsp;'' + pl.DelinquentCourse AS NVARCHAR(max)),CAST(pl.username AS NVARCHAR(max)),CAST(pl.uFirstname AS NVARCHAR(max)),CAST(pl.uLastname AS NVARCHAR(max))

		from 
		(  SELECT
		RowNum = Row_Number() OVER (partition BY userid order by userid)
		,userid,DelinquentCourse,username,uFirstname,uLastname

		FROM UsersToNotify
		) AS pl
		join UsersToNotifyList cte on pl.RowNum = cte.numb and (cte.userid is null or pl.userid = cte.userid)
	)




	, ManagersToNotifyList(numb, ManagerEmail, DelinquentCourse, FirstName, LastName,username,ManagerName,uFirstname,uLastname,deluserid, mgruserid) as
	(
	select numb,  CAST(UsersManagers.Email AS NVARCHAR(max)),DelinquentCourse,FirstName,LastName,UL.username,UsersManagers.UserName,uFirstname,uLastname, UL.userid, UsersManagers.mgruserid
	FROM UsersToNotifyList UL
	inner join (select max(numb) AS maxnumb,Userid  from UsersToNotifyList  group by userid) max on max.maxnumb = UL.numb and max.userid = UL.userid
	INNER JOIN
		(
			SELECT tblUnitAdmins.username, U.UserID, tblUnitAdmins.Email ,tblUnitAdmins.FirstName, tblUnitAdmins.LastName, tblUnitAdmins.UserID as mgruserid
			FROM  tblUser U  
						INNER JOIN  tblUnitAdministrator ON U.UnitID = tblUnitAdministrator.UnitID
						INNER JOIN   dbo.tblUser AS tblUnitAdmins ON dbo.tblUnitAdministrator.UserID = tblUnitAdmins.UserID AND tblUnitAdmins.UserTypeID = 3
						WHERE  U.NotifyUnitAdmin = 1
			UNION ALL 
			SELECT tblOrgAdmins.username, U.UserID, tblOrgAdmins.Email ,tblOrgAdmins.FirstName, tblOrgAdmins.LastName,tblOrgAdmins.UserID as mgruserid
			FROM  tblUser U  
						INNER JOIN  dbo.tblUser AS tblOrgAdmins ON U.OrganisationID = tblOrgAdmins.OrganisationID
						WHERE  U.NotifyOrgAdmin = 1 AND tblOrgAdmins.UserTypeID = 2
			UNION ALL
			SELECT ''DelinquencyManager'' as username, tblUserDelinquencyManager.UserID, tblUserDelinquencyManager.DelinquencyManagerEmail,'' '' AS FirstName, '' '' AS LastName,-1 as mgruserid
			FROM  dbo.tblUser AS tblUserDelinquencyManager WHERE  NotifyMgr = 1 and tblUserDelinquencyManager.Email IS NOT NULL AND (tblUserDelinquencyManager.Email != '''')
		) UsersManagers ON UsersManagers.UserID = UL.UserID

	)


	--select * from ManagersToNotify
	--select * from ManagersToNotifyList




	SELECT l.ManagerEmail,
	-- Recipient Email Address
	l.ManagerEmail as RecipientEmail,

	-- Sender Email Address
	l.ManagerEmail as SenderEmail,

	-- Subject
	(select   REPLACE(
	(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Overdue_Summary_Subject'')

	,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Overdue_Summary_Subject''))),''%APP_NAME%'',(SELECT Value FROM tblAppConfig where Name = ''AppName''))) as Subject,



	-- Header
	(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Overdue_Summary_Header'')

	,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Overdue_Summary_Header_Individual'')))
	
	
	
	

	--delinquent
	+ ''<BR>'' +''<B>''+ uFirstname +'' ''+uLastname+''</B>''+''&nbsp;&nbsp;''   + DelinquentCourse+ ''<BR>''

	--Email Sig
	+     
	(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Overdue_Summary_Sig'')
				,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Overdue_Summary_Sig'')))+ ''<BR>''  
	 as Body
	, -- Sender"On Behalf Of" Email Address
	(SELECT dbo.udfGetEmailOnBehalfOf (@OrganisationID))  as OnBehalfOfEmail,

	*

	FROM
	ManagersToNotifyList l

	join (select max(s.numb) numb ,ManagerEmail,ManagerName,UserName from ManagersToNotifyList s group by ManagerEmail,ManagerName,UserName)m on m.ManagerEmail = l.ManagerEmail and m.numb = l.numb and m.UserName = l.UserName and m.ManagerName = l.ManagerName
	ORDER BY l.numb DESC


--set flag to indicate delinquency note has been sent
UPDATE tblUserCourseDetails SET LastDelNoteToMgr  = 1
from tblUserCourseDetails
join (
SELECT U.userID , C.CourseID
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblUserCourseDetails UCD ON (UCD.UserID = u.UserID AND UCD.CourseID = C.CourseID)
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID)  AND (RemEsc.IndividualNotification=1) AND (RemEsc.NotifyMgr = 1)
where (coursestatusid = 1) 
AND (o.OrganisationID = @OrganisationID) 
AND (GETUTCDATE() > DATEADD(d,RemEsc.DaysToCompleteCourse+1, CS.DateCreated)) -- Is Overdue
AND (U.active = 1) 
AND (UCD.LastDelNoteToMgr = 0)
AND (GETUTCDATE() < DATEADD(m,6,DATEADD(d,RemEsc.DaysToCompleteCourse, CS.DateCreated))) -- Business Rule = If Course is more than 6 months overdue stop notifying managers
) a on a.userid = tblUserCourseDetails.UserID and a.CourseID = tblUserCourseDetails.CourseID


-- ReminderEscalations are logically grouped by the number of days that the reminders are sent
-- update the "Date last notified" field on the Reminder Escalation for all records that were notified this time.
UPDATE tblReminderEscalation SET LastNotified  = dbo.udfGetSaltOrgMidnight(OrgId)
from tblReminderEscalation
join (
SELECT o.OrganisationID , C.CourseID
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblUserCourseDetails UCD ON (UCD.UserID = u.UserID AND UCD.CourseID = C.CourseID)
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID)  AND (RemEsc.IndividualNotification=1) AND (RemEsc.NotifyMgr = 1)
where (coursestatusid = 1) 
AND (o.OrganisationID = @OrganisationID) 
AND (GETUTCDATE() > DATEADD(d,RemEsc.DaysToCompleteCourse+1, CS.DateCreated)) -- Is Overdue
AND (U.active = 1) 
AND (UCD.LastDelNoteToMgr = 0)
AND (GETUTCDATE() < DATEADD(m,6,DATEADD(d,RemEsc.DaysToCompleteCourse, CS.DateCreated))) -- Business Rule = If Course is more than 6 months overdue stop notifying managers
) a on a.OrganisationID = tblReminderEscalation.OrgId and a.CourseID = tblReminderEscalation.CourseID

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_ManagersToNotifyList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE PROCEDURE [prcAutomatedEmails_ManagersToNotifyList]
(
@OrganisationID int
)

AS

BEGIN
--                    S E L E C T    T H E    R E S U L T S

--declare @OrganisationID int
--set @OrganisationID = 68

create table #UsersToNotify
(userid int not null
,DelinquentCourse nvarchar(max) null)

insert into #UsersToNotify
SELECT distinct UsersToNotify.userid , UsersToNotify.DelinquentCourse FROM
(

-- delinquent users
SELECT DISTINCT CD.UserCourseStatusID as UserCourseStatusID, CS.userID , u.username, C.Name     as DelinquentCourse
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblUserCourseDetails UCD ON (UCD.UserID = u.UserID AND UCD.CourseID = C.CourseID)
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID)  AND (RemEsc.IndividualNotification=0)  AND (RemEsc.NotifyMgr = 1) AND (RemEsc.DaysToCompleteCourse>0)
INNER JOIN (select OrgID,NotifyMgrDays, max(lastnotified) as lastnotified  from tblReminderEscalation where tblReminderEscalation.NotifyMgr = 1   group by OrgID,NotifyMgrDays  ) LastNotified 
ON LastNotified.OrgID = o.OrganisationID  and LastNotified.NotifyMgrDays = RemEsc.NotifyMgrDays
INNER JOIN 
(
Select 
DISTINCT
tU.UserID
--, tU.UnitID
--, tU.OrganisationID
--, tM.ModuleID
,tC.CourseID

From
dbo.tblUser tU
--< get the courses a user has access to >--
Inner Join dbo.tblOrganisationCourseAccess tOCA
On  tOCA.OrganisationID = tU.OrganisationID
--< get the course details >--
Inner join dbo.tblCourse tC
On tC.CourseID = tOCA.GrantedCourseID
--< get the Active modules in a course >--
inner join dbo.tblModule tM
On tM.CourseID = tC.CourseID
and tM.Active = 1
--< get the details on which modules a user is configured to access >--
Left Outer join dbo.tblUserModuleAccess tUsrMA
On  tUsrMA.UserID = tU.UserID
And tUsrMA.ModuleID = tM.ModuleID
--< get the details on which modules a user''s Unit is excluded from  >--
Left Outer Join dbo.tblUnitModuleAccess tUnitMA
On  tUnitMA.UnitID = tU.UnitID
And tUnitMA.DeniedModuleID = tM.ModuleID
Where
tU.OrganisationID = @OrganisationID AND
tU.Active = 1
--< Active users only >--
and tu.UnitID is not null
--< Get the modules that the user''s Unit is not denied >--
and (tUnitMA.DeniedModuleID  is null
--<  and the user does not have special access to  it>--
And tUsrMA.ModuleID is null)
--< or Get modules that the user has been specially  granted
or tUsrMA.Granted=1
) um on um.UserID = U.UserID and um.CourseID = C.CourseID
where (coursestatusid = 1) 
AND (o.OrganisationID = @OrganisationID) 
AND (GETUTCDATE() > DATEADD(d,RemEsc.DaysToCompleteCourse+1, CS.DateCreated)) -- Is Overdue
AND (CS.DateCreated >= (SELECT MAX(DateCreated) FROM tblUserCourseStatus Expired where expired.CourseStatusID in (0,2) and Expired.CourseID = CS.CourseID and Expired.UserID =CS.UserID ) )
AND ((UCD.LastDelNoteToMgr = 0) OR (RemEsc.IsCumulative=1)) and  (U.active = 1)  -- and manager not notified OR CUMULATIVE notifications
AND (GETUTCDATE() > DATEADD(d,RemEsc.NotifyMgrDays,LastNotified.LastNotified )) -- Notify manager every N days
AND (GETUTCDATE() < DATEADD(m,6,DATEADD(d,RemEsc.DaysToCompleteCourse, CS.DateCreated))) -- Business Rule = If Course is more than 6 months overdue stop notifying managers

)  UsersToNotify

create index inx_1 on #UsersToNotify(userid)

create table #UsersToNotifyList
(userid int not null
,DelinquentCourse nvarchar(max) null)

create index inx_2 on #UsersToNotifyList(userid)


declare @userid int
,@DelinquentCourse nvarchar(max)
while exists (select 1 from #UsersToNotify)
begin
	set rowcount 1
	
	select @userid = userid
	,@DelinquentCourse = DelinquentCourse
	from #UsersToNotify
	
	if exists (select * from #UsersToNotifyList where userid = @userid)
	begin
		update #UsersToNotifyList set
		DelinquentCourse = rtrim(#UsersToNotifyList.DelinquentCourse + +  ''<BR>&nbsp;&nbsp;'' + @DelinquentCourse )
		from #UsersToNotifyList
		where #UsersToNotifyList.userid = @userid
	end
	else
	begin
		insert #UsersToNotifyList(userid,DelinquentCourse)
		values (@userid,@DelinquentCourse)

	end

	delete #UsersToNotify where
	@userid = userid
	and @DelinquentCourse = DelinquentCourse
	set rowcount 0
end


create table #ManagersToNotify
(ManagerName nvarchar(200) null
,ManagerEmail nvarchar(200) null
,DelinquentCourse nvarchar(max) null
,FirstName nvarchar(200) null
,LastName nvarchar(200) null
,username nvarchar(200) null
,deluserid int
,mgruserid int)

create index inx_3 on #ManagersToNotify(ManagerName)

INSERT into #ManagersToNotify( ManagerName, ManagerEmail ,DelinquentCourse,FirstName,LastName,username, deluserid,mgruserid) 

select  UsersManagers.username as managername,  UsersManagers.Email ,''<BR><B>''+U.Firstname+'' ''+U.Lastname+''</B><BR>&nbsp;&nbsp;''+DelinquentCourse,UsersManagers.FirstName as FirstName,UsersManagers.LastName, U.username,u.UserID,mgruserid
FROM #UsersToNotifyList UL
inner join tblUser U on U.userid=UL.userid


INNER JOIN
	(
		SELECT tblUnitAdmins.username, U.UserID, tblUnitAdmins.Email ,tblUnitAdmins.FirstName, tblUnitAdmins.LastName,tblUnitAdmins.UserID as mgruserid
		FROM  tblUser U  
					INNER JOIN  tblUnitAdministrator ON U.UnitID = tblUnitAdministrator.UnitID
					INNER JOIN   dbo.tblUser AS tblUnitAdmins ON dbo.tblUnitAdministrator.UserID = tblUnitAdmins.UserID AND tblUnitAdmins.UserTypeID = 3
					WHERE  U.NotifyUnitAdmin = 1
		UNION ALL 
		SELECT tblOrgAdmins.username, U.UserID, tblOrgAdmins.Email ,tblOrgAdmins.FirstName, tblOrgAdmins.LastName,tblOrgAdmins.UserID as mgruserid
		FROM  tblUser U  
					INNER JOIN  dbo.tblUser AS tblOrgAdmins ON U.OrganisationID = tblOrgAdmins.OrganisationID
					WHERE  U.NotifyOrgAdmin = 1 AND tblOrgAdmins.UserTypeID = 2
		UNION ALL
		SELECT ''DelinquencyManager'' as username, tblUserDelinquencyManager.UserID, tblUserDelinquencyManager.DelinquencyManagerEmail,'' '' AS FirstName, '' '' AS LastName, -1 as mgruserid
		FROM  dbo.tblUser AS tblUserDelinquencyManager WHERE  NotifyMgr = 1 and tblUserDelinquencyManager.Email IS NOT NULL AND (tblUserDelinquencyManager.Email != '''')
	) UsersManagers ON UsersManagers.UserID = UL.UserID



create table #ManagersToNotifyList
(ManagerName nvarchar(200) null
,ManagerEmail nvarchar(200) null
,DelinquentCourse nvarchar(max) null
,FirstName nvarchar(200) null
,LastName nvarchar(200) null
,username nvarchar(200) null
,deluserid int
,mgruserid int)

create index inx_4 on #ManagersToNotifyList(ManagerName)




declare 
@ManagerName nvarchar(200)
,@ManagerEmail nvarchar(200)
,@FirstName nvarchar(200)
,@LastName nvarchar(200)
,@username nvarchar(200)
,@deluserid int
,@mgruserid int

while exists (select 1 from #ManagersToNotify)
begin
	set rowcount 1
	select @ManagerName = ManagerName
	,@DelinquentCourse = DelinquentCourse
	,@ManagerEmail = ManagerEmail
	,@username = username
	,@FirstName = FirstName
	,@LastName = LastName
	,@deluserid = deluserid
	,@mgruserid = mgruserid
	from #ManagersToNotify

	if exists (select * from #ManagersToNotifyList where ManagerName = @ManagerName)
	begin
		update #ManagersToNotifyList set
		DelinquentCourse = rtrim(#ManagersToNotifyList.DelinquentCourse + +  ''<BR>&nbsp;&nbsp;'' + @DelinquentCourse )
		from #ManagersToNotifyList
		where #ManagersToNotifyList.ManagerName = @ManagerName
	end
	else
	begin
		insert #ManagersToNotifyList(ManagerName,DelinquentCourse,ManagerEmail ,username ,FirstName ,LastName,deluserid, mgruserid )
		values (@ManagerName,@DelinquentCourse,@ManagerEmail,@username ,@FirstName ,@LastName,@deluserid,@mgruserid )
	end

	delete #ManagersToNotify where
	@ManagerName = ManagerName
	and @DelinquentCourse = DelinquentCourse
	and @ManagerEmail = ManagerEmail
	and @username = username
	and @FirstName = FirstName
	and @LastName = LastName
	and @deluserid =deluserid
	and @mgruserid=mgruserid
	set rowcount 0
end




SELECT l.ManagerEmail,
-- Recipient Email Address
l.ManagerEmail as RecipientEmail,

-- Sender Email Address
l.ManagerEmail as SenderEmail,

-- Subject
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Overdue_Summary_Subject'')
	,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Overdue_Summary_Subject''))) as Subject,



-- Header
(
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Overdue_Summary_Header'')
								,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Overdue_Summary_Header'')))
)


--delinquent
+ ''<BR>'' + DelinquentCourse + ''<BR>''

--Email Sig
+     
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Overdue_Summary_Sig'')
			,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Overdue_Summary_Sig'')))+ ''<BR>''   as Body
, -- Sender"On Behalf Of" Email Address
(SELECT dbo.udfGetEmailOnBehalfOf (@OrganisationID))  as OnBehalfOfEmail,


*

FROM
#ManagersToNotifyList l




--set flag to indicate delinquency note has been sent
UPDATE tblUserCourseDetails SET LastDelNoteToMgr  = 1
from tblUserCourseDetails
join (
SELECT U.userID , C.CourseID
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblUserCourseDetails UCD ON (UCD.UserID = u.UserID AND UCD.CourseID = C.CourseID)
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID)  AND (RemEsc.IndividualNotification=0) AND (RemEsc.NotifyMgr = 1)
INNER JOIN (select OrgID,CourseId,NotifyMgrDays, max(lastnotified) as lastnotified  from tblReminderEscalation where tblReminderEscalation.NotifyMgr = 1   group by OrgID,CourseId,NotifyMgrDays  ) LastNotified 
ON LastNotified.OrgID = o.OrganisationID and LastNotified.CourseId =  C.CourseID and LastNotified.NotifyMgrDays = RemEsc.NotifyMgrDays
where (coursestatusid = 1) AND (o.OrganisationID = @OrganisationID) AND (GETUTCDATE() > DATEADD(d,RemEsc.NotifyMgrDays+1, CS.DateCreated))
AND ((UCD.LastDelNoteToMgr = 0) OR (RemEsc.IsCumulative=1)) and  (U.active = 1)
AND (GETUTCDATE() > DATEADD(d,RemEsc.NotifyMgrDays,LastNotified.LastNotified ))
) a on a.userid = tblUserCourseDetails.UserID and a.CourseID = tblUserCourseDetails.CourseID


-- ReminderEscalations are logically grouped by the number of days that the reminders are sent
-- update the "Date last notified" field on the Reminder Escalation for all records that were notified this time.
UPDATE tblReminderEscalation SET LastNotified  = dbo.udfGetSaltOrgMidnight(OrgId)
from tblReminderEscalation
join (
SELECT o.OrganisationID , C.CourseID
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblUserCourseDetails UCD ON (UCD.UserID = u.UserID AND UCD.CourseID = C.CourseID)
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID)  AND (RemEsc.IndividualNotification=0) AND (RemEsc.NotifyMgr = 1)
INNER JOIN (select OrgID,CourseId,NotifyMgrDays, max(lastnotified) as lastnotified  from tblReminderEscalation where tblReminderEscalation.NotifyMgr = 1   group by OrgID,CourseId,NotifyMgrDays  ) LastNotified 
ON LastNotified.OrgID = o.OrganisationID and LastNotified.CourseId =  C.CourseID and LastNotified.NotifyMgrDays = RemEsc.NotifyMgrDays
where (coursestatusid = 1) AND (o.OrganisationID = @OrganisationID) AND (GETUTCDATE() > DATEADD(d,RemEsc.NotifyMgrDays+1, CS.DateCreated))
AND ((UCD.LastDelNoteToMgr = 0) OR (RemEsc.IsCumulative=1)) and  (U.active = 1)
AND (GETUTCDATE() > DATEADD(d,RemEsc.NotifyMgrDays,LastNotified.LastNotified ))
) a on a.OrganisationID = tblReminderEscalation.OrgId and a.CourseID = tblReminderEscalation.CourseID


if OBJECT_ID(''tempdb..#UsersToNotifyList'') is not null
begin
	drop table #UsersToNotifyList
end

if  OBJECT_ID(''tempdb..#UsersToNotify'')is not null
begin
	drop table #UsersToNotify
END


if OBJECT_ID(''tempdb..#ManagersToNotify'') is not null
begin
	drop table #ManagersToNotify
end


if OBJECT_ID(''tempdb..#ManagersToNotifyList'') is not null
begin
	drop table #ManagersToNotifyList
end


END


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_New StartersToNotify]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE PROCEDURE [prcAutomatedEmails_New StartersToNotify]
(
@OrganisationID int
)


AS
Set Xact_Abort On
BEGIN


declare @stopEmails bit
set @stopEmails = 0
select @stopEmails = StopEmails from tblOrganisation where OrganisationID = @OrganisationID

-- New Starter
SELECT userid,email,(SELECT dbo.udfUser_GetAdministratorsEmailAddress (U.UserID)) as SenderEmail, (SELECT Value + '' login details '' FROM tblAppConfig where Name = ''AppName'') as subject, 
coalesce
(
(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_NewStarter'')
,
(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_NewStarter'')
) as body
, -- Sender"On Behalf Of" Email Address
(SELECT dbo.udfUser_GetAdministratorsOnBehalfOfEmailAddress (U.UserID))  as OnBehalfOfEmail

from tblUser U where  U.OrganisationID = @OrganisationID and U.active = 1 and U.NewStarter = 1
  and @stopEmails = 0 

update tblUser set NewStarter = 0  where  OrganisationID = @OrganisationID and active = 1 and NewStarter = 1


END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_OrganisationsToNotify]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE   Procedure [prcAutomatedEmails_OrganisationsToNotify]
AS
Set Nocount On



declare @OrgID	    int

SELECT @OrgID = cast(coalesce((SELECT top 1 OrganisationID
from tblOrganisation
WHERE DelinquenciesLastNotified < CourseStatusLastUpdated and dateadd(hh,0,CourseStatusLastUpdated )< dbo.udfUTCtoDaylightSavingTime(getutcdate(),OrganisationID)) ,-1) as varchar(50))

update tblOrganisation set DelinquenciesLastNotified = dbo.udfUTCtoDaylightSavingTime(getutcdate(),OrganisationID) where @OrgID = OrganisationID


select @OrgID
return @OrgID


' 
END
GO



IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_UsersToNotify]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[prcAutomatedEmails_UsersToNotify]
(
@OrganisationID int
)


AS

BEGIN

declare @OrgMidnight datetime
set @OrgMidnight =  dbo.udfGetSaltOrgMidnight(@OrganisationID)

declare @StopEmails bit
set @StopEmails = 0
select @StopEmails = StopEmails from tblOrganisation where OrganisationID = @OrganisationID 


--                    H O U S E K E E P I N G
--tblUserCourseDetails contains information on notifications about courses that have ''at risk'' quizes
--add any new courses
INSERT INTO tblUserCourseDetails (UserID,CourseID,UserCourseStatusID,NumberOfDelinquencyNotifications, NewStarterFlag, AtRiskQuizList, NotifiedModuleList, LastDelinquencyNotification)

select U.UserID,CourseID,UserCourseStatusID,0,null,'''','''',null
FROM  tblUser U inner join tblUserCourseStatus tUCS ON U.UserID = tUCS.UserID and U.OrganisationID = @organisationID  INNER JOIN
(SELECT MAX(UserCourseStatusID) AS MaxUserCourseStatusID
FROM   dbo.tblUserCourseStatus
GROUP BY UserID, CourseID) AS currentStatus ON tUCS.UserCourseStatusID = currentStatus.MaxUserCourseStatusID

where  CourseStatusID in (1,2) and UserCourseStatusID NOT IN (SELECT UserCourseStatusID FROM tblUserCourseDetails)




--remove data on courses that are now unassigned
DELETE FROM tblUserCourseDetails WHERE UserCourseStatusID IN
(SELECT UserCourseStatusID
FROM  tblUser U inner join tblUserCourseStatus tUCS ON U.UserID = tUCS.UserID and U.OrganisationID = @organisationID  INNER JOIN
(SELECT MAX(UserCourseStatusID) AS MaxUserCourseStatusID
FROM   dbo.tblUserCourseStatus
GROUP BY UserID, CourseID) AS currentStatus ON tUCS.UserCourseStatusID = currentStatus.MaxUserCourseStatusID

where  CourseStatusID = 0
)


--                    S E L E C T    T H E    R E S U L T S

--declare @OrganisationID int
--set @OrganisationID = 68

create table #UsersToNotify
(userid int not null
,NewContent nvarchar(max) null
,PassedCourses nvarchar(max) null
,PassedModules nvarchar(max) null
,AtRiskOfdelinquency nvarchar(max) null
,Delinquent nvarchar(max) null)



insert into #UsersToNotify
SELECT distinct UsersToNotify.userid , UsersToNotify.NewContent , PassedCourses, PassedModules ,AtRiskOfdelinquency, delinquent FROM
(
	-- users with courses expired, due to new content
	SELECT '''' as UserCourseStatusID, tblExpiredNewContent.UserID , tblCourse.Name + '' - ''+ tblModule.Name as NewContent , '''' as PassedCourses ,'''' as PassedModules ,  '''' as AtRiskOfdelinquency,'''' as Delinquent
	FROM  tblExpiredNewContent INNER JOIN
	tblModule ON tblModule.ModuleID = tblExpiredNewContent.ModuleID
	INNER JOIN tblCourse ON tblCourse.CourseID = tblModule.CourseID 
	WHERE tblExpiredNewContent.organisationID = @OrganisationID
    and @StopEmails = 0
    
	-- users with passed courses
	UNION all SELECT '''' as UserCourseStatusID, CS.userid , '''' as NewContent,''   ''+ C.Name as PassedCourses,'''' as PassedModules,  '''' as AtRiskOfdelinquency, '''' as Delinquent
	FROM tblUserCourseStatus CS
	inner join tblUser U ON U.UserID = CS.UserID
	INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
	where U.OrganisationID = @OrganisationID and CS.CourseStatusID=2 and DATEDIFF(d,CS.DateCreated,@OrgMidnight) < 1
	and @StopEmails = 0

	-- users with passed modules
	UNION all SELECT '''' as UserCourseStatusID, QuizStatus.userid ,	'''' as NewContent, '''' as PassedCourses,	''   ''+c.name  + '' - '' + m.name as PassedModules, '''' as AtRiskOfdelinquency, '''' as delinquent
	from
	tblUserQuizStatus QuizStatus
	join tblUser  u on u.UserID = QuizStatus.UserID and u.OrganisationID = @OrganisationID
	inner join tblModule m on m.ModuleID = QuizStatus.ModuleID
	join tblCourse c on c.CourseID = m.CourseID
	inner join
	(
	select
	max(UserQuizStatusID) UserQuizStatusID, uqs.UserID, uqs.ModuleID --UserQuizStatusID is identity
	from
	tblUserQuizStatus uqs
	join tblUser  u on u.UserID = uqs.UserID
	WHERE DATEDIFF(d,uqs.DateCreated,@OrgMidnight) < 1
	and u.OrganisationID = @OrganisationID
	group by
	uqs.UserID,moduleID
	) currentStatus
	on QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
	where m.active = 1
	and QuizStatusID =2
    and @StopEmails = 0
    
	-- users with courses at risk (pre expiry)
	union all SELECT DISTINCT '''' as UserCourseStatusID, AR.userID,  '''' as NewContent , '''' as PassedCourses,'''' as PassedModules, ''   ''+ C.Name +'' ( ''+M.name +'') ''+ convert(varchar (11),ar.ExpiryDate ,113) as AtRiskOfdelinquency,'''' as delinquent
	from tblQuizExpiryAtRisk AR
	INNER JOIN tblUser U On U.UserID = AR.UserID
	inner join tblModule M on m.ModuleID = AR.ModuleID and m.Active = 1 and AR.OrganisationID = @OrganisationID
	INNER JOIN tblCourse C ON C.CourseID = M.CourseID
	where U.Active = 1 AND ar.PreExpiryNotified = 0
	and ar.ExpiryDate >= dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrganisationID)
    and @StopEmails = 0
    
	-- users with expired courses
	union all SELECT DISTINCT '''' as UserCourseStatusID, AR.userID,  '''' as NewContent , '''' as PassedCourses,'''' as PassedModules, '''' as AtRiskOfdelinquency ,''   ''+ C.Name +'' ( ''+M.name +'') ''+ convert(varchar (11),ar.ExpiryDate ,113)  as delinquent
	from tblQuizExpiryAtRisk AR
	INNER JOIN tblUser U On U.UserID = AR.UserID
	inner join tblModule M on m.ModuleID = AR.ModuleID and m.Active = 1 and AR.OrganisationID = @OrganisationID
	INNER JOIN tblCourse C ON C.CourseID = M.CourseID
	INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = @OrganisationID) AND (RemEsc.CourseId = C.CourseID) and RemEsc.PostExpReminder =1
	where U.Active = 1 AND ar.PreExpiryNotified != 0 
		and (ar.ExpiryNotifications =0 and ExpiryDate<=GETUTCDATE())
		and ar.ExpiryDate >= dateadd(year,-1,GETUTCDATE())
		or (ar.ExpiryNotifications>0 and ar.ExpiryNotifications<=(RemEsc.NumOfRemNotfy-1) and DATEADD (DAY,remesc.RepeatRem,ar.datenotified)<GETUTCDATE() )
    and @StopEmails = 0
    
) UsersToNotify

create index in_1 on #UsersToNotify(userid)


create table #UsersToNotifyList
(userid int not null
,NewContent nvarchar(max) null
,PassedCourses nvarchar(max) null
,PassedModules nvarchar(max) null
,AtRiskOfdelinquency nvarchar(max) null
,delinquent nvarchar(max) null)

create index in_2 on #UsersToNotifyList(userid)

declare @userid int
,@NewContent nvarchar(max)
,@PassedCourses nvarchar(max)
,@PassedModules nvarchar(max)
,@AtRiskOfdelinquency nvarchar(max)
,@delinquent nvarchar(max)

while exists (select 1 from #UsersToNotify)
begin
	set rowcount 1
	
	select @userid = userid
	,@NewContent = NewContent
	, @PassedCourses = PassedCourses
	,@PassedModules = PassedModules
	,@AtRiskOfdelinquency = AtRiskOfdelinquency
	,@delinquent =Delinquent

	from #UsersToNotify
	if exists (select * from #UsersToNotifyList where userid = @userid)
	begin

		update #UsersToNotifyList set
		NewContent = rtrim(CAST(#UsersToNotifyList.NewContent + (case when #UsersToNotifyList.NewContent = '''' or @NewContent = '''' then '''' else ''<BR>'' end ) + (case when @NewContent ='''' then '''' else ''&nbsp;&nbsp;'' end) +@NewContent AS NVARCHAR(max)))
		, PassedCourses = rtrim(CAST(#UsersToNotifyList.PassedCourses + (case when #UsersToNotifyList.PassedCourses = '''' or @PassedCourses = '''' then '''' else ''<BR>'' end)+ (case when @PassedCourses ='''' then '''' else ''&nbsp;&nbsp;'' end) + @PassedCourses AS NVARCHAR(max)))
		,PassedModules = rtrim(CAST(#UsersToNotifyList.PassedModules + (case when #UsersToNotifyList.PassedModules = '''' or @PassedModules = '''' then '''' else ''<BR>'' end)+ (case when @PassedModules ='''' then '''' else ''&nbsp;&nbsp;'' end) + @PassedModules AS NVARCHAR(max)))
		,AtRiskOfdelinquency = rtrim(CAST(#UsersToNotifyList.AtRiskOfdelinquency + (case when #UsersToNotifyList.AtRiskOfdelinquency = '''' or @AtRiskOfdelinquency = '''' then '''' else ''<BR>'' end)+ (case when @AtRiskOfdelinquency ='''' then '''' else ''&nbsp;&nbsp;'' end) + @AtRiskOfdelinquency AS NVARCHAR(max)))
		,delinquent = rtrim(CAST(#UsersToNotifyList.delinquent + (case when #UsersToNotifyList.delinquent = '''' or @delinquent = '''' then '''' else ''<BR>'' end)+ (case when @delinquent ='''' then '''' else ''&nbsp;&nbsp;'' end) + @delinquent AS NVARCHAR(max)))
		from #UsersToNotifyList
		where #UsersToNotifyList.userid = @userid
		
	end
	else
	begin

		insert #UsersToNotifyList(userid,NewContent,PassedCourses,PassedModules,AtRiskOfdelinquency,delinquent)
		values (@userid,@NewContent,@PassedCourses,@PassedModules,@AtRiskOfdelinquency,@delinquent)

	end
	
	delete #UsersToNotify where
	@userid = userid
	and @NewContent = NewContent
	and  @PassedCourses = PassedCourses
	and  @PassedModules = PassedModules
	and  @AtRiskOfdelinquency = AtRiskOfdelinquency
	and @delinquent = Delinquent
	set rowcount 0
end

-- 
-- select the final result the result set for return to the app  (also, builds the whole body just once for each user!)

SELECT l.UserID,
-- Recipient Email Address
(SELECT Email FROM tblUser WHERE UserID = l.UserID) as RecipientEmail,

-- Sender Email Address
(SELECT dbo.udfUser_GetAdministratorsEmailAddress (l.UserID)) as SenderEmail,

-- Subject
(select REPLACE(
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_Subject'')
,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_Subject''))),''%APP_NAME%'',(SELECT Value FROM tblAppConfig where Name = ''AppName''))) as Subject,


--1. Body --Header
(select coalesce((SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_Header'')
,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_Header''))),''header error''))

--2. Body --Passed Courses
+coalesce( (select case when PassedCourses = '''' then '''' else replace (
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_PassedCourses'')
,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_PassedCourses''))),''%AUTO_LIST%'',PassedCourses)end),'''')

--3. Body --Passed Modules
+coalesce( (select case when PassedModules = '''' then '''' else '' <br /> '' + replace (
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_PassedModules'')
,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_PassedModules''))),''%AUTO_LIST%'',PassedModules)end),'''')

--4. Body --Expired Content
+ coalesce( (select case when NewContent = '''' then '''' else '' <br /> '' + replace(
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_ExpiredContent'')
,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_ExpiredContent''))),''%AUTO_LIST%'',NewContent)end),'''')

--5. Body --Delinquent
+ coalesce((select case when delinquent = '''' then '''' else '' <br /> '' + replace(
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_AtRiskOfBeingOverdue'')
,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_AtRiskOfBeingOverdue''))),''%AUTO_LIST%'',delinquent)end),'''')

--6. Body --AtRiskOfdelinquency
+coalesce( (select case when AtRiskOfdelinquency = '''' then '''' else '' <br /> '' + replace(
 ( SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_AtRiskOfExpiry'')
,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_AtRiskOfExpiry''))),''%AUTO_LIST%'',AtRiskOfdelinquency) end),'''')

--7. Body --Email Sig
+     (select REPLACE(
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_Sig'')
,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_Sig'')))+ ''<BR>''  ,''%APP_NAME%'',(SELECT Value FROM tblAppConfig where Name = ''AppName''))) as Body
, -- Sender"On Behalf Of" Email Address
(SELECT dbo.udfUser_GetAdministratorsOnBehalfOfEmailAddress (l.UserID))  as OnBehalfOfEmail,


*

FROM
#UsersToNotifyList l
where NewContent !='''' or PassedCourses !='''' or PassedModules != '''' or AtRiskOfdelinquency != ''''  or delinquent != ''''





--                    H O U S E K E E P I N G  (tidy up for tomorrow)

-- Update record of "at risk of Delinquency" notifications
-- Update tblUserCourseDetails.LastDelinquencyNotification
UPDATE tblUserCourseDetails  SET LastDelinquencyNotification = GETUTCDATE(), NumberOfDelinquencyNotifications = NumberOfDelinquencyNotifications + 1
WHERE  UserCourseStatusID in (-- users with courses at risk of delinquency (1ST WARNING)

SELECT DISTINCT UserCourseStatusID
FROM (SELECT MAX(CD.UserCourseStatusID) as UserCourseStatusID, CS.userID ,  RemEsc.DaysToCompleteCourse, MIN(CS.DateCreated) as DateCreated,C.Name,CS.CourseID
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on O.OrganisationID = u.OrganisationID 
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID) AND (RemindUsers=1)
where U.Active = 1 and @StopEmails = 0
AND ((o.DefaultQuizCompletionDate is not null AND CS.DateCreated >  dateadd(year,-1,o.DefaultQuizCompletionDate))
OR     (o.DefaultQuizCompletionDate is  null AND CS.DateCreated >= (select ISNULL((SELECT MAX(DateCreated) FROM tblUserCourseStatus Expired where expired.CourseStatusID in (0,2) and Expired.CourseID = CS.CourseID and Expired.UserID =CS.UserID) ,''1 jan 1990'')) ))
AND CD.LastDelinquencyNotification IS NULL
AND coursestatusid=1
AND o.OrganisationID = @OrganisationID
AND (GETUTCDATE() > DATEADD(d,RemEsc.DaysToCompleteCourse-RemEsc.NumOfRemNotfy*RemEsc.RepeatRem, CS.DateCreated))
AND (RemEsc.NumOfRemNotfy > cd.NumberOfDelinquencyNotifications)
AND (GETUTCDATE() < DATEADD(d,RemEsc.DaysToCompleteCourse+6, CS.DateCreated))
GROUP BY  CS.CourseID, CS.userID ,  RemEsc.DaysToCompleteCourse, C.Name) ThisCycle
)




UPDATE tblUserCourseDetails  SET LastDelinquencyNotification = GETUTCDATE(), NumberOfDelinquencyNotifications = NumberOfDelinquencyNotifications + 1
WHERE  UserCourseStatusID in (-- users with courses at risk of delinquency (SUBSEQUENT WARNINGS)
SELECT DISTINCT UserCourseStatusID
FROM (SELECT MAX(CD.UserCourseStatusID) as UserCourseStatusID, CS.userID ,  RemEsc.DaysToCompleteCourse, MIN(CS.DateCreated) as DateCreated,C.Name,CS.CourseID
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID) AND (RemindUsers=1)
where U.Active = 1 AND coursestatusid=1 AND o.OrganisationID = @OrganisationID and @StopEmails = 0
AND CD.LastDelinquencyNotification IS NOT NULL
AND ((o.DefaultQuizCompletionDate is not null AND CS.DateCreated >  dateadd(year,-1,o.DefaultQuizCompletionDate))
OR     (o.DefaultQuizCompletionDate is  null AND CS.DateCreated >= (select ISNULL((SELECT MAX(DateCreated) FROM tblUserCourseStatus Expired where expired.CourseStatusID in (0,2) and Expired.CourseID = CS.CourseID and Expired.UserID =CS.UserID) ,''1 jan 1990'')) ))
AND coursestatusid=1
AND o.OrganisationID = @OrganisationID
AND (GETUTCDATE() > DATEADD(d,RemEsc.DaysToCompleteCourse-RemEsc.NumOfRemNotfy*RemEsc.RepeatRem, CS.DateCreated))
AND (RemEsc.NumOfRemNotfy > cd.NumberOfDelinquencyNotifications)
AND (GETUTCDATE() > DATEADD(d,RemEsc.RepeatRem, CD.LastDelinquencyNotification))
AND (GETUTCDATE() < DATEADD(d,RemEsc.DaysToCompleteCourse+6, CS.DateCreated))

GROUP BY  CS.CourseID, CS.userID ,  RemEsc.DaysToCompleteCourse, C.Name) ThisQuizCycle
)


DELETE FROM tblExpiredNewContent WHERE organisationID = @OrganisationID  and @StopEmails = 0


-- Update record for post expiry notified -- use same criteria as selection above.
update tblQuizExpiryAtRisk SET --PreExpiryNotified = case when preexpirynotified = 0 then 1 else PreExpiryNotified end,
	ExpiryNotifications  = case when @StopEmails=1 then remesc.NumOfRemNotfy else ExpiryNotifications +1  end,
	datenotified = case when @StopEmails= 1 then null else  GETUTCDATE() end
from tblQuizExpiryAtRisk AR
	INNER JOIN tblUser U On U.UserID = AR.UserID
	inner join tblModule M on m.ModuleID = AR.ModuleID and m.Active = 1 and AR.OrganisationID = @OrganisationID
	INNER JOIN tblCourse C ON C.CourseID = M.CourseID
	INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = @OrganisationID) AND (RemEsc.CourseId = C.CourseID) and RemEsc.PostExpReminder =1
	where U.Active = 1 AND ar.PreExpiryNotified != 0 
		and (ar.ExpiryNotifications =0 and ExpiryDate<=GETUTCDATE())
		and ar.ExpiryDate >= dateadd(year,-1,GETUTCDATE())
		or (ar.ExpiryNotifications>0 and ar.ExpiryNotifications<=(RemEsc.NumOfRemNotfy-1) and DATEADD (DAY,remesc.RepeatRem,ar.datenotified)<GETUTCDATE() )    


--update record for pre expiry notified -- straightforward where not prexpiry notified
update tblQuizExpiryAtRisk set 
	PreExpiryNotified = 1,
	DateNotified = case when @StopEmails= 1 then null else GETUTCDATE() end
from tblQuizExpiryAtRisk ar
join tblUser u on u.UserID= ar.UserID
where PreExpiryNotified = 0 and u.OrganisationID = @OrganisationID



if OBJECT_ID(''tempdb..#UsersToNotifyList'') is not null
begin
drop table #UsersToNotifyList
end

if  OBJECT_ID(''tempdb..#UsersToNotify'')is not null
begin
drop table #UsersToNotify
END
end
' 
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcBookMark_GetBookMarkBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'






/*Summary:
Given (UserID or SessionID) and (lessonID or ToolbookID)
returns the bookmark for this lesson (toolbook) for this user
Returns:
table, 1 row (lessonPageID int,  Tolbook Page ID string)

Called By:
TooolBooLlistner.aspx via BusinessServices.Toolbook.GetBookmark
Calls:
dbo.udfGetUserIDBySessionID
dbo.udfGetLessonIDBySessionID
Remarks:
- at least one of UserID or SessionID must be supplied
- at least one of lessonID or ToolbookID must be supplied
- returns both the lessonPageID and the Tolbook Page ID for this page

Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



--------------------
exec prcBookMark_GetBookMarkBySessionID @lessonSessionID = ''134E8E5F-EC8A-4C95-8FA5-142AC87246C1''

**/


CREATE     PROC [prcBookMark_GetBookMarkBySessionID]
(
@lessonSessionID varchar(50) -- the lesson Session ID
)

AS

SET NOCOUNT ON

select top 1
ToolBookPageID
from

tblLessonSession tLS

inner join tblLessonPage tLP
on tLP.LessonID = tLS.LessonID

inner join tblBookmark tBM
on tBM.lessonPageID = tLP.LessonPageID
and tBM.UserID = tLS.UserID
where
lessonSessionID = @lessonSessionID

order by
--< only get the latest bookmark set >--
tBM.DateCreated




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_AddClassification]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary:
Adds a Classification for a Classification Type.

Parameters:
@name nVarChar(50)
@active Bit
@classificationTypeID Integer

Returns:
None

Called By:
Classification.cs

Calls:
None

Remarks:
Exception:
0. Succeed
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 19th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/
CREATE   Procedure [prcClassification_AddClassification]
(
@name nVarChar(50) = Null, -- Name of the Classification
@active Bit = 1, -- Status of the classification
@classificationTypeID Integer = Null -- ID of the Classification Type that you wish to get the Classification List For.
)

As

Set NoCount On

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage VarChar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @intErrorNumber = 0
Set @strErrorMessage = ''''

-- Validation Routines
If(@classificationTypeID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @classificationTypeID in stored procedure  prcClassification_AddClassification''
Goto Finalise
End

If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure  prcClassification_AddClassification''
Goto Finalise
End

If Exists(Select * From tblClassification Where Value = @name And ClassificationTypeID = @classificationTypeID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Classification Value '' + @name + '' already exists for this ClassificationType please choose another value for your ClassificationType.''
Goto Finalise
End

If(@active Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure  prcClassification_AddClassification''
Goto Finalise
End

Insert Into tblClassification
(
Value,
Active,
ClassificationTypeID
)
Values
(
@name,
@active,
@classificationTypeID
)

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End



' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_AddType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary:
Adds a Classification Type for an Organisation

Parameters:
@name nVarChar(50)
@organisationID Integer

Returns:
None

Called By:
Classification.cs

Calls:
None

Remarks:
Exception:
0. Succeed
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 18th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcClassification_AddType]
(
@name nVarChar(50) = Null, -- The name of the ClassificationType
@organisationID Integer = Null -- The ID of the Organisation that you wish to get the Classifications For.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage VarChar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

-- Validation Routines
If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure  prcClassification_AddType''
Goto Finalise
End

If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure  prcClassification_AddType''
Goto Finalise
End

If Exists(Select * From tblClassificationType Where Name = @name And OrganisationID = @organisationID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The ClassificationType Name '' + @name + '' already exists for this organisation please choose another name for your ClassificationType.''
Goto Finalise
End

Insert Into tblClassificationType
(
Name,
OrganisationID
)
Values
(
@name,
@organisationID
)

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End



' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_GetList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*
Summary:
Gets a list of Classifications for the specified classification type.

Parameters:
OrganisationID

Returns:
ClassificationID
ClassificationTypeID
Value
Active

Called By:
Classification.cs

Calls:
None

Remarks:
None

Author: John Crawford
Date Created: 17th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE     Procedure [prcClassification_GetList]
(
@classificationTypeID Integer = Null -- ID of the classification type that you wish to get the classification list for.
)

As

Set NoCount On

Select
ClassificationID,
ClassificationTypeID,
Value,
Active
From
tblClassification
Where
((ClassificationTypeID = @classificationTypeID)
And (Active = 1))
Order By
Value Asc




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_GetListAll]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Gets a list of all classifications for the specified classification type.

Parameters:
@classificationTypeID Integer

Returns:
ClassificationID
ClassificationTypeID
Value
Active

Called By:
Classification.cs

Calls:
None

Remarks:
None

Author: Peter Vranich
Date Created: 19th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcClassification_GetListAll]
(
@classificationTypeID Integer = Null -- ID of the Classification Type that you wish to get the Classification List For.
)

As

Set NoCount On

Select
ClassificationID,
ClassificationTypeID,
Value,
Active
From
tblClassification
Where
(ClassificationTypeID = @classificationTypeID)


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_GetType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary: Gets a list of Classification Types for an Organisation
Parameters: OrganisationID
Returns: ClassificationTypeID, OrganisationID, Name

Called By: Classification.cs
Calls: None

Remarks: None

Author: John Crawford
Date Created: 17th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE   Procedure [prcClassification_GetType]
(
@organisationID Integer = Null -- ID of the Organisation that you wish to get the Classifications For.
)

As

Set NoCount On

Select
ClassificationTypeID,
OrganisationID,
[Name]
From
tblClassificationType
Where
OrganisationID = @organisationID



' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_UpdateClassification]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*
Summary:
Updates a Classification.

Parameters:
@name nVarChar(50)
@active Bit
@classificationID Integer

Returns:
None

Called By:
Classification.cs

Calls:
None

Remarks:
Exception:
0. Succeed
1. RecordNotFoundException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 19th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/
CREATE  Procedure [prcClassification_UpdateClassification]
(
@name nVarChar(50) = Null, -- Name of the Classification
@active Bit = 1, -- Status of the classification
@classificationID Integer = Null, -- The ID of the classification that you wish to update.
@classificationTypeID Integer = Null -- The ID of the classification type that this classification belongs to.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage VarChar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @intErrorNumber = 0
Set @strErrorMessage = ''''

-- Validation Routines
If(@classificationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @classificationID in stored procedure  prcClassification_UpdateClassification''
Goto Finalise
End

If(@classificationTypeID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @classificationTypeID in stored procedure  prcClassification_UpdateClassification''
Goto Finalise
End

If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure  prcClassification_UpdateClassification''
Goto Finalise
End

If Exists(Select * From tblClassification Where Value = @name And ClassificationID != @classificationID And ClassificationTypeID = @classificationTypeID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Classification Value '' + @name + '' already exists for this ClassificationType please choose another value for your ClassificationType.''
Goto Finalise
End

If(@active Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure  prcClassification_UpdateClassification''
Goto Finalise
End

If Exists(Select * From tblClassification Where ClassificationID = @classificationID)
Begin

Update tblClassification
Set
Value = @name,
Active = @active
Where
ClassificationID = @classificationID
DELETE FROM
tblUserClassification
WHERE
ClassificationID = @classificationID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_UpdateType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*
Summary:
Updates a Classification Type for an Organisation

Parameters:
@name VarChar(50)
@classificationTypeID Integer
@organisationID Integer

Returns:
None

Called By:
Classification.cs

Calls:
None

Remarks:
Exception:
0. Succeed
1. RecordNotFoundException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 18th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcClassification_UpdateType]
(
@name nVarChar(50) = Null, -- The name of the ClassificationType.
@classificationTypeID Integer = Null, -- The ID of the ClassificationType that you wish to update.
@organisationID Integer -- ID of the Organisation that you are updating the ClassificationType for.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage VarChar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @intErrorNumber = 0
Set @strErrorMessage = ''''

-- Validation Routines
If(@classificationTypeID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @classificationTypeID in stored procedure  prcClassification_AddType''
Goto Finalise
End

If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure  prcClassification_AddType''
Goto Finalise
End

If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure  prcClassification_AddType''
Goto Finalise
End

If Exists(Select * From tblClassificationType Where ClassificationTypeID = @classificationTypeID)
Begin
Update tblClassificationType
Set
Name = @name
Where
ClassificationTypeID  = @classificationTypeID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_AdminMashup]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:		Compiles a bunch of info based on the selected units/courses then filters it based on administrator selection
Parameters:		Comma separated list of userID:courseID, comma separated list of adminID (unit administrators)
Returns:		table (lastname firstname userid email course_names)

Called By:		BusinessServices.Course.GetAdminMashup in Course.cs
Calls:			None

Remarks:		None

Author:			Mark Donald
Date Created:	20 Jan 2010

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcCourse_AdminMashup]
@organisationID int,
@unitIDs 			varchar(MAX),
@courseIDs 			varchar(8000),
@input_csv varchar(8000),
@adminids varchar(8000),
@classificationID 	int,
@courseModuleStatus	int,
@quizDateFrom 		datetime,
@quizDateTo 		datetime,
@includeInactive	int
AS
BEGIN
SET NOCOUNT ON;


set @quizDateFrom = dbo.udfDaylightSavingTimeToUTC(@quizDateFrom, @organisationID)
set @quizDateTo = dbo.udfDaylightSavingTimeToUTC(@quizDateTo, @organisationID)

declare @tblUserUnit table
(
UserID int,
UnitID int
)


declare @tblUnit table
(
unitID int
)

declare @tblUnitAdministrator table
(
unitID int,
AdminUserID int,
firstname nvarchar(200),
lastname nvarchar(200)
)
Set Nocount On
Declare
@CONST_INCOMPLETE     	int,
@CONST_COMPLETE     	int,
@CONST_FAILD            int,
@CONST_NOTSTARTED 	    int,
@CONST_UNKNOWN 	        int,
@CONST_EXPIRED_TIMELAPSED int,
@CONST_EXPIRED_NEWCONTENT int

set @CONST_INCOMPLETE	= 0
set @CONST_COMPLETE	    = 1
set @CONST_FAILD		= 2
set @CONST_NOTSTARTED	= 3
set @CONST_EXPIRED_TIMELAPSED	= 4
set @CONST_EXPIRED_NEWCONTENT  = 5

DECLARE @Units TABLE (UnitID INT)
DECLARE @Courses TABLE (CourseID INT)
DECLARE @CoursesWithAccess TABLE (CourseID INT PRIMARY KEY, [name] nvarchar(100))
DECLARE @UserModuleWithAccess TABLE (UserID INT, ModuleID INT, UnitID INT, PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE (ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE (UserID INT, UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @UsersQuizStatusNOTSTARTED TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @mashup TABLE (userid int, courseid int)
DECLARE @selectedadmin TABLE (adminid int)
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50)

INSERT INTO
@Courses
SELECT
*
FROM
dbo.udfCsvToInt(@courseIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

INSERT INTO
@selectedadmin
SELECT
*
FROM
dbo.udfCsvToInt(@adminids)

--Get Rid of courses which do not have access to specified org
INSERT INTO
@CoursesWithAccess
SELECT
A.CourseID, [name]
FROM
@Courses A, tblOrganisationCourseAccess B, tblCourse C
WHERE
A.CourseID = B.GrantedCourseID
AND B.OrganisationID = @organisationID
AND A.CourseID = C.CourseID
AND C.Active = 1

--Get All the users for all specfied units
INSERT INTO
@Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
join  @Units B on A.UnitID = B.UnitID
join  tblUnit C on B.UnitID = C.UnitID  AND C.Active = 1
WHERE
@includeinactive =1 or A.Active = 1 -- show all or only active users



if @courseModuleStatus = @CONST_COMPLETE or @courseModuleStatus = @CONST_INCOMPLETE
begin -- completed / -- InComplete
--------------------
-- Completed --
--------------------
-- A user is completed if they became complete and remained completed in the period of interest
-- the query only needs to check to see status at the max date in this period as a line item
-- as tblUserCourseStatus is only writen to when an event occours that would
-- change the status.
-- When "Course/Module Status" is set to "Complete"
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question
--------------------
-- InComplete
--------------------
-- A user is in-completed if for any reason they are not complete but do have access to the course
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Incomplete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question

INSERT INTO @tblUserUnit(UserID, UnitID)
SELECT
DISTINCT A.UserID, A.UnitID
FROM
(SELECT
A.UserID, D.UnitID
FROM
(SELECT
A.UserID, A.CourseID, MAX(A.UserCourseStatusID) AS ''LatestCourseStatus''
FROM
tblUserCourseStatus A, @CoursesWithAccess B
WHERE
A.DateCreated < DATEADD(DD, 1, @quizDateTo)
and A.CourseID = B.CourseID
GROUP BY
A.UserID, A.CourseID
) A, @Users B, tblUserCourseStatus C, tblUser D
WHERE
A.UserID = B.UserID
AND B.UserID = C.UserID
AND A.LatestCourseStatus = C.UserCourseStatusID
AND (C.DateCreated BETWEEN @quizDateFrom AND @quizDateTo)
AND C.CourseStatusID = case @courseModuleStatus
when @CONST_COMPLETE then 2   -- Complete
when @CONST_INCOMPLETE then 1 -- InComplete
end
AND A.UserID = D.UserID
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
WHERE
--If classification is Any (0), This will find users of any Custom Classification
(@classificationID =0 OR tblUserClassification.classificationID = @classificationID)
AND A.UserID IN (select UserID from tblUser where OrganisationID = @organisationID and Active = 1)
ORDER BY
A.UserID, A.UnitID
END -- completed / -- InComplete


if @courseModuleStatus = @CONST_FAILD or @courseModuleStatus = @CONST_EXPIRED_TIMELAPSED or @courseModuleStatus = @CONST_EXPIRED_NEWCONTENT
begin -- Failed
--------------------
-- Failed  --
--------------------
-- When "Course/Module Status" is set to "Failed"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND took a quiz, for a Module within the selected Course, within the date range and failed it
--  - AND who currently have a status other than "Passed" for that same quiz
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
)A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID

INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID = case @courseModuleStatus
when @CONST_FAILD then 3   -- Failed
when @CONST_EXPIRED_TIMELAPSED then 4 -- Expired time lapsed
when @CONST_EXPIRED_NEWCONTENT then 5 -- Expired new content
end

--Get Data in report format
INSERT INTO @tblUserUnit(UserID, UnitID)
SELECT
DISTINCT A.UserID, UnitID
FROM
(select
distinct userid, moduleid
from
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D
WHERE
A.UserID = B.UserID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
ORDER BY
A.UserID, UnitID
end --/ Failed


-- Not started --

if @courseModuleStatus = @CONST_NOTSTARTED
begin -- Not started - Any
--------------------
-- Not started  --
--------------------
-- When "Course/Module Status" is set to "Not Started"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND who have not started ANY of the quizes they have access to in this course
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
) A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID
AND (B.DateCreated BETWEEN @quizDateFrom AND @quizDateTo)

--select * from @UsersNQuizStatus

--Get User with Quiz NOT STARTED
INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID NOT IN (2,3)
AND UserID NOT IN (SELECT UserID FROM @UsersNQuizStatus WHERE QuizStatusID IN (2,3))

--select * from @UsersQuizStatusNOTSTARTED
--select distinct userid,moduleid from @UsersQuizStatusNOTSTARTED

--Get Data in report format
INSERT INTO @tblUserUnit(UserID, UnitID)
SELECT
A.UserID, UnitID
FROM
(SELECT
DISTINCT A.UserID, B.UnitID
FROM
(SELECT
DISTINCT userid, moduleid
FROM
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D
WHERE
A.UserID = B.UserID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
WHERE
--If classification is Any (0), This will find users of any Custom Classification
@classificationID =0 OR tblUserClassification.classificationID = @classificationID
ORDER BY
A.UserID, UnitID

end --/ Not started - Any


insert into @tblUnit(UnitID)
select distinct UnitID
from @tblUserUnit

---If "Administrators" was selected as the Recipient Type, then the email will be sent to the administrators of the users Units.
insert into @tblUnitAdministrator (UnitID, AdminUserID,firstname, lastname)
select u.UnitID, ua.UserID, us.firstname, us.lastname
from @tblUnit u
inner join tblUnitAdministrator ua
on ua.UnitID = u.UnitID
inner join tblUser us
on us.UserID = ua.UserID and us.UserTypeID = 3 --Unit Administrator

--If a user belongs to a Unit that does not have its own administrator, the email will go to the Organisation Administrators.
insert into @tblUnitAdministrator (UnitID, AdminUserID,firstname, lastname)
select u.UnitID, us.UserID, us.firstname, us.lastname
from tblUser us
cross join @tblUnit u
where us.OrganisationID = @organisationID
and us.UserTypeID = 2 -- Organisation Administrator
and u.UnitID not in (select UnitID from @tblUnitAdministrator)
and us.Active = 1


-- clean up the input so it resembles ''userid:courseid,userid:courseid,''
SELECT @input_csv = replace(rtrim(ltrim(replace(replace(replace(@input_csv,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''

-- rip input_csv
WHILE patindex(''%,%'', @input_csv) <> 0
BEGIN
SELECT @pos = patindex(''%,%'', @input_csv)
SELECT @temp = left(@input_csv, @pos - 1)
SELECT @colon_pos = patindex(''%:%'', @input_csv)
INSERT @mashup VALUES (
cast(substring(@temp, 1, @colon_pos - 1) AS int),
cast(substring(@temp, @colon_pos + 1, len(@temp)) AS int)
)
SELECT @input_csv = substring(@input_csv, @pos + 1, len(@input_csv))
END

-- join @mashup, @tblunitadministrator & @selectedadmin tables & sort results by adminid and courseid
SELECT
adminid, a.email, a.firstname, a.lastname, m.courseid, [name] coursename, u.firstname, u.lastname, n.firstname, n.lastname, u.UserID
FROM
@mashup m,
@tblunitadministrator n,
@selectedadmin s,
tbluser a,
tblcourse c,
tbluser u
WHERE
u.userid = m.userid
AND n.unitid = u.unitid
AND a.userid = adminid
AND adminid = adminuserid
AND c.courseid = m.courseid
ORDER BY
adminid, m.courseid

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_Create]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Created a new Course.

Parameters:
@intCourseID
@name
@notes
@active
@userID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Course.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeeded
4. UniqueViolationException
5. ParameterException
10. BusinessServiceException (General)


Author: Gavin Buddis
Date Created: 17th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE   Procedure [prcCourse_Create]
(
@intCourseID Integer OutPut, -- The ID of the newly created course.
@name nVarchar(100) = Null,
@notes nVarchar(1000) = Null,
@active Bit = 1,
@userID Integer = Null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @name
If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure prcCourse_Create''
Goto Finalise
End

--Validate Parameter @showDisclaimer
If(@active Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure prcCourse_Create''
Goto Finalise
End

--Validate Parameter @userID
If(@userID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcCourse_Create''
Goto Finalise
End

If Not Exists(Select * From tblCourse Where Name = @name)
Begin
-- Insert the new record
Insert Into tblCourse
(
[Name],
Notes,
Active,
CreatedBy,
DateCreated,
UpdatedBy,
DateUpdated
)
Values
(
@name,
@notes,
@active,
@userID,
GetUTCDate(),
@userID,
GetUTCDate()
)

-- Set the error message to successfull
Set @intErrorNumber = 0
Select @intCourseID = @@Identity

-- Finalise the procedure
Goto Finalise
End
Else
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Course Name '' + @name + '' already exists please choose another Course Name.''

Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetByUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Given a user id returns the list of Active courses a user has access to
If the User id is ommited it returns all the courses
Returns:
Course ID

Called By: Home.aspx
Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



--------------------
prcCourse_GetByUser @userID=11

**/

CREATE  Proc [prcCourse_GetByUser]
(
@userID int = Null
)
AS
------------------------------------------
Set Nocount On
Select Distinct
CourseID
, Name
From
tblCourse tC
inner join tblOrganisationCourseAccess tOCA
on tC.CourseID = tOCA.GrantedCourseID
inner join tblUser tU
on tU.OrganisationID = tOCA.OrganisationID
Where
tC.Active = 1
and tU.UserID = isnull(@userID, tU.UserID)
Order By
tC.CourseID




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary: Gets a list of all Courses
Parameters: None
Returns: table

Called By: BusinessServices.Course.GetCourseList in Course.cs
Calls: None

Remarks: None

Author: Stephen Kenendy-Clark
Date Created: 06th of Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcCourse_GetList]

@OrgID int

As

Select
[CourseID]
, [Name]
, [Notes]
, [Active]
, [CreatedBy]
, dbo.udfUTCtoDaylightSavingTime([DateCreated], @OrgID)
, [UpdatedBy]
, dbo.udfUTCtoDaylightSavingTime([DateUpdated], @OrgID)
From
[tblCourse]
Order by Name

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetListByOrganisation]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'




/*
Summary: Gets a list of all Courses
Parameters: None
Returns:

Called By: BusinessServices.Course.GetCourseListAccessableToOrg
Calls: None

Remarks: None

Author: Stephen Kenendy-Clark
Date Created: 06th of Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/


CREATE     Procedure [prcCourse_GetListByOrganisation]
(
@organisationID  int -- The organisation ID
,@excludeInactive int
)

As

-------------------------------------------------------------
-- Return Select
-------------------------------------------------------------
Select
c.[CourseID]
, c.[Name]
, c.[Notes]
, c.[Active]
, c.[CreatedBy]
, dbo.udfUTCtoDaylightSavingTime(c.[DateCreated], @organisationID)
, c.[UpdatedBy]
, dbo.udfUTCtoDaylightSavingTime(c.[DateUpdated], @organisationID)
From
[tblCourse] c
inner Join tblOrganisationCourseAccess oca
on oca.GrantedCourseID = c.CourseID and (@excludeInactive = 0 or (@excludeInactive = 1 and Active = 1))
and oca.organisationID = @organisationID
order by c.Name





' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetListByUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets a list of all Courses a user can access
Parameters: None
Returns:

Called By: BusinessServices.Course.GetCourseListAccessableToUser
Calls: None

Remarks: None

Author: Stephen Kenendy-Clark
Date Created: 04th of May 2004

prcCourse_GetListByUser 11
Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcCourse_GetListByUser]
(
@userid  int -- The UserID
)

As

-------------------------------------------------------------
-- Return Select
-------------------------------------------------------------
Select distinct
c.[CourseID]
, c.[Name]
, c.[Notes]
, c.[Active]
, c.[CreatedBy]
, dbo.udfUTCtoDaylightSavingTime(c.[DateCreated], vUMA.OrganisationID)
, c.[UpdatedBy]
, dbo.udfUTCtoDaylightSavingTime(c.[DateUpdated], vUMA.OrganisationID)
From
[tblCourse] c
inner Join vwUserModuleAccess vUMA
on vUMA.CourseID = c.CourseID
and vUMA.userid = @userid
order by c.Name
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetNotes]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Given a Course id return the Course notes
Returns:
Course Notes

Called By: Home.aspx via BusinessServices.Course.GetNotes
Calls: null

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

--------------------
prcCourse_GetNotes @courseID=11

**/

CREATE  Proc [prcCourse_GetNotes]
(
@courseID int -- Course ID
)
AS
------------------------------------------
Set Nocount On
Select
Notes
From
tblCourse
Where
CourseID = @courseID





' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets a list of all Courses
Parameters: CourseID int
Returns: table

Called By: BusinessServices.Course.GetCourse
Calls: None

Remarks: None

Author: Stephen Kenendy-Clark
Date Created: 06th of Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE   Procedure [prcCourse_GetOne]
(
@CourseID  int=null -- the course id
, @OrgID int
)

As

Select
[CourseID]
, [Name]
, [Notes]
, [Active]
, [CreatedBy]
, dbo.udfUTCtoDaylightSavingTime([DateCreated], @OrgID) as DateCreated
, [UpdatedBy]
, dbo.udfUTCtoDaylightSavingTime([DateUpdated], @OrgID) as DateUpdated
From
[tblCourse]
Where
CourseID = @CourseID
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetOneBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
Gets the course id for a session.
This proc is called by the home page

Parameters:
@sessionID


Returns:
table

Called By:
Course.cs.

Calls:
udfGetLessonIDBySessionID

Remarks:
no exceptions thrown

Author: Stephen Kennedy - Clark
Date Created: 4 March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


-- prcCourse_GetOneBySessionID @sessionID=''329E7586-81D3-45B2-A981-E7760435DDE4''

**/
CREATE   Procedure [prcCourse_GetOneBySessionID]
(
@sessionID varchar(50) = Null
)

As
-----------------------------------------------------------
-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Simple error check, if the session ID is not a valid guid then dont try and
-- get the course ID
if (dbo.udfIsGUID(@sessionID) = 0)
begin
select -1 as CourseID
return
end
if dbo.udfGetLessonIDBySessionID(@sessionID) is null and dbo.udfGetQuizIDBySessionID(@sessionID) is null
begin
select -1 as CourseID
return
end


--  The GUID is valid and exists
--  so get the details required form the underlying udfs
Select
tM.CourseID
From
tblModule tM
inner join tblLesson tL
on tL.ModuleID = tM.ModuleID
and tL.LessonID = dbo.udfGetLessonIDBySessionID(@sessionID)
union
Select
tM.CourseID
From
tblModule tM
inner join tblQuiz tQ
on tQ.ModuleID = tM.ModuleID
and tQ.QuizID = dbo.udfGetQuizIDBySessionID(@sessionID)




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetSelected]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:		Gets a list of Courses
Parameters:		Comma separated list of courseIDs
Returns:		table

Called By:		BusinessServices.Course.GetCourseList in Course.cs
Calls:			None

Remarks:		None

Author:			Mark Donald
Date Created:	10 Nov 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcCourse_GetSelected]
@courseIDs varchar(8000)
, @OrgID int
AS
BEGIN
SET NOCOUNT ON;

SELECT
courseid, [name], notes, active, createdby, dbo.udfUTCtoDaylightSavingTime(datecreated, @OrgID), updatedby, dbo.udfUTCtoDaylightSavingTime(dateupdated, @OrgID)
FROM
tblcourse
WHERE
courseid IN (SELECT * FROM dbo.udfCsvToInt(@courseIDs))
ORDER BY [name]
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Updates a Course.

Parameters:
@courseID
@name
@notes
@active
@userID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Course.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Gavin Buddis
Date Created: 16 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE  Procedure [prcCourse_Update]
(
@courseID Integer = Null,
@name nVarchar(100) = Null,
@notes nVarchar(1000) = Null,
@active Bit = 1,
@userID Integer = Null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @courseID
If(@courseID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @courseID in stored procedure prcCourse_Update''
Goto Finalise
End

-- Validate that the Caption for this link doesn''t exist.
If Exists(Select * From tblCourse Where [Name] = @name And courseID != @courseID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Name '' + @name + '' already exists please choose another Name.''
Goto Finalise
End

--Validate Parameter @name
If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure prcCourse_Update''
Goto Finalise
End

--Validate Parameter @notes
If(@notes Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @notes in stored procedure prcCourse_Update''
Goto Finalise
End

--Validate Parameter @active
If(@active Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure prcCourse_Update''
Goto Finalise
End

--Validate Parameter @userID
If(@userID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcCourse_Update''
Goto Finalise
End

If Exists(Select * From tblCourse Where CourseID = @courseID)
Begin
-- Update the record in tblCourse
Update tblCourse
Set
[Name] = @name,
Notes = @notes,
Active = @active,
UpdatedBy = @userID,
DateUpdated = GetUTCDate()
Where
CourseID = @courseID

-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Updated''

-- Finalise the procedure
Goto Finalise
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''

Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_UserMashup]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:		Compiles a %COURSE_NAMES% block and returns it with a bunch of user info for sending email to that user
Parameters:		Comma separated list of userID:courseID
Returns:		table (lastname nvarchar(50), firstname nvarchar(50), userid int, email nvarchar(100), course_names varchar(8000))

Called By:		BusinessServices.Course.GetUserMashup in Course.cs
Calls:			None

Remarks:		None

Author:			Mark Donald
Date Created:	13 Nov 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcCourse_UserMashup]
@input_csv varchar(8000),
@user_ids varchar(8000)
AS
BEGIN
SET NOCOUNT ON;

DECLARE @mashup TABLE (userid int, courseid int)
DECLARE @selected_users TABLE (userid int)
DECLARE @result TABLE (firstname nvarchar(50), lastname nvarchar(50), userid int, email nvarchar(100), course_names varchar(8000))
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50),
@userid int,
@course_names varchar(8000)

-- rip the user selection
INSERT INTO @selected_users
SELECT
*
FROM
dbo.udfCsvToInt(@user_ids)

-- clean up the input so it resembles ''userid:courseid,userid:courseid,''
SELECT @input_csv = replace(rtrim(ltrim(replace(replace(replace(@input_csv,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''

-- rip the csv into a table
WHILE patindex(''%,%'', @input_csv) <> 0
BEGIN
SELECT @pos = patindex(''%,%'', @input_csv)
SELECT @temp = left(@input_csv, @pos - 1)
SELECT @colon_pos = patindex(''%:%'', @input_csv)
INSERT @mashup VALUES (
cast(substring(@temp, 1, @colon_pos - 1) AS int),
cast(substring(@temp, @colon_pos + 1, len(@temp)) AS int)
)
SELECT @input_csv = substring(@input_csv, @pos + 1, len(@input_csv))
END

-- Note to self: if the reporting server environment is ever upgraded
-- to SQL Server 2005+ we can improve performace by dicing the cursor
-- and @result table in favour of a UDA function... (UDAs are not
-- available in SS2000)
SELECT @course_names = ''<BR>&nbsp;''
DECLARE concatenator CURSOR READ_ONLY FOR
SELECT
userid
FROM
@selected_users
OPEN concatenator
FETCH NEXT FROM concatenator INTO @userid
WHILE @@FETCH_STATUS = 0
BEGIN
SELECT
@course_names = @course_names + [name] + ''<BR>&nbsp;''
FROM
tblcourse c, @mashup m
WHERE
c.courseid = m.courseid
AND userid = @userid
INSERT INTO
@result
SELECT
lastname, firstname, userid, email, @course_names
FROM
tbluser
WHERE
userid = @userid
SELECT @course_names = ''<BR>&nbsp;''
FETCH NEXT FROM concatenator INTO @userid
END
CLOSE concatenator
DEALLOCATE concatenator

SELECT * FROM @result
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDEmail_Report]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE procedure [prcCPDEmail_Report]
(
@ProfileID  int,
@UnitIDs varchar(MAX)
)
as
select  distinct pf.profileid
, u.userid
, u.lastname
, u.firstname
,hierarchyname = dbo.udfGetUnitPathway(u.UnitID)
,u.email as useremail
from tblProfile pf
join tblprofileperiod pp on pp.profileid = pf.profileid
join tbluserprofileperiodaccess upa on upa.profileperiodid = pp.profileperiodid
and granted = 1
join tbluser  u on u.userid = upa.userid
left join tblusercpdpoints upt on upt.userid = u.userid
where pf.profileid = @ProfileID and
pp.profileperiodactive = 1 and
getutcdate() between pp.datestart and dateadd(d,1,pp.dateend) and
pp.points > coalesce(upt.points,0) and
u.unitid in (select IntValue from dbo.udfCsvToInt(@UnitIDs)) and
u.userid in
(-- users for a course
select distinct uma.userid from
tblProfile p
join tblProfilePeriod pp
on p.profileid = pp.profileid
join tblProfilePoints ppts
on pp.profileperiodid = ppts.profileperiodid
join tblModule m on ppts.typeid = m.moduleid
join vwUserModuleAccess uma on uma.courseid = m.courseid and u.userid=uma.userid
where p.profileid = @profileid
and pp.profileperiodactive = 1
and ppts.profilepointstype = ''M'')
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDModuleHistory_Report]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE procedure [prcCPDModuleHistory_Report]
(
@ProfileID  varchar(20),
@ModuleID	varchar(20),
@UserID		varchar(20),
@OrgID		int
)
as

select
convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(pp.DateStart, @OrgID),113) + '' - '' + convert( varchar(11),dbo.udfUTCtoDaylightSavingTime(pp.DateEnd, @OrgID),113) as PeriodDesc,
sum(upt.Points) as Points
from
tblProfilePeriod pp
join tblProfilePoints pt
on pt.profileperiodid =pp.profileperiodid
join tbluserCPDPoints upt
on upt.profilepointsID = pt.profilepointsid
where
pt.profilepointstype =''M''
and pt.typeid = @ModuleID
and pp.profileid =@ProfileID
and upt.userid =@UserID
--and GETUTCDATE() between pp.DateStart and pp.dateend
group by
convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(pp.DateStart, @OrgID),113) + '' - '' + convert( varchar(11),dbo.udfUTCtoDaylightSavingTime(pp.DateEnd, @OrgID),113)


SET QUOTED_IDENTIFIER ON
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDPoints_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE procedure [prcCPDPoints_Update]
(
@profileid int = -1,
@OrgID int
)
as begin
set nocount on
declare @userquizstatusid int
declare @userlessonstatusid int
declare @userid int
declare @quizstatusid int
declare @lessonstatusid int
declare @datecreated datetime
declare @pointsgiven bit
declare @applytoquiz bit
declare @applytolesson bit
declare @profilepointsid int
declare @points numeric(10,1)
declare @quizpassed bit
declare @lessonpassed bit
declare @userstatusid int
declare @statusid int
declare @type char
declare @moduleid int
declare @newmoduleid int

set @applytoquiz = (select applytoquiz from tblProfilePeriod pp join tblProfile p
on pp.profileid = p.profileid where p.profileid = @profileid and ProfilePeriodActive = 1)

set @applytolesson = (select applytolesson from tblProfilePeriod pp join tblProfile p
on pp.profileid = p.profileid where p.profileid = @profileid and ProfilePeriodActive = 1)

-- delete points (if requirements re: lesson and quiz have changed)
-- find User CPD points within the period
declare @lessonquizstatus int
declare @profileperiodid int

-- lessonquizstatus
-- 0 Lesson Only
-- 1 Quiz Only
-- 2 Lesson and Quiz

select @lessonquizstatus =
(case when (applytoquiz = 1 and applytolesson = 1) then	2
when (applytoquiz = 0 and applytolesson = 1) then	0
when (applytoquiz = 1 and applytolesson = 0) then	1
end), @profileperiodid = pp.profileperiodid
from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
where p.profileid = @profileid and ProfilePeriodActive =1

delete from tblusercpdpoints
where profilepointsid in
(select profilepointsid from tblprofilepoints where profileperiodid = @profileperiodid and active=1 and profilepointstype=''M'')
--and lessonquizstatus not in (@lessonquizstatus)
and userid in (select distinct uppa.UserID from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
where p.ProfileID = @profileid
and uppa.Granted = 1)

-- need to interate through for each user that has access to the profile
declare usercursor cursor for
select distinct uppa.UserID from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID and pp.ProfilePeriodActive = 1
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
where p.ProfileID = @profileid
and uppa.Granted = 1

open usercursor

fetch next from usercursor into @userid

while @@FETCH_STATUS = 0

begin

-- Apply to Quiz only
if (@applytoquiz = 1 and @applytolesson = 0)
begin
-- Get and iterate through the user quiz status records for the user
declare userquizcursor cursor for
select m.moduleid, ppts.profilepointsid, ppts.points, UserQuizStatusID, QuizStatusID, dbo.udfUTCtoDaylightSavingTime(uqs.datecreated, @OrgID) from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID and pp.ProfilePeriodActive = 1
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserQuizStatus uqs on uppa.UserID = uqs.UserID
join tblQuizSession qs on uqs.quizsessionid = qs.quizsessionid
join tblQuiz q on q.quizid = qs.quizid
join tblModule m on m.moduleid = q.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uqs.datecreated between pp.datestart and dateadd(d,1,pp.dateend)
order by m.moduleid, uqs.datecreated

-- initialise
set @pointsgiven = 0
set @moduleid = 0
set @newmoduleid = 0

open userquizcursor

fetch next from userquizcursor
into @newmoduleid, @profilepointsid, @points, @userquizstatusid, @quizstatusid, @datecreated

while @@FETCH_STATUS = 0
begin
if @newmoduleid <> @moduleid
begin
set @pointsgiven = 0
end
if @pointsgiven = 0
begin
if @quizstatusid = 2
begin
insert into tblUserCPDPoints (ProfilePointsID, UserID, Points, DateAssigned, LessonQuizStatus)
values (@profilepointsid, @userID, @points, @datecreated, 1)
set @pointsgiven = 1
end
end
if @pointsgiven = 1
begin
if @quizstatusid = 5
begin
set @pointsgiven = 0
end
end

set @moduleid = @newmoduleid
fetch next from userquizcursor
into @newmoduleid, @profilepointsid, @points, @userquizstatusid, @quizstatusid, @datecreated
end

close userquizcursor
deallocate userquizcursor
end

-- Apply to Lesson Only
if (@applytoquiz = 0 and @applytolesson = 1)
begin
-- Get and iterate through the user lesson status records for the user
declare userlessoncursor cursor for
select m.moduleid, ppts.profilepointsid, ppts.points, UserLessonStatusID, LessonStatusID, dbo.udfUTCtoDaylightSavingTime(uls.datecreated, @OrgID) from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID and pp.ProfilePeriodActive = 1
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserLessonStatus uls on uppa.UserID = uls.UserID
join tblModule m on m.moduleid = uls.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uls.datecreated between pp.datestart and dateadd(d,1,pp.dateend)
order by m.moduleid, uls.datecreated

-- initialise
set @pointsgiven = 0
set @moduleid = 0
set @newmoduleid = 0

open userlessoncursor

fetch next from userlessoncursor
into @newmoduleid, @profilepointsid, @points,@userlessonstatusid, @lessonstatusid, @datecreated

while @@FETCH_STATUS = 0
begin
if @newmoduleid <> @moduleid
begin
set @pointsgiven = 0
end
if @pointsgiven = 0
begin
if @lessonstatusid = 3
begin
insert into tblUserCPDPoints (ProfilePointsID, UserID, Points, DateAssigned, LessonQuizStatus)
values (@profilepointsid, @userID, @points, @datecreated, 0)
set @pointsgiven = 1
end
end
if @pointsgiven = 1
begin
if @lessonstatusid = 5
begin
set @pointsgiven = 0
end
end
set @moduleid = @newmoduleid
fetch next from userlessoncursor
into @newmoduleid, @profilepointsid, @points,@userlessonstatusid, @lessonstatusid, @datecreated
end

close userlessoncursor
deallocate userlessoncursor
end

-- Apply to Quiz and Lesson
if (@applytoquiz = 1 and @applytolesson = 1)
begin
create table #tempUserStatus
(
moduleid int,
profilepointsid int,
points numeric(10,1),
userstatusid int,
statusid int,
datecreated datetime,
type char
)
-- insert quiz status values into temp status table
insert into #tempUserStatus (moduleid, profilepointsid, points, userstatusid, statusid, datecreated, type)
select m.moduleid, ppts.profilepointsid, ppts.points, UserQuizStatusID, QuizStatusID, uqs.datecreated, ''Q'' from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID and pp.ProfilePeriodActive = 1
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserQuizStatus uqs on uppa.UserID = uqs.UserID
join tblQuizSession qs on uqs.quizsessionid = qs.quizsessionid
join tblQuiz q on q.quizid = qs.quizid
join tblModule m on m.moduleid = q.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uqs.datecreated between pp.datestart and dateadd(d,1,pp.dateend)

-- insert lesson status values into temp status table
insert into #tempUserStatus (moduleid, profilepointsid, points, userstatusid, statusid, datecreated, type)
select m.moduleid, ppts.profilepointsid, ppts.points, UserLessonStatusID, LessonStatusID, uls.datecreated, ''L'' from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID and pp.ProfilePeriodActive = 1
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserLessonStatus uls on uppa.UserID = uls.UserID
join tblModule m on m.moduleid = uls.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uls.datecreated between pp.datestart and dateadd(d,1,pp.dateend)

set @pointsgiven = 0
set @quizpassed = 0
set @lessonpassed = 0
set @moduleid = 0
set @newmoduleid = 0

declare userquizlessoncursor cursor for
select * from #tempUserStatus order by moduleid, datecreated

open userquizlessoncursor

fetch next from userquizlessoncursor
into @newmoduleid, @profilepointsid, @points,@userstatusid, @statusid, @datecreated, @type
while @@FETCH_STATUS = 0
begin
if @newmoduleid <> @moduleid
begin
set @pointsgiven = 0
set @lessonpassed = 0
set @quizpassed = 0
end
if @pointsgiven = 0
begin
if (@statusid = 2 and @type = ''Q'' and @quizpassed = 0)
begin
-- passed quiz
set @quizpassed = 1
end
if (@statusid = 3 and @type = ''L'' and @lessonpassed = 0)
begin
-- lesson passed
set @lessonpassed = 1
end
if (@quizpassed = 1 and @lessonpassed = 1)
begin
-- give points
insert into tblUserCPDPoints (ProfilePointsID, UserID, Points, DateAssigned, LessonQuizStatus)
values (@profilepointsid, @userID, @points, @datecreated, 2)
set @pointsgiven = 1
end
end
if (@pointsgiven = 1)
begin
if (@statusid = 5 and @type = ''Q'')
begin
set @quizpassed = 0
set @pointsgiven = 0
end
if (@statusid = 5 and @type = ''L'')
begin
set @lessonpassed = 0
set @pointsgiven = 0
end
end
set @moduleid = @newmoduleid
fetch next from userquizlessoncursor
into @newmoduleid, @profilepointsid, @points,@userstatusid, @statusid, @datecreated, @type
end

drop table #tempUserStatus
close userquizlessoncursor
deallocate userquizlessoncursor
end

fetch next from usercursor into @userid

end

close usercursor
deallocate usercursor
set nocount off
end

SET QUOTED_IDENTIFIER ON
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDPoints_UpdateUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE procedure [prcCPDPoints_UpdateUser]
(
@profileid int,
@userid int,
@OrgID int
)
as begin
set nocount on
declare @userquizstatusid int
declare @userlessonstatusid int
declare @quizstatusid int
declare @lessonstatusid int
declare @datecreated datetime
declare @pointsgiven bit
declare @applytoquiz bit
declare @applytolesson bit
declare @profilepointsid int
declare @points numeric(10,1)
declare @quizpassed bit
declare @lessonpassed bit
declare @userstatusid int
declare @statusid int
declare @type char
declare @moduleid int
declare @newmoduleid int

set @applytoquiz = (select applytoquiz from tblProfilePeriod pp join tblProfile p
on pp.profileid = p.profileid where p.profileid = @profileid and pp.profileperiodactive = 1)

set @applytolesson = (select applytolesson from tblProfilePeriod pp join tblProfile p
on pp.profileid = p.profileid where p.profileid = @profileid and pp.profileperiodactive = 1)

-- delete points (if requirements re: lesson and quiz have changed)
-- find User CPD points within the period
declare @lessonquizstatus int
declare @profileperiodid int

-- lessonquizstatus
-- 0 Lesson Only
-- 1 Quiz Only
-- 2 Lesson and Quiz

select @lessonquizstatus =
(case when (applytoquiz = 1 and applytolesson = 1) then	2
when (applytoquiz = 0 and applytolesson = 1) then	0
when (applytoquiz = 1 and applytolesson = 0) then	1
end), @profileperiodid = pp.profileperiodid
from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
where p.profileid = @profileid and pp.profileperiodactive=1 and GETUTCDATE() between pp.datestart and dateadd(d,1,pp.dateend)


delete from tblusercpdpoints
where profilepointsid in
(select profilepointsid from tblprofilepoints where profileperiodid = @profileperiodid and active=1 and profilepointstype=''M'')
and userid = @userid

-- add points for user

-- Apply to Quiz only
if (@applytoquiz = 1 and @applytolesson = 0)
begin
-- Get and iterate through the user quiz status records for the user
declare userquizcursor cursor for
select m.moduleid, ppts.profilepointsid, ppts.points, UserQuizStatusID, QuizStatusID, dbo.udfUTCtoDaylightSavingTime(uqs.datecreated, @OrgID) from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserQuizStatus uqs on uppa.UserID = uqs.UserID
join tblQuizSession qs on uqs.quizsessionid = qs.quizsessionid
join tblQuiz q on q.quizid = qs.quizid
join tblModule m on m.moduleid = q.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uqs.datecreated between pp.datestart and dateadd(d,1,pp.dateend)
order by m.moduleid, uqs.datecreated

-- initialise
set @pointsgiven = 0
set @moduleid = 0
set @newmoduleid = 0

open userquizcursor

fetch next from userquizcursor
into @newmoduleid, @profilepointsid, @points, @userquizstatusid, @quizstatusid, @datecreated

while @@FETCH_STATUS = 0
begin
if @newmoduleid <> @moduleid
begin
set @pointsgiven = 0
end
if @pointsgiven = 0
begin
if @quizstatusid = 2
begin
insert into tblUserCPDPoints (ProfilePointsID, UserID, Points, DateAssigned, LessonQuizStatus)
values (@profilepointsid, @userID, @points, @datecreated, 1)
set @pointsgiven = 1
end
end
if @pointsgiven = 1
begin
if @quizstatusid = 5
begin
set @pointsgiven = 0
end
end

set @moduleid = @newmoduleid
fetch next from userquizcursor
into @newmoduleid, @profilepointsid, @points, @userquizstatusid, @quizstatusid, @datecreated
end

close userquizcursor
deallocate userquizcursor
end

-- Apply to Lesson Only
if (@applytoquiz = 0 and @applytolesson = 1)
begin
-- Get and iterate through the user lesson status records for the user
declare userlessoncursor cursor for
select m.moduleid, ppts.profilepointsid, ppts.points, UserLessonStatusID, LessonStatusID, dbo.udfUTCtoDaylightSavingTime(uls.datecreated, @OrgID) from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserLessonStatus uls on uppa.UserID = uls.UserID
join tblModule m on m.moduleid = uls.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uls.datecreated between pp.datestart and dateadd(d,1,pp.dateend)
order by m.moduleid, uls.datecreated

-- initialise
set @pointsgiven = 0
set @moduleid = 0
set @newmoduleid = 0

open userlessoncursor

fetch next from userlessoncursor
into @newmoduleid, @profilepointsid, @points,@userlessonstatusid, @lessonstatusid, @datecreated

while @@FETCH_STATUS = 0
begin
if @newmoduleid <> @moduleid
begin
set @pointsgiven = 0
end
if @pointsgiven = 0
begin
if @lessonstatusid = 3
begin
insert into tblUserCPDPoints (ProfilePointsID, UserID, Points, DateAssigned, LessonQuizStatus)
values (@profilepointsid, @userID, @points, @datecreated, 0)
set @pointsgiven = 1
end
end
if @pointsgiven = 1
begin
if @lessonstatusid = 5
begin
set @pointsgiven = 0
end
end
set @moduleid = @newmoduleid
fetch next from userlessoncursor
into @newmoduleid, @profilepointsid, @points,@userlessonstatusid, @lessonstatusid, @datecreated
end

close userlessoncursor
deallocate userlessoncursor
end

-- Apply to Quiz and Lesson
if (@applytoquiz = 1 and @applytolesson = 1)
begin
create table #tempUserStatus
(
moduleid int,
profilepointsid int,
points numeric(10,1),
userstatusid int,
statusid int,
datecreated datetime,
type char
)
-- insert quiz status values into temp status table
insert into #tempUserStatus (moduleid, profilepointsid, points, userstatusid, statusid, datecreated, type)
select m.moduleid, ppts.profilepointsid, ppts.points, UserQuizStatusID, QuizStatusID, uqs.datecreated, ''Q'' from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserQuizStatus uqs on uppa.UserID = uqs.UserID
join tblQuizSession qs on uqs.quizsessionid = qs.quizsessionid
join tblQuiz q on q.quizid = qs.quizid
join tblModule m on m.moduleid = q.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uqs.datecreated between pp.datestart and dateadd(d,1,pp.dateend)

-- insert lesson status values into temp status table
insert into #tempUserStatus (moduleid, profilepointsid, points, userstatusid, statusid, datecreated, type)
select m.moduleid, ppts.profilepointsid, ppts.points, UserLessonStatusID, LessonStatusID, dbo.udfUTCtoDaylightSavingTime(uls.datecreated, @OrgID), ''L'' from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserLessonStatus uls on uppa.UserID = uls.UserID
join tblModule m on m.moduleid = uls.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uls.datecreated between pp.datestart and dateadd(d,1,pp.dateend)

set @pointsgiven = 0
set @quizpassed = 0
set @lessonpassed = 0
set @moduleid = 0
set @newmoduleid = 0

declare userquizlessoncursor cursor for
select * from #tempUserStatus order by moduleid, datecreated

open userquizlessoncursor

fetch next from userquizlessoncursor
into @newmoduleid, @profilepointsid, @points,@userstatusid, @statusid, @datecreated, @type
while @@FETCH_STATUS = 0
begin
if @newmoduleid <> @moduleid
begin
set @pointsgiven = 0
set @lessonpassed = 0
set @quizpassed = 0
end
if @pointsgiven = 0
begin
if (@statusid = 2 and @type = ''Q'' and @quizpassed = 0)
begin
-- passed quiz
set @quizpassed = 1
end
if (@statusid = 3 and @type = ''L'' and @lessonpassed = 0)
begin
-- lesson passed
set @lessonpassed = 1
end
if (@quizpassed = 1 and @lessonpassed = 1)
begin
-- give points
insert into tblUserCPDPoints (ProfilePointsID, UserID, Points, DateAssigned, LessonQuizStatus)
values (@profilepointsid, @userID, @points, @datecreated, 2)
set @pointsgiven = 1
end
end
if (@pointsgiven = 1)
begin
if (@statusid = 5 and @type = ''Q'')
begin
set @quizpassed = 0
set @pointsgiven = 0
end
if (@statusid = 5 and @type = ''L'')
begin
set @lessonpassed = 0
set @pointsgiven = 0
end
end
set @moduleid = @newmoduleid
fetch next from userquizlessoncursor
into @newmoduleid, @profilepointsid, @points,@userstatusid, @statusid, @datecreated, @type
end

drop table #tempUserStatus
close userquizlessoncursor
deallocate userquizlessoncursor
end
set nocount off
end

SET QUOTED_IDENTIFIER ON
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDProfileHistory_Report]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE procedure [prcCPDProfileHistory_Report]
(
@ProfileID  varchar(20),
@UserID		varchar(20)
)
as

select
convert(varchar (11),pp.DateStart,113) + '' - '' + convert( varchar(11),pp.DateEnd,113) as PeriodDesc,
sum(upt.Points) as PointsEarned,
pp.points as PointsRequired
from
tblProfilePeriod pp
join tblProfilePoints pt
on pt.profileperiodid =pp.profileperiodid
join tbluserCPDPoints upt
on upt.profilepointsID = pt.profilepointsid
where
pt.profilepointstype =''M''
and pp.profileid =@ProfileID
and upt.userid =@UserID
--and getutcdate() between pp.DateStart and pp.dateend
group by
convert(varchar (11),pp.DateStart,113) + '' - '' + convert( varchar(11),pp.DateEnd,113),pp.points


SET QUOTED_IDENTIFIER ON
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPD_CurrentPoints]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE procedure [prcCPD_CurrentPoints]
(
@ProfileID  varchar(20),
@ModuleID	varchar(20),
@UserID		varchar(20)
)
as

select
sum(upt.Points) as Points
from
tblProfilePeriod pp
join tblProfilePoints pt
on pt.profileperiodid =pp.profileperiodid
join tbluserCPDPoints upt
on upt.profilepointsID = pt.profilepointsid
where
pt.profilepointstype =''M''
and pt.typeid = @ModuleID
and pp.profileid =@ProfileID
and upt.userid =@UserID
and getutcdate() between pp.DateStart and dateadd(d,1,pp.dateend)
group by
convert(varchar (11),pp.DateStart,113) + '' - '' + convert( varchar(11),pp.DateEnd,113)

SET QUOTED_IDENTIFIER ON
' 
END
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPD_Report]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE procedure [dbo].[prcCPD_Report]
(
@profileid int = -1,
@profileperiodid int = -1,
@firstname varchar(200)='''',
@lastname varchar(200) ='''',
@username varchar(200)='''',
@shortfallusers smallint=0,
@UnitIDs varchar(max)='''',
@OrgID int
)
as begin


(select
hierarchyname as pathway
, u.lastname as lastname
, u.firstname as firstname
,u.username as username
,u.email as useremail
,c.name as coursee
,m.name collate database_default as module
,coalesce(upt.points,0) as points
,pf.profileid
,dbo.udfUTCtoDaylightSavingTime(upt.DateAssigned, @OrgID) as dateassigned
,m.sequence as modID
from tblProfile pf
join tblprofileperiod pp on pp.profileid = pf.profileid
join tbluserprofileperiodaccess upa on upa.profileperiodid = pp.profileperiodid
and granted = 1
join tbluser  u on u.userid = upa.userid
join tblunithierarchy uh on uh.unitid = u.unitid and u.unitid in (select IntValue from dbo.udfCsvToInt(@unitIDs))
left join tblProfilePoints ppt on ppt.profileperiodid =pp.profileperiodid
left join tblusercpdpoints upt on upt.userid = u.userid	 and upt.profilepointsid = ppt.profilepointsid
left join tblmodule m on m.moduleid = ppt.typeid and profilepointstype =''M''
left join tblcourse c on c.CourseID =  m.courseid
join vwusermoduleaccess uma on u.userid = uma.userid and m.moduleid = uma.moduleid
where
((@profileid= -1) or (pf.profileid = @profileid)) and
((@profileperiodid=-1) or (pp.profileperiodid  = @profileperiodid))and
((@firstname ='''') or (u.firstname=@firstname) ) and
((@lastname ='''') or (u.lastname =@lastname)) and
((@username ='''') or (u.username =@username)) and
((@shortfallusers =0)
or (
(select sum(u2.points) from tblusercpdpoints u2 where u2.userid = u.userid)<pp.points)
or (select sum(u2.points) from tblusercpdpoints u2 where u2.userid = u.userid) is null)
)

union

(select
hierarchyname as pathway
, u.lastname as lastname
, u.firstname as firstname
,u.username as username
,u.email as useremail
,case when policyname is null then '''' else ''Policy'' end as coursee
,coalesce(policyname,'''') collate database_default as module
,coalesce(upt.points,0) as points
,pf.profileid
,dbo.udfUTCtoDaylightSavingTime(upt.DateAssigned, @OrgID) as dateassigned
,null as modID
from tblProfile pf
join tblprofileperiod pp on pp.profileid = pf.profileid
join tbluserprofileperiodaccess upa on upa.profileperiodid = pp.profileperiodid
and granted = 1
join tbluser  u on u.userid = upa.userid
join tblunithierarchy uh on uh.unitid = u.unitid and u.unitid in (select IntValue from dbo.udfCsvToInt(@unitIDs))
left join tblProfilePoints ppt on ppt.profileperiodid =pp.profileperiodid
left join tblusercpdpoints upt on upt.userid = u.userid	 and upt.profilepointsid = ppt.profilepointsid
left join tblpolicy on tblPolicy.policyid = ppt.typeid and profilepointstype =''P''
join tblUserPolicyAccess upola on upola.userid = u.userid and upola.policyid = ppt.typeid and upola.granted = 1
where
(@profileid= -1 or pf.profileid = @profileid) and
(@profileperiodid=-1 or pp.profileperiodid  = @profileperiodid)and
(@firstname ='''' or u.firstname=@firstname ) and
(@lastname ='''' or u.lastname =@lastname) and
(@username ='''' or u.username =@username) and
(@shortfallusers =0
or (
(select sum(u2.points) from tblusercpdpoints u2 where u2.userid = u.userid)<pp.points)
or (select sum(u2.points) from tblusercpdpoints u2 where u2.userid = u.userid) is null)
)
Order by
coursee,
modID


end

SET QUOTED_IDENTIFIER OFF
' 
END
GO




SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcDatabaseMail_Setup]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE Procedure [prcDatabaseMail_Setup]

As

Set NoCount On

EXECUTE master.dbo.sp_configure ''show advanced options'', 1

reconfigure with override

EXECUTE  master.dbo.sp_configure ''Database Mail XPs'', 1

reconfigure

EXECUTE  master.dbo.sp_configure ''show advanced options'', 0

EXEC prcDatabaseMail_SetupProfile
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcDatabaseMail_SetupProfile]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE  Procedure [prcDatabaseMail_SetupProfile]

As

Set NoCount On

-- **** SETUP DATABASE MAIL ****

DECLARE @ProfileName VARCHAR(255)
DECLARE @AccountName VARCHAR(255)
DECLARE @SMTPAddress VARCHAR(255)
DECLARE @EmailAddress VARCHAR(128)
DECLARE @DisplayUser VARCHAR(128)
DECLARE @principal_sid varbinary(85)

SET @ProfileName = ''Salt_MailAccount'';
SET @AccountName = ''Salt_MailAccount'';
SELECT @SMTPAddress = Value FROM tblAppConfig WHERE Name = ''MailServer''
SELECT @EmailAddress = Value FROM tblAppConfig WHERE Name = ''FromEmail''
SELECT @DisplayUser = Value FROM tblAppConfig WHERE Name = ''FromName''

IF @EmailAddress IS NULL
SELECT @EmailAddress = Value FROM tblAppConfig WHERE Name = ''SupportEmail''

IF @DisplayUser IS NULL
SELECT @DisplayUser = Value FROM tblAppConfig WHERE Name = ''SupportEmail''

IF EXISTS (SELECT * FROM msdb.dbo.sysmail_account a WHERE a.name = @AccountName)
EXECUTE msdb.dbo.sysmail_update_account_sp
@account_name = @AccountName
,@email_address = @EmailAddress
,@display_name = @DisplayUser
,@mailserver_name = @SMTPAddress
ELSE
EXECUTE msdb.dbo.sysmail_add_account_sp
@account_name = @AccountName
,@email_address = @EmailAddress
,@display_name = @DisplayUser
,@mailserver_name = @SMTPAddress

IF NOT EXISTS (	SELECT *
FROM msdb.dbo.sysmail_profile p
WHERE p.name = @ProfileName
)
EXECUTE msdb.dbo.sysmail_add_profile_sp
@profile_name = @ProfileName

IF NOT EXISTS (	SELECT *
FROM msdb.dbo.sysmail_profileaccount pa
JOIN msdb.dbo.sysmail_profile p ON pa.profile_id = p.profile_id
JOIN msdb.dbo.sysmail_account a ON pa.account_id = a.account_id
WHERE p.name = @ProfileName AND a.name = @AccountName
)
EXECUTE msdb.dbo.sysmail_add_profileaccount_sp
@profile_name = @ProfileName
,@account_name = @AccountName
,@sequence_number = 1

SELECT @principal_sid = msdb.dbo.get_principal_sid(principal_id)
FROM msdb.sys.database_principals dp
WHERE dp.name = N''guest'' AND dp.type in (''U'',''S'',''G'')

IF NOT EXISTS (	SELECT *
FROM msdb.dbo.sysmail_principalprofile pp
JOIN msdb.dbo.sysmail_profile p ON pp.profile_id=p.profile_id
WHERE pp.principal_sid = @principal_sid AND p.name = @ProfileName
)
EXECUTE msdb.dbo.sysmail_add_principalprofile_sp
@principal_name=N''guest''
,@profile_name=@ProfileName
,@is_default=0
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcDeleteReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 2/11/2011
-- Description:	Deletes periodic report along with adding entry in audit table
-- =============================================
CREATE PROCEDURE [prcDeleteReport] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
    
    DELETE FROM tblReportSchedule WHERE ScheduleID=@ScheduleId
	
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcDeleteTimezoneDaylightSavingRule]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 18/06/2011
-- Description:	Deletes Daylight saving rule for timezone
-- =============================================
CREATE PROCEDURE [prcDeleteTimezoneDaylightSavingRule]
@TimezoneId int,
@RuleID int
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

DELETE FROM tblTimeZoneDaylightSavingRules
WHERE TimezoneID=@TimezoneId AND TimezoneRuleID=@RuleID
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_EnableQueuedMessage]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcEmail_EnableQueuedMessage]

@EmailQueueID bigint
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

UPDATE tblEmailQueue
SET [SendStarted] = NULL
WHERE EmailQueueID = @EmailQueueID
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_GetAttachments]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcEmail_GetAttachments]
@EmailQueueID INT
AS
BEGIN
SELECT ContentID,ByteStream FROM tblEmailQueueLinkedResource WHERE EmailQueueID = @EmailQueueID


END
' 
END
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_GetNext]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE PROCEDURE [dbo].[prcEmail_GetNext]
AS
BEGIN

select
tblEmailQueue.EmailQueueID
into
#tblEmailsToPurge
FROM tblEmailQueue
inner join tblOrganisation on tblOrganisation.OrganisationID = tblEmailQueue.organisationID
join tblAppConfig on name  = ''SEND_AUTO_EMAILS''
where upper(Value) = ''NO''
or ( tblOrganisation.StopEmails = 1 
     and ( tblEmailQueue.[Subject] like ''%Student Summary%'' 
	       or tblEmailQueue.[Subject] like ''%Course Completion%'' 
           or tblEmailQueue.[Subject] like ''%Overdue Summary%'' 
         )
	)

INSERT INTO tblEmailPurged
([ToEmail]
,[ToName]
,[FromEmail]
,[FromName]
,[CC]
,[BCC]
,[Subject]
,[Body]
,[DateCreated]
,[OrganisationID])

SELECT  case when ((CHARINDEX (''>'',AddressTo) > 0) and (CHARINDEX (''<'',AddressTo) > 0)) then SUBSTRING(AddressTo,CHARINDEX (''<'',AddressTo)+1,CHARINDEX (''>'',AddressTo)-CHARINDEX (''<'',AddressTo)-1) else AddressTo end

,case when ((CHARINDEX (''>'',AddressTo) > 0) and (CHARINDEX (''<'',AddressTo) > 0)) then SUBSTRING(AddressTo,1,CHARINDEX (''<'',AddressTo)-1) else AddressTo end
,case when ((CHARINDEX (''>'',AddressFrom) > 0) and (CHARINDEX (''<'',AddressFrom) > 0)) then SUBSTRING(AddressFrom,CHARINDEX (''<'',AddressFrom)+1,CHARINDEX (''>'',AddressFrom)-CHARINDEX (''<'',AddressFrom)-1) else AddressFrom end
,case when ((CHARINDEX (''>'',AddressFrom) > 0) and (CHARINDEX (''<'',AddressFrom) > 0)) then SUBSTRING(AddressFrom,1,CHARINDEX (''<'',AddressFrom)-1) else AddressFrom end
,''''
,AddressBccs
,Subject
,Body
,QueuedTime
,tblEmailQueue.organisationID
FROM tblEmailQueue 
inner join #tblEmailsToPurge ON tblEmailQueue.EmailQueueID = #tblEmailsToPurge.EmailQueueID

-- do the purge
DELETE FROM tblEmailQueue WHERE EmailQueueID in (SELECT EmailQueueID FROM #tblEmailsToPurge)

DECLARE  @EmailQueueID INT
SELECT @EmailQueueID = MIN (EmailQueueID)
FROM tblEmailQueue
inner join tblOrganisation on tblOrganisation.OrganisationID = tblEmailQueue.organisationID
--join tblAppConfig on name  = ''SEND_AUTO_EMAILS''
--WHERE (tblOrganisation.StopEmails = 0 AND upper(Value) <> ''NO'')  --< already been purged and deleted above!?
--AND 
where ((SendStarted is NULL) OR (DATEADD(DAY,1,SendStarted) < GETUTCDATE()))


-- A single instance will be calling this procedure so there is no need to do multi-user code here
SELECT TOP (1) EmailQueueID,OrganisationID,AddressTo,AddressBCCs,[Subject],body,AddressSender,AddressFrom,IsHTML,CASE WHEN DATEDIFF(d,QueuedTime,GETUTCDATE()) > 1 THEN 1 ELSE 0 END AS Retry
FROM tblEmailQueue  WHERE @EmailQueueID =  EmailQueueID
UPDATE tblEmailQueue SET SendStarted = GETUTCDATE()  WHERE @EmailQueueID =  EmailQueueID

END
' 
END
GO




SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_LogSentEmail]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE Procedure [prcEmail_LogSentEmail]
@toEmail	nvarchar(1000),
@toName	nvarchar(128),
@fromEmail	nvarchar(128),
@fromName	nvarchar(128),
@CC		nvarchar(1000) = '''',
@BCC 		nvarchar(1000) = '''',
@subject	nvarchar (256),
@body		ntext,
@organisationID	int,
@userID int = 0
As


-- attempt to check if the user exist and find the userid
-- else we just insert 0
-- this is because the service log the email as well and i am unable to find where it can retrieve
-- the userid in a short time
-- hence the workaround
if(@userID=0)
begin

set @userid=coalesce((select top 1 userid from tblUser where organisationid=@organisationid and email=@toemail), 0)

end

Insert Into
tblEmail
(
ToEmail,
ToName,
FromEmail,
FromName,
CC,
BCC,
Subject,
Body,
DateCreated,
OrganisationID,
userID
)

Values
(
@toEmail,
@toName,
@fromEmail,
@fromName,
@CC,
@BCC,
@subject,
@body,
GetUTCDate(),
@organisationID,
@userid
)
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_Purge]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE procedure [prcEmail_Purge] as

begin

	INSERT INTO tblEmailPurged
		([ToEmail]
		,[ToName]
		,[FromEmail]
		,[FromName]
		,[CC]
		,[BCC]
		,[Subject]
		,[Body]
		,[DateCreated]
		,[OrganisationID])

	SELECT  
		case when ((CHARINDEX (''>'',AddressTo) > 0) and (CHARINDEX (''<'',AddressTo) > 0)) then SUBSTRING(AddressTo,CHARINDEX (''<'',AddressTo)+1,CHARINDEX (''>'',AddressTo)-CHARINDEX (''<'',AddressTo)-1) else AddressTo end
		,case when ((CHARINDEX (''>'',AddressTo) > 0) and (CHARINDEX (''<'',AddressTo) > 0)) then SUBSTRING(AddressTo,1,CHARINDEX (''<'',AddressTo)-1) else AddressTo end
		,case when ((CHARINDEX (''>'',AddressFrom) > 0) and (CHARINDEX (''<'',AddressFrom) > 0)) then SUBSTRING(AddressFrom,CHARINDEX (''<'',AddressFrom)+1,CHARINDEX (''>'',AddressFrom)-CHARINDEX (''<'',AddressFrom)-1) else AddressFrom end
		,case when ((CHARINDEX (''>'',AddressFrom) > 0) and (CHARINDEX (''<'',AddressFrom) > 0)) then SUBSTRING(AddressFrom,1,CHARINDEX (''<'',AddressFrom)-1) else AddressFrom end
		,''''
		,AddressBccs
		,Subject
		,Body
		,QueuedTime
		,tblEmailQueue.organisationID
	FROM 
		tblEmailQueue 
		
	DELETE FROM tblEmailQueue 
	
	
end

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_QueuedMessageAttachments]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcEmail_QueuedMessageAttachments]

@EmailQueueID bigint,
@ContentID nvarchar(100),
@Content varbinary(max)
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;


INSERT INTO tblEmailQueueLinkedResource
([EmailQueueID]
,[ContentID]
,[ByteStream])
VALUES
(@EmailQueueID
,@ContentID
,@Content)
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_QueueMessage]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcEmail_QueueMessage]
-- Add the parameters for the stored procedure here
@organisationID int,
@AddressTo nvarchar(255),
@Subject nvarchar(255),
@Body nvarchar(max),
@AddressSender nvarchar(255),
@AddressFrom nvarchar(255),
@IsHTML bit,
@AddressBccs nvarchar(max)
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

DECLARE @TEMP datetime
DECLARE @QueuedTime datetime
SET @TEMP = DATEADD(YEAR,1,GETUTCDATE())
SET @QueuedTime = GETUTCDATE()
INSERT INTO tblEmailQueue
([organisationID]
,[AddressTo]
,[Subject]
,[Body]
,[QueuedTime]
,[SendStarted]
,[AddressSender]
,[AddressFrom]
,[IsHTML]
,[AddressBccs])
VALUES
(@organisationID,
@AddressTo,
@Subject,
@Body,
@QueuedTime,
@TEMP,
@AddressSender,
@AddressFrom,
@IsHTML,
@AddressBccs)


SELECT EmailQueueID from tblEmailQueue
WHERE
[organisationID] = @organisationID
AND	[AddressTo] = @AddressTo
AND [Subject]  = @Subject
AND [Body] = @Body
AND [QueuedTime] = @QueuedTime
AND [SendStarted] = @TEMP
AND [AddressSender] = @AddressSender
AND [AddressFrom] = @AddressFrom
AND [IsHTML] = @IsHTML
AND [AddressBccs] = @AddressBccs
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_RemoveMessage]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcEmail_RemoveMessage]

@EmailQueueID int

AS
BEGIN

DELETE FROM tblEmailQueue WHERE EmailQueueID = @EmailQueueID
DELETE FROM tblEmailQueueLinkedResource WHERE EmailQueueID = @EmailQueueID
END
' 
END
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_Search]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
The procedure will search email sent within the selected date range to a email and contain text in subject or body

Returns:


Called By:
Calls:

Remarks:


Author: Jack Liu
Date Created: 25 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
select * from tblEmail


prcEmail_Search''20040102'',''20040228'','''','''',''''

**/

CREATE  PROCEDURE [dbo].[prcEmail_Search]
(

@dateFrom  datetime,
@dateTo  datetime,
@toEmail nvarchar(50),
@subject nvarchar(50),
@body nvarchar(50),
@organisationID int
)
as
set nocount on

set @dateFrom = dbo.udfDaylightSavingTimeToUTC(@dateFrom, @organisationID)
set @dateTo = dbo.udfDaylightSavingTimeToUTC(DATEADD(day,1,@dateTo), @organisationID)

if @toEmail=''''
set @toEmail=null

if @subject=''''
set @subject=null

if @body=''''
set @body=null


select
emailid,
ToEmail,
subject,
body,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @organisationID) as DateCreated
from tblEmail
where DateCreated between @dateFrom and  @dateTo
and (@toEmail is null  or toEmail =@toEmail)
and (@subject is null  or subject like ''%''+ @subject +''%'')
and (@body is null  or body   like ''%''+ @body +''%'')
and OrganisationID = IsNull(@organisationID,OrganisationID)
order by datecreated desc
' 
END
GO




SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_SearchByUserID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N' 

CREATE  PROCEDURE [prcEmail_SearchByUserID]
(
@userID int,
@organisationID int
)
as
set nocount on

select
emailid,
ToEmail,
subject,
body,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @organisationID) as DateCreated
from tblEmail
where 
userID = @userID
order by datecreated desc
'
END

GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_Users]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Returns: result set (active users in the csv list of units)

Author: Mark Donald
Date Created: 04 Aug 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

exec dbo.prcEmail_Users 109, ''4463''
**/

CREATE PROC [prcEmail_Users]
(
@organisationID		int,
@unitIDs 			varchar(MAX)
)
AS
SET NOCOUNT ON

BEGIN
SELECT DISTINCT
u.userid, firstname, lastname, email
FROM
tblUser u, tblunit t
WHERE
u.unitid = t.unitid
AND u.organisationid = @organisationID
AND t.unitid IN (SELECT * FROM dbo.udfCsvToInt(@unitIDs))
AND u.Active = 1
AND t.Active = 1
END

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_Create]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Creates a new entry in the error log.
Returns:
Nothing.

Called By:
ErrorLog Class.

Calls:
Nothing
Remarks:
This procedure creates an entry in the error log when an error is raised.
The Date Created field will be stamped with the current date and time.

Author:
Peter Kneale
Date Created: 9 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcErrorLog_Create ''Source'', ''Module'', ''Function'', ''Code'', ''Message'', ''StackTrace'', 1
**/

CREATE Procedure [prcErrorLog_Create]

@strSource varchar(1000) ,		-- Source of Error
@strModule varchar(100), 		-- Module Error occured in
@strFunction varchar(100), 		-- Function Error occured in
@strCode varchar(100), 			-- Code executing when error occurred
@strMessage varchar(500), 		-- Message from exception
@strStackTrace varchar(8000), 		-- Complete stack trace from exception
@intErrorLevel int			-- Error Level from tblErrorLevel

AS
Set NoCount On
Set Xact_Abort On
Begin Tran

Insert Into
tblErrorLog
(
Source,
Module,
[Function],
Code,
Message,
StackTrace,
ErrorLevel,
DateCreated,
DateUpdated
)
Values
(
@strSource,
@strModule,
@strFunction,
@strCode,
@strMessage,
@strStackTrace,
@intErrorLevel,
GetUTCDate(),
GetUTCDate()
)

Commit Tran
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_ErrorLevelList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


Create  Procedure [prcErrorLog_ErrorLevelList]


as

SELECT
[ErrorLevelID],
[ErrorLevelDescription]
FROM
[tblErrorLevel]


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_ErrorStatusList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


Create  Procedure [prcErrorLog_ErrorStatusList]


as

SELECT
[ErrorStatusID],
[ErrorStatusDescription]
FROM
[tblErrorStatus]


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Returns a single error
Returns:
A single error of the tblErrorLog table

Called By:
ErrorLog Class.

Calls:
Nothing
Remarks:
None.

Author:
Peter Kneale
Date Created: 9 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcErrorLog_GetReport
**/
CREATE Procedure [prcErrorLog_GetOne]
@ErrorLogID int,
@OrgID int

As

Set NoCount On

SELECT
[ErrorLogID],
[Source],
[Module],
[Function],
[Code],
[Message],
[StackTrace],
[ErrorLevel],
[ErrorLevelDescription],
[ErrorStatusDescription],
[ErrorStatus],
[Resolution],
dbo.udfUTCtoDaylightSavingTime([DateCreated], @OrgID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime([DateUpdated], @OrgID) as DateUpdated
FROM
tblErrorLog
Inner Join
tblErrorLevel
on
tblErrorLog.[ErrorLevel] = tblErrorLevel.[ErrorLevelID]
Inner Join
tblErrorStatus
on
tblErrorLog.[ErrorStatus] = tblErrorStatus.[ErrorStatusID]
Where
ErrorLogID = @ErrorLogID



' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_GetReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Returns an report of the most recent errors and when they occured.
Errors containing the exact same Module, Function, Code and Stack Trace
are assumed to be the same error.
Returns:
A Summary of the tblErrorLog table

Called By:
ErrorLog Class.

Calls:
Nothing
Remarks:
None.

Author:
Peter Kneale
Date Created: 9 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcErrorLog_GetReport
**/
CREATE Procedure [prcErrorLog_GetReport]

@OrgID int

As

Set NoCount On

SELECT
[ErrorLogID],
[Source],
[Module],
[Function],
[Code],
[Message],
[StackTrace],
[ErrorLevel],
[ErrorLevelDescription],
[ErrorStatusDescription],
[ErrorStatus],
[Resolution],
dbo.udfUTCtoDaylightSavingTime([DateCreated], @OrgID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime([DateUpdated], @OrgID) as DateUpdated
FROM
tblErrorLog
Inner Join
tblErrorLevel
on
tblErrorLog.[ErrorLevel] = tblErrorLevel.[ErrorLevelID]
Inner Join
tblErrorStatus
on
tblErrorLog.[ErrorStatus] = tblErrorStatus.[ErrorStatusID]
Order by
DateCreated desc
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
Create Procedure [prcErrorLog_Update]

@ErrorLogID	int,
@ErrorLevel	int,
@ErrorStatus	int,
@Resolution	varchar(1000)
as

UPDATE [tblErrorLog]

SET

[ErrorLevel]=@ErrorLevel,
[ErrorStatus]=@ErrorStatus,
[Resolution]=@Resolution

WHERE
[ErrorLogID] = @ErrorLogID

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEscalationConfigForCourse_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcEscalationConfigForCourse_Update]
(
	@remEscID int = -1,
	@orgID int ,
	@courseIDs varchar(max)  = '''',
	@updateOption int =-1,
	@DaysToCompleteCourse int,
	@RemindUsers bit=0,
	@NumOfRemNotfy int =-1,
	@RepeatRem int =-1,
	@NotifyMgr bit =0,
	@IndividualNotification bit =0,
	@IsCumulative bit =0,
	@NotifyMgrDays int=-1,
	@QuizExpiryWarn bit =0,
	@DaysQuizExpiry int =-1,
	@preexpiryInitEnrolment bit =0,
	@postExpReminder bit = 0,
	@postExpInitEnrolment bit = 0,
	@postExpResitPeriod bit = 0,
	@preExpResitPeriod bit = 0
)
AS
BEGIN

		--update existing ones
		update
		tblReminderEscalation
		set
		DaysToCompleteCourse = @DaysToCompleteCourse,
		RemindUsers = @RemindUsers,
		NumOfRemNotfy = @NumOfRemNotfy,
		RepeatRem = @RepeatRem,
		NotifyMgr = @NotifyMgr,
		IsCumulative = @IsCumulative,
		QuizExpiryWarn = @QuizExpiryWarn,
		DaysQuizExpiry = @DaysQuizExpiry,		
		NotifyMgrDays = @NotifyMgrDays,
		IndividualNotification = @IndividualNotification,
		PreExpInitEnrolment = @preexpiryInitEnrolment,
		PostExpReminder =@postExpReminder,
		PostExpInitEnrolment = @postExpInitEnrolment,
		PostExpResitPeriod = @postExpResitPeriod,
		PreExpResitPeriod = @preExpResitPeriod
		
		where
		OrgId =@orgID
		and CourseId IN (SELECT * FROM dbo.udfCsvToInt(@courseIDs))
	
		insert into tblReminderEscalation (
		OrgId,
		CourseId,
		DaysToCompleteCourse,
		RemindUsers,
		NumOfRemNotfy,
		RepeatRem,
		NotifyMgr,
		IsCumulative,
		QuizExpiryWarn,
		DaysQuizExpiry,
		NotifyMgrDays,
		IndividualNotification,
		PreExpInitEnrolment,
		PostExpReminder,
		PostExpInitEnrolment,
		PostExpResitPeriod,
		PreExpResitPeriod,
		DateEnabled
		)
		select 
		@orgID,
		c.CourseID,
		@DaysToCompleteCourse,
		@RemindUsers,
		@NumOfRemNotfy,
		@RepeatRem,
		@NotifyMgr,
		@IsCumulative,
		@QuizExpiryWarn,
		@DaysQuizExpiry,
		@NotifyMgrDays,
		@IndividualNotification,
		@preexpiryInitEnrolment,
		@postExpReminder,
		@postExpInitEnrolment,
		@postExpResitPeriod,
		@preExpResitPeriod,
		GETUTCDATE()
		from tblCourse c
		left join tblReminderEscalation re on re.CourseId = c.CourseID and re.OrgId = @orgID
		where re.CourseId is null and c.CourseID IN (SELECT * FROM dbo.udfCsvToInt(@courseIDs))
		
END' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetCCList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 26/10/2011
-- Description:	Gets the list of cc users for a periodic report
-- =============================================
CREATE PROCEDURE [prcGetCCList] 
(
	@ScheduleId int
)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT u.UserID, u.Username FROM tblCCList cc
		JOIN tblUser u ON cc.UserId = u.UserID
		WHERE cc.ScheduleId = @ScheduleId
END' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetCCListMain]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 4/11/2011
-- Description:	Get the CC List on the Periodic report main page
-- =============================================
CREATE PROCEDURE [prcGetCCListMain] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    SELECT u.UserID, FirstName, LastName, Email FROM tblCCList cc 
    JOIN tblUser u ON u.UserID = cc.UserID
    WHERE cc.ScheduleId = @ScheduleId
END' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetEmailThroughput]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcGetEmailThroughput]
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

SELECT o.OrganisationName AS OrganisationName, dbo.udfGetEmailsinHour(o.OrganisationName) AS "Emails delivered in last hour", dbo.udfGetEmailsinDay(o.OrganisationName) AS "Emails delivered in last day", dbo.udfGetPercentExpectedEmails(o.OrganisationName) AS "Percent of Expected Emails"
FROM tblEmail e JOIN tblOrganisation o ON e.OrganisationID = o.OrganisationID
GROUP BY OrganisationName
ORDER BY "Percent of Expected Emails" DESC
END' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcgetEscalationConfigForCourse ]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


CREATE PROCEDURE [prcgetEscalationConfigForCourse ]
(
	@orgID int ,
	@courseID int	
)
AS
BEGIN
	
	
	select
		*
	from 
		tblReminderEscalation 
	where 
		CourseId =@courseID
		and OrgId= @orgID
	
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetMailThroughputPagedandSorted]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 21/06/2011
-- Description:	Custom paging and sorting of mail throughput
-- =============================================
CREATE PROCEDURE [prcGetMailThroughputPagedandSorted]
@sortExpression nvarchar(100),
@startRowIndex int,
@maximumRows int
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

IF LEN(@sortExpression) = 0
SET @sortExpression = ''Percent of Expected Emails''

SELECT ''OrganisationName'', ''Emails delivered in last hour'', ''Emails delivered in last day'', ''Percent of Expected Emails''
FROM (SELECT o.OrganisationName AS OrganisationName, dbo.udfGetEmailsinHour(o.OrganisationName) AS "Emails delivered in last hour", dbo.udfGetEmailsinDay(o.OrganisationName) AS "Emails delivered in last day", dbo.udfGetPercentExpectedEmails(o.OrganisationName) AS "Percent of Expected Emails",
ROW_NUMBER() OVER (ORDER BY @sortExpression) AS RowRank
FROM tblEmail AS e INNER JOIN tblOrganisation AS o ON e.OrganisationID = o.OrganisationID) AS MailWithRowNumbers
WHERE ''RowRank'' > CONVERT(nvarchar(10), @startRowIndex)
AND ''RowRank'' <= (CONVERT(nvarchar(10), @startRowIndex) + CONVERT(nvarchar(10), @maximumRows))
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicFields]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Name
-- Create date: 26/10/2011
-- Description:	Gets the periodicity related fields for a periodic report
-- =============================================
CREATE PROCEDURE [prcGetPeriodicFields] 
(
	-- Add the parameters for the stored procedure here
	@ScheduleId int
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT ReportTitle, IsPeriodic, ReportStartDate, ReportFrequency, ReportFrequencyPeriod, 
		CASE WHEN ((ReportEndDate IS NULL) AND (NumberOfReports IS NULL)) THEN 1 ELSE 0 END AS NoEndDate,
		CASE WHEN NumberOfReports IS NOT NULL THEN 1 ELSE 0 END AS EndAfter,
		NumberOfReports, CASE WHEN ReportEndDate IS NOT NULL THEN 1 ELSE 0 END AS EndOn,
		ReportEndDate, ReportPeriodType, ReportFromDate FROM tblReportSchedule WHERE ScheduleID=@ScheduleId 
END' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 30/09/2011
-- Description:	Gets the list of periodic reports
-- =============================================
CREATE PROCEDURE [prcGetPeriodicReportList]
(
	@OrgID int
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @CCList TABLE(ScheduleId int, CC int)
	INSERT INTO @CCList(ScheduleId, CC) 
		(SELECT ccl.ScheduleId, Count(UserId) as CC FROM tblCCList ccl
			GROUP BY ccl.ScheduleId
			HAVING ccl.ScheduleId In 
				(SELECT rs.ScheduleId FROM tblReportSchedule rs
				JOIN dbo.tblUser u ON u.UserID = rs.UserID))

	SELECT rs.ScheduleID, rs.ReportID, rs.UserID, rs.ReportTitle, ri.ReportName, 
	(convert(varchar, rs.ReportFrequency) + (CASE rs.ReportFrequencyPeriod WHEN ''D'' THEN '' Days'' WHEN ''W'' THEN '' Weeks'' WHEN ''M'' THEN '' Months'' WHEN ''Y'' THEN '' Years'' END)) AS ReportFrequency, 
	convert(varchar(11), rs.DateCreated, 113) as DateCreated,
	convert(varchar(11), rs.ReportStartDate, 113) as ReportStartDate, 
	convert(varchar(11), rs.ReportEndDate, 113) as ReportEndDate,
	CASE WHEN rs.NextRun > rs.ReportEndDate THEN ''''
		 WHEN rs.NextRun = cast(''1 jan 2050'' as datetime) THEN ''''
		 ELSE convert(varchar(11), rs.NextRun, 113) END
		 as NextRun, 
	(u.FirstName + '' '' + u.LastName) as Username, ut.Type, 
	CASE WHEN (ccl.CC > 0) THEN (Convert(varchar, (ccl.CC + 1)) + '' Recepients'') ELSE u.UserName END as CCUser
		FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID
		JOIN dbo.tblUser u ON u.UserID = rs.UserID
		JOIN dbo.tblUserType ut ON u.UserTypeID = ut.UserTypeID
		LEFT JOIN @CCList ccl ON ccl.ScheduleId = rs.ScheduleId
		WHERE rs.ParamOrganisationID = @OrgID AND rs.IsPeriodic != ''N''

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportListOnInactivateBulkUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 21/10/2011
-- Description:	Gets the list of periodic reports on bulk inactivating users
-- =============================================
CREATE PROCEDURE [prcGetPeriodicReportListOnInactivateBulkUsers]
(
	@OrgID int
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @InActivatedUsers TABLE(UserID int, Processed bit)
	INSERT INTO @InActivatedUsers(UserID, Processed) (SELECT UserID, Processed from tblBulkInactiveUsers WHERE Processed = 0)

	SELECT rs.ScheduleID, rs.UserID, ri.ReportID, rs.ReportTitle, u.Username, ri.ReportName, rs.ReportFrequency
		FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID
		JOIN dbo.tblUser u ON u.UserID = rs.UserID
		WHERE rs.ParamOrganisationID = @OrgID
		AND u.UserID in (SELECT UserID FROM @InActivatedUsers)
			
	UPDATE tblBulkInactiveUsers SET Processed = 1 
		WHERE UserID in (SELECT UserID FROM @InActivatedUsers)
		
	DELETE FROM tblBulkInactiveUsers WHERE Processed = 1

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportListOnInactivateEmail]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 21/10/2011
-- Description:	Gets the list of periodic reports on inactivating user
-- =============================================
CREATE PROCEDURE [prcGetPeriodicReportListOnInactivateEmail]
(
	@OrgID int,
	@Email varchar(50)
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  	SELECT rs.ScheduleID, rs.UserID, ri.ReportID, rs.ReportTitle, u.Username, ri.ReportName, rs.ReportFrequency
	FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID
	JOIN dbo.tblUser u ON u.UserID = rs.UserID
	WHERE rs.ParamOrganisationID = @OrgID AND 
	(u.Email=@Email OR rs.scheduleid in 
	(select scheduleid from tblCCList ccl JOIN 
	tblUser tu ON tu.userid = ccl.userid where tu.Email=@Email))
END
-- OR 
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportListOnInactivateUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 21/10/2011
-- Description:	Gets the list of periodic reports on inactivating user
-- =============================================
CREATE PROCEDURE [prcGetPeriodicReportListOnInactivateUser]
(
	@OrgID int,
	@Username varchar(50)
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  	SELECT rs.ScheduleID, rs.UserID, ri.ReportID, rs.ReportTitle, u.Username, ri.ReportName, rs.ReportFrequency
	FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID
	JOIN dbo.tblUser u ON u.UserID = rs.UserID
	WHERE rs.ParamOrganisationID = @OrgID AND 
	(u.Username=@Username OR rs.scheduleid in 
	(select scheduleid from tblCCList ccl JOIN 
	tblUser tu ON tu.userid = ccl.userid where tu.username = @Username))
END
-- OR ' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportListUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 18/10/2011
-- Description:	Gets the list of periodic reports for a user
-- =============================================
CREATE PROCEDURE [prcGetPeriodicReportListUser]
(
	@OrgID int,
	@Username varchar(50)
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @CCList TABLE(ScheduleId int, CC int)
	INSERT INTO @CCList(ScheduleId, CC) 
		(SELECT ccl.ScheduleId, Count(UserId) as CC FROM tblCCList ccl
			GROUP BY ccl.ScheduleId
			HAVING ccl.ScheduleId In 
				(SELECT rs.ScheduleId FROM tblReportSchedule rs
				JOIN dbo.tblUser u ON u.UserID = rs.UserID))

	SELECT rs.ScheduleID, rs.ReportID, rs.UserID, rs.ReportTitle, ri.ReportName, 
	(convert(varchar, rs.ReportFrequency) + (CASE rs.ReportFrequencyPeriod WHEN ''D'' THEN '' Days'' WHEN ''W'' THEN '' Weeks'' WHEN ''M'' THEN '' Months'' WHEN ''Y'' THEN '' Years'' END)) AS ReportFrequency, 
	convert(varchar(11), rs.DateCreated, 113) as DateCreated,
	convert(varchar(11), rs.ReportStartDate, 113) as ReportStartDate, 
	convert(varchar(11), rs.ReportEndDate, 113) as ReportEndDate, 
	CASE WHEN rs.NextRun > rs.ReportEndDate THEN ''''
		 WHEN rs.NextRun = cast(''1 jan 2050'' as datetime) THEN ''''
		 ELSE convert(varchar(11), rs.NextRun, 113) END
		 as NextRun, 
	(u.FirstName + '' '' + u.LastName) as Username, ut.Type, 
	CASE WHEN (ccl.CC > 0) THEN (Convert(varchar, (ccl.CC + 1)) + '' Recepients'') ELSE u.UserName END as CCUser
		FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID
		JOIN dbo.tblUser u ON u.UserID = rs.UserID
		JOIN dbo.tblUserType ut ON u.UserTypeID = ut.UserTypeID
		LEFT JOIN @CCList ccl ON ccl.ScheduleId = rs.ScheduleId
		WHERE rs.ParamOrganisationID = @OrgID AND rs.IsPeriodic != ''N''
		AND u.UserName = @Username AND (u.UserTypeID <> 1 OR u.UserTypeID = 3)
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetReminderEscalations]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcGetReminderEscalations]
(
@orgID int,
@langcode varchar(10)
)

AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from interfering with SELECT statements.
SET NOCOUNT ON


declare @enabled varchar(10)
declare @disabled varchar(10)

declare @enable varchar(10)
declare @disable varchar(10)

declare @edit varchar(10)
declare @delete varchar(10)


SELECT     @enabled = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @langcode) AND (tblLangInterface.LangInterfaceName = ''/Administration/Organisation/OrganisationMail.aspx'') AND
(tblLangResource.LangResourceName = ''enabled'') AND (tblLangValue.Active = 1)


SELECT     @disabled = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @langcode) AND (tblLangInterface.LangInterfaceName = ''/Administration/Organisation/OrganisationMail.aspx'') AND
(tblLangResource.LangResourceName = ''disabled'') AND (tblLangValue.Active = 1)



SELECT     @enable = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @langcode) AND (tblLangInterface.LangInterfaceName = ''/Administration/Organisation/OrganisationMail.aspx'') AND
(tblLangResource.LangResourceName = ''enable'') AND (tblLangValue.Active = 1)


SELECT     @disable = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @langcode) AND (tblLangInterface.LangInterfaceName = ''/Administration/Organisation/OrganisationMail.aspx'') AND
(tblLangResource.LangResourceName = ''disable'') AND (tblLangValue.Active = 1)



SELECT     @edit = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @langcode) AND (tblLangInterface.LangInterfaceName = ''/Administration/Organisation/OrganisationMail.aspx'') AND
(tblLangResource.LangResourceName = ''edit'') AND (tblLangValue.Active = 1)


SELECT     @delete = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @langcode) AND (tblLangInterface.LangInterfaceName = ''/Administration/Organisation/OrganisationMail.aspx'') AND
(tblLangResource.LangResourceName = ''delete'') AND (tblLangValue.Active = 1)



select
re.RemEscId,
re.CourseId,
c.Name as CourseName,
case when re.RemindUsers= 1 then @enabled else @disabled end as RemindUsers,
case when re.QuizExpiryWarn =1 then @enabled else @disabled end as QuizExpiryWarn,
case when re.PostExpReminder = 1 then @enabled else @disabled end as PostExpReminder,
case when dateEnabled is null then @enable else @disable end as dateEnabled,
@edit as coledit,
@delete as colDel
from
tblReminderEscalation re
join tblCourse c on c.CourseID = re.CourseId and c.Active = 1
inner Join tblOrganisationCourseAccess oca	on oca.GrantedCourseID = c.CourseID
and oca.organisationID = @orgID
where
OrgId = @orgID

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetSaltOrgDate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE procedure [prcGetSaltOrgDate]
(
@OrgID int

)

AS

begin


SELECT  convert( varchar(17), dbo.udfUTCtoDaylightSavingTime(GETUTCDATE(),@OrgID),113) as PrintDate

end








' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetSet_MailFlag]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'create  Procedure [prcGetSet_MailFlag]
(
@OrganisationID int,
@getSet int,
@UserID int
)

As
begin 
	if (@getSet =1)
	begin
		update tblOrganisation set StopEmails = case when StopEmails = 0 then 1 else 0 end, 
			DateUpdated = GETDATE(), UpdatedBy = @UserID 
		where OrganisationID = @OrganisationID
	end
	
	select stopemails from tblOrganisation where organisationID = @OrganisationID
end
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetTimezoneDaylightRules]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 18/06/2011
-- Description:	Gets daylight saving rules for timezone and start year
-- =============================================
CREATE PROCEDURE [prcGetTimezoneDaylightRules]
@TimezoneId int,
@RuleID int
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

SELECT tz.WrittenName AS WrittenName, tzd.start_year AS StartYear, tzd.end_year AS EndYear, tzd.offset_mins AS Offset,
tzd.hours_start AS TimeStart, tzd.day_start AS WeekdayStart, tzd.week_start AS WeekStart, tzd.month_start AS MonthStart,
tzd.hours_end AS TimeEnd, tzd.day_end AS WeekdayEnd, tzd.week_end AS WeekEnd, tzd.month_end AS MonthEnd
FROM tblTimeZoneDaylightSavingRules tzd JOIN tblTimeZone tz ON tzd.TimezoneID = tz.TimeZoneID
WHERE tzd.TimezoneID=@TimezoneId AND tzd.TimezoneRuleID=@RuleID

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGridExport_Headers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcGridExport_Headers]
	@LangInterfaceName NVarChar(4000),
	@CurrentCultureName NVarChar(20)

AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @OrgID int
	Declare @UserID int
	DECLARE @Sort NVarChar(4000)

	DECLARE @SQL NVarChar(4000)
	DECLARE @LangID NVarChar(40)
		SELECT @LangID=LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName 
		IF @LangID IS NULL 
		BEGIN
			SET @LangID=2
		END

SELECT
(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C1'') ) as C1,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C2'') ) as C2,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C3'') ) as C3,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C4'') ) as C4,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C5'') ) as C5,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C6'') ) as C6,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C7'') ) as C7,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C8'') ) as C8,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C9'') ) as C9,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C10'') ) as C10,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C11'') ) as C11

END
' 
END
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGridExport_PeriodicCSV]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcGridExport_PeriodicCSV]

	@Param1 NVarChar(4000),
	@Param2 NVarChar(4000),
	@Param3 NVarChar(4000),
	@CurrentCultureName NVarChar(4000)
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @OrgID int
	Declare @UserID int
	DECLARE @Sort NVarChar(4000)
	SET @OrgID=@Param1
	SET @UserID=@Param2
	SET @Sort=@Param3
	DECLARE @SQL NVarChar(4000)
	DECLARE @LangID NVarChar(4000)
		SELECT @LangID=LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName 
		IF @LangID IS NULL 
		BEGIN
			SET @LangID=2
		END

	--DECLARE @CCList TABLE(ScheduleId int, CC int)
	--INSERT INTO @CCList(ScheduleId, CC) 
	--	(SELECT ccl.ScheduleId, Count(UserId) as CC FROM tblCCList ccl
	--		GROUP BY ccl.ScheduleId
	--		HAVING ccl.ScheduleId In 
	--			(SELECT rs.ScheduleId FROM tblReportSchedule rs
	--			INNER JOIN dbo.tblUser u ON u.UserID=rs.UserID WHERE ParamOrganisationID=@OrgID))

	 SET @SQL=
	 --N''SELECT   ''''Report Title'''', ''''Report Type'''',''''Report Interval'''',''''Date Created'''',''''Report Starts On'''',''''Report Ends On'''',''''Next Run'''',''''Report Owner'''',''''Administration Level'''',''''Report Delivered To;'''',''''Unique ID''''    UNION ALL ''+
N''SELECT rs.ReportTitle,
ri.ReportName,
CAST(rs.ReportFrequency AS varchar(5))+'''' ''''+
CASE
WHEN (rs.ReportFrequencyPeriod=''''D'''') THEN
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.1''''))
WHEN (rs.ReportFrequencyPeriod=''''W'''') THEN
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.2''''))
WHEN (rs.ReportFrequencyPeriod=''''M'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.3''''))
ELSE
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.3''''))
END AS ReportInterval, 
convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(rs.DateCreated,rs.ParamOrganisationID),113) as DateCreated , 
convert(varchar (11),rs.ReportStartDate,113) as StartDate ,  
CASE WHEN rs.ReportEndDate IS NULL THEN ''''--'''' ELSE  convert(varchar (11),rs.ReportEndDate,113)  END as EndDate, 
CASE WHEN rs.NextRun > rs.ReportEndDate THEN ''''--''''
		 WHEN rs.NextRun = cast(''''1 jan 2050'''' as datetime) THEN ''''--''''
		 ELSE convert(varchar(11), rs.NextRun, 113) END
		 as NextRun,
(u.FirstName + '''' '''' + u.LastName) as Username,
CASE WHEN u.UserTypeID=1 THEN ''''APP ADMIN''''
WHEN u.UserTypeID=2 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''GLOBAL.UserControls.AdminMenu.ascx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''lblAdminMenuOrganisation''''))
WHEN u.UserTypeID=3 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''GLOBAL.UserControls.AdminMenu.ascx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''lblAdminMenuUnit''''))
ELSE  (SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''GLOBAL.UserControls.AdminMenu.ascx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''lblAdminMenuUser''''))
END as AdministrationLevel,
ccu.Email as DeliveredTo,
rs.ScheduleID as UniqueID
FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID=ri.ReportID
INNER JOIN dbo.tblUser u ON u.UserID=rs.UserID
INNER JOIN dbo.tblUserType ut ON u.UserTypeID=ut.UserTypeID
INNER JOIN (SELECT ScheduleId,UserID FROM tblCCList UNION ALL SELECT ScheduleId,UserID FROM tblReportSchedule) as cc ON  cc.ScheduleId=rs.ScheduleId
INNER JOIN tblUser ccu ON cc.UserID=ccu.UserID
WHERE rs.ParamOrganisationID=''+@Param1+'' AND rs.IsPeriodic !=''''N''''	ORDER BY ''+ @Sort

	EXEC dbo.sp_executesql @SQL

END
' 
END
GO




SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGridExport_PeriodicPDF]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcGridExport_PeriodicPDF]

	@Param1 NVarChar(4000),
	@Param2 NVarChar(4000),
	@Param3 NVarChar(4000),
	@CurrentCultureName NVarChar(4000)
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @OrgID int
	Declare @UserID int
	DECLARE @Sort NVarChar(4000)
	SET @OrgID = @Param1
	SET @UserID = @Param2
	SET @Sort = @Param3
	DECLARE @SQL NVarChar(4000)
	DECLARE @LangID NVarChar(4000)
		SELECT @LangID = LangID FROM tblLang where tblLang.LangCode =   @CurrentCultureName 
		IF @LangID IS NULL 
		BEGIN
			SET @LangID = 2
		END

	--DECLARE @CCList TABLE(ScheduleId int, CC int)
	--INSERT INTO @CCList(ScheduleId, CC) 
	--	(SELECT ccl.ScheduleId, Count(UserId) as CC FROM tblCCList ccl
	--		GROUP BY ccl.ScheduleId
	--		HAVING ccl.ScheduleId In 
	--			(SELECT rs.ScheduleId FROM tblReportSchedule rs
	--			INNER JOIN dbo.tblUser u ON u.UserID = rs.UserID WHERE ParamOrganisationID = @OrgID))

	 SET @SQL = 
	 --N''SELECT   ''''Report Title'''', ''''Report Type'''',''''Report Interval'''',''''Date Created'''',''''Report Starts On'''',''''Report Ends On'''',''''Next Run'''',''''Report Owner'''',''''Administration Level'''',''''Report Delivered To;'''',''''Unique ID''''    UNION ALL ''+
N''SELECT rs.ReportTitle,
ri.ReportName, 
CAST(rs.ReportFrequency AS varchar(5))+'''' ''''+
CASE 
WHEN (rs.ReportFrequencyPeriod = ''''D'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.1''''))
WHEN (rs.ReportFrequencyPeriod = ''''W'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.2''''))
WHEN (rs.ReportFrequencyPeriod = ''''M'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.3''''))
ELSE 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.3''''))
END AS ReportInterval, 
convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(rs.DateCreated,rs.ParamOrganisationID),113) as DateCreated , 
convert(varchar (11),rs.ReportStartDate,113) as StartDate ,  
CASE WHEN rs.ReportEndDate IS NULL THEN ''''--'''' ELSE  convert(varchar (11),rs.ReportEndDate,113)  END as EndDate, 
CASE WHEN rs.NextRun > rs.ReportEndDate THEN ''''--''''
		 WHEN rs.NextRun = cast(''''01 jan 2050'''' as datetime) THEN ''''--''''
		 ELSE convert(varchar(11), rs.NextRun, 113) END
		 as NextRun, 
(u.FirstName + '''' '''' + u.LastName) as Username,
CASE WHEN u.UserTypeID = 1 THEN ''''APP ADMIN''''
WHEN u.UserTypeID = 2 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''GLOBAL.UserControls.AdminMenu.ascx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''lblAdminMenuOrganisation''''))
WHEN u.UserTypeID = 3 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''GLOBAL.UserControls.AdminMenu.ascx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''lblAdminMenuUnit'''')) 
ELSE  (SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''GLOBAL.UserControls.AdminMenu.ascx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''lblAdminMenuUser'''')) 
END as AdministrationLevel,
CASE WHEN ((SELECT count(*) FROM tblCCList WHERE tblCCList.ScheduleID = rs.ScheduleID) > 0) THEN (Convert(varchar, (SELECT 1+count(*) FROM tblCCList WHERE tblCCList.ScheduleID = rs.ScheduleID)) + '''' Recepients'''') ELSE u.Email  END as DeliveredTo,
rs.ScheduleID as UniqueID
FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID		inner JOIN dbo.tblUser u ON u.UserID = rs.UserID		inner JOIN dbo.tblUserType ut ON u.UserTypeID = ut.UserTypeID				WHERE rs.ParamOrganisationID = ''+@Param1+'' AND rs.IsPeriodic != ''''N''''		ORDER BY ''+ @Sort

	EXEC dbo.sp_executesql @SQL

END
' 
END
GO




SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGridExport_PeriodicRS]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcGridExport_PeriodicRS]

	@Param1 NVarChar(4000),
	@Param2 NVarChar(4000),
	@Param3 NVarChar(4000),
	@CurrentCultureName NVarChar(4000),
	@Expanded bit
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @OrgID int
	Declare @UserID int
	DECLARE @Sort NVarChar(4000)
	SET @OrgID=@Param1
	SET @UserID=@Param2
	SET @Sort=@Param3
	DECLARE @SQL NVarChar(4000)
	DECLARE @LangID NVarChar(4000)
		SELECT @LangID=LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName 
		IF @LangID IS NULL 
		BEGIN
			SET @LangID=2
		END

IF (@Expanded = 1)
BEGIN

	 SET @SQL=
	 --N''SELECT   ''''Report Title'''', ''''Report Type'''',''''Report Interval'''',''''Date Created'''',''''Report Starts On'''',''''Report Ends On'''',''''Next Run'''',''''Report Owner'''',''''Administration Level'''',''''Report Delivered To;'''',''''Unique ID''''    UNION ALL ''+
N''SELECT rs.ReportTitle as C1,
ri.ReportName as C2,
CAST(rs.ReportFrequency AS varchar(5))+'''' ''''+
CASE
WHEN (rs.ReportFrequencyPeriod=''''D'''') THEN
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.1''''))
WHEN (rs.ReportFrequencyPeriod=''''W'''') THEN
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.2''''))
WHEN (rs.ReportFrequencyPeriod=''''M'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.3''''))
ELSE
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.3''''))
END AS C3, 
convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(rs.DateCreated,rs.ParamOrganisationID),113) as C4 , 
convert(varchar (11),rs.ReportStartDate,113) as C5 ,  
CASE WHEN rs.ReportEndDate IS NULL THEN ''''--'''' ELSE  convert(varchar (11),rs.ReportEndDate,113)  END as C6, 
CASE WHEN rs.NextRun > rs.ReportEndDate THEN ''''--''''
		 WHEN rs.NextRun = cast(''''1 jan 2050'''' as datetime) THEN ''''--''''
		 ELSE convert(varchar(11), rs.NextRun, 113) END
		 as C7,
(u.FirstName + '''' '''' + u.LastName) as C8,
CASE WHEN u.UserTypeID=1 THEN ''''APP ADMIN''''
WHEN u.UserTypeID=2 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''GLOBAL.UserControls.AdminMenu.ascx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''lblAdminMenuOrganisation''''))
WHEN u.UserTypeID=3 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''GLOBAL.UserControls.AdminMenu.ascx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''lblAdminMenuUnit''''))
ELSE  (SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''GLOBAL.UserControls.AdminMenu.ascx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''lblAdminMenuUser''''))
END as C9,
ccu.Email as C10,
rs.ScheduleID as C11
FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID=ri.ReportID
INNER JOIN dbo.tblUser u ON u.UserID=rs.UserID
INNER JOIN dbo.tblUserType ut ON u.UserTypeID=ut.UserTypeID
INNER JOIN (SELECT ScheduleId,UserID FROM tblCCList UNION ALL SELECT ScheduleId,UserID FROM tblReportSchedule) as cc ON  cc.ScheduleId=rs.ScheduleId
INNER JOIN tblUser ccu ON cc.UserID=ccu.UserID
WHERE rs.ParamOrganisationID=''+@Param1+'' AND rs.IsPeriodic !=''''N''''	ORDER BY ''+ @Sort
END
ELSE
BEGIN
	 SET @SQL = 
	 --N''SELECT   ''''Report Title'''', ''''Report Type'''',''''Report Interval'''',''''Date Created'''',''''Report Starts On'''',''''Report Ends On'''',''''Next Run'''',''''Report Owner'''',''''Administration Level'''',''''Report Delivered To;'''',''''Unique ID''''    UNION ALL ''+
N''SELECT rs.ReportTitle as C1,
ri.ReportName as C2, 
CAST(rs.ReportFrequency AS varchar(5))+'''' ''''+
CASE 
WHEN (rs.ReportFrequencyPeriod = ''''D'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.1''''))
WHEN (rs.ReportFrequencyPeriod = ''''W'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.2''''))
WHEN (rs.ReportFrequencyPeriod = ''''M'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.3''''))
ELSE 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.3''''))
END AS C3, 
convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(rs.DateCreated,rs.ParamOrganisationID),113) as C4, 
convert(varchar (11),rs.ReportStartDate,113) as C5,
CASE WHEN rs.ReportEndDate IS NULL THEN ''''--'''' ELSE  convert(varchar (11),rs.ReportEndDate,113)  END as C6,
CASE WHEN rs.NextRun > rs.ReportEndDate THEN ''''--''''
		 WHEN rs.NextRun = cast(''''1 jan 2050'''' as datetime) THEN ''''--''''
		 ELSE convert(varchar(11), rs.NextRun, 113) END
		 as C7,
(u.FirstName + '''' '''' + u.LastName) as C8,
CASE WHEN u.UserTypeID = 1 THEN ''''APP ADMIN''''
WHEN u.UserTypeID = 2 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''GLOBAL.UserControls.AdminMenu.ascx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''lblAdminMenuOrganisation''''))
WHEN u.UserTypeID = 3 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''GLOBAL.UserControls.AdminMenu.ascx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''lblAdminMenuUnit'''')) 
ELSE  (SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''GLOBAL.UserControls.AdminMenu.ascx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''lblAdminMenuUser'''')) 
END as C9,
CASE WHEN ((SELECT count(*) FROM tblCCList WHERE tblCCList.ScheduleID = rs.ScheduleID) > 0) THEN (Convert(varchar, (SELECT 1+count(*) FROM tblCCList WHERE tblCCList.ScheduleID = rs.ScheduleID)) + '''' Recepients'''') ELSE u.Email  END as C10,
rs.ScheduleID as C11
FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID		inner JOIN dbo.tblUser u ON u.UserID = rs.UserID		inner JOIN dbo.tblUserType ut ON u.UserTypeID = ut.UserTypeID				WHERE rs.ParamOrganisationID = ''+@Param1+'' AND rs.IsPeriodic != ''''N''''		ORDER BY ''+ @Sort
END

	EXEC dbo.sp_executesql @SQL

END
' 
END
GO




SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcJobGetAgentStatus]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


CREATE Procedure [prcJobGetAgentStatus]
@Status Varchar(50) OUTPUT
AS

/******************************************************************************
**		File:
**		Name: prcJobGetAgentStatus
**		Desc:
**
**		This template can be customized:
**
**		Return values:
**
**		Called by:
**
**		Parameters:
**		Input							Output
**     ----------							-----------
**
**		Auth:
**		Date:
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		--------		--------				-------------------------------------------
**
*******************************************************************************/


EXEC @Status= master..xp_servicecontrol ''QUERYSTATE'', ''SQLServerAgent''
RETURN



' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcJobMaintainUnitHierarchies]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcJobMaintainUnitHierarchies] AS

if (select count(*) from sysobjects where [name] = ''tblUnitHierarchy'') = 0
BEGIN

CREATE TABLE [dbo].[tblUnitHierarchy] (
[UnitID] [int] NOT NULL ,
[Hierarchy] [nvarchar] (500) COLLATE Latin1_General_CI_AS NULL ,
[HierarchyName] [nvarchar] (2000) COLLATE Latin1_General_CI_AS NULL
) ON [PRIMARY]


CREATE  INDEX [IX_tblUnitHierarchy] ON [dbo].[tblUnitHierarchy]([Hierarchy]) ON [PRIMARY]
END


if (select count(*) from sysobjects where [name] = ''utg_UpdateUnitHierarchy'') = 0
BEGIN

EXEC(''CREATE TRIGGER utg_UpdateUnitHierarchy ON tblUnit AFTER INSERT, UPDATE AS '' +
--Update Existing hierarchies
''UPDATE '' +
''tblUnitHierarchy '' +
''SET '' +
''Hierarchy = B.Hierarchy, '' +
''HierarchyName = dbo.udfGetUnitPathway(B.UnitID) '' +
''FROM '' +
''tblUnitHierarchy A, tblUnit B '' +
''WHERE '' +
''A.UnitID = B.UnitID AND '' +
''B.UnitID IN (Select A.UnitID FROM tblUnit A, INSERTED B WHERE A.Hierarchy LIKE ''''%'''' + CAST(B.UnitID AS VARCHAR(10)) + ''''%'''') '' +
''INSERT INTO '' +
''tblUnitHierarchy '' +
''SELECT '' +
''A.UnitID, A.Hierarchy, dbo.udfGetUnitPathway(A.UnitID) '' +
''FROM '' +
''INSERTED A '' +
''WHERE '' +
''A.UnitID NOT IN (SELECT B.UnitID FROM tblUnitHierarchy B WHERE B.UnitID = A.UnitID)'')
END



if (select count(*) from sysobjects where [name] = ''utg_DeleteUnitHierarchy'') = 0
BEGIN

EXEC(''CREATE TRIGGER utg_DeleteUnitHierarchy ON tblUnit AFTER DELETE AS '' +
''DELETE FROM tblUnitHierarchy '' +
''WHERE UnitID IN (SELECT UnitID FROM Deleted) '')

END

--Dummy to fill tblUnitHierarchy table
UPDATE tblUnit SET Hierarchy = Hierarchy
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLanguage_ReportLabels]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE Procedure [prcLanguage_ReportLabels]
@LangCode varchar(10) = ''en-AU'',
@LangInterfaceName varchar(200) = ''Report.Summary''
As

DECLARE NameValueLOOP CURSOR
FOR
SELECT     tblLangResource.LangResourceName, tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @LangCode) AND (tblLangInterface.LangInterfaceName = @LangInterfaceName or tblLangInterface.LangInterfaceName = ''Report.GLOBAL'')
AND (tblLangValue.Active = 1)

Open NameValueLOOP

declare @cursor_Name nvarchar(200)
declare @cursor_Value nvarchar(4000)

FETCH NEXT FROM NameValueLOOP INTO @cursor_Name, @cursor_Value

declare @fieldList as nvarchar(4000)
set @fieldList = ''''

WHILE @@FETCH_STATUS = 0
BEGIN

if @fieldList <> ''''
BEGIN
set @fieldList = @fieldList + '', ''
END

set @fieldList = @fieldList + ''N'''''' + @cursor_Value + '''''' as '' + @cursor_Name
FETCH NEXT FROM NameValueLOOP INTO @cursor_Name, @cursor_Value
END
CLOSE NameValueLOOP
DEALLOCATE NameValueLOOP

declare @createTable as nvarchar(4000)
set @createTable = ''SELECT '' + @fieldList

EXEC(@createTable)


SET QUOTED_IDENTIFIER OFF
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLendLeaseUnitRestructure]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [prcLendLeaseUnitRestructure]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    declare @organisationid int


	set @organisationid = 29

	select
	un.UnitID, un.Name
	into #tblParentUnit
	from
	tblUnit un
	where
	un.OrganisationID=@organisationid
	and ParentUnitID is null
	and un.Active=1


	declare unitCursor cursor
	for 
	select
	pu.UnitID, pu.Name, un2.UnitID, un2.name, un.UnitID, un.name
	from #tblParentUnit pu,
	tblUnit un inner join tblUnit un2
	on un.ParentUnitID=un2.unitid
	where
	un.hierarchy like (convert(varchar(10), pu.unitid) + ''%'') 
	and un.unitid not in
	(
		select distinct parentunitid from tblUnit where organisationid=@organisationid and parentunitid is not null and active=1
	)
	and un.organisationid=@organisationid
	and un.active = 1
	and un.name like ''[A-Z][A-Z][A-Z][0-9][0-9][0-9]''
	--and pu.unitid = 767 -- BLL
	and pu.unitid in
	(1319, 1325, 1357, 1494, 1569)
	
	open unitCursor

	declare @main_unitid int
	declare @main_unitname varchar(200)
	declare @parent_unitid int
	declare @parent_unitname varchar(200)
	declare @child_unitid int
	declare @child_unitname varchar(200)
	declare @default_date datetime


	set @default_date = GETDATE()

	fetch next from unitCursor into 
	@main_unitid,
	@main_unitname,
	@parent_unitid,
	@parent_unitname,
	@child_unitid,
	@child_unitname

	while @@FETCH_STATUS <> -1
	begin
		if @@FETCH_STATUS <> -2
		begin

		declare @new_unitname varchar(200)
		set @new_unitname= @parent_unitname + '' '' + @child_unitname

		print ''Renaming '' + @child_unitname + '' to '' + @new_unitname	
		exec prcUnit_Update @unitid=@child_unitid, @name=@new_unitname, @active = 1, @updatedByUserID=1, @originalDateUpdated = @default_date

		print ''Moving '' + @new_unitname + '' as child unit of '' + @main_unitname
		exec prcUnit_Move @fromUnitID = @child_unitid, @toUnitID = @main_unitid, @adminuserid=1

		print ''Set '' + @parent_unitname + '' to inactive''
		exec prcUnit_Update @unitid=@parent_unitid, @name=@parent_unitname, @active = 0, @updatedByUserID=1, @originalDateUpdated = @default_date

		end
		
		fetch next from unitCursor into 
		@main_unitid,
		@main_unitname,
		@parent_unitid,
		@parent_unitname,
		@child_unitid,
		@child_unitname
	end

	close unitcursor
	deallocate unitcursor

	drop table #tblParentUnit
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonPageAudit_GetPagesVisited]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'







/*Summary:
Given (UserID or SessionID) and (lessonID or ToolbookID)
return a list of the pages that a user has visited in thIs lesson (toolbook)
Returns:
ordered table of distinct PageID''s

Called By: TooolBooLlistner.aspx
Calls:

Remarks:
- at least one of UserID or SessionID must be supplied
- at least one of lessonID or ToolbookID must be supplied
- returns true (Int 1) if the user''s unit has access to the course the lesson Is in
and neither of the users unit / or the user themselves have been excluded from accessing that module.

Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



--------------------
prcLessonPageAudit_GetPagesVisited @userID=11, @lessonSessionID=''D91F43C9-AA74-46FC-AAA6-F3B4E184FEFF''
select * from tblLessonSession
**/


CREATE        Proc [prcLessonPageAudit_GetPagesVisited]
(
@userID Int = Null,			-- The users ID
@lessonSessionID Varchar(50) = Null,	-- The Lesson Session ID (a GUID)
@lessonID Int = Null,			-- The Lesson ID
@toolBookID Varchar(50) = Null		-- The ToolBook ID
)

As

Set  NOCOUNT ON


------------------------------------------
-- Validation - ensure that the required paramaters
-- were supplied
------------------------------------------

--< check that either the userID or the lessonSessionID were supplied >--
If @userID Is Null AND @lessonSessionID Is Null
Begin
Raiserror (''Procedure prcLessonPageAudit_GetPagesVisited expects at least one  the following pramaters: UserID or SessionID'', 16, 1)
Return
End


------------------------------------------
-- If @userID not suppled then get it from @lessonSessionID
------------------------------------------
If @userID Is Null
Begin
Set  @userID= dbo.udfGetUserIDBySessionID(@lessonSessionID)
End


------------------------------------------
-- If @lessonID not suppled then get it from @toolBookID
------------------------------------------

If @lessonID Is Null and @toolBookID is not null
Begin
Set  @lessonID = dbo.udfGetLessonIDByToolbookID(@toolBookID)
End

If @lessonID Is Null and @toolBookID is null and @lessonSessionID is not null
Begin
set @lessonID = dbo.udfGetLessonIDBySessionID(@lessonSessionID)
end

------------------------------------------
-- Join and select back tblLessonPageAudit to tblLessonSession
-- to get all the pages the user has visited
------------------------------------------

select distinct
tLP.ToolbookPageID
from
tblLessonPage tLP
inner join tblLessonPageAudit tLPA
on tLPA.LessonPageID = tLP.LessonPageID
inner Join tblLessonSession tLS
on tLS.LessonSessionID = tLPA.LessonSessionID
Where
tLS.userID = @userID
and tLS.LessonID = @lessonID







' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonPageAudit_GetPagesVisitedBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Given (UserID or SessionID) and (lessonID or ToolbookID)
return a list of the pages that a user has visited in this lesson (toolbook)
Returns:
ordered table of distinct PageID''s

Called By:
TooolBooLlistner.aspx via Businessservices.Toolbook.GetPagesVisited
Calls:
dbo.udfGetUserIDBySessionID
dbo.udfGetLessonIDBySessionID
Remarks:
- at least one of UserID or SessionID must be supplied
- at least one of lessonID or ToolbookID must be supplied
- returns true (Int 1) if the user''s unit has access to the course the lesson is in
and neither of the users unit / or the user themselves have been excluded From accessing that module.
-------------------
-- get the lessionID from this sessionID
-- get all the sessions that this user has started against this lesson
-- get (distinct) all the lessnoPageID''s that the user has visited
-- get the toolbookPageID''s from these lesson-PageID''s pages that have been visited in these sessions
-------------------

Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v# Author  Date   Description
#1



--------------------
prcLessonPageAudit_GetPagesVisitedBySessionID @lessonSessionID = ''036E63C1-1724-4480-A42C-70F63D8A0FDA''
exec prcLessonPageAudit_GetPagesVisitedBySessionID @lessonSessionID = ''036E63C1-1724-4480-A42C-70F63D8A0FDA''
exec prcBookMark_GetBookMarkBySessionID @lessonSessionID = ''036E63C1-1724-4480-A42C-70F63D8A0FDA''
exec prcUser_GetNameBySessionID @sessionID  = ''036E63C1-1724-4480-A42C-70F63D8A0FDA''
exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''036E63C1-1724-4480-A42C-70F63D8A0FDA'', @toolBookPageID = ''salt_29-230001''
exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''036E63C1-1724-4480-A42C-70F63D8A0FDA'', @toolBookPageID = ''salt_29-230002''
print dbo.udfGetUserIDBySessionID(''036E63C1-1724-4480-A42C-70F63D8A0FDA'') -- 4
print dbo.udfGetLessonIDBySessionID(''036E63C1-1724-4480-A42C-70F63D8A0FDA'') -- 16

**/


CREATE PROC [prcLessonPageAudit_GetPagesVisitedBySessionID]
(
@lessonSessionID varchar(50)  -- The Lesson Session ID ( a GUID)
)

AS

Set NOCOUNT ON


------------------------------------------
-- Declerations
------------------------------------------
Declare
@intUserID  integer  -- The Users ID
,@intLessonID  integer  -- The Lesson ID

------------------------------------------
-- If @intUserID not suppled then get it From @lessonSessionID
------------------------------------------

Set @intUserID= dbo.udfGetUserIDBySessionID(@lessonSessionID)



------------------------------------------
-- get @intLessonID From @lessonSessionID
------------------------------------------
Set @intLessonID = dbo.udfGetLessonIDBySessionID(@lessonSessionID)


-------------------


select distinct
tLP.ToolBookPageID
from
( --< get all the sessions (SessionID''s) that this user has started against this lesson >--
select
lessonSessionID
, LessonID
from
tblLessonSession
where
UserID = @intUserID
and lessonID = @intLessonID
) ilvLS -- in line view Lesson - Session
--< get the pages the user has visited in all these sessions >--
inner join tblLessonPageAudit tLPA
on tLPA.LessonSessionID = ilvLS.lessonSessionID
--< to get the toolbook page id we need to joi onto tblLessonPage >--
inner join tblLessonPage tLP
on tLP.LessonPageID = tLPA.LessonPageID










' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonPageAudit_InsertPageVisited]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

-- exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''EC58F6F8-85FB-4BEC-9E42-1C54E4B16D3F'', @toolBookPageID = ''salt_2-293008''
/*Summary:
inserts the page visited
returns true if the lesson has not (a) already been finished and (b) page exists in the toolbook
Returns:
bit 1 = true, 0 = false

Called By:
TooolBooLlistner.aspx via Businessservices.Toolbook.RecordPageVisited
Calls:
dbo.udfGetLessonPageIDByToolbookPageID

Remarks:
- at least one of lessonPageID or ToolbookPageID must be supplied
- returns nothing
Exception:
0. Success
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author:
Stephen Kennedy-Clark
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v# Author  Date   Description
#1

exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''4686890D-B458-402B-B32A-80F8FDCEB6BA'', @toolBookPageID = ''salt_34-253006''
exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''F6D89B6F-CE87-4AF0-880F-61037538B0BC'', @toolBookPageID = ''salt_29-231005''
exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''EC58F6F8-85FB-4BEC-9E42-1C54E4B16D3F'', @toolBookPageID = ''salt_2-293008''
exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''0860A9EA-3D97-423C-AAC4-42435A15E336'', @toolBookPageID = ''salt_34-250002''
exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''0860A9EA-3D97-423C-AAC4-42435A15E336'', @toolBookPageID = ''salt_34-250008A''
print dbo.udfGetLessonPageIDByToolbookPageID(''salt_34-250002'')
--------------------


**/


CREATE     PROC [prcLessonPageAudit_InsertPageVisited]
(
@lessonSessionID  varchar(50)  -- the Lesson Session ID
, @lessonPageID   int   = null -- the lesson page id
, @toolBookPageID  varchar(50)  = null -- the toolbook page id
)

AS
Set NoCount On
Set Xact_Abort On
Begin Transaction



------------------------------------------
-- Declerations
------------------------------------------
Declare @intReturnValue int 		-- Return Value
, @strErrorMessage varchar(100) -- error message
, @intErrorNumber int		-- error Number
, @intLessonID int		-- the lesson ID
-- Initialise variables
Set @intErrorNumber = 0
Set @strErrorMessage = ''''


------------------------------------------
-- Validation - ensure that the required paramaters
-- were supplied
------------------------------------------

--< check that either the userID or the lessonSessionID were supplied >--
IF @lessonPageID IS NULL AND @toolBookPageID IS NULL
BEGIN
set @intErrorNumber = 5 -- MissingParameterException
set @strErrorMessage = ''Procedure prcLessonPageAudit_InsertPageVisited expects at least one  the following pramaters: @lessonPageID or @toolBookPageID''
Goto Finalise
END

------------------------------------------
-- If @lessonPageID not suppled then get it from @toolBookPageID
------------------------------------------

IF @lessonPageID IS NULL
BEGIN
-- first we need the lesson ID because toolbook id''s are not unique
SET @intLessonID = dbo.udfGetLessonIDBySessionID(@lessonSessionID)
-- now we can get the lessonpageID from the
SET @lessonPageID = dbo.udfGetLessonPageIDByToolbookPageID(@toolBookPageID, @intLessonID)
END
IF @lessonPageID IS NULL
BEGIN
set @intErrorNumber = 10 --BusinessServiceException
set @strErrorMessage =  ''Procedure prcLessonPageAudit_InsertPageVisited was passed a value for the paramater "@toolBookPageID" that does not exist in this database''
Goto Finalise
END
------------------------------------------
-- Validation - ensure that the lesson has been started but is not already finished
-- and that the ToolBook pageID exists
------------------------------------------
if exists --< ensure that the lesson has been started but is not already finished  >--
(
Select
LessonSessionID
From
tblLessonSession
where
LessonSessionID = @lessonSessionID
and DateTimeStarted is not null
and DateTimeCompleted is null
)
and exists --< ensure that the ToolBook pageID exists >--
(
SELECT TOP 1
LessonPageID
FROM
tblLessonPage
WHERE
ToolbookPageID = @toolBookPageID
)

Begin --< It''s ok to continue>--

------------------------------------------
-- insert the new row
-- what checks for uniquness should be preformed ???
------------------------------------------
if not exists (select LessonSessionID from tblLessonPageAudit where LessonPageID = @lessonPageID and LessonSessionID = @lessonSessionID)
Begin
INSERT INTO
[tblLessonPageAudit]
(
[LessonSessionID],
[LessonPageID],
[DateAccessed]
)
VALUES(
@lessonSessionID,
@lessonPageID,
getdate()
)
End
set @intReturnValue = 1
End
Else
Begin --< opps - error, either the lesson has finished or has not been started ??? TB should error.salt will handel this gracefully in TBListiner>--
set @intReturnValue = 0
Goto Finalise
End



------------------------------------------
-- return
------------------------------------------
Finalise:
If(@intErrorNumber > 0)
Begin
set @strErrorMessage = ''Error Number: '' + cast(@intErrorNumber as char(2) ) + '' ,'' + @strErrorMessage
Raiserror (@strErrorMessage, 16, 1)
Rollback Transaction
select @intReturnValue as ''Insert is OK''
End
Else
Begin
Commit Transaction
select @intReturnValue as ''Insert is OK''
End









' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonQuizSession_CheckSessionUnique]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
Given SessionID (lesson or quiz) guid
returns true if the session is unique else returns false
Returns:
scaler bit 0 = false,  1 = true

Called By: TooolBooLlistner.aspx via Businessservices.Toolbook.SessionIsUnique
Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



--------------------

**/


CREATE   Proc [prcLessonQuizSession_CheckSessionUnique]
(
@sessionID varchar(50) -- The session ID
)

AS

Set NoCount On

------------------------------------------
-- Declerations
------------------------------------------
Declare @intReurnValue int
set @intReurnValue = 1

------------------------------------------
-- Check to see if lesson or session already exists
------------------------------------------
if exists
(
(select LessonSessionID from tblLessonSession where LessonSessionID = @sessionID)
union
(select QuizSessionID from tblQuizSession where QuizSessionID = @sessionID)
)
Begin
set @intReurnValue = 0
End

Select @intReurnValue
Return

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonQuizSession_GetUserIDBySession]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Starts a Lesson and Returns a  sessionID
Returns:
UserID int

Called By: TooolBooLlistner.aspx
prcUserModuleAccess_Validate
Calls:
udfGetUserIDBySessionID
Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


declare @val int
execute @val =prcLessonQuizSession_GetUserIDBySession @SessionID=''EDB764D3-5099-4E94-B870-DEE8C56243EA''
print @val

print dbo.udfGetUserIDBySessionID(''EDB764D3-5099-4E94-B870-DEE8C56243EA'')
-- select * from tblQuizSession
-- select * from tblLessonSession
**/

CREATE Proc [prcLessonQuizSession_GetUserIDBySession]
(
@SessionID varchar(50)
)

As

Set NoCount On


------------------------------------------
-- Declerations
------------------------------------------
Declare @intRetVal int

------------------------------------------
-- get user id for this session
------------------------------------------
set @intRetVal = dbo.udfGetUserIDBySessionID(@SessionID)

------------------------------------------
-- return
------------------------------------------
select @intRetVal as ''SessionName'';
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonSession_BeforeStartLesson]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Given a UserID and LessonID starts a Lesson and returns a LessonSessionID
Returns:
LessonSessionID guid

Called By:
Businessservices.Toolbook.BeforeLessonStart
Calls:

Remarks:
starts a lesson and returns the details of the lesson so that it can be opened by salt
Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004


Modification History
-----------------------------------------------------------
v# Author  Date   Description
#1 Peter Kneale Update to return active lesson location not first lesson location found.
? pending change added module id to where clause in select
#2 Removed unnecessary transactions

prcLessonSession_StartLesson @UserID=11, @LessonID=3
prcLessonSession_BeforeStartLesson @userID = 11, @moduleID = 3
select * from tblLessonSession
-- truncate tblLessonSession
**/

CREATE       Proc [prcLessonSession_BeforeStartLesson]
(
@userID int,  -- Users ID
@moduleID int  -- the Lesson ID
)

As
Set NoCount On
Set Xact_Abort On




------------------------------------------
-- Declerations
------------------------------------------
declare @strLessonSessionID varchar(50)
, @intLessonID int
set @strLessonSessionID = newid()
set @intLessonID = (select top 1 LessonID from tblLesson where ModuleID = @moduleID and Active=1)

------------------------------------------
-- Insert
------------------------------------------


Insert Into
tblLessonSession
(
[LessonSessionID],
[UserID],
[LessonID]
)
Values
(
@strLessonSessionID,
@userID,
@intLessonID
)


------------------------------------------
-- select Session Details: SessionID, ModuleName,
------------------------------------------

Select
tM.[Name]   As ''ModuleName''
, tC.[Name]   As ''CourseName''
, @strLessonSessionID  As ''SessionID''
, tL.ToolbookLocation  As ''Location''
,Scorm1_2
From
tblModule tM
Inner Join tblLesson tL
On tL.ModuleID = tM.ModuleID
Inner Join tblCourse tC
On tC.CourseID = tM.CourseID
where
tM.ModuleID = @moduleID
And
tL.Active = 1




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonSession_EndLesson]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
this proc records that a lesson has ended
it also:
-- Checks that the lesson has started -- if it has not - return false
-- Checks that the lesson has not already ended -- if it has - return false

Returns:
boolean (bit) OK true = 1, false = 0

Called By:
Businessservices.Toolbook.EndLessonSession
Calls:
dbo.udfGetUserIDBySessionID
dbo.udfGetLessonPageIDByToolbookPageID
dbo.udfGetLessonIDBySessionID
Remarks:

Author:
Stephen Kennedy-Clark
Date Created: 5 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
#2 Removed unnecessary transactions

-----------
prcLessonSession_EndLesson @LessonSessionID = ''4986F67F-FF29-4979-9A97-D7846839E0DB''
select * from tblLessonSession

**/

CREATE      Procedure  [prcLessonSession_EndLesson]
(
@lessonSessionID	varchar(50),		-- the lesson session id
@duration		int,			-- the duration
@bookmark		varchar(50)  = null 	-- the bookmark
)

As
Set NoCount On
Set Xact_Abort On


------------------------------------------
-- Declerations
------------------------------------------
Declare @bitReturnCalue  bit, -- Return Code
@intUserID 	 int, -- User ID
@intLessonPageID int, -- Lesson Page ID
@intlessonID 	 int  -- Lesson ID (PK on lesson table)

------------------------------------------
-- initations
------------------------------------------
set @intUserID 	   	= dbo.udfGetUserIDBySessionID(@lessonSessionID)
set @intlessonID	= dbo.udfGetLessonIDBySessionID(@lessonSessionID)

------------------------------------------
-- Checks that the lesson has started - if it has not -> return false
-- and
-- Checks that the lesson has not already ended - if it has -> return false
-- If all is OK then end the lessson by recording lesson end time and duration
-- and delete the old bookmark
-- and then set the bookmark (if one was given)
------------------------------------------
If Exists
(
Select
LessonSessionID
From
tblLessonSession
Where
LessonSessionID=@LessonSessionID
--< Check that the lesson has started >--
And DateTimeStarted Is Not Null
--< Check that the lesson has not already ended >--
And DateTimeCompleted Is Null
)


Begin --< it is ok to End, record End and return true >--
Update
[tblLessonSession]
Set
[DateTimeCompleted]= GETUTCDATE(),
[Duration]         = @duration
Where
[LessonSessionID]  = @lessonSessionID
------------------------------------------

--< delete the existing bookmark for this user for this lesson >--
delete tblBookmark
From
tblBookmark tBM
Inner Join tblLessonPage tLP
On tLP.LessonPageID = tBM.LessonPageID
Where
tLP.LessonID = @intlessonID
And tBM.UserID = @intUserID
------------------------------------------

--< create a new bookmark for this user for this lesson >--
if len(@bookmark) != 0 or @bookmark is not null
begin
set @intLessonPageID = dbo.udfGetLessonPageIDByToolbookPageID(@bookmark, @intlessonID)
Insert Into
tblBookmark
(
[LessonPageID]
, [UserID]
, [DateCreated]
)
Values
(
@intLessonPageID
, @intUserID
, GETUTCDATE()
)
end
------------------------------------------
set @bitReturnCalue = 1 --< return 1 indicates sucess >--


End
Else
Begin  -- it is NOT ok to End, return false
set @bitReturnCalue = 0
End


------------------------------------------
-- return
------------------------------------------

Select @bitReturnCalue as ''OKToEnd''




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonSession_StartLesson]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
-- Check that the lesson has not already been started
-- if it has - return false
-- if it has not, start it and return true
Returns:
boolean (bit) OKToStart true = 1, false = 0

Called By:
Businessservices.Toolbook.StartLesson
Calls:

Remarks:

Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
#2 Removed unnecessary transactions

-----------
prcLessonSession_StartLesson @LessonSessionID = ''4986F67F-FF29-4979-9A97-D7846839E0DB''


**/

CREATE     Procedure [prcLessonSession_StartLesson]
(
@lessonSessionID varchar(50) -- ToolBook Session ID - GUID
)

As
Set NoCount On
Set Xact_Abort On



------------------------------------------
-- Declerations
------------------------------------------
Declare @bitReturnValue bit -- Return Value

------------------------------------------
-- Check that the lesson has not already been started
-- if it has - return false
-- if it has not, start it and return true
-- Start the lesson ( insert a start date )
------------------------------------------
if exists (select LessonSessionID from tblLessonSession where LessonSessionID=@LessonSessionID and DateTimeStarted is null)
Begin -- it is ok to start, record start and return true
--< do update >--
Update
tblLessonSession
Set
[DateTimeStarted] = GETUTCDATE()
Where
[LessonSessionID] = @LessonSessionID
--< set return value >--
Set @bitReturnValue = 1
End
Else
Begin  -- it is NOT ok to start, return false
--< set return value >--
Set @bitReturnValue = 0
End


------------------------------------------
-- select SessionID
------------------------------------------

Select @bitReturnValue as ''OKToStart''
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLesson_GetListByModule]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Selects a list of lessons for a module. Caller can specify whether to only return only valid modules.

Parameters:
@moduleID
@activeOnly

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Module.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
5. ParameterException


Author: Gavin Buddis
Date Created: 16 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		4/5/2007		Added WorkSiteIDs to select

**/
CREATE  Procedure [prcLesson_GetListByModule]
(
@moduleID Integer = Null,
@activeOnly Bit = 0,
@OrgID int
)

As

Set Nocount On

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @moduleID
If (@moduleID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @moduleID in stored procedure prcLesson_GetListByModule''
Goto Finalise
End

If (@activeOnly = 1)
Begin
Select
LessonID,
ModuleID,
ToolbookID,
ToolbookLocation,
dbo.udfUTCtoDaylightSavingTime(DatePublished, @OrgID),
LoadedBy,
dbo.udfUTCtoDaylightSavingTime(DateLoaded, @OrgID),
Active,
LWorkSiteID,
QFWorkSiteID
From
tblLesson
Where
ModuleID = @moduleID
And Active = 1
End
Else
Begin
Select
LessonID,
ModuleID,
ToolbookID,
ToolbookLocation,
dbo.udfUTCtoDaylightSavingTime(DatePublished, @OrgID),
LoadedBy,
dbo.udfUTCtoDaylightSavingTime(DateLoaded, @OrgID),
Active,
LWorkSiteID,
QFWorkSiteID
From
tblLesson
Where
ModuleID = @moduleID

End

Finalise:
If(@intErrorNumber > 0)
Begin
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End



' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLink_Add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Adds a new Link.

Parameters:
@organisationID
@caption
@url
@showDisclaimer
@userID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Link.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Peter Vranich
Date Created: 12th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE   Procedure [prcLink_Add]
(
@organisationID Integer = Null,
@caption nVarchar(100) = Null,
@url nVarchar(200) = Null,
@showDisclaimer Bit = 1,
@userID Integer = Null,
@LinkOrder Integer = 999
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

-- Validate that the Caption for this link doesn''t exist.
If Exists(Select * From tblLink Where Caption = @caption And OrganisationID = @organisationID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Caption '' + @caption + '' already exists please choose another Caption.''
Goto Finalise
End

--Validate Parameter @organisationID
If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure prcLink_Add''
Goto Finalise
End

--Validate Parameter @caption
If(@caption Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @caption in stored procedure prcLink_Add''
Goto Finalise
End


--Validate Parameter @showDisclaimer
If(@showDisclaimer Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @showDisclaimer in stored procedure prcLink_Add''
Goto Finalise
End

--Validate Parameter @userID
If(@userID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcLink_Add''
Goto Finalise
End

-- Insert the new record into tblLink
Insert Into tblLink
(
OrganisationID,
Caption,
Url,
ShowDisclaimer,
CreatedBy,
LinkOrder
)
Values
(
@organisationID,
@caption,
@url,
@showDisclaimer,
@userID,
@LinkOrder
)

-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Added''

-- Finalise the procedure
Goto Finalise

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLink_Delete]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Deletes a Link.

Parameters:
@linkID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Link.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 12 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE Procedure [prcLink_Delete]
(
@linkID Integer = Null -- The LinkID of the record to delete.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @linkID
If(@linkID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @linkID in stored procedure prcLink_Update''
Goto Finalise
End

-- If the record exists delete it from the tblLink table.
If Exists(Select * From tblLink Where LinkID = @linkID)
Begin
Delete tblLink
Where
LinkID = @linkID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record you tried to delete no longer exists.''

Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLink_GetListByOrganisation]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Gets a List of Links per Organisation
Parameters:
@organisationID Integer ID of the Organisatyion to return the Links for.
Returns:

Called By:
Links.cs
Calls:

Remarks:

Author: Peter Vranich
Date Created: 10th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcLink_GetListByOrganisation]
(
@organisationID Integer = Null -- ID of the Organisation to return the Links for.
)

As

Set Nocount On

If(@organisationID Is Null)
Begin
Raiserror(''The @organisationID parameter was Null.  You must supply a value.'', 16, 1)
Return
End

Select
LinkID,
OrganisationID,
Caption,
Url,
ShowDisclaimer,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @organisationID),
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @organisationID),
LinkOrder
From
tblLink
Where
(OrganisationID = @organisationID)
Order by
LinkOrder, Caption
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLink_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Updates a Link.

Parameters:
@linkID
@caption
@url
@showDisclaimer
@userID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Link.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Peter Vranich
Date Created: 12 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE  Procedure [prcLink_Update]
(
@linkID Integer = Null,
@caption nVarchar(100) = Null,
@url nVarchar(200) = Null,
@showDisclaimer Bit = 1,
@userID Integer = Null,
@LinkOrder Integer = 999
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction
if @url is null
begin
set @url = ''''
end

-- Declarations
Declare @organisationID Int -- Organisation ID for the link to be updated
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @linkID
If(@linkID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @linkID in stored procedure prcLink_Update''
Goto Finalise
End

-- Get the Organisation ID for the link to be updated
Set @organisationID = (Select organisationID From tblLink Where linkID = @linkID)

-- Validate that the Caption for this link doesn''t exist.
If Exists(Select * From tblLink Where Caption = @caption And LinkID != @linkID And OrganisationID = @organisationID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Caption '' + @caption + '' already exists please choose another Caption.''
Goto Finalise
End

--Validate Parameter @caption
If(@caption Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @strErrorMessage in stored procedure prcLink_Update''
Goto Finalise
End

--Validate Parameter @showDisclaimer
If(@showDisclaimer Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @showDisclaimer in stored procedure prcLink_Update''
Goto Finalise
End

--Validate Parameter @userID
If(@userID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcLink_Update''
Goto Finalise
End

If Exists(Select * From tblLink Where LinkID = @linkID)
Begin
-- Update the record in tblLink
Update tblLink
Set
Caption = @caption,
Url = @url,
ShowDisclaimer = @showDisclaimer,
UpdatedBy = @userID,
DateUpdated = GetUTCDate(),
LinkOrder = @LinkOrder
Where
LinkID = @linkID

-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Updated''

-- Finalise the procedure
Goto Finalise
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''

Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLocalisationGet]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcLocalisationGet]
	@LangInterfaceName NVarChar(4000),
	@LangResourceName NVarChar(4000),
	@CurrentCultureName NVarChar(4000)
AS
BEGIN
	DECLARE @LangID VarChar(4)
		SELECT @LangID = LangID FROM tblLang where tblLang.LangCode =   @CurrentCultureName
		IF @LangID IS NULL 
		BEGIN
			SELECT @LangID = LangID FROM tblLang where tblLang.LangCode = ''en_AU''
		END
	DECLARE @LangEntryValue NVarChar(4000)
SELECT @LangEntryValue = LangEntryValue
FROM tblLangValue
where LangID = @LangID and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = @LangInterfaceName  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = @LangResourceName)
	
	IF @LangEntryValue is NULL
	BEGIN
		SET @LangEntryValue = '' ''
		IF  @LangResourceName = ''lblPageTitle''
			BEGIN
				SELECT @LangEntryValue =  [Value]
				FROM tblAppConfig
				WHERE ''AppName''  = Name
			END
	END
	SELECT @LangEntryValue
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLogUsage_Daily]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcLogUsage_Daily]
as
Insert
into
tblLogDaily ([OrganisationID]
,[TimePeriod1]
,[TimePeriod2]
,[TimePeriod3]
,[TimePeriod4]
,[TimePeriod5]
,[TimePeriod6]
,[TimePeriod7]
,[TimePeriod8]
,[DateCreated])

SELECT  MAX(tblOrganisation.[OrganisationID]) ,
COUNT(User_A.User_A) AS ''12am - 7am '',
COUNT(User_B.User_B) AS '' 7am - 9am '',
COUNT(User_C.User_C) AS '' 9am - 11am'',
COUNT(User_D.User_D) AS ''11am - 1pm '',
COUNT(User_E.User_E) AS ''1pm  - 3pm'',
COUNT(User_F.User_F) AS '' 3pm - 5pm '',
COUNT(User_G.User_G) AS '' 5pm - 7pm'',
COUNT(User_H.User_H) AS '' 7pm - 12pm '',
GetUTCDate()
FROM         tblUser INNER JOIN
tblOrganisation ON tblUser.OrganisationID = tblOrganisation.OrganisationID LEFT OUTER JOIN
(SELECT     UserID AS User_A
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 0 AND DATEPART(hh, LastLogin) < 7) AS User_A ON UserID = User_A LEFT OUTER JOIN
(SELECT     UserID AS User_B
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 7 AND DATEPART(hh, LastLogin) < 9) AS User_B ON UserID = User_B LEFT OUTER JOIN
(SELECT     UserID AS User_C
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 9 AND DATEPART(hh, LastLogin) < 11) AS User_C ON UserID = User_C LEFT OUTER JOIN
(SELECT     UserID AS User_D
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 11 AND DATEPART(hh, LastLogin) < 13) AS User_D ON UserID = User_D LEFT OUTER JOIN
(SELECT     UserID AS User_E
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 13 AND DATEPART(hh, LastLogin) < 15) AS User_E ON UserID = User_E LEFT OUTER JOIN
(SELECT     UserID AS User_F
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 15 AND DATEPART(hh, LastLogin) < 17) AS User_F ON UserID = User_F LEFT OUTER JOIN
(SELECT     UserID AS User_G
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 17 AND DATEPART(hh, LastLogin) < 19) AS User_G ON UserID = User_G LEFT OUTER JOIN
(SELECT     UserID AS User_H
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 19 AND DATEPART(hh, LastLogin) < 24) AS User_H ON UserID = User_H
GROUP BY tblUser.OrganisationID
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLogUsage_Hourly]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcLogUsage_Hourly] AS

Insert Into
tblLogHourly ([OrganisationID]
,[TimePeriod1]
,[TimePeriod2]
,[TimePeriod3]
,[TimePeriod4]
,[TimePeriod5]
,[TimePeriod6]
,[DateCreated] )


SELECT  MAX(tblOrganisation.OrganisationID),
COUNT(Minute.UserMinute) AS ''Last Minute'',
COUNT(Hour.UserHour) AS ''Last Hour'',
COUNT(Days.UserDay) AS ''Last Day'',
COUNT(Weeks.userWeek) AS ''Last Week'',
COUNT(Months.UserMonth) AS ''Last Month'',
COUNT(Years.UserYear) AS ''Last Year'',
GetUTCDate()
FROM         tblUser INNER JOIN
tblOrganisation ON tblUser.OrganisationID = tblOrganisation.OrganisationID LEFT OUTER JOIN
(SELECT     UserID AS UserYear
FROM          tblUser
WHERE      DATEDIFF(Year, LastLogin, getutcdate()) <= 1) AS Years ON UserID = UserYear LEFT OUTER JOIN
(SELECT     UserID AS UserMonth
FROM          tblUser
WHERE      DATEDIFF(Month, LastLogin, getutcdate()) <= 1) AS Months ON UserID = UserMonth LEFT OUTER JOIN
(SELECT     UserID AS UserWeek
FROM          tblUser
WHERE      DATEDIFF(Week, LastLogin, getutcdate()) <= 1) AS Weeks ON UserID = UserWeek LEFT OUTER JOIN
(SELECT     UserID AS UserDay
FROM          tblUser
WHERE      DATEDIFF(Day, LastLogin, getutcdate()) <= 1) AS Days ON UserID = UserDay LEFT OUTER JOIN
(SELECT     UserID AS UserHour
FROM          tblUser
WHERE      DATEDIFF(Hour, LastLogin, getutcdate()) <= 1) AS Hour ON UserID = UserHour LEFT OUTER JOIN
(SELECT     UserID AS UserMinute
FROM          tblUser
WHERE      DATEDIFF(Minute, LastLogin, getutcdate()) <= 1) AS Minute ON UserID = UserMinute
GROUP BY tblUser.OrganisationID
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModuleStatusUpdateHistory_GetLastRun]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get the Module Status Updatelast run date time

Returns:

Called By:

Calls:
Nothing

Remarks:

Author: Jack Liu
Date Created: 26 March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcModuleStatusUpdateHistory_GetLastRun

**/
CREATE Procedure [prcModuleStatusUpdateHistory_GetLastRun]

@OrgID int

AS
Set Nocount On
select dbo.udfUTCtoDaylightSavingTime((select  max(FinishTime) as LastRunDate
from tblModuleStatusUpdateHistory), @OrgID) as LastRunDate




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_Create]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Creates a new Module.

Parameters:
@courseID
@name
@description
@active
@userID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Module.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Gavin Buddis
Date Created: 18th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE   Procedure [prcModule_Create]
(
@courseID Integer = Null,
@name nVarchar(100) = Null,
@description nVarchar(1000) = Null,
@active Bit = 1,
@userID Integer = Null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @courseID
If(@courseID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @courseID in stored procedure prcModule_Create''
Goto Finalise
End

--Validate Parameter @name
If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure prcModule_Create''
Goto Finalise
End

--Validate Parameter @active
If(@active Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure prcModule_Create''
Goto Finalise
End

--Validate Parameter @userID
If(@userID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcModule_Create''
Goto Finalise
End

--Check that there are no other modules of this name within this course
If Exists(Select CourseID from tblModule Where CourseID=@courseID and [Name]=@name)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''There is already a module of that name within this course''
Goto Finalise
End


-- Insert the new record
Insert Into tblModule
(
CourseID,
[Name],
[Description],
Active,
CreatedBy,
DateCreated,
UpdatedBy,
DateUpdated
)
Values
(
@courseID,
@name,
@description,
@active,
@userID,
GetUTCDate(),
@userID,
GetUTCDate()
)

-- Set the error message to successfull
Set @intErrorNumber = 0
Set @strErrorMessage = @@identity

-- Finalise the procedure
Goto Finalise



Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_GetDetailsForHomePage]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'





/*Summary:
Given a users ID this proc Gets all Details For the datagrid on the HomePage
Returns:
ordered table of distinct PageID''s

Called By:
TooolBooLlistner.aspx via Businessservices.user.HomePageDetails
Calls:
dbo.udfReport_IndividualDetails
dbo.udfGetLessonStatus
dbo.tblLesson
Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


--------------------
exec prcModule_GetDetailsForHomePage @userID = 2, @courseID = 1

**/
CREATE Procedure [prcModule_GetDetailsForHomePage]

(
@userID  int = null     -- ID of this User
, @courseID int	= null	-- ID of this Course
, @ProfileID int,
	@CurrentCultureName NVarChar(40) = ''en-AU''
)
AS
------------------------------------------
Set Nocount On



if @ProfileID <> -1
begin
	select
	userModule.UserID
	, userModule.CourseID
	, userModule.ModuleID
	, userModule.ModuleName
	, userModule.LessonID
	, userModule.LessonStatus
	, userModule.LessonStatusName
	, userModule.QuizStatus
	, userModule.QuizStatusName
	, userModule.QFSPath
	, case
	when userProfilePoints.Points is null
	then 0
	else userProfilePoints.Points
	end Points
	,QuizExpiryDate as QuizDue
	,LastComp
	,Red
	from
	(
	select
	udfRID.*, tLS.LessonStatusID, tLS.Status LessonStatusName, tQs.QuizStatusID, tQs.Status QuizStatusName
	from
	udfReport_IndividualDetailsExtended(@userID,@CurrentCultureName) udfRID
	--< Get the name of the lesson status >--
	inner join tblLessonStatus tLS
	on tLS.LessonStatusID = udfRID.LessonStatus
	--< Get the name of the quiz status >--
	inner join tblQuizStatus tQS
	on tQS.QuizStatusID = udfRID.QuizStatus
	) userModule

	left join
	(
	select
	ppts.*, pp.ProfileID, pp.ProfilePeriodActive
	from
	tblProfilePoints ppts
	inner join tblProfilePeriod pp
	on pp.ProfilePeriodID = ppts.ProfilePeriodID
	where
	ppts.ProfilePointsType=''M''
	and ppts.Active = 1
	and (pp.ProfileID = @ProfileID)
	and pp.profileperiodactive = 1
	) userProfilePoints
	on
	userProfilePoints.TypeID = userModule.ModuleID
	where
	userModule.CourseID = isNull(@courseID, userModule.CourseID)
	order by
	[Sequence]
end
else
begin
	select
	udfRID.UserID
	, udfRID.CourseID
	--, CourseName
	, udfRID.ModuleID
	, udfRID.ModuleName
	, udfRID.LessonID
	, udfRID.LessonStatus as LessonStatus
	, tLS.Status 	      as LessonStatusName
	, udfRID.QuizStatus   as QuizStatus
	, tQS.Status 	      as QuizStatusName
	--, QuizScore
	--, QuizPassMark
	, udfRID.QFSPath
	, 0			  as Points
	,QuizExpiryDate as QuizDue
	,LastComp
	,Red
	from
	udfReport_IndividualDetailsExtended(@userID,@CurrentCultureName) udfRID
	--< Get the name of the lesson status >--
	inner join tblLessonStatus tLS
	on tLS.LessonStatusID = udfRID.LessonStatus
	--< Get the name of the quiz status >--
	inner join tblQuizStatus tQS
	on tQS.QuizStatusID = udfRID.QuizStatus
	--	left join tblProfilePoints ppts
	--		on ppts.TypeID = udfRID.ModuleID
	--	left join tblProfilePeriod pp
	--		on pp.ProfilePeriodID = ppts.ProfilePeriodID
	where
	udfRID.CourseID = isNull(@courseID, udfRID.CourseID)
	--	and ppts.ProfilePointsType=''M''
	--	and ppts.Active = 1
	--	and (pp.ProfileID = @ProfileID or @profileid  =-1)
	order by
	[Sequence]
end

' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_GetListByCourse]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Gets a list of Modules per Course
Parameters:
@courseID Integer ID of the Course to return the Modules for.
Returns:

Called By:
Module.cs
Calls:

Remarks:

Author: Gavin Buddis
Date Created: 16th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcModule_GetListByCourse]
(
@courseID Integer = Null, -- ID of the Course to return the Modules for.
@OrgID int
)

As

Set Nocount On

If(@courseID Is Null)
Begin
Raiserror(''The @courseID parameter was Null.  You must supply a value.'', 16, 1)
Return
End

Select
ModuleID,
CourseID,
[Name],
[Sequence],
[Description],
Active,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @OrgID),
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @OrgID)
From
tblModule
Where
(CourseID = @courseID)
Order By
[Sequence] ASC
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary: Gets the details of one Module
Parameters: @moduleID integer
Returns: ModuleID, CourseID, Name, Sequence, Description, Active, CreatedBy, DateCreated, UpdatedBy, DateUpdated

Called By: Module.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Gavin Buddis
Date Created: 16th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcModule_GetOne]
(
@moduleID Integer = null, -- ModuleID
@OrgID int
)

As

If @moduleID Is Null
Begin
Raiserror(''The Parameter @moduleID was null.  @moduleID does not accept Null values.'', 16, 1)
Return
End

Select
ModuleID,
CourseID,
[Name],
[Sequence],
[Description],
Active,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @OrgID),
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @OrgID)
From
tblModule
Where
ModuleID = @moduleID


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Updates a Module''s details (except its sequence value).

Parameters:
@moduleID
@name
@description
@active
@updatedByUserID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Course.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Gavin Buddis
Date Created: 16 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE Procedure [prcModule_Update]
(
@moduleID Integer = Null,
@name nVarchar(100) = Null,
@description nVarchar(1000) = Null,
@active Bit = Null,
@updatedByUserID Integer = Null
)

As
-- Used to hold the course id when checking for duplicate module names.
Declare @CourseID int

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

-- Validate Parameter @moduleID
If(@moduleID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @moduleID in stored procedure prcModule_Update''
Goto Finalise
End

-- Validate Parameter @name
If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure prcModule_Update''
Goto Finalise
End

-- Validate Parameter @active
If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure prcModule_Update''
Goto Finalise
End

-- Validate Parameter @userID
If(@updatedByUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @updatedByUserID in stored procedure prcModule_Update''
Goto Finalise
End

--Check that there are no other modules of this name within this course
Select @CourseID = CourseID From tblModule Where ModuleID=@ModuleID
If Exists(Select CourseID from tblModule Where CourseID=@courseID and [Name]=@name and ModuleID <> @moduleID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''There is already a module of that name within this course''
Goto Finalise
End

If Exists(Select * From tblModule Where ModuleID = @moduleID)
Begin
-- Update the record in tblModule
Update tblModule
Set
[Name] = @name,
[Description] = @description,
Active = @active,
UpdatedBy = @updatedByUserID,
DateUpdated = GetUTCDate()
Where
ModuleID = @moduleID

-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Updated''

-- Finalise the procedure
Goto Finalise
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''

Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_UpdateSequence]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Updates a Module''s sequence value.

Parameters:
@moduleID
@sequence
@userID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Course.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Gavin Buddis
Date Created: 16 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE Procedure [prcModule_UpdateSequence]
(
@moduleID Integer = Null,
@sequence Varchar(100) = Null,
@updatedByUserID Integer = Null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @moduleID
If(@moduleID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @moduleID in stored procedure prcModule_UpdateSequence''
Goto Finalise
End

--Validate Parameter @name
If(@sequence Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @sequence in stored procedure prcModule_UpdateSequence''
Goto Finalise
End

--Validate Parameter @userID
If(@updatedByUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @updatedByUserID in stored procedure prcModule_UpdateSequence''
Goto Finalise
End

If Exists(Select * From tblModule Where ModuleID = @moduleID)
Begin
-- Update the record in tblModule
Update tblModule
Set
[Sequence] = @sequence,
UpdatedBy = @updatedByUserID,
DateUpdated = GetUTCDate()
Where
ModuleID = @moduleID

-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Updated''

-- Finalise the procedure
Goto Finalise
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''

Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisationConfig_Delete]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'




/*Summary:
Deletes a Client Config Entry.

Parameters:
@OrganisationID
@Name

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
OrganisationConfiguration.aspx

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Peter Kneale
Date Created: 16 August 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE     Procedure [prcOrganisationConfig_Delete]
(
@OrganisationID	Integer=null,
@Name		nVarchar(255)=null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @OrganisationID
If(@OrganisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @OrganisationID in stored procedure prcOrganisationConfig_Delete''
Goto Finalise
End
--Validate Parameter @Name
If(@Name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @Name in stored procedure prcOrganisationConfig_Delete''
Goto Finalise
End
-- Validate that the Organsiation exists exist.
If Not Exists(Select * From tblOrganisation Where [OrganisationID] = @OrganisationID)
Begin
Set @intErrorNumber = 2
Set @strErrorMessage = ''The Organisation '' + cast(@OrganisationID as varchar) + '' doesnt exist.''
Goto Finalise
End
-- Validate that the Name exists exist.
If Not Exists(Select * From tblOrganisationConfig Where [Name] = @Name)
Begin
Set @intErrorNumber = 21
Set @strErrorMessage = ''The Name '' + @Name + '' doesnt exist.''
Goto Finalise
End

DELETE FROM
[tblOrganisationConfig]
WHERE
[OrganisationID] 	= @OrganisationID
and
[Name]			= @Name

-- Finalise the procedure
Goto Finalise



Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End






' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisationConfig_GetList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*
Summary: Get a list of client configuration values
Parameters:
Returns:

Called By:
Calls:

Remarks:

Author: Peter Kneale
Date Created: 16 August 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE   Procedure [prcOrganisationConfig_GetList]
@organisationID 	Int = 0
As

Set Nocount On


if(@organisationID > 0)
begin
-- This returns the specific org values
Select
0 as ''Default'',
[Name],
[Description],
[Value]
From
tblOrganisationConfig
Where
OrganisationID = @organisationID
UNION
-- And unions it with the default ones.
Select
-1 as ''Default'',
[Name],
[Description],
[Value]
From tblOrganisationConfig

Where Name not in
(
select [Name] from tblOrganisationConfig where organisationID = @organisationID
)
And
OrganisationID is Null
-- do the filter to not show some of the config
and [Name] not in
(
''Ebook_NewUpdate_Subject'',
''Ebook_NewUpdate_Body''
)
Order By
[Name]
end
else if(@organisationID = 0)
begin

Select
[Name],
[Description],
[Value]
From
tblOrganisationConfig
Where
organisationID is null
and name not in
(
''ShowDetailedHelp'',
''css'',
''Number_Of_Quiz_Questions''
)
Order By
[Name]

end



' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisationConfig_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary: Get a single client configuration values
Parameters:
Returns:

Called By:
Calls:

Remarks:

Author: Peter Kneale
Date Created: 16 August 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcOrganisationConfig_GetOne]
@organisationID 	Int,
@name			nVarchar(255)
As

Set Nocount On

If Exists (Select OrganisationID From tblOrganisationConfig Where OrganisationID = @organisationID And [Name]	= @Name)
Begin
Select
[Value]
From
tblOrganisationConfig
Where
OrganisationID	= @organisationID
And
[Name]		= @Name
Order by
[Name]
End
Else
Begin
Select
[Value]
From
tblOrganisationConfig
Where
OrganisationID	= null
And
[Name]		= @Name
Order by
[Name]
End


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisationConfig_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
Updates a Client Config Entry if it exists.
Creates a Client Config Entry if it doesnt.


Parameters:
@OrganisationID
@Name
@Description
@Value

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Link.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
2. FK constraint
5. MissingParameterException



Author: Peter Kneale
Date Created: 16 August 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE    Procedure [prcOrganisationConfig_Update]
(
@OrganisationID	Integer=null,
@Name		    nVarchar(255)=null,
@Description	nVarchar(255)=null,
@Value		    nVarchar(4000)=null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @OrganisationID
If(@OrganisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @OrganisationID in stored procedure prcOrganisationConfig_Update''
Goto Finalise
End
--Validate Parameter @Name
If(@Name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @Name in stored procedure prcOrganisationConfig_Update''
Goto Finalise
End
--Validate Parameter @Description
If(@Description Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @Description in stored procedure prcOrganisationConfig_Update''
Goto Finalise
End
-- Validate that the Organsiation exists exist.
If(@organisationID > 0)
begin
If Not Exists(Select * From tblOrganisation Where [OrganisationID] = @OrganisationID)
Begin
Set @intErrorNumber = 2
Set @strErrorMessage = ''The Organisation '' + cast(@OrganisationID as varchar) + '' doesnt exist.''
Goto Finalise
End
end
-- Validate that the Name exists exist.
If Not Exists(Select * From tblOrganisationConfig Where [Name] = @Name)
Begin
Set @intErrorNumber = 21
Set @strErrorMessage = ''The Name '' + @Name + '' doesnt exist.''
Goto Finalise
End

if(@organisationID > 0)
begin
Begin
INSERT INTO [tblOrganisationConfig]
([OrganisationID], 	[Name], [Description],	[Value])
VALUES
(@OrganisationID,	@Name, @Description,	@Value)
End
end if(@organisationID = 0)
begin
update [tblOrganisationConfig]
set [Value] = @value
where
organisationid is null and
description = @description

end

-- Finalise the procedure
Goto Finalise



Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End





' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_Add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Add a new Organisation.

Parameters:
@intOrganisationID Integer OutPut
@organisationID Integer
@organisationName VarChar(50)
@notes VarChar(1000)
@logo VarChar(100)
@lessonFrequency Integer
@quizFrequency Integer
@quizPassMark Integer
@CPDReportName nvarchar(255)
@AllocatedDiskSpace Integer = Null
@InclLogo bit = 0,
@PasswordLockout bit = 0
@TimeZoneID int = Null


Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
4. UniqueViolationException
5. MissingParameterException
6. PermissionDeniedException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 18th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		30/4/2007		Added @lessonCompletionDate and @quizCompletionDate
#2  aaronc		May 2008		Added @CPDReportName
#3	aaronc		June 2008		Added @AllocatedDiskSpace
#4  aaronc		June2008		Addition of organisation record to tblOrganisationCPDPolicyAccess
#5  vdl			08 June 2011	Time zone

**/
CREATE    Procedure [prcOrganisation_Add]
(
@intOrganisationID Integer OutPut, -- The ID of the newly created organisation.
@organisationName nVarChar(50) = Null, -- The name of the organisation.
@notes nVarChar(4000) = Null, -- The notes for the organisation.
@logo VarChar(100) = Null, -- The name of the organisation logo image.
@lessonFrequency Integer = Null, -- Default Lesson frequency for the organisation.
@quizFrequency Integer = Null, -- Default Quiz frequency for the organisation.
@quizPassMark Integer = Null, -- Default Quiz pass mark for the organisation.
@lessonCompletionDate DateTime = Null, -- Default Lesson completion date
@quizCompletionDate DateTime = Null, -- Default Quiz completion date
@advancedReporting bit = 0,
@actionUserID Integer = Null, -- ID of the User that is making the changes.
@CPDReportName nvarchar(255) = Null, -- CPD Report Name
@AllocatedDiskSpace Integer = Null, -- Allocated Disk Space
@InclLogo bit = 0, -- include Certificate Logo
@PasswordLockout bit = 0,
@TimeZoneID int = Null,
@ShowLastPassed bit = 1,
@DisablePasswordField bit = 0,
@DefaultEbookEmailNotification bit = 0
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number
Declare @intUserTypeOrgAdmin Integer -- Holds the value for the OrgAdmin UserTypeID from the tblUserType table.

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0
Select @intUserTypeOrgAdmin = UserTypeID From tblUserType Where Type = ''Organisation Administrator''

-- Validation Routines
If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_Add''
Goto Finalise
End

If Not Exists(Select * From tblUser Where UserID = @actionUserID And UserTypeID <= @intUserTypeOrgAdmin)
Begin
Set @intErrorNumber = 6
Set @strErrorMessage = ''You do not have access to modify this Organisation.''
Goto Finalise
End

If(@organisationName Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationName in stored procedure prcOrganisation_Add''
Goto Finalise
End

If Exists(Select * From tblOrganisation Where OrganisationName = @organisationName)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Organisation Name '' + @organisationName + '' already exists please choose another name for your Organisation.''
Goto Finalise
End

If(@notes Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @notes in stored procedure prcOrganisation_Add''
Goto Finalise
End

If(@logo Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @logo in stored procedure prcOrganisation_Add''
Goto Finalise
End

If(@lessonFrequency Is Null and @lessonCompletionDate Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @lessonFrequency, @lessonCompletionDate in stored procedure prcOrganisation_Add''
Goto Finalise
End

If(@quizFrequency Is Null and @quizCompletionDate Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @quizFrequency, @quizCompletionDate in stored procedure prcOrganisation_Add''
Goto Finalise
End

If(@quizPassMark Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @quizPassMark in stored procedure prcOrganisation_Add''
Goto Finalise
End

Insert Into tblOrganisation
(
OrganisationName,
Logo,
DefaultLessonFrequency,
DefaultQuizFrequency,
DefaultQuizPassMark,
--	DefaultLessonCompletionDate,
--	DefaultQuizCompletionDate,
advancedReporting,
CreatedBy,
CPDReportName,
AllocatedDiskSpace,
IncludeCertificateLogo,
PasswordLockout,
TimeZoneID,
ShowLastPassed,
DisablePasswordField,
DefaultEbookEmailNotification
)
Values
(
@organisationName,
@logo,
@lessonFrequency,
@quizFrequency,
@quizPassMark,
--	@lessonCompletionDate,
--	@quizCompletionDate,
@advancedReporting,
@actionUserID,
@CPDReportName,
@AllocatedDiskSpace,
@InclLogo,
@PasswordLockout,
@TimeZoneID,
@ShowLastPassed,
@DisablePasswordField,
@DefaultEbookEmailNotification
)


Select @intOrganisationID = @@Identity

-- lesson completion datetime to utc
set @lessonCompletionDate = dbo.udfDaylightSavingTimeToUtc (@lessonCompletionDate, @intOrganisationID)

-- quiz completion time to utc
set @quizCompletionDate = dbo.udfDaylightSavingTimeToUtc (@quizCompletionDate, @intOrganisationID)


--update the org with these utc dates
update
tblOrganisation
set
DefaultLessonCompletionDate = @lessonCompletionDate,
DefaultQuizCompletionDate = @quizCompletionDate
where
OrganisationID =  @intOrganisationID



/* Remove this as the tables below no longer exist
insert into tblOrganisationCPDAccess
(
OrganisationID,
GrantCPDAccess
)
values
(
@intOrganisationID,
0 -- no access initially
)

insert into tblOrganisationPolicyAccess
(
OrganisationID,
GrantPolicyAccess
)
values
(
@intOrganisationID,
0 -- no access initially
)
*/

-- Add values to tblOrganisationNotes
Declare LangIDLOOP CURSOR
for
select LangID from tblLang

open LangIDLOOP

declare @LangID int

FETCH NEXT from LangIDLOOP into @LangID
while @@FETCH_STATUS = 0
BEGIN

insert into tblOrganisationNotes
(
OrganisationID,
LanguageID,
Notes
)
values
(
@intOrganisationID,
@LangID,
@notes
)
FETCH NEXT from LangIDLOOP into @LangID
END
close LangIDLOOP
deallocate LangIDLOOP

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
''Successfully Added'' As ''ErrorMessage''
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_CheckDisabledPasswordField]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE Procedure [prcOrganisation_CheckDisabledPasswordField]
(
@OrgID int
)
as
Select
DisablePasswordField
From
tblOrganisation
Where
OrganisationID = @OrgID
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_CheckUnitTree]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Check and rebuild unit tree hierarchy for a specified organisation,


Returns:
none


Called By:
Calls:

Remarks:
The unit hierarchy data are redundent and may be inconsistent with the actual tree structure

This procedure will guarantee the tree hierarchy are correct.


Author: Jack Liu
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcOrganisation_CheckUnitTree 3
prcOrganisation_CheckUnitTree


**/

CREATE  PROCEDURE [prcOrganisation_CheckUnitTree]
(
@organisationID  int=null
)
as
set nocount on

declare @intLevel int
declare @intRecordCount int

SET XACT_ABORT On

begin tran
--Initialize
Update tblUnit
set 	[level]=null,
Hierarchy=null
where 	(organisationID = @organisationID)
or (@organisationID is null)

--Build top level
set @intLevel=0

Update tblUnit
set 	[level]=@intLevel+1,
Hierarchy=cast(UnitID as varchar)
where 	((organisationID = @organisationID)
or (@organisationID is null))
and (parentUnitID is null)

set @intRecordCount=@@ROWCOUNT
set @intLevel=@intLevel+1

-- build middle level
while @intRecordCount>0
begin

Update 	tblUnit
set 	[Level]=@intLevel+1,
Hierarchy=parent.Hierarchy + '','' + cast(tblUnit.UnitID as varchar)
from 	tblUnit
inner join tblUnit parent
on tblUnit.ParentUnitID = parent.UnitID
and parent.[Level] = @intLevel
where (tblUnit.organisationID = @organisationID)
or (@organisationID is null)

set @intRecordCount=@@ROWCOUNT
set @intLevel=@intLevel+1
end

COMMIT TRAN
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_CheckUserRole]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Check user role for one organisation,


Returns:
none


Called By:
Calls:

Remarks:
The user role may be changed due to permission changes, it may be inconsistent with the other data

This procedure will check the permission and guarantee the roles are correct.


Author: Jack Liu
Date Created: 12 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcOrganisation_CheckUserRole 3



**/

CREATE  PROCEDURE [prcOrganisation_CheckUserRole]
(
@organisationID  int=null
)
as
set nocount on

--1. Salt Admin(1) or Org Admin (2)
-- Remove Unit Administrator permission because these two roles have full permission to all units
delete tblUnitAdministrator
from tblUnitAdministrator ua
inner join tblUser u on ua.userID=u.UserID
where ((u.organisationID = @organisationID)
or (@organisationID is null))
and u.UserTypeID in (1,2) --Salt Admin or Org Admin

--2. Unit Administrator(3)
--Change User role to Unit Administrator(3) if a Salt User(4) manage some units
Update tblUser
set UserTypeID=3
from tblUser u
inner join tblUnitAdministrator ua on ua.userID=u.UserID
where ((u.organisationID = @organisationID)
or (@organisationID is null))
and u.UserTypeID=4 --Salt user


--3. Salt User (4)
--Change User role to Salt User(4) if a Unit Administrator(3) no longer manages any units
Update tblUser
set UserTypeID=4
from tblUser u
left join tblUnitAdministrator ua on ua.userID=u.UserID
where ((u.organisationID = @organisationID)
or (@organisationID is null))
and u.UserTypeID=3 --Unit Administrator
and ua.unitID is null



' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_EnabledLastPassed]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE Procedure [prcOrganisation_EnabledLastPassed]
(
@OrgID int
)
as
Select
ShowLastPassed
From
tblOrganisation
Where
OrganisationID = @OrgID
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetAdminList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Gets a List of all the Administrators for a particular organisation.

Parameters:
@organisationID

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
None

Author: Peter Vranich
Date Created: 12th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE   Procedure [prcOrganisation_GetAdminList]
(
@organisationID Integer = Null -- ID of the Organisation that you wish to get the Admins for.
)

As

Select
UserID,
FirstName,
LastName,
Email,
OrganisationID,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @organisationID) as DateCreated,
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @organisationID) as DateUpdated
From
tblUser
Where
((OrganisationID = @organisationID)
And (UserTypeID = 2)
And (Active = 1))
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetAllocatedDiskSpace]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE Procedure [prcOrganisation_GetAllocatedDiskSpace]
(
@OrganisationID int
)

as

select
AllocatedDiskSpace
from tblOrganisation
where OrganisationID = @OrganisationID

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetCourseAccessList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary:
Gets a list of all Courses and flags which one the organisation has access to.

Parameters:
@organisationID Integer

Returns:
CourseID
Name
Notes
Active
Granted
CreatedBy
DateCreated
UpdatedBy
DateUpdated

Called By:
Course.cs
Calls: None

Remarks: None

Author: Peter Vranich
Date Created: 19th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcOrganisation_GetCourseAccessList]
(
@organisationID Integer -- The ID of the organisation that you wish to get the course access list for.
)

As

Set NoCount On

Select
CourseID,
Name,
Notes,
Active,
Case
When toca.GrantedCourseID Is Not Null Then 1
Else 0
End As Granted,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @organisationID),
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @organisationID)
From
tblCourse As tc
Left Outer Join tblOrganisationCourseAccess As toca
On tc.CourseID = toca.GrantedCourseID
And toca.OrganisationID = @organisationID
Order By
Name


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Gets a list of all Organisation
Parameters: None
Returns: OrganisationID, OrganisationName,  Logo, Notes, DefaultLessonFrequency, DefaultQuizFrequency, DefaultQuizPassMark, CreatedBy, DateCreated,  UpdatedBy, DateUpdated

Called By: Header.ascx
Calls: None

Remarks: None

Author: Peter Vranich
Date Created: 28th of January 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcOrganisation_GetList]

As

Select
OrganisationID,
OrganisationName,
Logo,
Notes,
DefaultLessonFrequency,
DefaultQuizFrequency,
DefaultQuizPassMark,
dbo.udfUTCtoDaylightSavingTime(DefaultLessonCompletionDate, OrganisationID),
dbo.udfUTCtoDaylightSavingTime(DefaultQuizCompletionDate, OrganisationID),
DomainName,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, OrganisationID),
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, OrganisationID)
From
tblOrganisation
order by OrganisationName


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetNotesByUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
Given a Course id return the Course notes
Returns:
Course Notes

Called By: Home.aspx via Businessservices.Organisation.GetOrganisationNotes
Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

--------------------
prcOrganisation_GetNotesByUser   @organisationID=3

**/

CREATE   Proc [prcOrganisation_GetNotesByUser]
(
@LangCode varchar(10),
@organisationID Int = Null, 	-- organisation id 	- not required
@userID 	Int = Null		 	-- user id 		- not required
)
AS
------------------------------------------
Set Nocount On

------------------------------------------
-- Validate Requird Paramaters were supplied
------------------------------------------
If @organisationID Is Null And @userID Is Null
Begin
Raiserror (''Procedure prcOrganisation_GetNotesByUser expects at least one  the following pramaters: @userID or @organisationID'', 16, 1)
Return
End

------------------------------------------
-- Get OrganisationID if it was not Supplied
------------------------------------------
If @organisationID Is Null
Begin
Set @organisationID = (Select Top 1 organisationID From tblUser Where UserID = @userID)
End

------------------------------------------
-- Return select
------------------------------------------

--Select
--	Notes
--From
--	tblOrganisation
--Where
--	OrganisationID = @organisationID

select
Notes
from dbo.tblOrganisationNotes orgN
left Join dbo.tblLang l
on orgN.[LanguageID] = l.[LangID]
where orgN.[OrganisationID] = @OrganisationID
and l.[LangCode] = @LangCode




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Gets othe details of one Organisation
Parameters: @orgID integer
Returns: OrganisationID, OrganisationName,  Logo, Notes, DefaultLessonFrequency, DefaultQuizFrequency, DefaultQuizPassMark, CreatedBy, DateCreated,  UpdatedBy, DateUpdated

Called By: Organisation.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Peter Vranich
Date Created: 4th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	aaronc		May 2008		Added retrieval of CPDReportName
#2	aaronc		June2008		Added retrieval of AllocatedDiskSpace
*/

CREATE procedure [prcOrganisation_GetOne]
(
	@LangCode nvarchar(10),
	@orgID Integer = null -- OrganisationID
)

As
BEGIN

	If @orgID Is Null
	Begin
		Raiserror(''''''''''The Parameter @orgID was null.  @orgID does not accept Null values.'''''''''', 16, 1)
		Return
	End

	Select
		o.OrganisationID,
		o.OrganisationName,
		o.Logo,
		orgN.Notes,
		o.DefaultLessonFrequency,
		o.DefaultQuizFrequency,
		o.DefaultQuizPassMark,
		dbo.udfUTCtoDaylightSavingTime(o.DefaultLessonCompletionDate, o.OrganisationID) as DefaultLessonCompletionDate,
		dbo.udfUTCtoDaylightSavingTime(o.DefaultQuizCompletionDate, o.OrganisationID) as DefaultQuizCompletionDate,
		o.AdvancedReporting,
		o.CreatedBy,
		dbo.udfUTCtoDaylightSavingTime(o.DateCreated, o.OrganisationID) as DateCreated,
		o.UpdatedBy,
		dbo.udfUTCtoDaylightSavingTime(o.DateUpdated, o.OrganisationID)as DateUpdated,
		o.CPDReportName,
		o.AllocatedDiskSpace,
		o.IncludeCertificateLogo,
		o.PasswordLockout,
		o.TimeZoneID,
		o.IncludeLogoOnCorrespondence,
		o.QuizDueDate,
		o.ShowLastPassed,
		o.DisablePasswordField,
		o.DefaultEbookEmailNotification
	From
		tblOrganisation o
		left join tblOrganisationNotes orgN	on o.OrganisationID = orgN.OrganisationID
		left join tblLang l	on orgN.LanguageID = l.LangID
	Where
		o.OrganisationID = @orgID
		and l.LangCode = @LangCode

END

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetPolicies]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get''s a list of policies for an organisation

Parameters:
@OrganisationID int,

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcOrganisation_GetPolicies]
(
@OrganisationID int
)
as

select
PolicyID,
PolicyName,
Active,
PolicyFileName,
PolicyFileSize
from tblPolicy
where
OrganisationID = @OrganisationID
and deleted = 0
order by PolicyName

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetPolicyList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Gets a List of Policies for a particular organisation.

Parameters:
@organisationID

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

CREATE   Procedure [prcOrganisation_GetPolicyList]
(
@organisationID Integer = Null -- ID of the Organisation that you wish to get the Policies for
)

As


select
PolicyID,
PolicyName,
PolicyFileName,
Active
from
tblPolicy pol left join
tblOrganisationPolicyAccess opa on
pol.OrganisationID = opa.OrganisationID
where
pol.OrganisationID = @OrganisationID and	--OrganisationID passed into stored procedure
opa.GrantPolicyAccess = 1					--Organisation has access to policy
and pol.Deleted = 0
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetPolicyUsedSpace]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE Procedure [prcOrganisation_GetPolicyUsedSpace]
(
@OrganisationID int
)

as

select sum(PolicyFileSize)
from tblPolicy
where OrganisationID=@OrganisationID
and Deleted=0
and Active=1

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetProfiles]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get''s a list of profiles for an organisation

Parameters:
@OrganisationID int,

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcOrganisation_GetProfiles]
(
@OrganisationID int
)
as

select
pro.profileid,
propd.profileperiodid,
pro.profilename,
dbo.udfUTCtoDaylightSavingTime(propd.datestart, @OrganisationID),
dbo.udfUTCtoDaylightSavingTime(propd.dateend, @OrganisationID),
dbo.udfUTCtoDaylightSavingTime(propd.futuredatestart, @OrganisationID),
dbo.udfUTCtoDaylightSavingTime(propd.futuredateend, @OrganisationID),
case when ((propd.datestart < GETUTCDATE()) and (GETUTCDATE() < dateadd(hh,24,propd.dateend))) then ''Enabled'' else ''Disabled'' end [ProfileStatus]
from
tblProfile pro
left join tblProfilePeriod propd on pro.profileid = propd.profileid
where
pro.organisationid = @OrganisationID
and (profileperiodactive = 1)
order by
pro.profilename

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetTimeZone]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



CREATE Procedure [prcOrganisation_GetTimeZone]
(
@OrganisationID int
)

As

select TimeZoneID from tblOrganisation where organisationID = @OrganisationID

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetTimeZoneStandardName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


Create Procedure [prcOrganisation_GetTimeZoneStandardName]
(
@OrgID int 		-- Organisation ID
)

As

Set NoCount On

-- Declarations
Declare @userID Integer

-- Validation
If (@OrgID Is Null)
Begin
Raiserror(''The Parameter @OrgID was null.  @OrgID does not accept Null values.'', 16, 1)
Return
End

-- Logic

Select
WrittenName
From
tblOrganisation ORG
inner join tblTimeZone TZ on ORG.TimeZoneID = TZ.TimeZoneID

WHERE ORG.OrganisationID = @OrgID


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetTimeZoneWrittenName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


Create Procedure [prcOrganisation_GetTimeZoneWrittenName]
(
@OrgID int 		-- Organisation ID
)

As

Set NoCount On

-- Declarations
Declare @userID Integer

-- Validation
If (@OrgID Is Null)
Begin
Raiserror(''The Parameter @OrgID was null.  @OrgID does not accept Null values.'', 16, 1)
Return
End

-- Logic

Select
WrittenName
From
tblOrganisation ORG
inner join tblTimeZone TZ on ORG.TimeZoneID = TZ.TimeZoneID

WHERE ORG.OrganisationID = @OrgID


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetURL]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE procedure [prcOrganisation_GetURL] @organisationID int

as 
begin
	
	declare @orgurl varchar(500)
	
	SELECT @orgurl =CASE WHEN ''true'' = [Value] THEN ''HTTPS://'' ELSE ''http://'' END FROM tblAppConfig where Name = ''SSL'' 
	SELECT organisationname, ORGURL =@orgurl + COALESCE(DOMAINNAME,''localhost'')  + ''/Restricted/Login.aspx'' FROM tblOrganisation ORG WHERE ORG.OrganisationID =  @OrganisationID
	
	

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Gets a list of all users that are not organisation administrators for the specified organisation.

Parameters:
@organisationID Integer
@firstName Varchar(50) = ''''
@lastname Varchar(50) = ''''

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:

Author: Peter Vranich
Date Created: 17th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE    Procedure [prcOrganisation_GetUsers]
(
@organisationID Integer = Null, -- ID of the Organisation to get the users from.
@firstName nVarchar(50) = '''', -- First name of the user(s) to search for.
@lastname nVarchar(50) = '''' -- Last name of the user(s) to search for.
)

As

Set NoCount On

-- Declarations
Declare @intUserTypeOrgAdmin Integer -- Holds the value for the OrgAdmin UserTypeID from the tblUserType table.

-- Initialisation
Select @intUserTypeOrgAdmin = UserTypeID From tblUserType Where Type = ''Organisation Administrator''

If(@firstName Is Null)
Begin
Set @firstName = ''''
End

If(@lastName Is Null)
Begin
Set @lastName = ''''
End


Select
UserID,
FirstName,
LastName,
Email,
OrganisationID,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, OrganisationID) as DateCreated,
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, OrganisationID) as DateUpdated
From
tblUser
Where
((OrganisationID = @organisationID)
And (FirstName Like ''%'' + @firstName + ''%'')
And (LastName Like ''%'' + @lastName + ''%'')
And (UserTypeID > @intUserTypeOrgAdmin)
And (UnitID Is Not Null)
And (Active = 1))
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_InitialisePolicyAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s Granted value in tblUnitPolicyAccess and tblUserPolicyAccess when
the Policy is intitially created

Parameters:
@organisationID Integer	,
@PolicyID Integer

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: Feb 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE    Procedure [prcOrganisation_InitialisePolicyAccess]
(
@organisationID Integer,
@PolicyID Integer,
@granted bit
)

As

Set NoCount On

-- Get all units for this organisation
create table #OrgUnits
(
UnitID int
)

insert into #OrgUnits
select
unitid
from
tblUnit
where
OrganisationID = @OrganisationID
and active = 1
-- Insert all unitid''s into tblUnitProfilePeriodAccess with
-- initial granted value of 0 (not granted)

Insert into tblUnitPolicyAccess
select @PolicyID, UnitID, @granted from #OrgUnits
where unitid not in
(select unitid from tblUnitPolicyAccess where Unitid in
(select unitid from tblUnit where organisationid = @organisationid)
and policyid = @policyid)


drop table #OrgUnits

-- Get all users for this organisation
create table #OrgUsers
(
UserID int
)

insert into #OrgUsers
Select
UserID
From
tblUser
Where
OrganisationID = @organisationID



-- Insert all userid''s not already added into tblUserProfilePeriodAccess
Insert into tblUserPolicyAccess
select @PolicyID, UserID, @granted from #OrgUsers
where userid not in
(select userid from tblUserPolicyAccess where userid in
(select userid from tblUser where organisationid = @organisationid)
and policyid = @policyid)


-- update any users that were already existing
update tblUserPolicyAccess
set granted = @granted
where policyid = @policyid
and userid in (select userid from tbluser where organisationid = @organisationid)

drop table #OrgUsers

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_InitialiseProfilePeriodAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s Granted value in tblUnitProfilePeriod and tblUserProfilePeriod when
the Profile is intitially created

Parameters:
@organisationID Integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE    Procedure [prcOrganisation_InitialiseProfilePeriodAccess]
(
@organisationID Integer,
@ProfileID Integer,
@ProfilePeriodID Integer
)

As

Set NoCount On

-- Get all units for this organisation
create table #OrgUnits
(
UnitID int
)

insert into #OrgUnits
select
unitid
from
tblUnit
where
OrganisationID = @OrganisationID
and active = 1
-- Insert all unitid''s into tblUnitProfilePeriodAccess with
-- initial granted value of 0 (not granted)

Insert into tblUnitProfilePeriodAccess
select @ProfilePeriodID, UnitID, 0 from #OrgUnits


drop table #OrgUnits

-- Get all users for this organisation
create table #OrgUsers
(
UserID int
)

insert into #OrgUsers
Select
UserID
From
tblUser
Where
OrganisationID = @organisationID
--	And UnitID Is Not Null
--	And Active = 1

-- Insert all userid''s into tblUserProfilePeriodAccess with
-- initial granted value of 0 (not granted)
Insert into tblUserProfilePeriodAccess
select @ProfilePeriodID, UserID, 0 from #OrgUsers

drop table #OrgUsers

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_RemoveAdmin]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Updates the specified Organisation Administrator to be a SALT User.

Parameters:
@updateUserID Integer
@actionUserID Integer
@organisationID Integer
@originalDateUpdated DateTime

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
6. PermissionDeniedException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 13th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE   Procedure [prcOrganisation_RemoveAdmin]
(
@updateUserID Integer = Null, -- ID of the User that you wish to set Admin rights for.
@actionUserID Integer = Null, -- ID of the User that is making the changes.
@organisationID Integer = Null, -- ID of the Organisation that this user must belong to.
@originalDateUpdated DateTime -- original Date of the record.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

set @originalDateUpdated = dbo.udfDaylightSavingTimeToUTC(@originalDateUpdated, @organisationID)

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number
Declare @intUserTypeUser Integer -- Holds the value for the User UserTypeID from the tblUserType table.
Declare @intUserTypeOrgAdmin Integer -- Holds the value for the OrgAdmin UserTypeID from the tblUserType table.
Declare @dtCurrentDateUpdated DateTime -- Holds the current date updated date.

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0
Select @intUserTypeUser = UserTypeID From tblUserType Where Type = ''User''
Select @intUserTypeOrgAdmin = UserTypeID From tblUserType Where Type = ''Organisation Administrator''
Select @dtCurrentDateUpdated = DateUpdated From tblUser Where UserID = @updateUserID

-- Validation Routines
If(@updateUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If Not Exists(Select * From tblUser Where UserID = @actionUserID And UserTypeID <= @intUserTypeOrgAdmin)
Begin
Set @intErrorNumber = 6
Set @strErrorMessage = ''You do not have access to modify this User.  Click here to return to the login page.''
Goto Finalise
End

If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If(@originalDateUpdated != @dtCurrentDateUpdated)
Begin
Set @intErrorNumber = 7
Set @strErrorMessage = ''The user''''s details have been updated by another user, you will need to refresh the users details and re-enter your changes.  Click here to refresh.''
Goto Finalise
End

If Exists(Select * From tblUser Where UserID = @updateUserID)
Begin
Update tblUser
Set
UserTypeID = @intUserTypeUser
Where
UserID = @updateUserID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''Record not found @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End



' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_RemoveAdministrator]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'




/*Summary:
Updates the specified Organisation Administrator to be a SALT User.

Parameters:
@updateUserID Integer
@actionUserID Integer
@organisationID Integer
@originalDateUpdated DateTime

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
6. PermissionDeniedException
7. IntegrityViolationException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 13th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE  Procedure [prcOrganisation_RemoveAdministrator]
(
@updateUserID Integer = Null, -- ID of the User that you wish to set Admin rights for.
@actionUserID Integer = Null, -- ID of the User that is making the changes.
@organisationID Integer = Null, -- ID of the Organisation that this user must belong to.
@originalDateUpdated DateTime -- original Date of the record.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

set @originalDateUpdated = dbo.udfDaylightSavingTimeToUTC(@originalDateUpdated, @organisationID)

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number
Declare @intUserTypeUser Integer -- Holds the value for the User UserTypeID from the tblUserType table.
Declare @intUserTypeOrgAdmin Integer -- Holds the value for the OrgAdmin UserTypeID from the tblUserType table.
Declare @dtCurrentDateUpdated DateTime -- Holds the current date updated date.

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0
Select @intUserTypeUser = UserTypeID From tblUserType Where Type = ''User''
Select @intUserTypeOrgAdmin = UserTypeID From tblUserType Where Type = ''Organisation Administrator''
Select @dtCurrentDateUpdated = DateUpdated From tblUser Where UserID = @updateUserID

-- Validation Routines
If(@updateUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If Not Exists(Select * From tblUser Where UserID = @actionUserID And UserTypeID <= @intUserTypeOrgAdmin)
Begin
Set @intErrorNumber = 6
Set @strErrorMessage = ''You do not have access to modify this User.  Click here to return to the login page.''
Goto Finalise
End

If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If(@originalDateUpdated != @dtCurrentDateUpdated)
Begin
Set @intErrorNumber = 7
Set @strErrorMessage = ''The user''''s details have been updated by another user, you will need to refresh the users details and re-enter your changes.  Click here to refresh.''
Goto Finalise
End

If Exists(Select * From tblUser Where UserID = @updateUserID)
Begin
Update tblUser
Set
UserTypeID = @intUserTypeUser
Where
UserID = @updateUserID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''Record not found @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End





' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_SaveCourseAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Saves the course access settings for an organisation.

Called By:
Organisation.cs

Calls:
None

Remarks:
None

Author: Peter Vranich
Date Created: 19th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

Test:
Exec prcOrganisation_SaveCourseAccess 1, ''1, 3''
*/

CREATE Procedure [prcOrganisation_SaveCourseAccess]
(
@organisationID Integer,
@grantedCourseIDs VarChar(1000)
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Remove the existing settings
Delete From tblOrganisationCourseAccess
Where
OrganisationID = @organisationID

-- Insert the new settings
Insert Into tblOrganisationCourseAccess
(
OrganisationID,
GrantedCourseID
)
Select
@organisationID,
gc.IntValue
From dbo.udfCsvToInt(@grantedCourseIDs) As gc

Commit Transaction

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_SetAdmin]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Sets a new Organisation Administrator.

Parameters:
@updateUserID Integer
@actionUserID Integer
@organisationID Integer
@originalDateUpdated Integer

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
6. PermissionDeniedException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 13th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE  Procedure [prcOrganisation_SetAdmin]
(
@updateUserID Integer = Null, -- ID of the User that you wish to set Admin rights for.
@actionUserID Integer = Null, -- ID of the User that is making the changes.
@organisationID Integer = Null, -- ID of the Organisation that this user must belong to.
@originalDateUpdated Integer -- original Date of the record.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

set @originalDateUpdated = cast(dbo.udfDaylightSavingTimeToUTC(@originalDateUpdated, @organisationID) as integer)

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number
Declare @intUserTypeOrgAdmin Integer -- Holds the value for the OrgAdmin UserTypeID from the tblUserType table.
Declare @dtCurrentDateUpdated DateTime -- Holds the current date updated date.

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0
Select @intUserTypeOrgAdmin = UserTypeID From tblUserType Where Type = ''Organisation Administrator''
Select @dtCurrentDateUpdated = dbo.udfUTCtoDaylightSavingTime(DateUpdated, @organisationID) From tblUser Where UserID = @updateUserID

-- Validation Routines
If(@updateUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If Exists(Select * From tblUser Where UserID = @actionUserID And UserTypeID = @intUserTypeOrgAdmin)
Begin
Set @intErrorNumber = 6
Set @strErrorMessage = ''You do not have access to modify this User.  Click here to return to the login page.''
Goto Finalise
End

If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If(@originalDateUpdated != @dtCurrentDateUpdated)
Begin
Set @intErrorNumber = 7
Set @strErrorMessage = ''The user''''s details have been updated by another user, you will need to refresh the users details and re-enter your changes.  Click here to refresh.''
Goto Finalise
End

If Exists(Select * From tblUser Where UserID = @updateUserID)
Begin
Update tblUser
Set
UserTypeID = @intUserTypeOrgAdmin
Where
UserID = @updateUserID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''Record not found @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_SetAdministrator]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Sets a new Organisation Administrator.

Parameters:
@updateUserID Integer
@actionUserID Integer
@organisationID Integer
@originalDateUpdated Integer

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
6. PermissionDeniedException
7. IntegrityViolationException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 13th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE Procedure [prcOrganisation_SetAdministrator]
(
@updateUserID Integer, -- ID of the User that you wish to set Admin rights for.
@actionUserID Integer, -- ID of the User that is making the changes.
@organisationID Integer, -- ID of the Organisation that this user must belong to.
@originalDateUpdated DateTime -- original Date of the record.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

set @originalDateUpdated = dbo.udfDaylightSavingTimeToUTC(@originalDateUpdated, @organisationID)

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

declare @intActionUserTypeID integer
Declare @dtCurrentDateUpdated DateTime -- Holds the current date updated date.

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Select @dtCurrentDateUpdated = dbo.udfUTCtoDaylightSavingTime(DateUpdated, @organisationID) From tblUser Where UserID = @updateUserID
Select @dtCurrentDateUpdated = DateUpdated From tblUser Where UserID = @updateUserID

-- Validation Routines
If(@updateUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdministrator''
Goto Finalise
End

If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdministrator''
Goto Finalise
End

select @intActionUserTypeID =UserTypeID
from tblUser
where UserID = @actionUserID

--if action user is not  Salt Administrator(1) or Org Administrator
If (@intActionUserTypeID>2)
Begin
Set @intErrorNumber = 6
Set @strErrorMessage = ''You do not have access to modify this User.  Click here to return to the login page.''
Goto Finalise
End

If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdministrator''
Goto Finalise
End

If(@originalDateUpdated != @dtCurrentDateUpdated)
Begin
Set @intErrorNumber = 7
Set @strErrorMessage = ''The user''''s details have been updated by another user, you will need to refresh the users details and re-enter your changes.  Click here to refresh.''
Goto Finalise
End

If Exists(Select * From tblUser Where UserID = @updateUserID)
Begin
Update tblUser
Set
UserTypeID = 2, -- Org admin
DateUpdated = GETUTCDATE()
Where
UserID = @updateUserID

delete
from tblUnitAdministrator
where userID = @updateUserID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''Record not found @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcOrganisation_Update] (
@LangCode nvarchar(10),
@organisationID Integer = Null, -- ID of the organisation to update.
@organisationName nVarChar(50) = Null, -- The name of the organisation.
@notes nVarChar(4000) = Null, -- The notes for the organisation.
@logo VarChar(100) = Null, -- The name of the organisation logo image.
@lessonFrequency Integer = Null, -- Default Lesson frequency for the organisation.
@quizFrequency Integer = Null, -- Default Quiz frequency for the organisation.
@quizPassMark Integer = Null, -- Default Quiz pass mark for the organisation.
@lessonCompletionDate DateTime = Null, -- Default Lesson completion date
@quizCompletionDate DateTime = Null, -- Default Quiz completion date
@advancedReporting bit = 0,
@actionUserID Integer = Null, -- ID of the User that is making the changes.
@originalDateUpdated DateTime, -- original Date of the record.
@CPDReportName nvarchar(255) = Null, -- CPD Report Name
@AllocatedDiskSpace int = Null,
@inclLogo bit = 0,	-- include certificate logo
@PasswordLockout bit,
@TimeZoneID int = Null,
@ShowLastPassed bit =1,
@DisablePasswordField bit = 0,
@DefaultEbookEmailNotification bit = 0
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

set @lessonCompletionDate = dbo.udfDaylightSavingTimeToUTC(@lessonCompletionDate, @organisationID)
set @quizCompletionDate = dbo.udfDaylightSavingTimeToUTC(@quizCompletionDate, @organisationID)
set @originalDateUpdated = dbo.udfDaylightSavingTimeToUTC(@originalDateUpdated, @organisationID)

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number
Declare @intUserTypeOrgAdmin Integer -- Holds the value for the OrgAdmin UserTypeID from the tblUserType table.
Declare @dtCurrentDateUpdated DateTime -- Holds the current date updated date.

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0
Select @intUserTypeOrgAdmin = UserTypeID From tblUserType Where Type = ''Organisation Administrator''
Select @dtCurrentDateUpdated = DateUpdated From tblOrganisation Where OrganisationID = @organisationID

-- Validation Routines
If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If Not Exists(Select * From tblUser Where UserID = @actionUserID And UserTypeID <= @intUserTypeOrgAdmin)
Begin
Set @intErrorNumber = 6
Set @strErrorMessage = ''You do not have access to modify this Organisation.''
Goto Finalise
End

If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If(@organisationName Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationName in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If Exists(Select * From tblOrganisation Where OrganisationName = @organisationName And OrganisationID != @organisationID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Organisation Name '' + @organisationName + '' already exists please choose another name for your Organisation.''
Goto Finalise
End

If(@notes Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @notes in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If(@logo Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @logo in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If(@lessonFrequency Is Null and @lessonCompletionDate Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @lessonFrequency, @lessonCompletionDate in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If(@quizFrequency Is Null and @quizCompletionDate Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @quizFrequency, @quizCompletionDate in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If(@quizPassMark Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @quizPassMark in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If(@originalDateUpdated != @dtCurrentDateUpdated)
Begin
Set @intErrorNumber = 7
Set @strErrorMessage = ''The organisation''''s details have been updated by another user, you will need to refresh the organisation''''s details and re-enter your changes.  Click here to refresh.''
Goto Finalise
End

If Exists(Select * From tblOrganisation Where OrganisationID = @organisationID)
Begin
Update tblOrganisation
Set
OrganisationName = @organisationName,
Logo = @logo,
DefaultLessonFrequency = @lessonFrequency,
DefaultQuizFrequency = @quizFrequency,
DefaultQuizPassMark = @quizPassMark,
DefaultLessonCompletionDate = @lessonCompletionDate,
DefaultQuizCompletionDate = @quizCompletionDate,
advancedReporting = IsNull(@advancedReporting,advancedReporting),
UpdatedBy = @actionUserID,
DateUpdated = GETUTCDATE(),
CPDReportName = @CPDReportName,
AllocatedDiskSpace = @AllocatedDiskSpace,
IncludeCertificateLogo = @inclLogo,
PasswordLockout = @PasswordLockout,
TimeZoneID = @TimeZoneID,
ShowLastPassed=@ShowLastPassed,
DisablePasswordField=@DisablePasswordField,
DefaultEbookEmailNotification=@DefaultEbookEmailNotification
Where
OrganisationID = @organisationID

update tblOrganisationNotes
set
Notes = @notes
where OrganisationID = @OrganisationID
and LanguageID = (select LangID from tblLang where LangCode = @LangCode)
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''Record not found in stored procedure prcOrganisation_Update''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
''Successfully Updated'' As ''ErrorMessage''
End


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_UpdateDomainName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Updates the domain name for a orgaisation.
The domain name must be unique

This func is only available for Salt Admin

It is used for login

Remarks:
Exception:
0. Succeed
1. RecordNotFoundException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Jack Liu
Date Created: 16th of Sept  2005

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcOrganisation_UpdateDomainName]
(
@organisationID int,
@domainName nvarchar(100)
)

As

if exists(select 1
from tblOrganisation
where domainName=@domainName
and organisationID<>@organisationID)
begin
Select
4 As ''ErrorNumber'',
''Domain name is used by another organisation'' As ''ErrorMessage''
return
end
begin
Update tblOrganisation
set domainName =@domainName
where organisationID=@organisationID

select	0 As ''ErrorNumber'',
'''' As ''ErrorMessage''

end


' 
END
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_UpdateFeatureAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'  

CREATE Procedure [prcOrganisation_UpdateFeatureAccess]
(
@OrganisationID int,
@featurename nvarchar(100),
@granted tinyint
)

As


if(@granted = 1)
begin

delete from tblOrganisationFeatureAccess
where
organisationid=@organisationid and featurename=@featurename

insert into tblOrganisationFeatureAccess
(organisationid, featurename, granted)
values
(@organisationid, @featurename, @granted)

end
else if(@granted = 0)
begin

delete from tblOrganisationFeatureAccess
where
organisationid=@organisationid and featurename=@featurename

end
'
END
GO



SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOvernightJobGetNextPreprocessingOrg]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcOvernightJobGetNextPreprocessingOrg]

AS
BEGIN
IF (0 = (SELECT COUNT(*) FROM tblCounters))
begin
DECLARE @Org INT
SELECT @Org = OrganisationID  FROM tblOrganisation order by OrganisationID
INSERT tblCounters (OvernightJobCurrentOrg) VALUES (@Org )
end
DECLARE @MaxOrg INT
SELECT @MaxOrg = OrganisationID  FROM tblOrganisation order by OrganisationID
DECLARE @LastOrg INT
SELECT @LastOrg = COALESCE(OvernightJobCurrentOrg,1) FROM tblCounters
IF (@LastOrg = @MaxOrg)
BEGIN
SELECT @Org = OrganisationID  FROM tblOrganisation order by OrganisationID DESC
UPDATE tblCounters SET OvernightJobCurrentOrg = @Org
END
ELSE
BEGIN
SELECT @Org = OrganisationID  FROM tblOrganisation WHERE OrganisationID > @LastOrg order by OrganisationID DESC
UPDATE tblCounters SET OvernightJobCurrentOrg = @Org
END

SELECT @Org = COALESCE(OvernightJobCurrentOrg,1) FROM tblCounters
SELECT @org
RETURN @org
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOvernightJobPreprocessOneOrg]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE Procedure [prcOvernightJobPreprocessOneOrg]
AS
BEGIN


declare @cursor_OrgID	    int
-- get the next OrgID (prcOvernightJobGetNextPreprocessingOrg remembers the last OrgID to be preprocessed)
exec @cursor_OrgID = dbo.prcOvernightJobGetNextPreprocessingOrg

-- update the UserLessonStatus for this org (handles the administrative changes to modules assigned to students)
--(originally this appears to have been done by triggers but it appears that the triggers slowed the ASP.NET WebPage too much and were replaced by the overnight job)
INSERT INTO tblPreProcess
           (StartTime)
     VALUES
           (getdate())
declare @preprocessID bigint
select @preprocessID = max (PreProcessID) FROM tblPreProcess
exec prcUserLessonStatus_Update_Quick @cursor_OrgID

exec prcPreprocessOneOrgUnassignedCourses @cursor_OrgID
exec prcPreprocessOneOrgAssignedCourses @cursor_OrgID
exec prcPreprocessOneOrgNoLongerPassedCourses @cursor_OrgID
exec prcPreprocessOneOrgNoLongerFailedCourses @cursor_OrgID
update tblPreProcess set EndTime = getdate() where @preprocessID = PreProcessID
END' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_Add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Add a new Policy.

Parameters:
@PolicyID output int,
@OrganisationID int,
@PolicyName nvarchar(255),
@Active bit,
@Deleted bit,
@PolicyFileName nvarchar(255),
@PolicyFileSize bigint,
@UploadDate datetime


Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

CREATE procedure [prcPolicy_Add]
(
@PolicyID int output,
@OrganisationID int,
@PolicyName nvarchar(255),
@Active bit,
@Deleted bit,
@PolicyFileName nvarchar(255),
@PolicyFileSize bigint,
@ConfirmationMessage nvarchar(500)
)
as

insert into tblPolicy
(
OrganisationID,
PolicyName,
Active,
Deleted,
PolicyFileName,
PolicyFileSize,
UploadDate,
ConfirmationMessage
)
values
(
@OrganisationID,
@PolicyName,
@Active,
@Deleted,
@PolicyFileName,
@PolicyFileSize,
getUTCDate(),
@ConfirmationMessage
)

set @PolicyID = @@Identity

-- get a list of all users for the organisation
create table #UserTemp
(
UserID int
)

insert into #UserTemp (UserID)
Select
UserID
From
tblUser
Where
OrganisationID = @organisationID

insert into tblUserPolicyAccepted (PolicyID, UserID, Accepted)
select @PolicyID, UserID, 0 from #UserTemp

drop table #UserTemp

/*
do this bit for policies that are created after the profiles have been created
*/
insert into tblprofilepoints ( profilepointstype, typeid, profileperiodid, points, active, dateassigned)
select ''P'',@PolicyID,profileperiodid,0,1,getutcdate() from tblprofileperiod

select @PolicyID
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_AdminMashup]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary:		Compiles a bunch of info based on the selected units/policies then filters it based on administrator selection
Parameters:		Comma separated list of userID:policyID, comma separated list of adminID (unit administrators)
Returns:		table (lastname firstname userid email policy_names)

Called By:		BusinessServices.policy.GetAdminMashup in policy.cs
Calls:			None

Remarks:		None

Author:			Mark Donald
Date Created:	20 Jan 2010

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcPolicy_AdminMashup]
@organisationID int,
@unitIDs 			varchar(MAX),
@policyIDs 			varchar(8000),
@input_csv varchar(8000),
@adminids varchar(8000),
@classificationID 	int,
@policyStatus	int,
@acceptedDateFrom 		datetime,
@acceptedDateTo 		datetime,
@includeInactive	int
AS
BEGIN
SET NOCOUNT ON;


set @acceptedDateFrom = dbo.udfDaylightSavingTimeToUTC(@acceptedDateFrom, @organisationID)
set @acceptedDateTo = dbo.udfDaylightSavingTimeToUTC(@acceptedDateTo, @organisationID)

declare @tblUserUnit table
(
UserID int,
UnitID int
)


declare @tblUnit table
(
unitID int
)

declare @tblUnitAdministrator table
(
unitID int,
AdminUserID int
)
Set Nocount On
Declare
@CONST_NOT_ACCEPTED     int,
@CONST_ACCEPTED     	int,
@CONST_UNKNOWN          int


set @CONST_NOT_ACCEPTED	= 0
set @CONST_ACCEPTED	    = 1
set @CONST_UNKNOWN		= 2


DECLARE @Units TABLE (UnitID INT)
DECLARE @policies TABLE (policyID INT)
DECLARE @policiesWithAccess TABLE (policyID INT PRIMARY KEY, [name] nvarchar(100))
DECLARE @UserModuleWithAccess TABLE (UserID INT, ModuleID INT, UnitID INT, PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE (ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE (UserID INT, UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @UsersQuizStatusNOTSTARTED TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @mashup TABLE (userid int, policyid int)
DECLARE @selectedadmin TABLE (adminid int)
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50)

INSERT INTO
@policies
SELECT
*
FROM
dbo.udfCsvToInt(@policyIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

INSERT INTO
@selectedadmin
SELECT
*
FROM
dbo.udfCsvToInt(@adminids)

if @policyStatus = @CONST_ACCEPTED
BEGIN
SELECT

untadm.UserID, usr.Email, adm.FirstName, adm.LastName, pol.policyID, pol.PolicyName, usr.FirstName, usr.LastName
FROM
@policies ps
INNER JOIN tblPolicy pol ON ps.policyID = pol.policyID
INNER JOIN tblUserPolicyAccepted polacp ON polacp.policyID = pol.policyID AND polacp.Accepted = ''True'' AND COALESCE(polacp.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom AND COALESCE(polacp.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo
INNER JOIN tblUserPolicyAccess polacs ON polacs.policyID = pol.policyID AND polacs.Granted = ''True'' AND polacp.userID = polacs.userID
INNER JOIN tblUser usr ON usr.userID = polacp.userID
INNER JOIN tblUnitAdministrator untadm ON untadm.UnitID = usr.UserID
INNER JOIN tblUser adm ON adm.UserID = untadm.UserID
WHERE pol.organisationID = @organisationID;
END
else
BEGIN
SELECT

untadm.UserID, usr.Email, adm.FirstName, adm.LastName, pol.policyID, pol.PolicyName, usr.FirstName, usr.LastName
FROM
@policies ps
INNER JOIN tblPolicy pol ON ps.policyID = pol.policyID
INNER JOIN tblUserPolicyAccepted polacp ON polacp.policyID = pol.policyID AND polacp.Accepted = ''False''
INNER JOIN tblUserPolicyAccess polacs ON polacs.policyID = pol.policyID AND polacs.Granted = ''True'' AND polacp.userID = polacs.userID
INNER JOIN tblUser usr ON usr.userID = polacp.userID
INNER JOIN tblUnitAdministrator untadm ON untadm.UnitID = usr.UserID
INNER JOIN tblUser adm ON adm.UserID = untadm.UserID
WHERE pol.organisationID = @organisationID;

END

END




' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_CheckFileName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Stored procedure to check if a Policy with the same filename
as that being uploaded already exists on the server

Parameters:
@OrganisationID int
@PolicyFileName nvarchar(255)

Called By:
policydetails.aspx

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

*/
create procedure [prcPolicy_CheckFileName]
(
@OrganisationID int,
@PolicyFileName nvarchar(255)
)
as

select PolicyFileName
from tblPolicy
where OrganisationID = @OrganisationID
and PolicyFileName = @PolicyFileName
and Deleted = 0

' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_CheckPolicyName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Stored procedure to check if a Policy with the same name
as that being created already exists

Parameters:
@OrganisationID int
@PolicyName nvarchar(255)

Called By:
policydetails.aspx

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

*/
create procedure [prcPolicy_CheckPolicyName]
(
@OrganisationID int,
@PolicyName nvarchar(255)
)
as

select PolicyName
from tblPolicy
where OrganisationID = @OrganisationID
and PolicyName = @PolicyName
and deleted = 0

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_Get]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Gets a policy

Parameters:
@PolicyID int,

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcPolicy_Get]
(
@PolicyID int,
@OrgID int
)
as

select
PolicyID,
OrganisationID,
PolicyName,
Active,
Deleted,
PolicyFileName,
PolicyFileSize,
dbo.udfUTCtoDaylightSavingTime(UploadDate, @OrgID),
ConfirmationMessage
from tblPolicy
where
PolicyID = @PolicyID
and deleted = 0


' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetAcceptedUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Stored procedure to obtain the number of users who have accepted the policy
i.e. been allocated points for policy in current profile period

Parameters:
@OrganisationID int
@PolicyID int

Called By:

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

*/
create procedure [prcPolicy_GetAcceptedUsers]
(
@OrganisationID int,
@PolicyID int
)
as

select count(*) from
tblPolicy pol
join tblUserPolicyAccepted upa
on pol.PolicyID = upa.PolicyID
join tblUser u
on u.UserID = upa.UserID
where pol.PolicyID = @PolicyID
and pol.OrganisationID = @OrganisationID
and upa.Accepted = 1
and u.Active = 1

' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetAdminsInOrgPendingPolicy]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary:		Mainly just returns a list of unit admins that meet the flagged conditions

Parameters:		Comma separated list of userID:courseID
Returns:		table (lastname nvarchar(50), firstname nvarchar(50), userid int, email nvarchar(100), policy_name varchar(8000))

Called By:		BusinessServices.{Policy.GetAdminsInOrgPendingPolicy in Policy.cs
Calls:			None

Remarks:		None

Author:			John H
Date Created:	21 MAy 2010

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [dbo].[prcPolicy_GetAdminsInOrgPendingPolicy]
@policy_ids varchar(8000),
@unit_ids varchar(max),
@accepted varchar (20),
@acceptedDateFrom 		datetime,
@acceptedDateTo 		datetime
AS
BEGIN
SET NOCOUNT ON;

DECLARE @policies TABLE (policyid int)
DECLARE @selected_units TABLE (unitid int)
DECLARE @result TABLE (firstname nvarchar(50), lastname nvarchar(50), userid int, email nvarchar(100), new_policy_names varchar(8000), modified_policy_names varchar(8000), HierarchyName nvarchar(500))
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50),
@userid int, @admid int,
@new_policy_names varchar(8000),
@users_with_policies varchar(8000),
@modified_policy_names varchar(8000),
@strAccepted varchar(5),
@aunit int,@orgID int

IF @accepted = ''0''
BEGIN
SELECT @strAccepted = ''True''
END
ELSE
BEGIN
SELECT @strAccepted = ''False''
END



-- rip the unit selection
INSERT INTO @selected_units
SELECT
*
FROM
dbo.udfCsvToInt(@unit_ids)

SELECT @policy_ids = replace(rtrim(ltrim(replace(replace(replace(@policy_ids,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''
SELECT @aunit = (SELECT TOP (1) unitid FROM @selected_units)
SELECT @orgID = OrganisationID FROM tblUnit WHERE tblUnit.UnitID = @aunit


set @acceptedDateFrom = dbo.udfDaylightSavingTimeToUTC(@acceptedDateFrom, @orgID)
set @acceptedDateTo = dbo.udfDaylightSavingTimeToUTC(@acceptedDateTo, @orgID)

-- rip the policies into a table
INSERT INTO @policies
SELECT
*
FROM
dbo.udfCsvToInt(@policy_ids)



--	SELECT DISTINCT adm.UserID, hier.HierarchyName, adm.LastName, adm.FirstName,  adm.email, '''',''''
SELECT DISTINCT adm.UserID, unt.Name as HierarchyName, adm.LastName, adm.FirstName,  adm.email, '''',''''
FROM
@policies pols
INNER JOIN tblUserPolicyAccess polacs ON polacs.policyid = pols.policyid AND polacs.granted = ''True''
INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))
INNER JOIN tblUser usr ON usr.userid = polacs.userid AND usr.userid = polacd.userid AND usr.active = ''True''
INNER JOIN @selected_units su ON usr.unitid = su.unitid
INNER JOIN udf_GetAdminEmailsForORG(@orgID) uadm ON uadm.UnitID = su.unitid
INNER JOIN tblUnitHierarchy hier ON hier.UnitID = usr.UnitID
INNER JOIN tblUnit unt ON unt.UnitID = usr.UnitID
INNER JOIN tblUser adm ON adm.userid = uadm.userid
WHERE NOT EXISTS
(SELECT *
FROM
@policies Spols
INNER JOIN tblUserPolicyAccess Spolacs ON Spolacs.policyid = Spols.policyid AND Spolacs.granted = ''True''
INNER JOIN tblUserPolicyAccepted Spolacd ON Spolacd.policyid = Spols.policyid AND Spolacd.Accepted = @strAccepted
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))
INNER JOIN tblUser Susr ON Susr.userid = Spolacs.userid AND Susr.userid = Spolacd.userid AND Susr.active = ''True''
INNER JOIN @selected_units Ssu ON Susr.unitid = Ssu.unitid
INNER JOIN udf_GetAdminEmailsForORG(@orgID) Suadm ON Suadm.UnitID = Ssu.unitid
INNER JOIN tblUnitHierarchy Shier ON Shier.UnitID = Susr.UnitID
INNER JOIN tblUnit Sunt ON Sunt.UnitID = Susr.UnitID
INNER JOIN tblUser Sadm ON Sadm.userid = Suadm.userid and Sadm.UserID = adm.UserID
WHERE (hier.hierarchy LIKE Shier.hierarchy+'',%'') )





END


SET ANSI_NULLS ON
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetListByOrganisation]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Gets a list of all Policies assigned within the Organisation
Parameters: @organisationID  int -- The organisation ID
Returns:

Called By: BusinessServices.Policy.GetPolicyListAccessableToOrg
Calls: None

Remarks: Cut and Paste of course SP

Author: John R
Date Created: 17th of May 2010

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE     Procedure [prcPolicy_GetListByOrganisation]
(
@organisationID  int -- The organisation ID

)

As

-------------------------------------------------------------
-- Return Select
-------------------------------------------------------------
Select
p.[PolicyID]
, p.[PolicyName]
, dbo.udfUTCtoDaylightSavingTime(p.[UploadDate], @organisationID)

From
[tblPolicy] p
WHERE     (p.Active = ''True'') AND (p.Deleted = ''False'')
and p.organisationID = @organisationID
order by p.PolicyName







' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetPoliciesAssignedToUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*
Summary:		Compiles a %POLICY_NAMES% block and returns it with a bunch of user info for sending email to that user
(Mainly just returns a list of users and the policies that they are assigned to (that meet the flagged conditions))

Parameters:		Comma separated list of userID:courseID
Returns:		table (lastname nvarchar(50), firstname nvarchar(50), userid int, email nvarchar(100), policy_name varchar(8000))

Called By:		BusinessServices.{Policy.prcPolicy_GetUsersByPolicyAndUnit in Policy.cs
Calls:			None

Remarks:		None

Author:			Mark Donald (John R copied prcCourse_UserMashup - no optimising attempted as execution time expected to be small)
Date Created:	13 Nov 2009 (copied 18/05/2010)

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcPolicy_GetPoliciesAssignedToUsers]
@policy_ids varchar(8000),
@user_ids varchar(8000),
@accepted varchar (20),
@acceptedDateFrom 		datetime,
@acceptedDateTo 		datetime,
@OrgID int
AS

BEGIN
SET NOCOUNT ON;

set @acceptedDateFrom = dbo.udfDaylightSavingTimeToUTC(@acceptedDateFrom, @OrgID)
set @acceptedDateTo = dbo.udfDaylightSavingTimeToUTC(@acceptedDateTo, @OrgID)

DECLARE @policies TABLE (policyid int)
DECLARE @selected_users TABLE (userid int)
DECLARE @result TABLE (firstname nvarchar(50), lastname nvarchar(50), userid int, email nvarchar(100), new_policy_names varchar(8000), modified_policy_names varchar(8000), HierarchyName nvarchar(500))
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50),
@userid int,
@new_policy_names varchar(8000),
@modified_policy_names varchar(8000),
@strAccepted varchar(5)



IF @accepted = ''0''
BEGIN
SELECT @strAccepted = ''True''
END
ELSE
BEGIN
SELECT @strAccepted = ''False''
END



-- rip the user selection
INSERT INTO @selected_users
SELECT
*
FROM
dbo.udfCsvToInt(@user_ids)

-- clean up the input so it resembles ''userid:policyid,userid:policyid,''
SELECT @policy_ids = replace(rtrim(ltrim(replace(replace(replace(@policy_ids,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''

-- rip the policies into a table
INSERT INTO @policies
SELECT
*
FROM
dbo.udfCsvToInt(@policy_ids)
-- Note to self: String operations take hundreds of times longer than cursor operations so first think of a way to limit the number of string operations, then get rid of the cursors.
SELECT @new_policy_names = ''''
SELECT @modified_policy_names = ''''
DECLARE concatenator CURSOR READ_ONLY FOR
SELECT DISTINCT
userid
FROM
@selected_users
OPEN concatenator
FETCH NEXT FROM concatenator INTO @userid
WHILE @@FETCH_STATUS = 0
BEGIN
SELECT
@new_policy_names = @new_policy_names + [PolicyName] + char(13) + char(10) + char(9)
FROM
tblpolicy pol
INNER JOIN @policies pols ON	pol.policyid = pols.policyid
INNER JOIN tblUserPolicyAccess polacc ON polacc.policyid = pol.policyid AND polacc.granted = ''True'' AND polacc.userid = @userid
INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted AND polacd.userid = @userid
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))
INNER JOIN tblUser usr ON usr.userid = polacc.userid AND usr.active = ''True'' AND usr.userid = @userid

SELECT @new_policy_names = substring(@new_policy_names, 1, len(@new_policy_names) - 3)

INSERT INTO
@result
SELECT
usr.firstname, usr.lastname, usr.userid, usr.email, @new_policy_names, @modified_policy_names, hier.HierarchyName
FROM
tbluser usr
INNER JOIN tblUnitHierarchy hier ON hier.UnitID = usr.UnitID
WHERE
userid = @userid
SELECT @new_policy_names = ''''
SELECT @modified_policy_names = ''''
FETCH NEXT FROM concatenator INTO @userid
END
CLOSE concatenator
DEALLOCATE concatenator


--Get Data in report format
SELECT
DISTINCT UserID, HierarchyName, LastName, FirstName,  email, new_policy_names, modified_policy_names

FROM @result
END




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetPoliciesInUnit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*
Summary:		Compiles a %POLICY_NAMES% block and returns it with a bunch of user info for sending email to that user
(Mainly just returns a list of policies that are assigned to users that meet the flagged conditions)
Parameters:		Comma separated list of userID:courseID
Returns:		table (lastname nvarchar(50), firstname nvarchar(50), userid int, email nvarchar(100), policy_name varchar(8000))

Called By:		BusinessServices.{Policy.prcPolicy_GetUsersByPolicyAndUnit in Policy.cs
Calls:			None

Remarks:		None

Author:			Mark Donald (John R copied prcCourse_UserMashup - no optimising attempted as execution time expected to be small)
Date Created:	13 Nov 2009 (copied 18/05/2010)

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [dbo].[prcPolicy_GetPoliciesInUnit]
@policy_ids varchar(8000),
@unit_ids varchar(max),
@accepted varchar (20),
@acceptedDateFrom 		datetime,
@acceptedDateTo 		datetime,
@OrgID int
AS
BEGIN
SET NOCOUNT ON;

set @acceptedDateFrom = dbo.udfDaylightSavingTimeToUTC(@acceptedDateFrom, @OrgID)
set @acceptedDateTo = dbo.udfDaylightSavingTimeToUTC(@acceptedDateTo, @OrgID)

DECLARE @policies TABLE (policyid int)
DECLARE @selected_units TABLE (unitid int)
DECLARE @result TABLE (policy_names varchar(8000))
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50),
@userid int,
@policy_names varchar(8000),
@modified_policy_names varchar(8000),
@strAccepted varchar(5)



IF @accepted = ''0''
BEGIN
SELECT @strAccepted = ''True''
END
ELSE
BEGIN
SELECT @strAccepted = ''False''
END



-- rip the user selection
INSERT INTO @selected_units
SELECT
*
FROM
dbo.udfCsvToInt(@unit_ids)

-- clean up the input so it resembles ''userid:policyid,userid:policyid,''
SELECT @policy_ids = replace(rtrim(ltrim(replace(replace(replace(@policy_ids,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''

-- rip the policies into a table
INSERT INTO @policies
SELECT
*
FROM
dbo.udfCsvToInt(@policy_ids)
-- Note to self: String operations take hundreds of times longer than cursor operations so first think of a way to limit the number of string operations, then get rid of the cursors.


SELECT DISTINCT pol.PolicyName
FROM
@policies pols
INNER JOIN tblPolicy pol ON pol.PolicyID = pols.PolicyID
INNER JOIN tblUserPolicyAccess polacs ON polacs.policyid = pols.policyid AND polacs.granted = ''True''
INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))

INNER JOIN tblUser usr ON usr.userid = polacs.userid AND usr.userid = polacd.userid AND usr.active = ''True''
INNER JOIN @selected_units su ON usr.unitid = su.unitid
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetUnitAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get''s a list of units that have access to a policy

Parameters:
@PolicyID

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: Feb 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcPolicy_GetUnitAccess]
(
@PolicyID int
)
as
set nocount on

select
UnitID
from tblUnitPolicyAccess
where PolicyID = @PolicyID
and Granted=1

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetUserAndPoliciesForAdmins]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:		Compiles a %USER-POLICY_NAMES% block and returns it with a bunch of user info for sending email to that user


Parameters:		Comma separated list of adminuserID,policyID,unitID
Returns:		table (lastname nvarchar(50), firstname nvarchar(50), userid int, email nvarchar(100), policy_name varchar(8000))

Called By:		BusinessServices.{Policy.GetUserAndPoliciesForAdmins in Policy.cs
Calls:			None

Remarks:		None

Author:			John H
Date Created:	21 May 2010

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [dbo].[prcPolicy_GetUserAndPoliciesForAdmins]
@admin_ids varchar(8000),
@policy_ids varchar(8000),
@unit_ids varchar(max),
@accepted varchar (20),
@acceptedDateFrom 		datetime,
@acceptedDateTo 		datetime,
@OrgID int
AS
BEGIN
SET NOCOUNT ON;

set @acceptedDateFrom = dbo.udfDaylightSavingTimeToUTC(@acceptedDateFrom, @OrgID)
set @acceptedDateTo = dbo.udfDaylightSavingTimeToUTC(@acceptedDateTo, @OrgID)

DECLARE @policies TABLE (policyid int)
DECLARE @selected_units TABLE (unitid int)
DECLARE @selected_admins TABLE (userid int)
DECLARE @result TABLE (firstname nvarchar(50), policyname nvarchar(50), userid int, email nvarchar(100), user_list varchar(8000), PolicyID int, HierarchyName nvarchar(500))

DECLARE
@pos int,
@colon_pos int,
@temp varchar(50),
@admid int , @PolicyID int,
@PolicyName varchar(8000),
@user_list varchar(8000),
@users_with_policies varchar(8000),
@modified_policy_names varchar(8000),
@strAccepted varchar(5),
@aunit int


IF @accepted = ''0''
BEGIN
SELECT @strAccepted = ''True''
END
ELSE
BEGIN
SELECT @strAccepted = ''False''
END



-- rip the unit selection
INSERT INTO @selected_units
SELECT
*
FROM
dbo.udfCsvToInt(@unit_ids)

SELECT @aunit = (SELECT TOP (1) unitid FROM @selected_units)

-- rip the admin selection
INSERT INTO @selected_admins
SELECT
*
FROM
dbo.udfCsvToInt(@admin_ids)




SELECT @policy_ids = replace(rtrim(ltrim(replace(replace(replace(@policy_ids,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''

-- rip the policies into a table
INSERT INTO @policies
SELECT
*
FROM
dbo.udfCsvToInt(@policy_ids)
-- Note to self: String operations take hundreds of times longer than cursor operations so first think of a way to limit the number of string operations, then get rid of the cursors.

SELECT @user_list = ''''
DECLARE concatenator CURSOR READ_ONLY FOR
SELECT DISTINCT
uadm.userid , pol.PolicyName, pol.policyid
FROM
tblpolicy pol
INNER JOIN @policies pols ON pol.policyid = pols.policyid
INNER JOIN tblUserPolicyAccess polacc ON polacc.policyid = pol.policyid AND polacc.granted = ''True''
INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))

INNER JOIN tblUser u ON u.userid = polacc.userid AND u.userid = polacd.userid AND u.active = ''True''
INNER JOIN udf_GetAdminEmailsForORG(@orgID) uadm ON u.UnitID = uadm.unitid
INNER JOIN tblUnitHierarchy hier ON hier.UnitID = u.UnitID
INNER JOIN @selected_units su ON su.unitID = u.unitid
INNER JOIN @selected_admins sa on sa.userid = uadm.userid
ORDER BY uadm.userid
OPEN concatenator
FETCH NEXT FROM concatenator INTO @admID , @policyName, @PolicyID
WHILE @@FETCH_STATUS = 0
BEGIN
SELECT @user_list = COALESCE(@user_list,'''') +  char(13) + char(10) + char(9)  + u.FirstName + '' '' + u.LastName
FROM
tblpolicy pol
INNER JOIN @policies pols ON pol.policyid = pols.policyid AND pol.policyid = @PolicyID
INNER JOIN tblUserPolicyAccess polacc ON polacc.policyid = pol.policyid AND polacc.granted = ''True''
INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))

INNER JOIN tblUser u ON u.userid = polacc.userid AND u.userid = polacd.userid AND u.active = ''True''
INNER JOIN udf_GetAdminEmailsForORG(@orgID) uadm ON u.UnitID = uadm.unitid AND uadm.userid = @admid
INNER JOIN tblUnitHierarchy hier ON hier.UnitID = u.UnitID
INNER JOIN @selected_units su ON su.unitID = u.unitid
ORDER BY u.LastName , u.FirstName

INSERT INTO
@result
SELECT
adm.firstName+'' ''+adm.lastname, @policyName, adm.userid, adm.email, @user_list, @PolicyID, unt.HierarchyName
FROM
tblUser adm
INNER JOIN tblUnitHierarchy unt ON unt.unitid = adm.unitid AND adm.userid = @admID AND adm.active = ''True''

SELECT @user_list = ''''

FETCH NEXT FROM concatenator INTO @admID , @policyName, @PolicyID
END
CLOSE concatenator
DEALLOCATE concatenator


--Get Data in report format
SELECT
DISTINCT UserID, HierarchyName, PolicyName, FirstName,  email, user_list, PolicyID
FROM @result
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetUsersByPolicyAndUnit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary:		Compiles a %POLICY_NAMES% block and returns it with a bunch of user info for sending email to that user
(Mainly just returns a list of users and the policies that they are assigned to (that meet the flagged conditions))

Parameters:		Comma separated list of userID:courseID
Returns:		table (lastname nvarchar(50), firstname nvarchar(50), userid int, email nvarchar(100), policy_name varchar(8000))

Called By:		BusinessServices.{Policy.GetUsersByPolicyAndUnit in Policy.cs
Calls:			None

Remarks:		None

Author:			Mark Donald (John R copied prcCourse_UserMashup - no optimising attempted as execution time expected to be small)
Date Created:	13 Nov 2009 (copied 18/05/2010)

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [dbo].[prcPolicy_GetUsersByPolicyAndUnit]
@policy_ids varchar(8000),
@unit_ids varchar(max),
@accepted varchar (20),
@acceptedDateFrom 		datetime,
@acceptedDateTo 		datetime
AS
BEGIN
SET NOCOUNT ON;

DECLARE @policies TABLE (policyid int)
DECLARE @selected_units TABLE (unitid int)
DECLARE @result TABLE (firstname nvarchar(50), lastname nvarchar(50), userid int, email nvarchar(100), new_policy_names varchar(8000), modified_policy_names varchar(8000), HierarchyName nvarchar(500))
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50),
@userid int,
@new_policy_names varchar(8000),
@modified_policy_names varchar(8000),
@strAccepted varchar(5)



IF @accepted = ''0''
BEGIN
SELECT @strAccepted = ''True''
END
ELSE
BEGIN
SELECT @strAccepted = ''False''
END



-- rip the user selection
INSERT INTO @selected_units
SELECT
*
FROM
dbo.udfCsvToInt(@unit_ids)

-- clean up the input so it resembles ''userid:policyid,userid:policyid,''
SELECT @policy_ids = replace(rtrim(ltrim(replace(replace(replace(@policy_ids,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''

-- rip the policies into a table
INSERT INTO @policies
SELECT
*
FROM
dbo.udfCsvToInt(@policy_ids)
-- Note to self: String operations take hundreds of times longer than cursor operations so first think of a way to limit the number of string operations, then get rid of the cursors.
SELECT @new_policy_names = ''''
SELECT @modified_policy_names = ''''
DECLARE concatenator CURSOR READ_ONLY FOR
SELECT DISTINCT
usr.userid
FROM
@policies pols
INNER JOIN tblUserPolicyAccess polacs ON polacs.policyid = pols.policyid AND polacs.granted = ''True''
INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))

INNER JOIN tblUser usr ON usr.userid = polacs.userid AND usr.userid = polacd.userid AND usr.active = ''True''
INNER JOIN @selected_units su ON usr.unitid = su.unitid
OPEN concatenator
FETCH NEXT FROM concatenator INTO @userid
WHILE @@FETCH_STATUS = 0
BEGIN
SELECT
@new_policy_names = @new_policy_names + [PolicyName] + char(13) + char(10) + char(9)
FROM
tblpolicy pol
INNER JOIN @policies pols ON	pol.policyid = pols.policyid
INNER JOIN tblUserPolicyAccess polacc ON polacc.policyid = pol.policyid AND polacc.granted = ''True''
INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))

INNER JOIN tblUser usr ON usr.userid = polacc.userid AND usr.active = ''True'' AND usr.userid = @userid

SELECT @new_policy_names = substring(@new_policy_names, 1, len(@new_policy_names) - 3)

INSERT INTO
@result
SELECT
usr.firstname, usr.lastname, usr.userid, usr.email, @new_policy_names, @modified_policy_names, hier.HierarchyName
FROM
tbluser usr
INNER JOIN tblUnitHierarchy hier ON hier.UnitID = usr.UnitID
WHERE
userid = @userid
SELECT @new_policy_names = ''''
SELECT @modified_policy_names = ''''
FETCH NEXT FROM concatenator INTO @userid
END
CLOSE concatenator
DEALLOCATE concatenator


--Get Data in report format
SELECT
DISTINCT UserID, HierarchyName, LastName, FirstName,  email, new_policy_names, modified_policy_names

FROM @result
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_ResetUnitAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Reset''s all Unit''s access to profile to 0

Parameters:
@ProfileID integer

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: Feb 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcPolicy_ResetUnitAccess]
(
@PolicyID int
)
as
set nocount on


update tblUnitPolicyAccess
set Granted = 0
where PolicyID = @PolicyID

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_SetUnitAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s a list of units that have access to a profile

Parameters:
@PolicyID integer
@UnitID integer

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: Feb 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcPolicy_SetUnitAccess]
(
@PolicyID int,
@UnitID int
)
as
set nocount on

update tblUnitPolicyAccess
set Granted = 1
where PolicyID = @PolicyID
and UnitID = @UnitID

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_SetUserAccessByUnit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/**Summary:
Set''s a users that have access to a profile

Parameters:
@ProfileID integer
@UnitID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: Feb 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcPolicy_SetUserAccessByUnit]
(
@PolicyID int,
@UnitID int
)
as
set nocount on

update tblUserPolicyAccess
set Granted = 1
where PolicyID = @PolicyID
and UserID in
(select UserID from tblUser where UnitID = @UnitID and active=1)

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_SetUserAccessByUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s a users that have access to a profile

Parameters:
@PolicyID integer
@UserID integer
@Granted bit

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: Feb 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcPolicy_SetUserAccessByUser]
(
@PolicyID int,
@UserID int,
@Granted bit
)
as
set nocount on

update tblUserPolicyAccess
set Granted = @Granted
where PolicyID = @PolicyID
and UserID = @UserID

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Updates a Policy.

Parameters:
@PolicyID int,
@OrganisationID int,
@PolicyName nvarchar(255),
@Active bit,
@Deleted bit,
@PolicyFileName nvarchar(255),
@PolicyFileSize bigint,
@UploadDate datetime


Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

CREATE procedure [prcPolicy_Update]
(
@PolicyID int,
@OrganisationID int,
@PolicyName nvarchar(255),
@Active bit,
@Deleted bit,
@PolicyFileName nvarchar(255),
@PolicyFileSize bigint,
@UploadDate datetime,
@ConfirmationMessage nvarchar(500)
)
as

declare @SQL nvarchar(1000)
declare @SQLL nvarchar(1000)
declare @SQLR nvarchar(1000)
declare @Index int

set @PolicyName = replace(@PolicyName, '''''''', '''''''''''')
set @ConfirmationMessage = replace(@ConfirmationMessage, '''''''', '''''''''''')

set @SQL = ''update tblPolicy''
set @SQL = @SQL + '' set''
if @OrganisationID is not null
begin
set @SQL = @SQL + '' OrganisationID = '' + cast(@OrganisationID as nvarchar) + '',''
end
if @PolicyName is not null
begin
set @SQL = @SQL + '' PolicyName = '''''' + @PolicyName + '''''',''
end
if @Active is not null
begin
set @SQL = @SQL + '' Active = '' + cast(@Active as char(1)) + '', ''
end
if @Deleted is not null
begin
set @SQL = @SQL + '' Deleted = '' + cast(@Deleted as char(1)) + '', ''
end
if @PolicyFileName is not null
begin
set @SQL = @SQL + '' PolicyFileName = '''''' + @PolicyFileName + '''''',''
end
if @PolicyFileSize is not null
begin
set @SQL = @SQL + '' PolicyFileSize = '' + cast(@PolicyFileSize as nvarchar) + '',''
end
if @UploadDate is not null
begin
set @SQL = @SQL + '' UploadDate = getUTCDate() ,''
end
if @ConfirmationMessage is not null
begin
set @SQL = @SQL + '' ConfirmationMessage = '''''' + @ConfirmationMessage + '''''',''
end
set @SQL = @SQL + '' where PolicyID ='' + cast(@PolicyID as nvarchar)

-- this removes last '','' character from @SQL
set @SQL = reverse(@SQL)
set @index = charindex('','', @SQL)
if @index > 0
begin
set @SQLL = left(@SQL, @index-1)
set @SQLR = right(@SQL, len(@SQL) - (@index))
set @SQL = @SQLL + @SQLR
end
set @SQL = reverse(@SQL)

exec (@SQL)
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_UserSearch]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Returns results of search for users on Assign Users tab of CPDdetail.aspx

Returns:

Called By:

Calls:

Remarks:
The searching units will include all children and grandchildren
Only return users that logged on user has permission to see


Author: Aaron Cripps
Date Created: Feb 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

CREATE  Procedure  [dbo].[prcPolicy_UserSearch]
(
@organisationID  Int,
@PolicyID int,
@parentUnitIDs  Varchar(max),
@firstName	nVarchar(50),
@lastName	nVarchar(50),
@userName	nVarChar(100),
@Email		nVarChar(100),
@ExternalID nVarChar(50),
@adminUserID		Int,
@Type nvarchar(50)
)
As
Set Nocount On

Declare @intUserTypeID Int

Select @intUserTypeID = UserTypeID
From tblUser
Where userID = @adminUserID



--Check Data
If @parentUnitIDs is null
set @parentUnitIDs =''''

If @firstName is null
Set @firstName = ''''

Set @firstName =rtrim(@firstName)

If @lastName is null
Set @lastName = ''''

Set @lastName =rtrim(@lastName)

If @userName is null
Set @userName = ''''

set @userName = rtrim(@userName)

if @Email is null
set @Email = ''''

set @Email = rtrim(@Email)

if @ExternalID is null
set @ExternalID = ''''

set @ExternalID = rtrim(@ExternalID)

if @Type = ''search''
Begin
Select
us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(us.LastLogin as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active,
upa.Granted

From tblUnit un, tblUser us, tblUserPolicyAccess upa

Where (un.OrganisationID = @organisationID)
and
(
us.Active=1
)
--0. Join Unit and User tables
and (
un.UnitID = us.UnitID
)
-- Join User and UserProfilePeriodAccess tables
and (
us.UserID = upa.UserID
)
and (
upa.PolicyID = @PolicyID
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
and (
un.UnitID in
(
Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
)
or (@parentUnitIDs='''')
)
--2. User firstname contains the entered text
and (
(firstname like ''%''+ @firstName + ''%'')
or (firstname ='''')
)
--3. User lastname contains the entered text
and (
(lastname like ''%''+ @lastName + ''%'')
or (lastname ='''')
)
-- User username contains the entered text
and (
(username like ''%'' + @userName + ''%'')
or (userName='''')
)
-- User email contains the entered text
and (
(email like ''%'' + @Email + ''%'')
or (email='''') or (email = null)
)
-- User externalid contains the entered text
and (
(externalID like ''%'' + @ExternalID + ''%'')
or (externalID = '''') or (externalid = null)
)
--4. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
Order By Name
End
else if @Type = ''view''
Begin
Select
us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(us.LastLogin as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active,
upa.Granted

From tblUnit un, tblUser us, tblUserPolicyAccess upa

Where (un.OrganisationID = @organisationID)
and
(
us.Active=1
)
--0. Join Unit and User tables
and (
un.UnitID = us.UnitID
)
-- Join User and UserProfilePeriodAccess tables
and (
us.UserID = upa.UserID
)
and (
upa.PolicyID = @PolicyID
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
--and (
--un.UnitID in
--	(
--		Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
--	)
--	or (@parentUnitIDs='''')
--	)
--2. User firstname contains the entered text
--and (
--	(firstname like ''%''+ @firstName + ''%'')
--	or (firstname ='''')
--    )
--3. User lastname contains the entered text
--and (
--	(lastname like ''%''+ @lastName + ''%'')
--	or (lastname ='''')
--    )
-- User username contains the entered text
--and (
--	(username like ''%'' + @userName + ''%'')
--	or (userName='''')
--	)
-- User email contains the entered text
--and (
--	(email like ''%'' + @Email + ''%'')
--	or (email='''') or (email = null)
--	)
-- User externalid contains the entered text
--and (
--	(externalID like ''%'' + @ExternalID + ''%'' )
--	or (externalID = '''') or (externalid = null)
--	)
--4. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
and upa.Granted=1
Order By Name
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPreprocessOneOrgAssignedCourses]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcPreprocessOneOrgAssignedCourses] @orgid INT
AS
BEGIN

	-- **********************************
	--< This procedure looks for Courses for which a user  >--
	--<   * has access to any modules>--
	--<    * currently has a Course Status of unAssigned>--
	--< All Couses in the Organisation that match these criteria have their status recalculated >--
	-- **********************************




declare @UserID int, @ModuleID int
DECLARE ModuleLOOP CURSOR
FOR
	SELECT   
	CCS.UserID,	uma.moduleid

	FROM tblUserCourseStatus CCS  --< Detail Course Status information >--
	INNER JOIN (
																					--<  Last (Latest) Course Status  >--
		SELECT max(tblUserCourseStatus.UserCourseStatusID) AS maxUserCourseStatusID
			,tbluser.UserID
			,CourseID
		FROM tblUserCourseStatus
		INNER JOIN tblUser ON tblUser.UserID = tblUserCourseStatus.UserID
		WHERE  tblUser.OrganisationID = @OrgID AND tblUser.Active = 1
		GROUP BY tbluser.UserID
			,CourseID
																					--<  Last (Latest) Course Status  >--
		) lastStatus ON lastStatus.CourseID = CCS.CourseID
		AND lastStatus.UserID = CCS.UserID
		AND lastStatus.maxUserCourseStatusID = CCS.UserCourseStatusID
		
		inner join vwUserModuleAccess UMA on UMA.CourseID = CCS.CourseID and UMA.UserID = CCS.UserID
		
	WHERE  CCS.CourseStatusID  =  0
Open ModuleLOOP

FETCH NEXT FROM ModuleLOOP
Into
@UserID, @ModuleID

WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC prcUserQuizStatus_UpdateCourseStatus @UserID, @ModuleID
	DECLARE @Err integer
	SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcPreprocessOneOrgAssignedCourses'',''prcUserQuizStatus_UpdateCourseStatus'',''prcUserQuizStatus_UpdateCourseStatus'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END


FETCH NEXT FROM ModuleLOOP
Into
@UserID, @ModuleID
END

CLOSE ModuleLOOP
DEALLOCATE ModuleLOOP




END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPreprocessOneOrgNoLongerFailedCourses]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create PROCEDURE [prcPreprocessOneOrgNoLongerFailedCourses] @orgid INT
AS
BEGIN

	-- **********************************
	--< This procedure looks for Courses for which a user  >--
	--<   * has access to any modules with a status of '' Passed''>--
	--<   * has NO access to any modules with a status of ''Not Passed''>--
	--<    * currently has a Course Status of NOT Passed>--
	--< All Couses in the Organisation that match these criteria have their status recalculated >--
	-- **********************************




declare @UserID int, @ModuleID int
DECLARE ModuleLOOP CURSOR
FOR
	SELECT   
	CCS.UserID,	CAM.moduleid
	FROM tblUserCourseStatus CCS  --< Detail Course Status information >--
	INNER JOIN (
																					--<  Last (Latest) Course Status  >--
		SELECT max(tblUserCourseStatus.UserCourseStatusID) AS maxUserCourseStatusID
			,tbluser.UserID
			,CourseID
		FROM tblUserCourseStatus
		INNER JOIN tblUser ON tblUser.UserID = tblUserCourseStatus.UserID
		WHERE tblUser.OrganisationID = @orgid
			AND tblUser.Active = 1
		GROUP BY tbluser.UserID
			,CourseID
																					--<  Last (Latest) Course Status  >--
		) lastStatus ON lastStatus.CourseID = CCS.CourseID
		AND lastStatus.UserID = CCS.UserID
		AND lastStatus.maxUserCourseStatusID = CCS.UserCourseStatusID
	INNER JOIN (
																					--<         C   A   M              >--
																					--<   Current   Assigned  Modules  >--
																					--<   All modules a User Currently has access to                       >--
		SELECT um.UserID
			,um.ModuleID
			,um.CourseID
		FROM (
			SELECT tU.UserID
				,tU.UnitID
				,tU.OrganisationID
				,tM.ModuleID
				,tC.CourseID
			FROM dbo.tblUser tU
			--< get the courses a user has access to >--
			INNER JOIN dbo.tblOrganisationCourseAccess tOCA ON tOCA.OrganisationID = tU.OrganisationID
			--< get the course details >--
			INNER JOIN dbo.tblCourse tC ON tC.CourseID = tOCA.GrantedCourseID
			--< get the Active modules in a course >--
			INNER JOIN dbo.tblModule tM ON tM.CourseID = tC.CourseID
				AND tM.Active = 1
			--< get the details on which modules a user is configured to access >--
			LEFT OUTER JOIN dbo.tblUserModuleAccess tUsrMA ON tUsrMA.UserID = tU.UserID
				AND tUsrMA.ModuleID = tM.ModuleID
			--< get the details on which modules a user''s Unit is excluded from  >--
			LEFT OUTER JOIN dbo.tblUnitModuleAccess tUnitMA ON tUnitMA.UnitID = tU.UnitID
				AND tUnitMA.DeniedModuleID = tM.ModuleID
			WHERE tU.OrganisationID = @OrgID
				AND tU.Active = 1
				--< Active users only >--
				AND (
					tu.UnitID IS NOT NULL
					--< Get the modules that the user''s Unit is not denied >--
					AND (
						tUnitMA.DeniedModuleID IS NULL
						--<  and the user does  have special access to  it>--
						AND tUsrMA.ModuleID IS NULL
						)
					--< or Get modules that the user has been specially  granted >--
					OR tUsrMA.Granted = 1
					)
			) um
		INNER JOIN (
			SELECT u.UnitID
				,m.CourseID
				,m.ModuleID
			FROM tblOrganisationCourseAccess c
			INNER JOIN tblModule m ON m.CourseID = c.GrantedCourseID
			INNER JOIN tblOrganisation o -- Get default compliance rules
				ON o.OrganisationID = c.OrganisationID
			INNER JOIN tblUnit u ON u.OrganisationID = c.OrganisationID
			WHERE o.OrganisationID = @OrgID
			) umr ON umr.ModuleID = um.ModuleID
			AND umr.UnitID = um.UnitID
			AND um.UnitID IN (
				SELECT UnitID
				FROM tblUnit
				WHERE OrganisationID = @OrgID
				)
			AND um.UserID IN (
				SELECT UserID
				FROM tblUser
				WHERE OrganisationID = @OrgID
				)
																							--<   C   A   M   >--


		) CAM ON CAM.userid = CCS.userid
		AND cam.CourseID = CCS.CourseID
		
		inner join (select QuizStatus.UserID,QuizStatus.ModuleID,QuizStatus.QuizStatusID from
tblUserQuizStatus QuizStatus
inner join tblModule m on m.ModuleID = QuizStatus.ModuleID
inner join
(
select
max(UserQuizStatusID) UserQuizStatusID --UserQuizStatusID is identity
from
tblUserQuizStatus
WHERE
tblUserQuizStatus.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
group by
UserID,moduleID
) currentStatus
on QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
where m.active = 1 and QuizStatus.QuizStatusID = 2
) PMS on PMS.UserID=CAM.UserID and PMS.ModuleID = CAM.ModuleID  --PassedModulesStatus
left join (select QuizStatus.UserID,QuizStatus.ModuleID,QuizStatus.QuizStatusID from
tblUserQuizStatus QuizStatus
inner join tblModule m on m.ModuleID = QuizStatus.ModuleID
inner join
(
select
max(UserQuizStatusID) UserQuizStatusID --UserQuizStatusID is identity
from
tblUserQuizStatus
WHERE
tblUserQuizStatus.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
group by
UserID,moduleID
) currentStatus
on QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
where m.active = 1 and QuizStatus.QuizStatusID <> 2 -- FailedUserQuizStatus
) FQS on FQS.UserID=CAM.UserID and FQS.ModuleID = CAM.ModuleID		
	WHERE 
	  CCS.CourseStatusID = 1 and PMS.QuizStatusID =2		and FQS.QuizStatusID IS NULL




Open ModuleLOOP

FETCH NEXT FROM ModuleLOOP
Into
@UserID, @ModuleID

WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC prcUserQuizStatus_UpdateCourseStatus @UserID, @ModuleID
	DECLARE @Err integer
	SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcPreprocessOneOrgAssignedCourses'',''prcUserQuizStatus_UpdateCourseStatus'',''prcUserQuizStatus_UpdateCourseStatus'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END


FETCH NEXT FROM ModuleLOOP
Into
@UserID, @ModuleID
END

CLOSE ModuleLOOP
DEALLOCATE ModuleLOOP




END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPreprocessOneOrgNoLongerPassedCourses]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
create PROCEDURE [prcPreprocessOneOrgNoLongerPassedCourses] @orgid INT
AS
BEGIN

	-- **********************************
	--< This procedure looks for Courses for which a user  >--
	--<   * has access to any modules with a status of ''Not Passed''>--
	--<    * currently has a Course Status of Passed>--
	--< All Couses in the Organisation that match these criteria have their status recalculated >--
	-- **********************************




declare @UserID int, @ModuleID int
DECLARE ModuleLOOP CURSOR
FOR
	SELECT   
	CCS.UserID,	CAM.moduleid
	FROM tblUserCourseStatus CCS  --< Detail Course Status information >--
	INNER JOIN (
																					--<  Last (Latest) Course Status  >--
		SELECT max(tblUserCourseStatus.UserCourseStatusID) AS maxUserCourseStatusID
			,tbluser.UserID
			,CourseID
		FROM tblUserCourseStatus
		INNER JOIN tblUser ON tblUser.UserID = tblUserCourseStatus.UserID
		WHERE tblUser.OrganisationID = @orgid
			AND tblUser.Active = 1
		GROUP BY tbluser.UserID
			,CourseID
																					--<  Last (Latest) Course Status  >--
		) lastStatus ON lastStatus.CourseID = CCS.CourseID
		AND lastStatus.UserID = CCS.UserID
		AND lastStatus.maxUserCourseStatusID = CCS.UserCourseStatusID
	INNER JOIN (
																					--<         C   A   M              >--
																					--<   Current   Assigned  Modules  >--
																					--<   All modules a User Currently has access to                       >--
		SELECT um.UserID
			,um.ModuleID
			,um.CourseID
		FROM (
			SELECT tU.UserID
				,tU.UnitID
				,tU.OrganisationID
				,tM.ModuleID
				,tC.CourseID
			FROM dbo.tblUser tU
			--< get the courses a user has access to >--
			INNER JOIN dbo.tblOrganisationCourseAccess tOCA ON tOCA.OrganisationID = tU.OrganisationID
			--< get the course details >--
			INNER JOIN dbo.tblCourse tC ON tC.CourseID = tOCA.GrantedCourseID
			--< get the Active modules in a course >--
			INNER JOIN dbo.tblModule tM ON tM.CourseID = tC.CourseID
				AND tM.Active = 1
			--< get the details on which modules a user is configured to access >--
			LEFT OUTER JOIN dbo.tblUserModuleAccess tUsrMA ON tUsrMA.UserID = tU.UserID
				AND tUsrMA.ModuleID = tM.ModuleID
			--< get the details on which modules a user''s Unit is excluded from  >--
			LEFT OUTER JOIN dbo.tblUnitModuleAccess tUnitMA ON tUnitMA.UnitID = tU.UnitID
				AND tUnitMA.DeniedModuleID = tM.ModuleID
			WHERE tU.OrganisationID = @OrgID
				AND tU.Active = 1
				--< Active users only >--
				AND (
					tu.UnitID IS NOT NULL
					--< Get the modules that the user''s Unit is not denied >--
					AND (
						tUnitMA.DeniedModuleID IS NULL
						--<  and the user does  have special access to  it>--
						AND tUsrMA.ModuleID IS NULL
						)
					--< or Get modules that the user has been specially  granted >--
					OR tUsrMA.Granted = 1
					)
			) um
		INNER JOIN (
			SELECT u.UnitID
				,m.CourseID
				,m.ModuleID
			FROM tblOrganisationCourseAccess c
			INNER JOIN tblModule m ON m.CourseID = c.GrantedCourseID
			INNER JOIN tblOrganisation o -- Get default compliance rules
				ON o.OrganisationID = c.OrganisationID
			INNER JOIN tblUnit u ON u.OrganisationID = c.OrganisationID
			WHERE o.OrganisationID = @OrgID
			) umr ON umr.ModuleID = um.ModuleID
			AND umr.UnitID = um.UnitID
			AND um.UnitID IN (
				SELECT UnitID
				FROM tblUnit
				WHERE OrganisationID = @OrgID
				)
			AND um.UserID IN (
				SELECT UserID
				FROM tblUser
				WHERE OrganisationID = @OrgID
				)
																							--<   C   A   M   >--


		) CAM ON CAM.userid = CCS.userid
		AND cam.CourseID = CCS.CourseID
		
		inner join (select QuizStatus.UserID,QuizStatus.ModuleID,QuizStatus.QuizStatusID from
tblUserQuizStatus QuizStatus
inner join tblModule m on m.ModuleID = QuizStatus.ModuleID
inner join
(
select
max(UserQuizStatusID) UserQuizStatusID --UserQuizStatusID is identity
from
tblUserQuizStatus
WHERE
tblUserQuizStatus.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
group by
UserID,moduleID
) currentStatus
on QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
where m.active = 1) CMS on CMS.UserID=CAM.UserID and CMS.ModuleID = CAM.ModuleID
		
	WHERE 
	  CCS.CourseStatusID = 2 and CMS.QuizStatusID <>2		




Open ModuleLOOP

FETCH NEXT FROM ModuleLOOP
Into
@UserID, @ModuleID

WHILE @@FETCH_STATUS = 0
BEGIN
	EXEC prcUserQuizStatus_UpdateCourseStatus @UserID, @ModuleID
	DECLARE @Err integer
	SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcPreprocessOneOrgAssignedCourses'',''prcUserQuizStatus_UpdateCourseStatus'',''prcUserQuizStatus_UpdateCourseStatus'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END


FETCH NEXT FROM ModuleLOOP
Into
@UserID, @ModuleID
END

CLOSE ModuleLOOP
DEALLOCATE ModuleLOOP




END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPreprocessOneOrgUnassignedCourses]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcPreprocessOneOrgUnassignedCourses] @orgid INT
AS
BEGIN
	-- **********************************
	--< This procedure looks for Courses for which a user  >--
	--<   * has no access to any modules>--
	--<    * currently has a Course Status other than unAssigned>--
	--< All Couses in the Organisation that match these criteria are set to ''Unassigned''>--
	--< it is believed that the overnight job currently handles the reverse of this case correctly.>--
	--< don''t want to overload the cpu when admins are making big changes by assigning courses to units/ etc>--
	--< so don''t ''clean up'' the status of courses for at least one day after the last update to this course status.>--
	-- **********************************

	DECLARE @when DATETIME

	SET @when = DATEADD(d, - 1, getutcdate())

	INSERT INTO tblUserCourseStatus (
		[UserID]
		,[CourseID]
		,[CourseStatusID]
		,[ModulesAssigned]
		,[DateCreated]
		)
	SELECT CCS.UserID
		,CCS.CourseID
		,0
		,'''' AS ModulesAssigned
		,GETUTCDATE() AS DateCreated
	FROM tblUserCourseStatus CCS  --< Detail Course Status information >--
	INNER JOIN (
																					--<  Last (Latest) Course Status  >--
		SELECT max(tblUserCourseStatus.UserCourseStatusID) AS maxUserCourseStatusID
			,tbluser.UserID
			,CourseID
		FROM tblUserCourseStatus
		INNER JOIN tblUser ON tblUser.UserID = tblUserCourseStatus.UserID
		WHERE tblUser.OrganisationID = @orgid
			AND tblUser.Active = 1
		GROUP BY tbluser.UserID
			,CourseID
																					--<  Last (Latest) Course Status  >--
		) lastStatus ON lastStatus.CourseID = CCS.CourseID
		AND lastStatus.UserID = CCS.UserID
		AND lastStatus.maxUserCourseStatusID = CCS.UserCourseStatusID
	LEFT JOIN (
																					--<         C   A   M              >--
																					--<   Current   Assigned  Modules  >--
																					--<   All modules a User Currently has access to                       >--
		SELECT um.UserID
			,um.ModuleID
			,um.CourseID
		FROM (
			SELECT tU.UserID
				,tU.UnitID
				,tU.OrganisationID
				,tM.ModuleID
				,tC.CourseID
			FROM dbo.tblUser tU
			--< get the courses a user has access to >--
			INNER JOIN dbo.tblOrganisationCourseAccess tOCA ON tOCA.OrganisationID = tU.OrganisationID
			--< get the course details >--
			INNER JOIN dbo.tblCourse tC ON tC.CourseID = tOCA.GrantedCourseID
			--< get the Active modules in a course >--
			INNER JOIN dbo.tblModule tM ON tM.CourseID = tC.CourseID
				AND tM.Active = 1
			--< get the details on which modules a user is configured to access >--
			LEFT OUTER JOIN dbo.tblUserModuleAccess tUsrMA ON tUsrMA.UserID = tU.UserID
				AND tUsrMA.ModuleID = tM.ModuleID
			--< get the details on which modules a user''s Unit is excluded from  >--
			LEFT OUTER JOIN dbo.tblUnitModuleAccess tUnitMA ON tUnitMA.UnitID = tU.UnitID
				AND tUnitMA.DeniedModuleID = tM.ModuleID
			WHERE tU.OrganisationID = @OrgID
				AND tU.Active = 1
				--< Active users only >--
				AND (
					tu.UnitID IS NOT NULL
					--< Get the modules that the user''s Unit is not denied >--
					AND (
						tUnitMA.DeniedModuleID IS NULL
						--<  and the user does  have special access to  it>--
						AND tUsrMA.ModuleID IS NULL
						)
					--< or Get modules that the user has been specially  granted >--
					OR tUsrMA.Granted = 1
					)
			) um
		INNER JOIN (
			SELECT u.UnitID
				,m.CourseID
				,m.ModuleID
			FROM tblOrganisationCourseAccess c
			INNER JOIN tblModule m ON m.CourseID = c.GrantedCourseID
			INNER JOIN tblOrganisation o -- Get default compliance rules
				ON o.OrganisationID = c.OrganisationID
			INNER JOIN tblUnit u ON u.OrganisationID = c.OrganisationID
			WHERE o.OrganisationID = @OrgID
			) umr ON umr.ModuleID = um.ModuleID
			AND umr.UnitID = um.UnitID
			AND um.UnitID IN (
				SELECT UnitID
				FROM tblUnit
				WHERE OrganisationID = @OrgID
				)
			AND um.UserID IN (
				SELECT UserID
				FROM tblUser
				WHERE OrganisationID = @OrgID
				)
																							--<   C   A   M   >--

		) CAM ON CAM.userid = CCS.userid
		AND cam.CourseID = CCS.CourseID
	WHERE CAM.UserID IS NULL
		AND CCS.CourseStatusID <> 0
		AND CCS.DateCreated < @when
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfilePeriod_RollOver]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE procedure [prcProfilePeriod_RollOver]
as begin

-- AC notes:
-- Get all periods that are active and end date has passed then
-- a) if there are instructions to make a future period then populate a new
-- record with the future period (+ instructions with what to do with the period following
-- that

/*
-- b) if there are no instructions to make a future period then populate a new record
-- with no current period or future period instructions (so user can create a period
-- at a later time */
-- c) then make the active period inactive
-- d) following this need to go through all code that references profile periods and add
-- sql to that code to take into account the profileperiodactive field

declare @tmptable table
(
ppid int,
pid int,
newppid int
)

/*	get all the periods that have been,
and have a future period that havnt been created yet*/
/*insert into @tmptable (ppid, pid)
select
p2.profileperiodid, p2.profileid
from
tblprofileperiod p1
right join tblprofileperiod p2 on p1.profileid = p2.profileid
and p1.datestart = p2.futuredatestart and p1.dateend = p2.futuredateend
where
p1.profileperiodid is null
and dateadd(hh,24,p2.dateend) <getutcdate()
and p2.endofperiodaction in (2,3,4)*/

insert into @tmptable (ppid, pid)
select
profileperiodid, profileid
from
tblProfilePeriod
where
profileperiodactive = 1
and dateadd(hh,24,dateend) < getutcdate()
order by profileid



--	add them into the profile period table
insert into tblprofileperiod (profileid,datestart,dateend, points, applytoquiz, applytolesson, endofperiodaction, monthincrement, futuredatestart, futuredateend, futurepoints, profileperiodactive)
select
pid,
futuredatestart,
futuredateend,
futurepoints,
applytoquiz,
applytolesson,
case when endofperiodaction = 4 then 1
else endofperiodaction end
as futureendofperiodaction,
monthincrement,
case when endofperiodaction = 4 then null
else dateadd(day, 1, futuredateend) end
as newfuturedatestart,
case when endofperiodaction = 4 then null
when endofperiodaction = 3 then dateadd(month, monthincrement, futuredateend)
when endofperiodaction = 2 then dateadd(day, 1, dateadd(day, datediff(day, futuredatestart, futuredateend), futuredateend)) end
as newfuturedateend,
futurepoints,
1
from
tblprofileperiod
join @tmptable on ppid = profileperiodid


-- make the active period inactive
update tblprofileperiod
set
profileperiodactive = 0
where
profileperiodid in
(select ppid from @tmptable)


-- remove the ones we dont need to do anything with
delete from @tmptable where ppid not  in
(
select profileperiodid from
tblprofileperiod
join @tmptable on ppid = profileperiodid and endofperiodaction in (2,3,4)
)

-- get the ids for the new profile periods
update @tmptable set newppid = p1.profileperiodid
from
tblprofileperiod p1
--right join tblprofileperiod p2 on p1.profileid = p2.profileid
--and p1.datestart = p2.futuredatestart and p1.dateend = p2.futuredateend
join @tmptable t2 on t2.pid = p1.profileid
and p1.profileperiodactive = 1


--copy across the points from the previous period into the new one
insert into tblprofilepoints
(profileperiodid, profilepointstype,typeid, points,active, dateassigned)
select
newppid,
p1.profilepointstype,
p1.typeid,
p1.points,
p1.active,
getutcdate()
from
tblprofilepoints p1
join @tmptable on ppid = profileperiodid


/* initialise user access to the period
(will give the same users access as previously assigned)*/
insert into tbluserprofileperiodaccess
(profileperiodid, userid, granted)
select
newppid,
pa.userid,
pa.granted
from tbluserprofileperiodaccess pa
join @tmptable on ppid = profileperiodid

/* initialise unit access to the period
(will give the same unit access as previously assigned)*/
insert into tblunitprofileperiodaccess
(profileperiodid, unitid, granted)
select
newppid,
pa.unitid,
pa.granted
from tblunitprofileperiodaccess pa
join @tmptable on ppid = profileperiodid

end
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfilePoints_Add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Adds Profile

Parameters:
@ProfilePointsType nvarchar(1),
@TypeID int,
@ProfilePeriodID int,
@Points numeric(10,1),
@Active bit,
@DateAssigned datetime

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

CREATE procedure [prcProfilePoints_Add]
(
@ProfilePointsType nvarchar(1),
@TypeID int,
@ProfilePeriodID int,
@Points numeric(10,1),
@Active bit,
@OrgID int
--@ApplyToQuiz bit,
--@ApplyToLesson bit
)

as



-- insert values into tblProfilePoints
insert into tblProfilePoints
(
ProfilePointsType,
TypeID,
ProfilePeriodID,
Points,
Active,
DateAssigned --,
--ApplyToQuiz,
--ApplyToLesson
)
values
(
@ProfilePointsType,
@TypeID,
@ProfilePeriodID,
@Points,
@Active,
GETUTCDATE() --,
--@ApplyToQuiz,
--@ApplyToLesson
)

/****** Object:  Table [dbo].[tbllogInstall42]    Script Date: 07/07/2011 17:05:54 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''[dbo].[tbllogInstall42]'') AND type in (N''U''))
DROP TABLE [dbo].[tbllogInstall42]
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfilePoints_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Updates ProfilePoints

Parameters:
@ProfilePointsID int,
@ProfilePointsType nvarchar(1),
@TypeID int,
@ProfilePeriodID int,
@Points numeric(10,1),
@Active bit,
@DateAssigned datetime

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcProfilePoints_Update]
(
@ProfilePointsID int,
@ProfilePointsType nvarchar(1),
@TypeID int,
@ProfilePeriodID int,
@Points numeric(10,1),
@Active bit,
@DateAssigned datetime,
@OrgID int
--@ApplyToQuiz bit,
--@ApplyToLesson bit
)

as

set @DateAssigned = dbo.udfDaylightSavingTimeToUTC(@DateAssigned, @OrgID)

-- update tblProfilePoints values
update tblProfilePoints
set
ProfilePointsType = @ProfilePointsType,
TypeID = @TypeID,
ProfilePeriodID = @ProfilePeriodID,
Points = @Points,
Active = @Active --,
--DateAssigned = @DateAssigned --,
--ApplyToQuiz = @ApplyToQuiz,
--ApplyToLesson = @ApplyToLesson
where ProfilePointsID = @ProfilePointsID

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_Add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Adds Profile

Parameters:
@ProfileName

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcProfile_Add]
(
@ProfileID int output,
@profilePeriodID int Output,
@OrganisationID int,
@ProfileName nvarchar(255),
@DateStart datetime,
@DateEnd datetime,
@Points numeric(10,1),
@EndOfPeriodAction char(1),
@MonthIncrement int,
@FutureDateStart datetime,
@FutureDateEnd datetime,
@FuturePoints numeric(10,1)
)
as
Begin

set @DateStart = dbo.udfDaylightSavingTimeToUTC(@DateStart, @OrganisationID)
set @DateEnd =dbo.udfDaylightSavingTimeToUTC(@DateEnd, @OrganisationID)
set @FutureDateStart = dbo.udfDaylightSavingTimeToUTC(@FutureDateStart, @OrganisationID)
set @FutureDateEnd = dbo.udfDaylightSavingTimeToUTC(@FutureDateEnd, @OrganisationID)

-- insert values into tblProfile
insert into tblProfile
(OrganisationID,
ProfileName)
values
(@OrganisationID,
@ProfileName)

-- get ProfileID
set @ProfileID = @@Identity

-- insert values into tblProfilePeriod
insert into tblProfilePeriod
(ProfileID,
DateStart,
DateEnd,
Points,
EndOfPeriodAction,
MonthIncrement,
FutureDateStart,
FutureDateEnd,
FuturePoints,
ApplyToQuiz,
ApplyToLesson,
ProfilePeriodActive)
values
(@ProfileID,
@DateStart,
@DateEnd,
@Points,
@EndOfPeriodAction,
@MonthIncrement,
@FutureDateStart,
@FutureDateEnd,
@FuturePoints,
1,
1,
1)

-- get the profileperiodid
set @ProfilePeriodID = @@Identity
End
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_CheckProfileName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Stored procedure to check if a Profile with the same name
as that being created already exists

Parameters:
@OrganisationID int
@ProfileName nvarchar(255)

Called By:
Profile.cs

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

*/
create procedure [prcProfile_CheckProfileName]
(
@OrganisationID int,
@ProfileName nvarchar(255)
)
as

select ProfileName
from tblProfile
where OrganisationID = @OrganisationID
and ProfileName = @ProfileName

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_Get]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Gets a profile

Parameters:
@ProfileID int,

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

CREATE procedure [prcProfile_Get]
(
@ProfileID int,
@profileperiodID int,
@OrgID int
)
as

select
pro.profilename,
dbo.udfUTCtoDaylightSavingTime(propd.datestart, @OrgID) as DateStart,
dbo.udfUTCtoDaylightSavingTime(propd.dateend, @OrgID) as DateEnd,
propd.points,
propd.endofperiodaction,
propd.monthincrement,
dbo.udfUTCtoDaylightSavingTime(propd.futuredatestart, @OrgID) as FutureDateStart,
dbo.udfUTCtoDaylightSavingTime(propd.futuredateend, @OrgID) as FutureDateEnd,
propd.futurepoints,
propd.ApplyToQuiz,
propd.ApplyToLesson
from
tblProfile pro
left join tblProfilePeriod propd on pro.profileid = propd.profileid
where
pro.profileid = @ProfileID
and (@profileperiodID = -1 or propd.profileperiodid = @profileperiodid)
and (profileperiodactive =  1   or ((dbo.udfUTCtoDaylightSavingTime(propd.datestart, @OrgID)) > (dbo.udfUTCtoDaylightSavingTime(GETUTCDATE(), @OrgID))))
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_GetModulePointsByCourse]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets a list of Modules per Course
Parameters:
@courseID Integer ID of the Course to return the Modules for.
Returns:

Called By:
Module.cs
Calls:

Remarks:

Author: Gavin Buddis
Date Created: 16th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcProfile_GetModulePointsByCourse]
(
@courseID int, -- ID of the Course to return the Modules for.
@ProfilePeriodID int,
@OrgID int
)

As

BEGIN

Set Nocount On

If(@courseID Is Null)
Begin
Raiserror(''The @courseID parameter was Null.  You must supply a value.'', 16, 1)
Return
End

create table  #Modules
(
ModuleID int,
CourseID int,
Name nvarchar(100),
Sequence int,
Description nvarchar(1000),
Active bit,
CreatedBy int,
DateCreated datetime,
UpdatedBy int,
DateUpdated datetime
)

insert into #Modules
exec prcModule_GetListByCourse @CourseID, @OrgID

alter table #modules add [ptsid] int, pts numeric(10,1)

update #modules set ptsid = pp.ProfilePointsID, pts = pp.Points
from
#Modules m
left outer join tblProfilePoints pp	on m.ModuleID = pp.typeID
where
(pp.profilepointstype = ''M''
and pp.active = 1
and pp.ProfilePeriodID = @ProfilePeriodID)

select
ptsid as ProfilePointsID,
m.ModuleID,
m.Name as [Module Name],
coalesce(pts,0) as Points
from #modules m
where m.active = 1

drop table #modules
END

/****** Object:  StoredProcedure [dbo].[prcPolicy_GetAdminsInOrgPendingPolicy]    Script Date: 07/07/2011 13:54:32 ******/
SET ANSI_NULLS ON
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_GetPolicyPoints]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Gets policies and points for an organisation

Parameters:
@OrganisationID int,

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcProfile_GetPolicyPoints]
(
@OrganisationID int,
@ProfilePeriodID int
)
as

declare @policytmp table
(
policyid int,
policyname nvarchar(255),
ptsid int,
pts numeric(10,1)
)

insert into @policytmp (policyid, policyname)
select
policyid, policyname
from
tblpolicy
where organisationid =@organisationid
and deleted = 0

update @policytmp set ptsid = pp.profilepointsid, pts =pp.points
from
@policytmp pt
left join tblprofilepoints pp on pt.policyid = pp.typeid and pp.active = 1 and pp.profilepointstype =''P''
where pp.profileperiodid = @profileperiodid


select
ptsid as profilepointsid,
policyid,
policyname,
coalesce(pts,0) as policypoints
from @policytmp


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_GetUnitAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get''s a list of units that have access to a profile

Parameters:
@organisationID Integer
@ProfileID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcProfile_GetUnitAccess]
(
--@ProfileID int,
@ProfilePeriodID int
)
as
set nocount on

select
UnitID
from tblUnitProfilePeriodAccess
where ProfilePeriodID = @ProfilePeriodID
and Granted=1

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_ResetUnitAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Reset''s all Unit''s access to profile to 0

Parameters:
@ProfileID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcProfile_ResetUnitAccess]
(
@ProfileID int
)
as
set nocount on

declare @ProfilePeriodID int
set @ProfilePeriodID =
(select ProfilePeriodID
from tblProfilePeriod
where ProfileID = @ProfileID and profileperiodactive=1)

update tblUnitProfilePeriodAccess
set Granted = 0
where ProfilePeriodID = @ProfilePeriodID

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_ResetUserAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Reset''s all User''s access to profile to 0

Parameters:
@ProfileID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcProfile_ResetUserAccess]
(
@ProfileID int
)
as
set nocount on

declare @ProfilePeriodID int
set @ProfilePeriodID =
(select ProfilePeriodID
from tblProfilePeriod
where ProfileID = @ProfileID and profileperiodactive=1)

update tblUserProfilePeriodAccess
set Granted = 0
where ProfilePeriodID = @ProfilePeriodID

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_SetUnitAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s a list of units that have access to a profile

Parameters:
@organisationID Integer
@ProfileID integer
@UnitID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcProfile_SetUnitAccess]
(
@ProfileID int,
@UnitID int
)
as
set nocount on

declare @ProfilePeriodID int
set @ProfilePeriodID =
(select ProfilePeriodID
from tblProfilePeriod
where ProfileID = @ProfileID and profileperiodactive=1)

update tblUnitProfilePeriodAccess
set Granted = 1
where ProfilePeriodID = @ProfilePeriodID
and UnitID = @UnitID

' 
END
GO


SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[prcProfile_SetUserAccessByUnit]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[prcProfile_SetUserAccessByUnit]
GO

/*Summary:
	Set's a users that have access to a profile

Parameters:
	@organisationID Integer	
	@ProfileID integer
	@UnitID integer
	
Returns:
	Nothing
		
Called By: 
	Profile.cs.

Calls:
	Nothing

Remarks:

Author: Aaron Cripps	
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	

**/

Create procedure prcProfile_SetUserAccessByUnit
(
	@ProfileID int,
	@UnitID int
)
as
set nocount on

declare @ProfilePeriodID int
set @ProfilePeriodID =
(select ProfilePeriodID
from tblProfilePeriod
where ProfileID = @ProfileID and profileperiodactive=1)

update tblUserProfilePeriodAccess
set Granted = 1
where ProfilePeriodID = @ProfilePeriodID
and UserID in 
(select UserID from tblUser where UnitID = @UnitID and active=1)

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_SetUserAccessByUnit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s a users that have access to a profile

Parameters:
@organisationID Integer
@ProfileID integer
@UnitID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcProfile_SetUserAccessByUnit]
(
@ProfileID int,
@UnitID int
)
as
set nocount on

declare @ProfilePeriodID int
set @ProfilePeriodID =
(select ProfilePeriodID
from tblProfilePeriod
where ProfileID = @ProfileID and profileperiodactive=1)

update tblUserProfilePeriodAccess
set Granted = 1
where ProfilePeriodID = @ProfilePeriodID
and UserID in
(select UserID from tblUser where UnitID = @UnitID and active=1)

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_SetUserAccessByUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s a users that have access to a profile

Parameters:
@ProfileID integer
@UserID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcProfile_SetUserAccessByUser]
(
@ProfileID int,
@UserID int,
@Granted bit
)
as
set nocount on

declare @ProfilePeriodID int
set @ProfilePeriodID =
(select ProfilePeriodID
from tblProfilePeriod
where ProfileID = @ProfileID and profileperiodactive=1)

update tblUserProfilePeriodAccess
set Granted = @Granted
where ProfilePeriodID = @ProfilePeriodID
and UserID = @UserID

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Updates a Profile.

Parameters:



Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcProfile_Update]
(
@ProfileID int,
@ProfileName nvarchar(255),
@OrganisationID int,
@DateStart datetime,
@DateEnd datetime,
@Points numeric(10,1),
@EndOfPeriodAction char(1),
@MonthIncrement int,
@FutureDateStart datetime,
@FutureDateEnd datetime,
@FuturePoints numeric(10,1)
)
as

set @DateStart = dbo.udfDaylightSavingTimeToUTC(@DateStart, @OrganisationID)
set @DateEnd = dbo.udfDaylightSavingTimeToUTC(@DateEnd, @OrganisationID)
set @FutureDateStart = dbo.udfDaylightSavingTimeToUTC(@FutureDateStart, @OrganisationID)
set @FutureDateEnd = dbo.udfDaylightSavingTimeToUTC(@FutureDateEnd, @OrganisationID)

-- Update tblProfile
update tblProfile
set ProfileName =  @ProfileName
where ProfileID = @ProfileID
and OrganisationID = @OrganisationID

-- Get profileperiodid for profileid
declare @ProfilePeriodID int
-- Get ProfilePeriodID
set @ProfilePeriodID =
(select ProfilePeriodID
from tblProfilePeriod
where ProfileID = @ProfileID
and profileperiodactive = 1)

if @ProfilePeriodID > 0
begin
-- Update tblProfilePeriod
update tblProfilePeriod
set DateStart = @DateStart,
DateEnd = @DateEnd,
Points = @Points,
EndOfPeriodAction = @EndOfPeriodAction ,
MonthIncrement = @MonthIncrement ,
FutureDateStart = @FutureDateStart,
FutureDateEnd = @FutureDateEnd,
FuturePoints = @FuturePoints
where ProfilePeriodID = @ProfilePeriodID
and ProfileID = @ProfileID
end
else
begin
-- just in case - set any other profileperiods with same profileid
-- as inactive
update tblProfilePeriod
set profileperiodactive = 0
where profileid = @profileid

-- No profileperiod exists (profile with future period deleted)
-- so need to add the profile period
-- insert values into tblProfilePeriod


insert into tblProfilePeriod
(ProfileID,
DateStart,
DateEnd,
Points,
EndOfPeriodAction,
MonthIncrement,
FutureDateStart,
FutureDateEnd,
FuturePoints,
ApplyToQuiz,
ApplyToLesson,
profileperiodactive)
values
(
@ProfileID,
@DateStart,
@DateEnd,
@Points,
@EndOfPeriodAction,
@MonthIncrement,
@FutureDateStart,
@FutureDateEnd,
@FuturePoints,
1,
1,
1
)
end

' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_UserSearch]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Returns results of search for users on Assign Users tab of CPDdetail.aspx

Returns:

Called By:

Calls:

Remarks:
The searching units will include all children and grandchildren
Only return users that logged on user has permission to see


Author: Aaron Cripps
Date Created: July 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

CREATE  Procedure  [prcProfile_UserSearch]
(
@organisationID  Int,
@ProfileID int,
@ProfilePeriodID int,
@parentUnitIDs  Varchar(8000),
@firstName	nVarchar(50),
@lastName	nVarchar(50),
@userName	nVarChar(100),
@Email		nVarChar(100),
@ExternalID nVarChar(50),
@adminUserID		Int,
@Type nvarchar(50)
)
As
Set Nocount On

Declare @intUserTypeID Int

Select @intUserTypeID = UserTypeID
From tblUser
Where userID = @adminUserID


if  @ProfilePeriodID is null
Set @ProfilePeriodID =0


--Check Data
If @parentUnitIDs is null
set @parentUnitIDs =''''

If @firstName is null
Set @firstName = ''''

Set @firstName =rtrim(@firstName)

If @lastName is null
Set @lastName = ''''

Set @lastName =rtrim(@lastName)

If @userName is null
Set @userName = ''''

set @userName = rtrim(@userName)

if @Email is null
set @Email = ''''

set @Email = rtrim(@Email)

if @ExternalID is null
set @ExternalID = ''''

set @ExternalID = rtrim(@ExternalID)

if @Type = ''search''
Begin
Select
us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(dbo.udfUTCtoDaylightSavingTime(us.LastLogin, @organisationID) as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active,
uppa.Granted

From tblUnit un, tblUser us, tblUserProfilePeriodAccess uppa

Where (un.OrganisationID = @organisationID)
and
(
us.Active=1
)
--0. Join Unit and User tables
and (
un.UnitID = us.UnitID
)
-- Join User and UserProfilePeriodAccess tables
and (
us.UserID = uppa.UserID
)
and (
uppa.ProfilePeriodID = @ProfilePeriodID
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
and (
un.UnitID in
(
Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
)
or (@parentUnitIDs='''')
)
--2. User firstname contains the entered text
and (
(firstname like ''%''+ @firstName + ''%'')
or (firstname ='''')
)
--3. User lastname contains the entered text
and (
(lastname like ''%''+ @lastName + ''%'')
or (lastname ='''')
)
-- User username contains the entered text
and (
(username like ''%'' + @userName + ''%'')
or (userName='''')
)
-- User email contains the entered text
and (
(email like ''%'' + @Email + ''%'')
or (email='''') or (email is null)
)
-- User externalid contains the entered text
and (
(externalID like ''%'' + @ExternalID + ''%'')
or (externalID = '''') or (externalid is null)
)
--4. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
Order By Name
End
else if @Type = ''view''
Begin
Select
us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(dbo.udfUTCtoDaylightSavingTime(us.LastLogin, @organisationID) as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active,
uppa.Granted

From tblUnit un, tblUser us, tblUserProfilePeriodAccess uppa

Where (un.OrganisationID = @organisationID)
and
(
us.Active=1
)
--0. Join Unit and User tables
and (
un.UnitID = us.UnitID
)
-- Join User and UserProfilePeriodAccess tables
and (
us.UserID = uppa.UserID
)
and (
uppa.ProfilePeriodID = @ProfilePeriodID
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
--and (
--un.UnitID in
--	(
--		Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
--	)
--	or (@parentUnitIDs='''')
--	)
--2. User firstname contains the entered text
--and (
--	(firstname like ''%''+ @firstName + ''%'')
--	or (firstname ='''')
--    )
--3. User lastname contains the entered text
--and (
--	(lastname like ''%''+ @lastName + ''%'')
--	or (lastname ='''')
--    )
-- User username contains the entered text
--and (
--	(username like ''%'' + @userName + ''%'')
--	or (userName='''')
--	)
-- User email contains the entered text
--and (
--	(email like ''%'' + @Email + ''%'')
--	or (email='''') or (email is  null)
--	)
-- User externalid contains the entered text
--and (
--	(externalID like ''%'' + @ExternalID + ''%'' )
--	or (externalID = '''') or (externalid is null)
--	)
--4. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
and uppa.Granted=1
Order By Name
End

' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_BeforeStartQuiz]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Given a UserID and QuizID starts a Quiz and returns a QuizSessionID
Returns:
QuizSessionID guid

Called By:
ToolbookListener.cs

Calls:

Remarks:
starts a Quiz and returns the details of the Quiz Session so that it can be opened by salt

Author:
Peter Kneale
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date		Description
#1	GB		2/3/04		Added join to Module table in return select
#2 Removed unnecessary transactions

prcQuizSession_BeforeStartQuiz @UserID=11, @QuizID=1

**/

CREATE  Procedure [prcQuizSession_BeforeStartQuiz]
(
@userID int,		-- Users ID
@moduleID int		-- the Quiz ID
)

As

Set NoCount On
Set Xact_Abort On

------------------------------------------
-- Declarations
------------------------------------------
Declare @strQuizSessionID varchar(50)	-- GUID identifying the new session
Declare @intQuizID int			-- Quiz ID the user is starting

------------------------------------------
-- Start New Session
------------------------------------------
Set @strQuizSessionID = newid()

------------------------------------------
-- Start New Session
------------------------------------------
Set @intQuizID =
(
Select Top
1 QuizID
From
tblQuiz
Where
moduleID = @moduleID
And
Active=1
)
If (@intQuizID is NULL or datalength(@intQuizID) = 0)
Begin
Raiserror (''Procedure prcQuizSession_BeforeStartQuiz could not determine the @intQuizID'', 16, 1)
Return
End

------------------------------------------
-- Insert
------------------------------------------
Insert Into
tblQuizSession
(
QuizSessionID,
UserID,
QuizID
)
Values
(
@strQuizSessionID,
@userID,
@intQuizID
)

------------------------------------------
-- select Session Details: SessionID, ModuleName, CourseName and Location
------------------------------------------
Select Top 1
tblModule.[Name] 		As ''ModuleName'',
tblCourse.[Name] 		As ''CourseName'',
@strQuizSessionID 		As ''SessionID'',
tblQuiz.ToolbookLocation 	As ''Location''
,Scorm1_2
From
tblModule
Inner Join tblQuiz
on tblQuiz.ModuleID 	= tblModule.ModuleID
Inner Join tblCourse
on tblCourse.CourseID	 = tblModule.CourseID

Where
tblModule.ModuleID = @moduleID
And
tblQuiz.Active = 1

Return
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_CreateQuizAnswerAudit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
Given a QuizSessionID, ToolbookPageID and ToolbookAnswerID creates an
entry in the tblQuizAnswerAudit Table.

Returns:
Nothing

Called By:
ToolbookListener.cs

Calls:
dbo.udfGetQuizIDBySessionID
dbo.udfGetQuizQuestionIDByToolbookPageID
dbo.udfGetQuizAnswerIDByToolbookAnswerID

Remarks:

Author:
Peter Kneale
Date Created: 10 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Gavin Buddis	1 Mar 2004		Retreived the QuizAnswerID to insert rather than the ToolbookAnswerID

**/

CREATE    Procedure [prcQuizSession_CreateQuizAnswerAudit]
(
@strQuizSessionID 	Varchar(50),		-- Users Session ID
@strToolbookPageID 	Varchar(50),		-- the Toolbook ID of the quiz
@intToolbookAnswerID 	Integer			-- the Quiz Answer ID
)

As

Set NoCount On
Set Xact_Abort On
Begin Transaction

------------------------------------------
-- Declerations
-----------------------------------------
Declare @intQuizID integer
Declare @intQuizQuestionID integer
Declare @intQuizAnswerID integer

------------------------------------------
-- Get Quiz ID by SessionID
-------------------------------------------
Set @intQuizID = dbo.udfGetQuizIDBySessionID(@strQuizSessionID)
If (@intQuizID is NULL or datalength(@intQuizID) = 0)
Begin
Rollback
INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''Procedure prcQuizSession_CreateQuizAudit '',''No data found in tblQuizSession for QuizSessionID'',''@strQuizSessionID = ''+CAST(@strQuizSessionID AS varchar(40)),''No data found in tblQuizSession for QuizSessionID'',''No data found in tblQuizSession for QuizSessionID'',''prcQuizSession_CreateQuizAudit'',1,1,null,getutcdate(),getutcdate()) 
Raiserror (''Procedure prcQuizSession_CreateQuizAudit could not determine the @intQuizID using udfGetQuizIDBySessionID'', 16, 1)
Return
End

------------------------------------------
-- Get Quiz Question ID by Toolbook PageID
-------------------------------------------
Set @intQuizQuestionID 	=  dbo.udfGetQuizQuestionIDByToolbookPageID(@strToolbookPageID, @intQuizID)
If (@intQuizQuestionID is NULL or datalength(@intQuizQuestionID) = 0)
Begin
Rollback
INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''Procedure prcQuizSession_CreateQuizAudit '',''udfGetQuizQuestionIDByToolbookPageID returned null'',''@strToolbookPageID = ''+CAST(@strToolbookPageID AS varchar(40))+'', @intQuizID = ''+CAST(@intQuizID AS varchar(40)),''udfGetQuizQuestionIDByToolbookPageID returned null'',''udfGetQuizQuestionIDByToolbookPageID returned null'',''prcQuizSession_CreateQuizAudit'',1,1,null,getutcdate(),getutcdate()) 
Raiserror (''Procedure prcQuizSession_CreateQuizAudit could not determine the @intQuizQuestionID using udfGetQuizQuestionIDByToolbookPageID'', 16, 1)
Return
End

------------------------------------------
-- Get Quiz Answer ID by Toolbook AnswerID
-------------------------------------------
DECLARE @intValidAnswer integer
Set @intValidAnswer =
(
Select count(*)
From
tblQuizAnswer
Where
ToolbookAnswerID = @intToolbookAnswerID
And
QuizQuestionID = @intQuizQuestionID
)
if (@intValidAnswer = 0)
BEGIN
   Rollback
   INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''Procedure prcQuizSession_CreateQuizAudit '',''ToolBook Answer is not in the list of possible answers for this Quiz'',''@toolbookAnswerID = ''+CAST(@intToolbookAnswerID AS varchar(40))+'', @quizQuestionID = ''+CAST(@intQuizQuestionID AS varchar(40)),''ToolBook Answer is not in the list of possible answers for this Quiz'',''ToolBook Answer is not in the list of possible answers for this Quiz'',''prcQuizSession_CreateQuizAudit'',1,1,null,getutcdate(),getutcdate())
   DECLARE @ErrStr varchar(2000)
   Set @ErrStr = ''ToolBook Answer is not in the list of possible answers for this Quiz, @toolbookAnswerID = ''+CAST(@intToolbookAnswerID AS varchar(40))+'', @quizQuestionID = ''+CAST(@intQuizQuestionID AS varchar(40))
   Raiserror (@ErrStr, 16, 1)
   Return 
END
ELSE
BEGIN
	Set @intQuizAnswerID = dbo.udfGetQuizAnswerIDByToolbookAnswerID(@intToolbookAnswerID, @intQuizQuestionID)
	If (@intQuizAnswerID is NULL or datalength(@intQuizAnswerID) = 0)
	Begin
	Rollback
	INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''Procedure prcQuizSession_CreateQuizAudit '',''dbo.udfGetQuizAnswerIDByToolbookAnswerID returned null'',''@intToolbookAnswerID = ''+CAST(@intToolbookAnswerID AS varchar(40))+'', @intQuizQuestionID = ''+CAST(@intQuizQuestionID AS varchar(40)),''dbo.udfGetQuizAnswerIDByToolbookAnswerID returned null'',''dbo.udfGetQuizAnswerIDByToolbookAnswerID returned null'',''prcQuizSession_CreateQuizAudit'',1,1,null,getutcdate(),getutcdate())
	Raiserror (''Procedure prcQuizSession_CreateQuizAudit could not determine the @intAnswerID using udfGetQuizAnswerIDByToolbookAnswerID'', 16, 1)
	Return
	End
END
------------------------------------------
-- Insert
------------------------------------------
Insert Into
tblQuizAnswerAudit
(
QuizSessionID,
QuizQuestionID,
QuizAnswerID
)
Values
(
@strQuizSessionID,
@intQuizQuestionID,
@intQuizAnswerID
)
Commit Tran

' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_CreateQuizAudit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Given a QuizSessionID and ToolbookPageID creates an entry in the
tblQuizAudit Table.

Returns:
Nothing

Called By:
ToolbookListener.cs

Calls:
dbo.udfGetQuizIDBySessionID
dbo.udfGetQuizQuestionIDByToolbookPageID

Remarks:
The duration of the quiz is set to be 0 because toolbook does not
currently return this information, it may be added at a later date.

Author:
Peter Kneale
Date Created: 10 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

CREATE    Procedure [prcQuizSession_CreateQuizAudit]
(
@strQuizSessionID varchar(50),		-- Users Session ID
@strToolbookPageID varchar(50)	-- the Toolbook Page ID of the Quiz
)

As

Set NoCount On
Set Xact_Abort On
Begin Tran

------------------------------------------
-- Declerations
------------------------------------------
Declare @intQuizQuestionID  Integer		-- QuizQuestionID from Salt database.
Declare @intQuizID 	       Integer		-- QuizID from Salt database.

------------------------------------------
-- Get Quiz ID by SessionID
------------------------------------------
Set @intQuizID =  dbo.udfGetQuizIDBySessionID (@strQuizSessionID)
If (@intQuizID Is NULL or datalength(@intQuizID) = 0)
Begin
ROLLBACK
Raiserror (''Procedure prcQuizSession_CreateQuizAudit could not determine the @intQuizID using udfGetQuizIDBySessionID'', 16, 1)
Return
End

------------------------------------------
-- Get Question ID by SessionID
------------------------------------------
Set @intQuizQuestionID 	= dbo.udfGetQuizQuestionIDByToolbookPageID (@strToolbookPageID,@intQuizID)
If (@intQuizQuestionID Is NULL or datalength(@intQuizQuestionID) = 0)
Begin
ROLLBACK
Raiserror (''Procedure prcQuizSession_CreateQuizAudit could not determine the @intQuizQuestionID using udfGetQuizQuestionIDByToolbookPageID'', 16, 1)
Return
End

------------------------------------------
-- Insert
------------------------------------------
Insert Into
tblQuizQuestionAudit
(
QuizSessionID,
QuizQuestionID,
Duration,
DateAccessed
)
Values
(
@strQuizSessionID,
@intQuizQuestionID,
0,			-- Duration is recorded as 0 becuase the duration per question is not returned from Toolbook.
getutcDate()
)
Commit Tran
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_EndQuiz]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
this proc records that a Quiz has ended by updating tblQuizSession
is Sets
-- DateTimeCompleted from getutcDate();
-- Duration from Toolbook
-- QuizScore from Toolbook
-- QuizPassMark passmark (Using prcQuiz_GetPassMark).
it also:
-- Checks that the Quiz has started -- if it has NOT -> return false
-- Checks that the Quiz has not already ended -- if it has -> return false



Returns:
boolean (bit) OK true = 1, false = 0

Called By:
ToolbookListener.cs via Businessservices.Toolbook.EndQuizSession

Calls:
udfQuiz_GetPassMark
udfGetUserIDBySessionID
udfGetQuizIDBySessionID

Remarks:

Author:
Stephen Kennedy-Clark
Date Created: 11 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


-----------
prcQuizSession_EndQuiz @quizSessionID =
select * from tblQuizSession

**/

CREATE   Procedure  [prcQuizSession_EndQuiz]
(
@quizSessionID	varchar(50) 	-- unique GUID that identifies this toolbook quiz session
, @duration	int		-- The duration in seconds of the quiz as messured by toolbook
, @score	int		-- the score as mesured by toolbook
)

As
--Begin Transaction
Set NoCount On
Set Xact_Abort On

------------------------------------------
-- Declerations
------------------------------------------
Declare   @intRetVal 	bit 		-- return value indicating sucess or failure
, @intUserID 	int		-- user id
, @intQuizID 	int		-- Quiz id
, @intPassMark 	int		-- Pass Mark
, @intUnitID 	int		-- Unit ID
, @intModuleID 	int		-- Module ID

------------------------------------------
-- initations
------------------------------------------
Set @intUserID	   = dbo.udfGetUserIDBySessionID(@quizSessionID)
Set @intQuizID	   = dbo.udfGetQuizIDBySessionID(@quizSessionID)
Select @intUnitID  = (Select Top 1 UnitID From tblUser Where UserID = @intUserID)
Select @intModuleID= (Select Top 1 ModuleID From tblQuiz Where QuizID = @intQuizID)
Set @intPassMark   = dbo.udfQuiz_GetPassMark(@intUnitID,@intModuleID)


------------------------------------------
-- Checks that the Quiz has started - if it has not -> return false
-- and
-- Checks that the Quiz has not already ended - if it has -> return false
-- If all is OK then end the Quiz by recording end time, duration and score
------------------------------------------
If Exists
(
Select
QuizSessionID
From
tblQuizSession
Where
QuizSessionID=@quizSessionID
--< Check that the Quiz has started >--
And DateTimeStarted Is Not Null
--< Check that the @quizSessionID has not already ended >--
And DateTimeCompleted Is Null
)


Begin --< it is ok to End, record End and return true >--
Update
[tblQuizSession]
Set
[DateTimeCompleted]	= getutcdate()
, [Duration]		= @duration
, [QuizScore]		= @score
, [QuizPassMark]	= @intPassMark

Where
[QuizSessionID]  	= @quizSessionID
set @intRetVal = 1 --< return 1 indicates sucess >--


End
Else
Begin  -- it is NOT ok to End, return false
set @intRetVal = 0
End


------------------------------------------
-- return
------------------------------------------

Select @intRetVal as ''OKToEnd''

--Commit Tran
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_GetEndQuizInfo]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
read all information needed to end a quiz

Returns:
data table

Called By:
ToolBook.cs: GetEndQuizInfo

Remarks:

QuizStatusID Status
------------ --------------------------------------------------
0            Unassigned
1            Not Started
2            Passed
3            Failed
4            Expired (Time Elapsed)
5            Expired (New Content)

Author: Li Zhang
Date Created: 13-10-2006
Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		1/5/2007		Added LessonCompletionDate
**/

CREATE PROCEDURE [prcQuizSession_GetEndQuizInfo]
(
@quizSessionID varchar(50) -- unique that identifies this toolbook quiz session
, @duration int -- time used to complete the quiz
, @score int -- user quiz score
)
AS
SET nocount on
BEGIN
DECLARE @intUserID	int	-- user id
,		@intQuizID	int -- quiz id
,		@intPassMark	int	-- quiz pass mark
,		@intUnitID	int	-- user''s unit id
,		@intModuleID	int -- quiz module id
,		@intCourseID	int -- module course id
,		@intOldCourseStatus	int -- course status before update
,		@intNewQuizStatus int -- the quiz status
, 		@intNewCourseStatus	int	-- course status after update
,		@intQuizFrequency int
,		@dtmQuizCompletionDate datetime
DECLARE	@tblUserEndQuizInfo table	-- return table with all details needed to end a quiz
(
UserID	int
, QuizID int
, PassMark int
, UnitID int
, ModuleID int
, QuizFrequency int
, QuizCompletionDate datetime
, NewQuizStatus int
, OldCourseStatus int
, NewCourseStatus int
, CourseID int

)

--< read required data >--

SET @intUserID = dbo.udfGetUserIDBySessionID(@quizSessionID)
SET @intQuizID = dbo.udfGetQuizIDBySessionID(@quizSessionID)
SELECT @intUnitID = (SELECT TOP 1 UnitID FROM tblUser WHERE UserID = @intUserID)
SELECT @intModuleID = (SELECT TOP 1 ModuleID FROM tblQuiz WHERE QuizID = @intQuizID)
SET @intPassMark = dbo.udfQuiz_GetPassMark(@intUnitID, @intModuleID)
IF @score < @intPassMark
BEGIN
--< Quiz status: failed >--
SET @intNewQuizStatus = 3
END
IF @score > @intPassMark OR @score = @intPassMark
BEGIN
--< Quiz status: passed >--
SET @intNewQuizStatus = 2
END

SELECT @intCourseID = (SELECT TOP 1 CourseID FROM tblModule WHERE ModuleID = @intModuleID)
EXEC @intOldCourseStatus = prcUserCourseStatus_GetStatus @intCourseID, @intUserID
EXEC @intNewCourseStatus = prcUserCourseStatus_Calc @intCourseID, @intUserID,  @intNewQuizStatus,@intModuleID

--< get pre-defined quiz frequency from tblUnitRule >--
--< if the value is null then use the default quiz frequency in tblOrganisation >--

-- mikev(1): added QuizCompletionDate
SET @intQuizFrequency = (
SELECT  TOP 1   ISNULL(ur.QuizFrequency, o.DefaultQuizFrequency)
FROM   	tblUnitRule AS ur INNER JOIN tblUser AS u
ON ur.UnitID = u.UnitID
INNER JOIN tblOrganisation AS o ON u.OrganisationID = o.OrganisationID
WHERE	u.UserID = @intUserID
)

SET @dtmQuizCompletionDate = (
SELECT  TOP 1	ISNULL(ur.QuizCompletionDate, o.DefaultQuizCompletionDate)
FROM   	tblUnitRule AS ur INNER JOIN tblUser AS u
ON ur.UnitID = u.UnitID
INNER JOIN tblOrganisation AS o ON u.OrganisationID = o.OrganisationID
WHERE	u.UserID = @intUserID
)

INSERT INTO @tblUserEndQuizInfo ( UserID, QuizID, PassMark, UnitID, ModuleID, QuizFrequency, QuizCompletionDate, NewQuizStatus, OldCourseStatus, NewCourseStatus, CourseID)
VALUES (@intUserID, @intQuizID, @intPassMark, @intUnitID, @intModuleID, @intQuizFrequency,@dtmQuizCompletionDate,@intNewQuizStatus, @intOldCourseStatus, @intNewCourseStatus, @intCourseID)

SELECT * FROM @tblUserEndQuizInfo
END

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_GetEndQuizInfo2]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N' 

/*Summary:
read all information needed to end a quiz

Returns:
data table

Called By:
ToolBook.cs: GetEndQuizInfo

Remarks:

QuizStatusID Status
------------ --------------------------------------------------
0            Unassigned
1            Not Started
2            Passed
3            Failed
4            Expired (Time Elapsed)
5            Expired (New Content)

Author: John H
Date Created: 13-10-2011
Modification History
-----------------------------------------------------------
v#	Author		Date			Description
**/

CREATE PROCEDURE [prcQuizSession_GetEndQuizInfo2]
(
@intUserID int -- student must only sit one quiz at a time for a module
,@intModuleID int
, @duration int -- time used to complete the quiz
, @score int -- user quiz score
)
AS
SET nocount on
BEGIN
DECLARE 
		@intQuizID	int -- quiz id
,		@intPassMark	int	-- quiz pass mark
,		@intUnitID	int	-- user''s unit id
,		@intCourseID	int -- module course id
,		@intOldCourseStatus	int -- course status before update
,		@intNewQuizStatus int -- the quiz status
, 		@intNewCourseStatus	int	-- course status after update
,		@intQuizFrequency int
,		@dtmQuizCompletionDate datetime
DECLARE	@tblUserEndQuizInfo table	-- return table with all details needed to end a quiz
(
UserID	int
, QuizID int
, PassMark int
, UnitID int
, ModuleID int
, QuizFrequency int
, QuizCompletionDate datetime
, NewQuizStatus int
, OldCourseStatus int
, NewCourseStatus int
, CourseID int
, SessionID varchar(50)
, sendcert bit

)

--< read required data >--
DECLARE @quizSessionID varchar(50)
SELECT @quizSessionID =  (SELECT top 1 quizSessionID
  FROM tblQuiz Q
inner join tblQuizSession QS on  Q.QuizID = QS.QuizID 
WHERE Q.Active = 1 AND QS.DateTimeStarted IS NOT NULL
AND QS.DateTimeCompleted IS NULL
AND Q.ModuleID = @intModuleID
AND QS.UserID = @intUserID
order by DateTimeStarted desc)


select  @intQuizID = quizid from 
tblQuiz where ModuleID =@intModuleID





if @quizSessionID is null   begin
	set @quizSessionID = newid()
	
	Insert Into
	tblQuizSession
	(
	QuizSessionID,
	UserID,
	QuizID,
	DateTimeStarted
	)
	Values
	(
	@quizSessionID,
	@intUserID,
	@intQuizID,
	GETUTCDATE()
)

	
end 

							

SELECT @intUnitID = (SELECT TOP 1 UnitID FROM tblUser WHERE UserID = @intUserID)
--SELECT @intModuleID = (SELECT TOP 1 ModuleID FROM tblQuiz WHERE QuizID = @intQuizID)
SET @intPassMark = dbo.udfQuiz_GetPassMark(@intUnitID, @intModuleID)
IF @score < @intPassMark
BEGIN
--< Quiz status: failed >--
SET @intNewQuizStatus = 3
END
IF @score > @intPassMark OR @score = @intPassMark
BEGIN
--< Quiz status: passed >--
SET @intNewQuizStatus = 2
END

SELECT @intCourseID = (SELECT TOP 1 CourseID FROM tblModule WHERE ModuleID = @intModuleID)
EXEC @intOldCourseStatus = prcUserCourseStatus_GetStatus @intCourseID, @intUserID
EXEC @intNewCourseStatus = prcUserCourseStatus_Calc @intCourseID, @intUserID,  @intNewQuizStatus,@intModuleID

--< get pre-defined quiz frequency from tblUnitRule >--
--< if the value is null then use the default quiz frequency in tblOrganisation >--

-- mikev(1): added QuizCompletionDate
SET @intQuizFrequency = (
SELECT  TOP 1   ISNULL(ur.QuizFrequency, o.DefaultQuizFrequency)
FROM   	tblUnitRule AS ur INNER JOIN tblUser AS u
ON ur.UnitID = u.UnitID
INNER JOIN tblOrganisation AS o ON u.OrganisationID = o.OrganisationID
WHERE	u.UserID = @intUserID
)

SET @dtmQuizCompletionDate = (
SELECT  TOP 1	ISNULL(ur.QuizCompletionDate, o.DefaultQuizCompletionDate)
FROM   	tblUnitRule AS ur INNER JOIN tblUser AS u
ON ur.UnitID = u.UnitID
INNER JOIN tblOrganisation AS o ON u.OrganisationID = o.OrganisationID
WHERE	u.UserID = @intUserID
)

INSERT INTO @tblUserEndQuizInfo ( UserID, QuizID, PassMark, UnitID, ModuleID, QuizFrequency, QuizCompletionDate, NewQuizStatus, OldCourseStatus, NewCourseStatus, CourseID, SessionID)
VALUES (@intUserID, @intQuizID, @intPassMark, @intUnitID, @intModuleID, @intQuizFrequency,@dtmQuizCompletionDate,@intNewQuizStatus, @intOldCourseStatus, @intNewCourseStatus, @intCourseID,@quizSessionID)

SELECT * FROM @tblUserEndQuizInfo
END'
end
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_GetQuizIDBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:

Parameters: @strSessionID varchar(50)

Returns: integer

Called By: ToolbookListener.aspx

Calls: udfGetQuizIDBySessionID

Remarks: Raises an error any input parameter is null

Author: Peter Kneale
Date Created: 4th of February 2004

Modification History
-----------------------------------------------------------
v#	Author	Date		Description
#1	GB	9/2/04		Coding standards
#2	GB	3/3/04		Changed to retrieve QuizID by SessionID rather than ToolbookID
*/

CREATE  Procedure [prcQuizSession_GetQuizIDBySessionID]
(
@strSessionID varchar(50)
)
As
-- Declarations
Declare @intRetVal Int

-- Validation
If @strSessionID Is Null
Begin
Raiserror(''The Parameter @strSessionID was null.  @strSessionID does not accept Null values.'', 16, 1)
Return
End

-- Logic
Set @intRetVal = dbo.udfGetQuizIDBySessionID(@strSessionID)
If @intRetVal Is Null
Begin
Raiserror(''The QuizID could not be determined using udfGetQuizIDBySessionID .'', 16, 1)
Return
End

Select @intRetVal As ''QuizID''
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_GetQuizIDByToolbookID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:

Parameters: @ToolbookID varchar(50)

Returns: integer

Called By: ToolbookListener.aspx

Calls: None

Remarks: Raises an error any input parameter is null

Author: Peter Kneale
Date Created: 4th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	GB		9/2/04			Coding standards
*/

CREATE Procedure [prcQuizSession_GetQuizIDByToolbookID]
(
@strToolbookID varchar(50)
)

As

If @strToolbookID Is Null
Begin
Raiserror(''The Parameter @strToolbookID was null.  @strToolbookID does not accept Null values.'', 16, 1)
Return
End

Select
Top 1 *
From
[tblQuiz]
Where
ToolbookID = @strToolbookID
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_StartQuiz]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
-- Check that the quiz has not already been started
-- if it has - return false
-- if it has not, start it and return true
Returns:
boolean (bit) OKToStart true = 1, false = 0

Called By:
ToolbookListener.cs
Calls:

Remarks:

Author:
Peter Kneale
Date Created: 10 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


-----------
prcQuizSession_StartQuiz @QuizSessionID = ''4986F67F-FF29-4979-9A97-D7846839E0DB''


**/

CREATE Procedure  [prcQuizSession_StartQuiz]
(
@QuizSessionID varchar(50)
)

As

Set NoCount On
Set Xact_Abort On
Begin Tran


------------------------------------------
-- Declerations
------------------------------------------
Declare @RetVal bit 		-- Return value holding bit indicating success condition as described above

------------------------------------------
-- Check that the quiz has not already been started
-- if it has - return false
-- if it has not, start it and return true
-- Start the quiz ( insert a start date )
------------------------------------------
If Exists
(
Select
QuizSessionID
From
tblQuizSession
Where
QuizSessionID = @QuizSessionID
And
DateTimeStarted is Null
)

Begin
-- it is ok to start, record start and return true
--< do update >--
Update
tblQuizSession
Set
DateTimeStarted =	GETUTCDATE()
Where
QuizSessionID = @QuizSessionID
--< set return value >--
Set @RetVal = 1
End

Else

Begin  -- it is NOT ok to start, return false
--< set return value >--
Set @RetVal = 0
End

Commit Tran

------------------------------------------
-- select SessionID
------------------------------------------

Select @RetVal as ''OKToStart''
Return
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_UpdateEndQuizInfo]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Update record in tblQuizSession
Insert record into tblUserQuizStatus
Insert record into tblUserCourseStatus

Returns:
data table

Called By:
ToolBook.cs: UpdateEndQuizInfo

Author: Li Zhang
Date Created: 13-10-2006
Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		1/5/2007		Added QuizCompletionDate
**/

CREATE PROCEDURE [dbo].[prcQuizSession_UpdateEndQuizInfo]
(
@QuizSessionID	varchar(50) -- unique GUID that identifies this toolbook quiz session
, @Duration	int -- the duration in seconds of the quiz as mesured by toolbook
, @Score 	int -- the score as mesured by toolbook
, @UserID	int	-- user id
, @QuizID	int -- quiz id
, @PassMark	int	-- quiz pass mark
, @UnitID	int	-- user''s unit id
, @ModuleID	int -- quiz module id
, @CourseID	int -- module course id
, @OldCourseStatus	int -- course status before update
, @NewQuizStatus int -- the quiz status
, @NewCourseStatus	int	-- course status after update
, @QuizFrequency	int -- quiz frequency
, @QuizCompletionDate	datetime -- quiz completiondate
)
AS
SET nocount on
SET xact_abort on
BEGIN TRANSACTION

declare @createrec as bit
set @createrec = 0


declare @OrgID int
select @OrgID = organisationID from tblUnit where tblUnit.UnitID=@UnitID

set @QuizCompletionDate = dbo.udfDaylightSavingTimeToUTC(@QuizCompletionDate, @OrgID)

DECLARE @dateCreated datetime
SET @dateCreated = GETUTCDATE()

IF EXISTS
(
SELECT QuizSessionID
FROM tblQuizSession
WHERE QuizSessionID = @QuizSessionID
AND	DateTimeStarted IS NOT NULL
AND DateTimeCompleted IS NULL
)
BEGIN
	-- < update tblQuizSession >--
	UPDATE tblQuizSession
	SET DateTimeCompleted = @dateCreated
	, Duration = DATEDIFF(second,DateTimeStarted,@dateCreated)
	, QuizScore = @Score
	, QuizPassMark = @PassMark
	WHERE
	QuizSessionID = @QuizSessionID

	--< insert into tblUserQuizStatus >--
	INSERT INTO
	tblUserQuizStatus
	(
	UserID,
	ModuleID,
	QuizStatusID,
	QuizFrequency,
	QuizPassMark,
	QuizCompletionDate,
	QuizScore,
	QuizSessionID,
	DateCreated
	)
	VALUES
	(
	@UserID,
	@ModuleID,
	@NewQuizStatus,
	@QuizFrequency,
	@PassMark,
	@QuizCompletionDate,
	@Score,
	@QuizSessionID,
	@dateCreated
	)

	--< insert into tblUserCourseStatus >--

	-- if the user redo the quiz when they are still having a completed user course status
	-- check if the last 2 course status is a completed status
	-- if it is then we update the date of the last course status id to avoid new rows being inserted
	-- if not we just add a new row
	IF (@OldCourseStatus=2 and @OldCourseStatus = @NewCourseStatus)
	BEGIN
		
		declare @csdate datetime
		
		
		select top 1 @csdate = DateCreated 
		from tblUserCourseStatus 
		where UserID = @UserID 	and CourseID =@CourseID
		order by DateCreated desc

		declare @modss  table (moduleid int, dt datetime )

		insert into   @modss
		select m.moduleid, max(uqs.DateCreated) as dt
		 from tblUserQuizStatus uqs
		 -- join tblUserModuleAccess uma on uma.UserID = uqs.UserID and uma.ModuleID = uqs.ModuleID and uma.Granted = 1
		 join vwUserModuleAccess uma on uma.UserID = uqs.UserID and uma.ModuleID = uqs.ModuleID
		join tblModule m on m.ModuleID = uqs.ModuleID
		where m.CourseID =@CourseID and uqs.UserID = @UserID and QuizStatusID =2
		group by m.ModuleID

		select @createrec = case when MIN(dt)>@csdate then 1 else 0 end
		from @modss

		if(@createrec =1)
		begin
			EXEC prcUserCourseStatus_Insert @UserID, @ModuleID, @NewCourseStatus
		end

	END
	ELSE IF (@OldCourseStatus = -1) or (@OldCourseStatus <> @NewCourseStatus)	
	BEGIN
	
		if(@NewCourseStatus=2) begin
			set @createrec =1
		end
		
		EXEC prcUserCourseStatus_Insert @UserID, @ModuleID, @NewCourseStatus
	END
	ELSE BEGIN
		IF NOT EXISTS (SELECT UserID FROM vwUserModuleAccess where UserID = @UserID AND CourseID = @CourseID) AND
		EXISTS (SELECT UserCourseStatusID FROM tblUserCourseStatus WHERE UserID = @UserID AND CourseID = @CourseID AND CourseStatusID <> 0)
		BEGIN
			EXEC prcUserCourseStatus_Insert @UserID, @ModuleID,  0
		END
	END

END


COMMIT TRANSACTION

select @createrec as sendcert 
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetListByModule]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Selects a list of quizzes for a module. Caller can specify whether to only return active quizzes.

Parameters:
@moduleID
@activeOnly

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Module.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeeded
5. ParameterException
10. BusinessServiceException (General)


Author: Gavin Buddis
Date Created: 16 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		4/5/2007		Added WorkSiteID to select

**/
CREATE  Procedure [prcQuiz_GetListByModule]
(
@moduleID Integer = Null,
@activeOnly Bit = 0,
@OrgID int
)

As

Set Nocount On

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @moduleID
If (@moduleID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @moduleID in stored procedure prcQuiz_GetListByModule''
Goto Finalise
End

If (@activeOnly = 1)
Begin
Select
QuizID,
ModuleID,
ToolbookID,
ToolbookLocation,
dbo.udfUTCtoDaylightSavingTime(DatePublished, @OrgID),
LoadedBy,
dbo.udfUTCtoDaylightSavingTime(DateLoaded, @OrgID),
Active,
WorkSiteID
From
tblQuiz
Where
ModuleID = @moduleID And
Active = 1
End
Else
Begin
Select
QuizID,
ModuleID,
ToolbookID,
ToolbookLocation,
dbo.udfUTCtoDaylightSavingTime(DatePublished, @OrgID),
LoadedBy,
dbo.udfUTCtoDaylightSavingTime(DateLoaded, @OrgID),
Active,
WorkSiteID
From
tblQuiz
Where
ModuleID = @moduleID

End

Finalise:
If(@intErrorNumber > 0)
Begin
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End



' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetModuleIDBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Parameters: @ToolbookID varchar(50)
Returns: integer

Called By: ToolbookListener.aspx
Calls: udfGetQuizIDBySessionID, udfGetModuleIDByQuizID

Remarks: Raises an error if the parameter is null

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date		Description
#1	GB		9/2/04		Coding standards
#2	GB		3/3/04		Changed to retrieve QuizID by SessionID rather than ToolbookID
*/

CREATE  Procedure [prcQuiz_GetModuleIDBySessionID]
(
@sessionID varchar(50) = null -- Session ID
)

As

Declare @intQuizID int 		-- Quiz ID
Declare @intRetVal Int		-- Module ID that is to be returned

-- Retrieve the QuizID from the supplied SessionID
Set @intQuizID = dbo.udfGetQuizIDBySessionID(@sessionID)

-- Retrieve the ModuleID from the retrieved QuizID
Set @intRetVal = dbo.udfGetModuleIDByQuizID(@intQuizID)

-- Return the ModuleID
Select @intRetVal As ''ModuleID''
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetModuleIDByToolbookID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Parameters: @ToolbookID varchar(50)
Returns: integer

Called By: ToolbookListener.aspx
Calls: None

Remarks: Raises an error if the parameter is null

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	GB		9/2/04			Coding standards
*/

CREATE Procedure [prcQuiz_GetModuleIDByToolbookID]
(
@ToolbookID varchar(50) = null -- Toolbook ID
)

As

Select
ModuleID
From
tblQuiz
Where
ToolbookID = @ToolBookID
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetPassMark]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Returns the pass mark for the given module for the given unit
Parameters: @UnitID integer, @ModuleID integer
Returns: integer

Called By: ToolbookListener.aspx
Calls: udfQuiz_GetPassMark

Remarks: Raises an error if the parameter is null

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	GB		9/2/04			Coding standards
#2	SKC		11/2/04		Moved functionality into a udf so that it is accessable to other stored proc''s

-- prcQuiz_GetPassMark 1,1
*/

CREATE  Procedure [prcQuiz_GetPassMark]
(
@UnitID int = null,
@ModuleID int = null
)

As

If @UnitID Is Null
Begin
Raiserror(''The Parameter @UnitID was null.  @UnitID does not accept Null values.'', 16, 1)
Return
End

If @ModuleID Is Null
Begin
Raiserror(''The Parameter @ModuleID was null.  @ModuleID does not accept Null values.'', 16, 1)
Return
End

Select
dbo.udfQuiz_GetPassMark(@UnitID, @ModuleID) As ''PassMark''
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetScore]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Returns the score for a given quiz session
Parameters: quiz session id
Returns: integer

Called By: Quiz.aspx
Calls:nothing

Remarks: Raises an error if the parameter is null

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

-- prcQuiz_GetPassMark 1,1
*/

CREATE  Procedure [prcQuiz_GetScore]
(
@QuizSessionID varchar(50)
)

As

If (@QuizSessionID is NULL or datalength(@QuizSessionID) = 0)
Begin
Raiserror (''Procedure prcQuiz_GetScore requires a quiz session id'', 16, 1)
Return
End

select
cast(round(sum(cast(tblQuizAnswer.correct as int)*100.00)/count(tblQuizAnswer.QuizAnswerID),0) as int)
from
tblQuizQuestionAudit
inner join
tblQuizAnswerAudit
on
tblQuizAnswerAudit.QuizQuestionID = tblQuizQuestionAudit.QuizQuestionID
and
tblQuizQuestionAudit.QuizSessionID = @QuizSessionID
and
tblQuizAnswerAudit.QuizSessionID = @QuizSessionID
inner join
tblQuizAnswer
on
tblQuizAnswerAudit.QuizAnswerID = tblQuizAnswer.QuizAnswerID
group by tblQuizAnswerAudit.QuizSessionID

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReassignReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 31/10/2011
-- Description:	Reassigns the owner of the periodic report
-- =============================================
CREATE PROCEDURE [prcReassignReport] 
(
	-- Add the parameters for the stored procedure here
	@ScheduleId int,
	@UserId int
)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    UPDATE tblReportSchedule SET UserID=@UserId
		WHERE ScheduleID=@ScheduleId
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_ActiveInactive]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE Procedure [prcReport_ActiveInactive]
(
@FromDate	datetime,
@ToDate		datetime,
@CourseIDs	varchar(max),
@OrganisationID int,
@IncludeInactive int
)
AS

/******************************************************************************
**		File:
**		Name: dbo.prcReport_ActiveInactive
**		Desc:
**
**		This template can be customized:
**
**		Return values:
**
**		Called by:   Active INactive Users Report
**
**		Parameters:
**		Input							Output
**     ----------							-----------
**		Comma separated course id''s
**
**		Auth: Serguei Chkaroupine
**		Date: 5/01/2006
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		23/03/07	Yoppy Suwanto			Added a new colum Unit Pathway and sorted by it
**		21/07/09	Mark Donald				Order by LastName, FirstName
**		24/03/11	John Hedlefs			Timezone conversions
*******************************************************************************/

BEGIN

SELECT distinct
tblUnitHierarchy.HierarchyName as UnitPathway,
uma.[UserID],
uma.[LastName],
uma.[FirstName],
CASE
WHEN tblUser.Active <> 1 THEN ''(i)''
ELSE ''''
END as Flag
,tblUser.[ExternalID]
,tblUser.[Email]
,tblUser.[UserName]
,[CourseName]
-- used to count inactive users (RS does not counts nulls)
,CASE
WHEN Active = 0 THEN 1
ELSE NULL
END as Active,
dbo.udfUTCtoDaylightSavingTime(tblUser.DateCreated,@OrganisationID) as ''DateCreated'',
dbo.udfUTCtoDaylightSavingTime(case when Active = 0 then coalesce(tblUser.DAteArchived,tblUser.DateUpdated) end,@OrganisationID) as ''DateArchived''
FROM
-- derived table UserModuleAccess
(SELECT
tU.UserID,
tU.FirstName,
tU.LastName,
tU.UnitID,
tU.OrganisationID,
tM.ModuleID,
tM.CourseID,
tC.Name AS CourseName

FROM
dbo.tblUser AS tU INNER JOIN
dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID INNER JOIN
dbo.tblCourse AS tC ON tC.CourseID = tOCA.GrantedCourseID INNER JOIN
dbo.tblModule AS tM ON tM.CourseID = tC.CourseID AND tM.Active = 1 LEFT OUTER JOIN
dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID

WHERE
(tU.UnitID IS NOT NULL) AND
(tUnitMA.DeniedModuleID IS NULL) AND
(tUsrMA.ModuleID IS NULL) OR
(tUsrMA.Granted = 1)
)
as uma -- end derived table UserModuleAccess
LEFT JOIN tblUser on uma.UserID = tblUser.UserID
LEFT JOIN tblUnitHierarchy on tblUnitHierarchy.UnitID = tblUser.UnitID

WHERE
uma.OrganisationID = @OrganisationID
AND CourseID in (SELECT * FROM dbo.udfCsvToInt(@CourseIDs))
AND tblUser.DateCreated between dbo.udfDaylightSavingTimeToUTC(@FromDate,@OrganisationID) and dbo.udfDaylightSavingTimeToUTC(@ToDate,@OrganisationID)
and tblUser.Active = (case when @includeinactive =0 then 1 else tbluser.active end )

ORDER BY
UnitPathway,
uma.[LastName],
uma.[FirstName]

--Order By CourseName


END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_AdminSummaryReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
This will show the Current or historic Admin Report

See the remarks below.

Returns:

Called By: Current Admin Report
Calls:

Remarks:

1. Get the Current or historic user module status  based on the search criteria

2.  Group and sort the result
2.1    Group by Unit_User
Columns output:
Unit,
[User],
Course,
Module,
QuizStatus,
QuizScore,
QuizStatusDate,
LessonStatus

2.2    Group by Course
Columns output:
Course,
Module,
Unit,
[User],
QuizStatus,
QuizScore,
QuizStatusDate,
LessonStatus

then sorted by, either:
QuizScore
Last Name
QuizStatusDate


Author: Jack Liu
Date Created: 1 Mar 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Mark Donald	27/07/2009		add userName and userEmail params
#2  J hedlefs   09/06/2011      timezone


prcReport_AdminSummaryReport 3, '''', ''1,2,3,4'','''','''',NULL,NULL,''20040222'',''Unit_User'','''',4
prcReport_AdminSummaryReport 3, '''', ''1,2,3,4'','''','''',NULL,NULL,null,''Course'',''QuizDate'',4

--------------------

**/

CREATE      procedure [prcReport_AdminSummaryReport]
(
@organisationID 	int,
@unitIDs		Varchar(MAX),
@courseIDs		Varchar(8000),
@userFirstName		nVarchar(50),
@userLastName		nVarchar(50),
@userName			nVarchar(100),
@userEmail			nVarchar(100),
@effectiveDateOrg 		datetime,
@groupBy		nVarchar(50),
@sortBy			nVarchar(50),
@adminUserID		int,
@classificationID 	int,
@inclInactive	int -- Flag for including inactive user or not
--@inclInactive = 0: do not include inactive users
--@inclInactive = 1: include inactive users
)
As
set nocount on
/*
1. Get the Current or historic user module status  based on the search criteria
Unit,
[User],
Course,
Module,
QuizStatus,
QuizScore,
QuizStatusDate,
LessonStatus,
UnitID,
UserID,
CourseID,
ModuleID
*/

DECLARE @defaultDate DATETIME
SET @defaultDate = getUTCdate()

if  not ( @sortBy  = ''QUIZ_SCORE'' or @sortBy  = ''QUIZ_DATE'' or @sortBy  = ''LAST_NAME'')
Begin
-- sort order is not QUIZ_SCORE, QUIZ_DATE or LAST_NAME
set @sortBy = ''LAST_NAME''
End
Declare @tblResult TABLE
(
-- General
Unit		nVarchar(200),
[User]		nVarchar(100),
Course		nVarchar(100),
Module		nVarchar(100),
[Sequence]  Int,
-- Quiz Specific
QuizStatus	nvarchar(50),
QuizScore	Int,
QuizStatusDate	DateTime,
-- Lesson Specific
LessonStatus	nvarchar(50),
-- Hidden
UnitID		Int,
UserID		Int,
UserName	nvarchar(100),
ExternalID	nvarchar(50),
CourseID	Int,
ModuleID	Int,
Active		Int,
ClassificationName nvarchar(50),  -- This may need to be changed when multiple classifications become needed.
ClassificationValue nvarchar(50)
)
Insert Into
@tblResult
select
Results.*,
tblClassificationType.Name,
tblClassification.Value
from
-- ***************************** Timezone conversion is done in the UDF **********************************************
dbo.udfReport_HistoricAdminSummaryOptimised(@organisationID,@unitIDs,@courseIDs,@userFirstName,@userLastName,@userName,@userEmail,@effectiveDateOrg,@adminUserID,@classificationID,@defaultDate,@inclInactive)
-- *******************************************************************************************************************
as Results
left join
tblUserClassification on tblUserClassification.UserID = Results.UserID
left join
tblClassification on tblClassification.ClassificationID = tblUserClassification.ClassificationID
left join
tblClassificationType on tblClassification.ClassificationTypeID = tblClassificationType.ClassificationTypeID
/*
2.  Group and sort the result
2.1    Group by Unit/User
Columns output:
Unit,
[User],
Course,
Module,
QuizStatus,
QuizScore,
QuizStatusDate,
LessonStatus
*/
if (@groupBy = ''Unit_User'')
begin
select
Unit,
[User],
Course,
Module,
QuizStatus,
QuizScore,
QuizStatusDate,
LessonStatus,
UnitID,
UserID,
UserName,
ExternalID,
CourseID,
ModuleID,
Active,
ClassificationName,
ClassificationValue
from @tblResult
order by Unit, UnitID, [User], userID,  Course, CourseID, [Sequence]
end
/*
2.2    Group by Course
Columns output:
Course,
Module,
Unit,
[User],
QuizStatus,
QuizScore,
QuizStatusDate,
LessonStatus
then sorted by, either:
QuizScore
Last Name
QuizStatusDate
*/
else -- (@groupBy = ''Course'')
begin
if (@sortBy = ''QUIZ_SCORE'')
begin
select
*
from @tblResult
order by Course, CourseID, [Sequence], Unit, UnitID, QuizScore desc,[user]
end
else if (@sortBy = ''QUIZ_DATE'')
begin
select
*
from @tblResult
order by Course, CourseID, [Sequence], Unit, UnitID, QuizStatusDate desc,[user]
end
else -- order by ''LAST_NAME''
begin
select
*
from @tblResult
order by Course, CourseID, [Sequence], Unit, UnitID, [user]
end
end


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_AtRisk]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		File:
**		Name: prcReport_AtRisk
**		Desc: Returns a list of users who have failed a quiz the specified
**				of times.
**
**		Auth: Mark Donald
**		Date: 23 Dec 2009
**
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**      09/06/2011	j hedlefs			timezone
*******************************************************************************/


CREATE       Procedure [dbo].[prcReport_AtRisk]
(
@organisationID int,
@unitIDs varchar(max),
@courseIDs varchar(8000),
@failCounter int,
@dateFrom datetime,
@dateTo datetime,
@classificationID int
)
AS
SET NOCOUNT ON

DECLARE @Units TABLE (UnitID INT PRIMARY KEY(UnitID))
DECLARE @Courses TABLE (CourseID INT PRIMARY KEY(CourseID))
DECLARE @Users TABLE(UserID INT , UnitID INT PRIMARY KEY(UserID, UnitID))

INSERT INTO @Courses SELECT * FROM dbo.udfCsvToInt(@courseIDs)
INSERT INTO @Units SELECT * FROM  dbo.udfCsvToInt(@unitIDs)

--Get All the users for all specfied units, matching Custom Classification option (if provided)
INSERT INTO @Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
JOIN @Units B ON A.UnitID = B.UnitID
JOIN tblUnit C ON B.UnitID = C.UnitID AND C.Active = 1
LEFT JOIN tblUserClassification uc ON uc.UserID  = A.UserID
WHERE
A.Active = 1
AND ((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification

BEGIN
SELECT
s.userid, s.moduleid, hierarchyname as unitpathway, lastname, firstname, externalid, email, username, c.[name] as coursename, m.[name] as modulename, failnumber, [status] as currentstatus
FROM
(SELECT
q.userid, moduleid,
sum(CASE quizstatusid WHEN 3 THEN 1 ELSE 0 END) AS failnumber,
max(userquizstatusid) AS currentstatusid
FROM
tbluserquizstatus q, tbluser u
WHERE
q.userid = u.userid
AND organisationid = @organisationID
AND q.datecreated BETWEEN dbo.udfDaylightSavingTimeToUTC(@dateFrom,@OrganisationID) AND dateadd(dd, 1, dbo.udfDaylightSavingTimeToUTC(@dateTo,@OrganisationID))
GROUP BY
q.userid, moduleid
HAVING
sum(CASE quizstatusid WHEN 3 THEN 1 ELSE 0 END) >= @failCounter) s
LEFT JOIN tblusermoduleaccess a ON
a.userid = s.userid AND a.moduleid = s.moduleid
JOIN tbluser u ON
u.userid = s.userid
LEFT JOIN tblunitmoduleaccess n ON
n.unitid = u.unitid AND s.moduleid = deniedmoduleid,
tbluserquizstatus uq,
@Users x,
@Courses w,
tblmodule m,
tblcourse c,
tblquizstatus q,
tblunithierarchy h
WHERE
(
(deniedmoduleid IS NULL AND a.moduleid IS NULL)
OR a.granted = 1
)
AND uq.userquizstatusid = s.currentstatusid
AND x.userid = s.userid
AND m.moduleid = s.moduleid
AND c.courseid = m.courseid
AND w.courseid = m.courseid
AND q.quizstatusid = uq.quizstatusid
AND h.unitid = u.unitid
ORDER BY
unitpathway, lastname, firstname
END

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_AtRiskGrandTotal]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		File:
**		Name: prcReport_AtRisk
**		Desc: Returns a list of users who have failed a quiz the specified
**				of times.
**
**		Auth: Mark Donald
**		Date: 23 Dec 2009
**
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**    09/06/2011	j hedlefs			timezone
*******************************************************************************/


CREATE       Procedure [dbo].[prcReport_AtRiskGrandTotal]
(
@organisationID int,
@unitIDs varchar(max),
@courseIDs varchar(8000),
@failCounter int,
@dateFrom datetime,
@dateTo datetime,
@classificationID int
)
AS
SET NOCOUNT ON

DECLARE @Units TABLE (UnitID INT PRIMARY KEY(UnitID))
DECLARE @Courses TABLE (CourseID INT PRIMARY KEY(CourseID))
DECLARE @Users TABLE(UserID INT , UnitID INT PRIMARY KEY(UserID, UnitID))

INSERT INTO @Courses SELECT * FROM dbo.udfCsvToInt(@courseIDs)
INSERT INTO @Units SELECT * FROM  dbo.udfCsvToInt(@unitIDs)

--Get All the users for all specfied units, matching Custom Classification option (if provided)
INSERT INTO @Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
JOIN @Units B ON A.UnitID = B.UnitID
JOIN tblUnit C ON B.UnitID = C.UnitID AND C.Active = 1
LEFT JOIN tblUserClassification uc ON uc.UserID  = A.UserID
WHERE
A.Active = 1
AND ((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification

BEGIN
SELECT
count(DISTINCT s.userid) AS TotalDistinctUsers
FROM
(SELECT
q.userid, moduleid,
sum(CASE quizstatusid WHEN 3 THEN 1 ELSE 0 END) AS failnumber,
max(userquizstatusid) AS currentstatusid
FROM
tbluserquizstatus q, tbluser u
WHERE
q.userid = u.userid
AND organisationid = @organisationID
AND q.datecreated BETWEEN dbo.udfDaylightSavingTimeToUTC(@dateFrom,@OrganisationID) AND dateadd(dd, 1, dbo.udfDaylightSavingTimeToUTC(@dateTo,@OrganisationID))
GROUP BY
q.userid, moduleid
HAVING
sum(CASE quizstatusid WHEN 3 THEN 1 ELSE 0 END) >= @failCounter) s
LEFT JOIN tblusermoduleaccess a ON
a.userid = s.userid AND a.moduleid = s.moduleid
JOIN tbluser u ON
u.userid = s.userid
LEFT JOIN tblunitmoduleaccess n ON
n.unitid = u.unitid AND s.moduleid = deniedmoduleid,
tbluserquizstatus uq,
@Users x,
@Courses w,
tblmodule m,
tblcourse c,
tblquizstatus q,
tblunithierarchy h
WHERE
(
(deniedmoduleid IS NULL AND a.moduleid IS NULL)
OR a.granted = 1
)
AND uq.userquizstatusid = s.currentstatusid
AND x.userid = s.userid
AND m.moduleid = s.moduleid
AND c.courseid = m.courseid
AND w.courseid = m.courseid
AND q.quizstatusid = uq.quizstatusid
AND h.unitid = u.unitid

END

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CompletedUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'








/*Summary:
Given a user id returns the list of courses / modules and the latest results for that user
If the User id is ommited it returns results for all users
Returns:
Course ID

Called By:
Home.aspx via Businessservices.Report.GetCompletedUsersReport
Calls:
udfReport_CompletUsers_logic
udfReport_IncompletUsers_logic
Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 18 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1  Liz Dionisio(UW)	8/11/2005		Added Username, Email and ExternalID to returned recordset
#2  Mark Donald	24/07/2009		Add LastCompleted column to incomplete users select statement

prcReport_CompletedUsers @unitIDs=''1,2,3,4'' , @courseID=1 , @completed = 0

--------------------

**/

CREATE          Proc [prcReport_CompletedUsers]

(
@organisationID Integer,		-- Organisation of the current user
@unitIDs varchar(MAX) = '''',	-- string of unit id''s
@courseID int,			-- course ID to restrict search to
@effectiveDate datetime = Null,	-- Effective date as at when to run the report
@completed bit = 0 		-- Completed or incompleted flag
-- 1 = True = completed users
-- 0 = false (default) = not comleted or INcompleted users
)

AS
------------------------------------------
Set Nocount On
If @completed = 1
Begin
SELECT
f.userid, unitid, firstname, lastname, unitpathway,
dbo.udfUTCtoDaylightSavingTime(max(q.datecreated), @organisationID) as date, --date
username, email, externalid
FROM
dbo.udfreport_completeuserslogic(@organisationid, @unitids, @courseid, @effectivedate) f,
tbluserquizstatus q,
tblmodule m
WHERE
m.courseid = @courseid
AND q.moduleid = m.moduleid
AND q.userid = f.userid
AND quizstatusid = 2 -- passed
GROUP BY
f.userid, unitid, firstname, lastname, unitpathway, username, email, externalid
ORDER BY
unitpathway, lastname, firstname
End
Else
Begin
Select
userID
, unitID
, FirstName
, LastName
, UnitPathway
, LastCompleted
, Username
, Email
, ExternalID
From
dbo.udfReport_IncompleteUsersLogic(@organisationID, @unitIDs, @courseID,@effectiveDate)
Order By
UnitPathway, LastName, FirstName
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CompletedUsersDetails]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Given an list of incomplete users, derive all of the module status explaining why the users
are incomplete

Returns:
Table of Incomplete Users with the module status details

Called By:
Reporting/Advanced/CompletedUsersReport.aspx

Calls:
udfReport_IncompletUsers_logic

Remarks:


Author:
Yoppy Suwanto

Date Created: 05 Mar 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1  Mark Donald	24/07/2009		Add LastCompleted col to selects

prcReport_CompletedUsersDetails @unitIDs=''1,2,3,4'' , @courseID=1 , @completed = 0
prcReport_CompletedUsersDetails @organisationid=11, @unitIDs=null , @courseID=53, @effectivedate = null

--------------------

**/
CREATE            Proc [dbo].[prcReport_CompletedUsersDetails]
(
@organisationID Integer,	-- Organisation of the current user
@unitIDs varchar(max) = '''',	-- string of unit ids
@courseID int,					-- course ID to restrict search to
@effectiveDateOrg datetime = Null	-- Effective date as at when to run the report
--@completed bit = 0 			-- always run for incomplete status
)
AS
begin
/*
declare @orgid int
declare @courseid int
declare @unitids varchar(8000)
declare @effectivedate datetime

set @orgid = 11
set @courseid = 53
set @unitids = null
set @effectivedate = ''4 August 2007''
*/

DECLARE @effectiveDate DateTime
SET @effectiveDate = dbo.udfDaylightSavingTimeToUTC(@effectiveDateOrg,@OrganisationID)

if (@effectiveDateOrg is null)
/*
-- Report on current latest date
*/
Begin

select max(userquizstatusid) userquizstatusid
into #tmpUserQuizStatus
from tblUserQuizStatus
where userid in (select userid from tblUser where organisationid = @organisationID)
and moduleid in (select moduleid from tblModule where courseid = @courseid)
group by userid, moduleid

Select
IU.userID
, IU.unitID
, IU.FirstName
, IU.LastName
, IU.UnitPathway
, case when lastcompleted is null then ''Never'' else convert(varchar(10),dbo.udfUTCtoDaylightSavingTime(LastCompleted,@OrganisationID),103) end  as LastCompleted
, IU.Username
, IU.Email
, IU.ExternalID
, tM.[name] as ''Module''
, tQS.status
--,tM.moduleid
--,tUQS.quizstatusid
--,tUQS.userquizstatusid

From
dbo.udfReport_IncompleteUsersLogic(@organisationID, @unitIDs, @courseID,null) IU
inner join tblUserQuizStatus tUQS
on tUQS.userid = IU.userid
--inner join tmpUserQuizStatis UQS
--      on tUQS.userquizstatusid = UQS.userquizstatusid
inner join tblModule tM
on tUQS.moduleid = tM.moduleid
inner join tblQuizStatus tQS
on tQS.quizstatusid = tUQS.quizstatusid

Where
--tUQS.quizstatusid <> 2 --Every status except pass quiz status
tUQS.quizstatusid in (1,3,4,5)
and tUQS.moduleid in (select moduleid from tblModule where courseid = @courseid)
and tUQS.userquizstatusid in (select userquizstatusid from #tmpUserQuizStatus)

Order By
UnitPathway, LastName, FirstName,  tM.sequence

drop table #tmpUserQuizStatus

end

Else
-- Report results up to the effective date
Begin


select max(userquizstatusid) userquizstatusid
into #tmpUserQuizStatusDate
from tblUserQuizStatus
where userid in (select userid from tblUser where organisationid = @organisationID)
and moduleid in (select moduleid from tblModule where courseid = @courseid)
and Datecreated < @effectiveDate
group by userid, moduleid

Select
IU.userID
, IU.unitID
, IU.FirstName
, IU.LastName
, IU.UnitPathway
, case when lastcompleted is null then ''Never'' else convert(varchar(10),dbo.udfUTCtoDaylightSavingTime(LastCompleted,@OrganisationID),103) end  as LastCompleted
, IU.Username
, IU.Email
, IU.ExternalID
, tM.[name] as ''Module''
, tQS.status
--,tM.moduleid
--,tUQS.quizstatusid
--,tUQS.userquizstatusid

From
dbo.udfReport_IncompleteUsersLogic(@organisationID, @unitIDs, @courseID,@effectiveDate) IU
inner join tblUserQuizStatus tUQS
on tUQS.userid = IU.userid
--inner join tmpUserQuizStatis UQS
--      on tUQS.userquizstatusid = UQS.userquizstatusid
inner join tblModule tM
on tUQS.moduleid = tM.moduleid
inner join tblQuizStatus tQS
on tQS.quizstatusid = tUQS.quizstatusid

Where
--tUQS.quizstatusid <> 2 --Every status except pass quiz status
tUQS.quizstatusid in (1,3,4,5)
and tUQS.moduleid in (select moduleid from tblModule where courseid = @courseid)
and tUQS.userquizstatusid in (select userquizstatusid from #tmpUserQuizStatusDate)

Order By
UnitPathway, LastName, FirstName, tM.sequence

drop table #tmpUserQuizStatusDate

end
END

' 
END
GO


/****** Object:  StoredProcedure [dbo].[prcReport_CompletedUsersDetails2]    Script Date: 12/19/2012 15:23:40 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CompletedUsersDetails2]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary:
Given an list of incomplete users, derive all of the module status explaining why the users
are incomplete

Returns:
Table of Incomplete Users with the module status details

Called By:
Reporting/Advanced/CompletedUsersReport.aspx

Calls:
udfReport_IncompletUsers_logic

Remarks:


Author:
Yoppy Suwanto

Date Created: 05 Mar 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1  Mark Donald	24/07/2009		Add LastCompleted col to selects

prcReport_CompletedUsersDetails @unitIDs=''1,2,3,4'' , @courseID=1 , @completed = 0
prcReport_CompletedUsersDetails @organisationid=11, @unitIDs=null , @courseID=53, @effectivedate = null

--------------------

**/
create            Proc [prcReport_CompletedUsersDetails2]
(
@organisationID Integer,	-- Organisation of the current user
@unitIDs varchar(8000) = '''',	-- string of unit id''s
@courseID int,					-- course ID to restrict search to
@effectiveDateOrg datetime = Null	-- Effective date as at when to run the report
--@completed bit = 0 			-- always run for incomplete status
)
AS
/*
declare @orgid int
declare @courseid int
declare @unitids varchar(8000)
declare @effectivedate datetime

set @orgid = 11
set @courseid = 53
set @unitids = null
set @effectivedate = ''4 August 2007''
*/
DECLARE @effectiveDate DateTime
SET @effectiveDate = dbo.udfDaylightSavingTimeToUTC(@effectiveDateOrg,@OrganisationID)

if (@effectiveDate is null)
/*
-- Report on current latest date
*/
Begin

select max(userquizstatusid) userquizstatusid
into #tmpUserQuizStatus
from tblUserQuizStatus
where userid in (select userid from tblUser where organisationid = @organisationID)
and moduleid in (select moduleid from tblModule where courseid = @courseid)
group by userid, moduleid

Select
IU.userID
, IU.unitID
, IU.FirstName
, IU.LastName
, IU.UnitPathway
, dbo.udfUTCtoDaylightSavingTime(LastCompleted,@OrganisationID) as LastCompleted
, IU.Username
, IU.Email
, IU.ExternalID
, tM.[name] as ''Module''
, tQS.status
--,tM.moduleid
--,tUQS.quizstatusid
--,tUQS.userquizstatusid

From
dbo.udfReport_IncompleteUsersLogic(@organisationID, @unitIDs, @courseID,@effectiveDate) IU
inner join tblUserQuizStatus tUQS
on tUQS.userid = IU.userid
--inner join tmpUserQuizStatis UQS
--      on tUQS.userquizstatusid = UQS.userquizstatusid
inner join tblModule tM
on tUQS.moduleid = tM.moduleid
inner join tblQuizStatus tQS
on tQS.quizstatusid = tUQS.quizstatusid

Where
--tUQS.quizstatusid <> 2 --Every status except pass quiz status
tUQS.quizstatusid in (1,3,4,5)
and tUQS.moduleid in (select moduleid from tblModule where courseid = @courseid)
and tUQS.userquizstatusid in (select userquizstatusid from #tmpUserQuizStatus)

Order By
UnitPathway, LastName, FirstName,  tM.sequence

drop table #tmpUserQuizStatus

end

Else
-- Report results up to the effective date
Begin

select max(userquizstatusid) userquizstatusid
into #tmpUserQuizStatusDate
from tblUserQuizStatus
where userid in (select userid from tblUser where organisationid = @organisationID)
and moduleid in (select moduleid from tblModule where courseid = @courseid)
and Datecreated < @effectiveDate
group by userid, moduleid

Select
IU.userID
, IU.unitID
, IU.FirstName
, IU.LastName
, IU.UnitPathway
, dbo.udfUTCtoDaylightSavingTime(LastCompleted,@OrganisationID) as LastCompleted
, IU.Username
, IU.Email
, IU.ExternalID
, tM.[name] as ''Module Name''
, tQS.status
--,tM.moduleid
--,tUQS.quizstatusid
--,tUQS.userquizstatusid

From
dbo.udfReport_IncompleteUsersLogic(@organisationID, @unitIDs, @courseID,@effectiveDate) IU
inner join tblUserQuizStatus tUQS
on tUQS.userid = IU.userid
--inner join tmpUserQuizStatis UQS
--      on tUQS.userquizstatusid = UQS.userquizstatusid
inner join tblModule tM
on tUQS.moduleid = tM.moduleid
inner join tblQuizStatus tQS
on tQS.quizstatusid = tUQS.quizstatusid

Where
--tUQS.quizstatusid <> 2 --Every status except pass quiz status
tUQS.quizstatusid in (1,3,4,5)
and tUQS.moduleid in (select moduleid from tblModule where courseid = @courseid)
and tUQS.userquizstatusid in (select userquizstatusid from #tmpUserQuizStatusDate)

Order By
UnitPathway, LastName, FirstName, tM.sequence

drop table #tmpUserQuizStatusDate

end
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CourseStatusGrandTotal]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		Name: prcReport_CourseStatusGrandTotal
**		Desc: a copy of prcreport_CourseStatusSearch, but with select statements
**				altered to return a total, instead of a list of data.
**
**		Return values: Grand Total distinct users in Course Status report
**
**		Called by:
**
**		Parameters:
**		Input							Output
**     ----------							-----------
**
**		Auth: Mark Donald
**		Date: 27 Aug 2009
**
*******************************************************************************/

CREATE       Procedure [dbo].[prcReport_CourseStatusGrandTotal]
(
@organisationID		int,
@unitIDs 		varchar(max),
@courseIDs 		varchar(8000),
@courseModuleStatus	int,
@dateFromOrg 		datetime,
@dateToOrg 		datetime,
@IncludeInactive int,
@classificationID int
)
AS
------------------------------------------
Set Nocount On
DECLARE @dateFrom 		datetime
DECLARE @dateTo 		datetime
SET @dateFrom = dbo.udfDaylightSavingTimeToUTC(@dateFromOrg,@OrganisationID)
SET @dateTo = dbo.udfDaylightSavingTimeToUTC(@dateToOrg,@OrganisationID)
Declare
@CONST_INCOMPLETE     	int,
@CONST_COMPLETE     	int,
@CONST_FAILD            int,
@CONST_NOTSTARTED 	    int,
@CONST_EXPIRED_TIMELAPSED		int,
@CONST_EXPIRED_NEWCONTENT		int

set @CONST_INCOMPLETE	= 0
set @CONST_COMPLETE	= 1
set @CONST_FAILD	= 2
set @CONST_NOTSTARTED	= 3
set @CONST_EXPIRED_TIMELAPSED   = 4
set @CONST_EXPIRED_NEWCONTENT	= 5

DECLARE @Units TABLE
(
UnitID INT PRIMARY KEY(UnitID)
)

DECLARE @Courses TABLE
(
CourseID INT PRIMARY KEY(CourseID)
)

DECLARE @CoursesWithAccess 	TABLE (CourseID INT PRIMARY KEY(CourseID))
DECLARE @UserModuleWithAccess TABLE(UserID INT, ModuleID INT, UnitID INT PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE(ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE(UserID INT , UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus
TABLE
(
UserID	INT,
ModuleID INT,
LatestQuizID INT,
QuizStatusID INT,
QuizScore INT
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

DECLARE @UsersQuizStatusNOTSTARTED
TABLE
(
UserID	INT,
ModuleID INT,
LatestQuizID INT,
QuizStatusID INT,
QuizScore INT
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

INSERT INTO @Courses SELECT * FROM dbo.udfCsvToInt(@courseIDs)

INSERT INTO @Units SELECT * FROM  dbo.udfCsvToInt(@unitIDs)

--Get Rid of courses which do not have access to specified org
INSERT INTO @CoursesWithAccess
SELECT A.CourseID FROM @Courses A, tblOrganisationCourseAccess B, tblCourse C
WHERE A.CourseID = B.GrantedCourseID AND B.OrganisationID = @organisationID AND
A.CourseID = C.CourseID AND C.Active = 1

--Get All the users for all specfied units, matching Custom Classification option (if provided)
INSERT INTO @Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
join @Units B on A.UnitID = B.UnitID
join tblUnit C on B.UnitID = C.UnitID AND C.Active = 1
LEFT JOIN tblUserClassification uc ON uc.UserID  = A.UserID
WHERE
A.Active = CASE @IncludeInactive WHEN 0 THEN 1 ELSE A.Active END
AND ((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification



if @courseModuleStatus = @CONST_COMPLETE or @courseModuleStatus = @CONST_INCOMPLETE
begin -- completed / -- InComplete
--------------------
-- Completed --
--------------------
-- A user is completed if they became complete and remained completed in the period of interest
-- the query only needs to check to see status at the max date in this period as a line item
-- as tblUserCourseStatus is only writen to when an event occours that would
-- change the status.
-- When "Course/Module Status" is set to "Complete"
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question
--------------------
-- InComplete
--------------------
-- A user is in-completed if for any reason they are not complete but do have access to the course
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Courses
-- - AND have (at the end of the time-period in question) got a status of Incomplete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question

--Find the latest status of courses
SELECT
count(distinct A.UserID) AS TotalDistinctUsers
FROM
(
SELECT
A.UserID, A.CourseID, MAX(A.UserCourseStatusID) AS ''LatestCourseStatus''
FROM
tblUserCourseStatus A, @CoursesWithAccess B
WHERE
A.DateCreated < DATEADD(DD, 1, @dateTo)
and
A.CourseID = B.CourseID
GROUP BY
A.UserID, A.CourseID
) A, @Users B, tblUserCourseStatus C, tblUser D, tblCourse E, tblUnitHierarchy F
WHERE
A.UserID = B.UserID AND B.UserID = C.UserID AND
A.LatestCourseStatus = C.UserCourseStatusID AND
(C.DateCreated BETWEEN @dateFrom AND dateadd(d,1,@dateTo)) AND
C.CourseStatusID = case @courseModuleStatus
when @CONST_COMPLETE then 2   -- Complete
when @CONST_INCOMPLETE then 1 -- InComplete
end AND
A.UserID = D.UserID AND A.CourseID = E.CourseID AND
D.UnitID = F.UnitID

end -- completed / -- InComplete


if @courseModuleStatus = @CONST_FAILD or @courseModuleStatus = @CONST_EXPIRED_TIMELAPSED or @courseModuleStatus = @CONST_EXPIRED_NEWCONTENT
begin -- Failed
--------------------
-- Failed  --
--------------------
-- When "Course/Module Status" is set to "Failed"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Courses
--  - AND took a quiz, for a Module within the selected Course, within the date range of DateCreated in UserQuizStatus and failed it
--  - AND who currently have a status other than "Passed" for that same quiz
--------------------

--Find All Modules for all units with access

INSERT INTO @UserModuleWithAccess
SELECT DISTINCT A.UserID, A.ModuleID, A.UnitID FROM
(
SELECT A.UserID, A.ModuleID, A.UnitID
FROM vwUserModuleAccess A where courseid in (SELECT courseid from @Courses) )A, @Users B
Where A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO @UsersNQuizStatus
SELECT DISTINCT
A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(
SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID AND
A.LatestQuizID = B.UserQuizStatusID AND
(B.DateCreated BETWEEN @dateFrom AND dateadd(d,1,@dateTo))

INSERT INTO @UsersQuizStatusNOTSTARTED
SELECT * FROM @UsersNQuizStatus WHERE QuizStatusID = case @courseModuleStatus
when @CONST_FAILD then 3   -- Failed
when @CONST_EXPIRED_TIMELAPSED then 4 -- Expired time lapsed
when @CONST_EXPIRED_NEWCONTENT then 5 -- Expired new content
end

--Get Data in report format
SELECT
count(distinct A.UserID) AS TotalDistinctUsers
FROM
(select distinct userid, moduleid from @UsersQuizStatusNOTSTARTED) A,
tblUser B, tblCourse C, tblModule D, tblUnitHierarchy E
WHERE
A.UserID = B.UserID AND B.Active = 1 AND
A.ModuleID = D.ModuleID AND
B.UnitID = E.UnitID AND
D.CourseID = C.CourseID AND C.Active = 1 AND D.Active = 1

end --/ Failed


-- Not started --

if @courseModuleStatus = @CONST_NOTSTARTED
begin -- Not started - Any
--------------------
-- Not started  --
--------------------
-- When "Course/Module Status" is set to "Not Started"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Courses
--  - AND who have not started ANY of the quizes they have access to in this course within the selected date range(DateCreated in vwUserQuizStatus)
--------------------


--Find All Modules for all units with access

INSERT INTO @UserModuleWithAccess
SELECT DISTINCT A.UserID, A.ModuleID, A.UnitID FROM
(
SELECT A.UserID, A.ModuleID, A.UnitID
FROM vwUserModuleAccess A where courseid in (SELECT courseid from @Courses) )A, @Users B
Where A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO @UsersNQuizStatus
SELECT  DISTINCT
A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(
SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID AND
A.LatestQuizID = B.UserQuizStatusID AND
(B.DateCreated BETWEEN @dateFrom AND dateadd(d,1,@dateTo))


--Get User with Quiz NOT STARTED
INSERT INTO @UsersQuizStatusNOTSTARTED
SELECT * FROM @UsersNQuizStatus WHERE QuizStatusID NOT IN (2,3,4,5) AND
UserID NOT IN (SELECT UserID FROM @UsersNQuizStatus WHERE QuizStatusID IN (2,3,4,5))


--Get Data in report format
SELECT
count(distinct A.UserID) AS TotalDistinctUsers
FROM
(select distinct userid, moduleid from @UsersQuizStatusNOTSTARTED) A,
tblUser B, tblCourse C, tblModule D, tblUnitHierarchy E
WHERE
A.UserID = B.UserID AND B.Active = 1 AND
A.ModuleID = D.ModuleID AND B.UnitID = E.UnitID AND
D.CourseID = C.CourseID AND C.Active = 1 AND D.Active = 1

end --/ Not started - Any



' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CourseStatusReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Given a user id returns the list of courses / modules and the latest results for that user
If the User id is ommited it returns results for all users
Returns:
Course ID

Called By:
Home.aspx via Businessservices.Report.GetCourseStatusReport
Calls:
udfReport_CompletUsers_logic
udfReport_IncompletUsers_logic
Remarks:


Author:

Date Created: 16 March 2006

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

--------------------

**/

CREATE          Proc [prcReport_CourseStatusReport]

(
@organisationID Integer,		-- Organisation of the current user
@unitIDs varchar(max) = '''',	-- string of unit id''s
@courseIDs varchar(8000),			-- course IDs to restrict search to
@effectiveFromDate datetime = Null,	-- Effective date as at when to run the report
@effectiveToDate datetime = Null,	-- Effective date as at when to run the report
@completed bit = 0 		-- Completed or incompleted flag
-- 1 = True = completed users
-- 0 = false (default) = not comleted or INcompleted users
)

AS
------------------------------------------
Set Nocount On
If @completed = 1
Begin
Select
userID
, unitID
, FirstName
, LastName
, UnitPathway
,Date
,Username
,Email
,ExternalID
,CourseName
From
dbo.udfReport_CompleteCourseLogic(@organisationID, @unitIDs, @courseIDs,@effectiveFromDate,@effectiveToDate)
Order By
CourseName,UnitPathway,LastName, FirstName
End
Else
Begin
Select
userID
, unitID
, FirstName
, LastName
, UnitPathway
, Username
, Email
, ExternalID
, CourseName
From
dbo.udfReport_IncompleteCourseLogic(@organisationID, @unitIDs, @courseIDs,@effectiveFromDate,@effectiveToDate)
Order By
CourseName,UnitPathway,LastName,FirstName
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CourseStatusSearch]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/******************************************************************************
**		File:
**		Name: prcReport_CourseStatusSearch
**		Desc: Given a list of unit IDs, course IDs,
**
**		This template can be customized:
**
**		Return values:
**
**		Called by:
**
**		Parameters:
**		Input							Output
**     ----------							-----------
**
**		Auth:
**		Date:
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		23/07/2009	Mark Donald			Add @classificationID parameter and use
**										it to filter the insert into @Users
**		17/08/2009	Mark Donald			Change column order of ''fail option''
**										select statement to match others
**
*******************************************************************************/

--exec prcReport_CourseStatusSearch 109, ''4463,4464,4465,4469,4478,4479'', ''92'', 3, ''1997-01-01'',''2011-07-01'', 0, 0
CREATE       Procedure [prcReport_CourseStatusSearch]
(
@organisationID		int,
@unitIDs 		varchar(max),
@courseIDs 		varchar(8000),
@courseModuleStatus	int,
@dateFromOrg 		datetime,
@dateToOrg 		datetime,
@IncludeInactive int,
@classificationID int
)
AS

begin
------------------------------------------
DECLARE @dateFrom 		datetime
DECLARE @dateTo 		datetime
SET @dateFrom = dbo.udfDaylightSavingTimeToUTC(@dateFromOrg,@OrganisationID)
SET @dateTo = dbo.udfDaylightSavingTimeToUTC(@dateToOrg,@OrganisationID)

Set Nocount On

Declare
@CONST_INCOMPLETE     	int,
@CONST_COMPLETE     	int,
@CONST_FAILD            int,
@CONST_NOTSTARTED 	    int,
@CONST_EXPIRED_TIMELAPSED		int,
@CONST_EXPIRED_NEWCONTENT		int

set @CONST_INCOMPLETE	= 0
set @CONST_COMPLETE	= 1
set @CONST_FAILD	= 2
set @CONST_NOTSTARTED	= 3
set @CONST_EXPIRED_TIMELAPSED   = 4
set @CONST_EXPIRED_NEWCONTENT	= 5

DECLARE @Units TABLE
(
UnitID INT PRIMARY KEY(UnitID)
)

DECLARE @Courses TABLE
(
CourseID INT PRIMARY KEY(CourseID)
)

DECLARE @CoursesWithAccess 	TABLE (CourseID INT PRIMARY KEY(CourseID))
DECLARE @UserModuleWithAccess TABLE(UserID INT, ModuleID INT, UnitID INT PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE(ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE(UserID INT , UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus
TABLE
(
UserID	INT,
ModuleID INT,
LatestQuizID INT,
QuizStatusID INT,
QuizScore INT
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

DECLARE @UsersQuizStatusNOTSTARTED
TABLE
(
UserID	INT,
ModuleID INT,
LatestQuizID INT,
QuizStatusID INT,
QuizScore INT
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

INSERT INTO @Courses SELECT * FROM dbo.udfCsvToInt(@courseIDs)

INSERT INTO @Units SELECT * FROM  dbo.udfCsvToInt(@unitIDs)

--Get Rid of courses which do not have access to specified org
INSERT INTO @CoursesWithAccess
SELECT A.CourseID FROM @Courses A, tblOrganisationCourseAccess B, tblCourse C
WHERE A.CourseID = B.GrantedCourseID AND B.OrganisationID = @organisationID AND
A.CourseID = C.CourseID AND C.Active = 1

--Get All the users for all specfied units, matching Custom Classification option (if provided)
INSERT INTO @Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
join @Units B on A.UnitID = B.UnitID
join tblUnit C on B.UnitID = C.UnitID AND C.Active = 1
LEFT JOIN tblUserClassification uc ON uc.UserID  = A.UserID
WHERE
A.Active = CASE @IncludeInactive WHEN 0 THEN 1 ELSE A.Active END
AND ((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification



if @courseModuleStatus = @CONST_COMPLETE or @courseModuleStatus = @CONST_INCOMPLETE
begin -- completed / -- InComplete
--------------------
-- Completed --
--------------------
-- A user is completed if they became complete and remained completed in the period of interest
-- the query only needs to check to see status at the max date in this period as a line item
-- as tblUserCourseStatus is only writen to when an event occours that would
-- change the status.
-- When "Course/Module Status" is set to "Complete"
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question
--------------------
-- InComplete
--------------------
-- A user is in-completed if for any reason they are not complete but do have access to the course
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Courses
-- - AND have (at the end of the time-period in question) got a status of Incomplete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question

--Find the latest status of courses
SELECT
A.UserID, D.UnitID,
D.FirstName,
D.LastName,
case when D.Active = 1 then ''''  else ''(i)'' end as Flag,
F.HierarchyName AS ''UnitPathWay'',
dbo.udfUTCtoDaylightSavingTime( C.DateCreated , @organisationID)as ''Date'',
D.Username as ''UserName'',
D.Email as ''Email'',
D.ExternalID as ''ExternalID'',
E.[Name] as ''CourseName'',
dbo.udfUTCtoDaylightSavingTime(D.DateCreated, @organisationID)as ''DateCreated'',
case when D.Active =0 then coalesce(dbo.udfUTCtoDaylightSavingTime(D.DateArchived,@organisationid ),dbo.udfUTCtoDaylightSavingTime(D.DateUpdated,@organisationid)) end  as ''DateArchived''
FROM
(SELECT
A.UserID, A.CourseID, MAX(A.UserCourseStatusID) AS ''LatestCourseStatus''
FROM
tblUserCourseStatus A, @CoursesWithAccess B
WHERE
A.DateCreated < DATEADD(DD, 1, @dateTo)
and
A.CourseID = B.CourseID
GROUP BY
A.UserID, A.CourseID
) A,
@Users B, tblUserCourseStatus C, tblUser D, tblCourse E, tblUnitHierarchy F
WHERE
A.UserID = B.UserID AND B.UserID = C.UserID AND
A.LatestCourseStatus = C.UserCourseStatusID AND
(C.DateCreated BETWEEN @dateFrom AND dateadd(d,1,@dateTo)) AND
C.CourseStatusID = case @courseModuleStatus
when @CONST_COMPLETE then 2   -- Complete
when @CONST_INCOMPLETE then 1 -- InComplete
end AND
A.UserID = D.UserID AND A.CourseID = E.CourseID AND
D.UnitID = F.UnitID
ORDER BY
CourseName, UnitPathWay, LastName, FirstName

end -- completed / -- InComplete


if @courseModuleStatus = @CONST_FAILD or @courseModuleStatus = @CONST_EXPIRED_TIMELAPSED or @courseModuleStatus = @CONST_EXPIRED_NEWCONTENT
begin -- Failed
--------------------
-- Failed  --
--------------------
-- When "Course/Module Status" is set to "Failed"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Courses
--  - AND took a quiz, for a Module within the selected Course, within the date range of DateCreated in UserQuizStatus and failed it
--  - AND who currently have a status other than "Passed" for that same quiz
--------------------

--Find All Modules for all units with access

INSERT INTO @UserModuleWithAccess
SELECT DISTINCT A.UserID, A.ModuleID, A.UnitID FROM
(
SELECT A.UserID, A.ModuleID, A.UnitID
FROM vwUserModuleAccess A where courseid in (SELECT courseid from @Courses) )A, @Users B
Where A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO @UsersNQuizStatus
SELECT DISTINCT
A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(
SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID) A,
tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID AND
A.LatestQuizID = B.UserQuizStatusID AND
(B.DateCreated BETWEEN @dateFrom AND dateadd(d,1,@dateTo))

INSERT INTO @UsersQuizStatusNOTSTARTED
SELECT * FROM @UsersNQuizStatus WHERE QuizStatusID = case @courseModuleStatus
when @CONST_FAILD then 3   -- Failed
when @CONST_EXPIRED_TIMELAPSED then 4 -- Expired time lapsed
when @CONST_EXPIRED_NEWCONTENT then 5 -- Expired new content
end


--Get Data in report format
SELECT DISTINCT
A.UserID,
B.UnitID AS ''Unit'' ,
B.FirstName,
B.LastName,
case when B.Active = 1 then ''''  else ''(i)'' end  as Flag,
E.HierarchyName AS ''UnitPathWay'',
dbo.udfUTCtoDaylightSavingTime( C.DateCreated,@organisationID) AS ''Date'',
B.UserName,
B.Email,
B.ExternalID,C.Name AS ''CourseName'',
dbo.udfUTCtoDaylightSavingTime(B.DateCreated,@organisationID) AS ''DateCreated'',
case when B.Active =0 then coalesce(dbo.udfUTCtoDaylightSavingTime(B.DateArchived, @OrganisationID), dbo.udfUTCtoDaylightSavingTime(B.DateUpdated, @OrganisationID)) end as ''DateArchived''
FROM
(
select distinct userid, moduleid from @UsersQuizStatusNOTSTARTED) A,
tblUser B, tblCourse C, tblModule D, tblUnitHierarchy E
WHERE
A.UserID = B.UserID AND B.Active = 1 AND
A.ModuleID = D.ModuleID AND
B.UnitID = E.UnitID AND
D.CourseID = C.CourseID AND C.Active = 1 AND D.Active = 1
ORDER BY
CourseName, UnitPathWay, LastName, FirstName


end --/ Failed


-- Not started --

if @courseModuleStatus = @CONST_NOTSTARTED
begin -- Not started - Any
--------------------
-- Not started  --
--------------------
-- When "Course/Module Status" is set to "Not Started"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Courses
--  - AND who have not started ANY of the quizes they have access to in this course within the selected date range(DateCreated in vwUserQuizStatus)
--------------------


--Find All Modules for all units with access

INSERT INTO @UserModuleWithAccess
SELECT DISTINCT A.UserID, A.ModuleID, A.UnitID FROM
(
SELECT A.UserID, A.ModuleID, A.UnitID
FROM vwUserModuleAccess A where courseid in (SELECT courseid from @Courses) )A, @Users B
Where A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO @UsersNQuizStatus
SELECT  DISTINCT
A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(
SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID AND
A.LatestQuizID = B.UserQuizStatusID AND
(B.DateCreated BETWEEN @dateFrom AND dateadd(d,1,@dateTo))


--Get User with Quiz NOT STARTED
INSERT INTO @UsersQuizStatusNOTSTARTED
SELECT * FROM @UsersNQuizStatus WHERE QuizStatusID NOT IN (2,3,4,5) AND
UserID NOT IN (SELECT UserID FROM @UsersNQuizStatus WHERE QuizStatusID IN (2,3,4,5))


--Get Data in report format
SELECT DISTINCT
A.UserID,
B.UnitID ,
B.FirstName,
B.LastName,
case when B.Active = 1 then '''' else ''(i)'' end  as Flag,
dbo.udfGetUnitPathway(B.UnitID) AS ''UnitPathWay'',
dbo.udfUTCtoDaylightSavingTime(C.DateCreated,@organisationID) AS ''Date'',
B.UserName,
B.Email,
B.ExternalID,
C.Name AS ''CourseName'',
dbo.udfUTCtoDaylightSavingTime(B.DateCreated,@OrganisationID) as ''DateCreated'',
case when B.Active =0 then coalesce(dbo.udfUTCtoDaylightSavingTime(B.DateArchived,@OrganisationID),dbo.udfUTCtoDaylightSavingTime(B.DateUpdated,@OrganisationID)) end as ''DateArchived''
FROM
(select distinct userid, moduleid from @UsersQuizStatusNOTSTARTED) A,
tblUser B, tblCourse C, tblModule D, tblUnitHierarchy E
WHERE
A.UserID = B.UserID AND B.Active = 1 AND
A.ModuleID = D.ModuleID AND B.UnitID = E.UnitID AND
D.CourseID = C.CourseID AND C.Active = 1 AND D.Active = 1
ORDER BY
CourseName, UnitPathWay, LastName, FirstName

end --/ Not started - Any
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_DeleteReportInactive]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 15/12/2011
-- Description:	deletes report if owner and remove from cc if in cc list from periodic report on inactivating one user
-- =============================================
CREATE PROCEDURE [prcReport_DeleteReportInactive] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int = 0, 
	@UserId int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	IF EXISTS (SELECT * FROM tblReportSchedule 
		WHERE ScheduleID = @ScheduleId AND UserID = @UserId)
	BEGIN
		DELETE FROM tblReportSchedule
			WHERE ScheduleID = @ScheduleId 
			AND UserID = @UserId
	END
	
	IF EXISTS (SELECT * FROM tblCCList
		WHERE ScheduleId = @ScheduleId AND UserID = @UserId)
	BEGIN
		DELETE FROM tblCCList 
			WHERE ScheduleID = @ScheduleId
			AND UserId = @UserId
	END
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_EmailReportDistinctUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Used to build the CC list on step 2 of the report

Quiz Status
QuizStatusID Status
------------ --------------------------------------------------
0            Unassigned
1            Not Started
2            Passed
3            Failed
4            Expired (Time Elapsed)
5            Expired (New Content)

Course Status
CourseStatusID Status
-------------- --------------------------------------------------
0              Unassigned
1              InComplete
2              Complete

CourseModuleStatus enum
--------------------------------------------------
Complete	= 1,
Failed		= 2,
NotStarted	= 3,
Unknown		= 4

When "Course/Module Status" is set to "Complete"
This will find users that:
- Belong to any of the Units in @unitIDs
- AND are currently assigned Modules from the selected Course
- AND have the Custom Classification option
- AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
- AND the event that made them complete happened some time in the time-period in question

exec prcReport_EmailReportDistinctUsers
@organisationID = 3,
@unitIDs = ''5,6,7'',
@courseID = 5,
@classificationID = 1,
@courseModuleStatus = 0,
@quizDateFrom = ''Jan  1 2004 12:00:00:000AM'',
@quizDateTo = ''Sep 17 2004 11:59:59:000PM''

exec prcReport_EmailReportDistinctUsers
@organisationID = 3,
@unitIDs = ''5,6,7'',
@courseID = 5,
@classificationID = 1,
@courseModuleStatus = 3,
@quizDateFrom = ''Jan  1 2004 12:00:00:000AM'',
@quizDateTo = ''Sep 17 2004 11:59:59:000PM''


*/
CREATE        Proc [prcReport_EmailReportDistinctUsers]
(
@organisationID		int,
@unitIDs 			varchar(MAX),
@courseIDs 			varchar(8000),
@classificationID 	int,
@courseModuleStatus	int,
@quizDateFromOrg 		datetime,
@quizDateToOrg 		datetime,
@includeInactive	int
)
AS
------------------------------------------
Set Nocount On

DECLARE @quizDateFrom 		datetime
DECLARE @quizDateTo 		datetime
SET @quizDateFrom = dbo.udfDaylightSavingTimeToUTC(@quizDateFromOrg,@OrganisationID)
SET @quizDateTo = dbo.udfDaylightSavingTimeToUTC(@quizDateToOrg,@OrganisationID)




Declare
@CONST_INCOMPLETE     	int,
@CONST_COMPLETE     	int,
@CONST_FAILD            int,
@CONST_NOTSTARTED 	    int,
@CONST_UNKNOWN 	        int,
@CONST_EXPIRED_TIMELAPSED int,
@CONST_EXPIRED_NEWCONTENT int

set @CONST_INCOMPLETE	= 0
set @CONST_COMPLETE	    = 1
set @CONST_FAILD		= 2
set @CONST_NOTSTARTED	= 3
set @CONST_EXPIRED_TIMELAPSED	= 4
set @CONST_EXPIRED_NEWCONTENT  = 5

DECLARE @Units TABLE (UnitID INT)
DECLARE @Courses TABLE (CourseID INT)
DECLARE @CoursesWithAccess TABLE (CourseID INT PRIMARY KEY, [name] nvarchar(100))
DECLARE @UserModuleWithAccess TABLE (UserID INT, ModuleID INT, UnitID INT, PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE (ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE (UserID INT, UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @UsersQuizStatusNOTSTARTED TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

INSERT INTO
@Courses
SELECT
*
FROM
dbo.udfCsvToInt(@courseIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

--Get Rid of courses which do not have access to specified org
INSERT INTO
@CoursesWithAccess
SELECT
A.CourseID, [name]
FROM
@Courses A, tblOrganisationCourseAccess B, tblCourse C
WHERE
A.CourseID = B.GrantedCourseID
AND B.OrganisationID = @organisationID
AND A.CourseID = C.CourseID
AND C.Active = 1

--Get All the users for all specfied units
INSERT INTO
@Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
join  @Units B on A.UnitID = B.UnitID
join  tblUnit C on B.UnitID = C.UnitID  AND C.Active = 1
WHERE
@includeinactive =1 or A.Active = 1 -- show all or only active users



if @courseModuleStatus = @CONST_COMPLETE or @courseModuleStatus = @CONST_INCOMPLETE
begin -- completed / -- InComplete
--------------------
-- Completed --
--------------------
-- A user is completed if they became complete and remained completed in the period of interest
-- the query only needs to check to see status at the max date in this period as a line item
-- as tblUserCourseStatus is only writen to when an event occours that would
-- change the status.
-- When "Course/Module Status" is set to "Complete"
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question
--------------------
-- InComplete
--------------------
-- A user is in-completed if for any reason they are not complete but do have access to the course
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Incomplete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question

SELECT
DISTINCT A.UserID, F.HierarchyName, A.FirstName, A.LastName, dbo.udfUTCtoDaylightSavingTime(A.DateCreated, @organisationID) as DateCreated, dbo.udfUTCtoDaylightSavingTime(A.DateArchived, @organisationID) as DateArchived
FROM
(SELECT
A.UserID, D.UnitID, D.FirstName, D.LastName + case when D.Active <> 1 then ''(i)'' else '''' end as ''LastName'',
D.DateCreated as DateCreated, D.DateArchived as DateArchived, A.CourseID
FROM
(SELECT
A.UserID, A.CourseID, MAX(A.UserCourseStatusID) AS ''LatestCourseStatus''
FROM
tblUserCourseStatus A, @CoursesWithAccess B
WHERE
A.DateCreated < DATEADD(DD, 1, @quizDateTo)
and A.CourseID = B.CourseID
GROUP BY
A.UserID, A.CourseID
) A, @Users B, tblUserCourseStatus C, tblUser D
WHERE
A.UserID = B.UserID
AND B.UserID = C.UserID
AND A.LatestCourseStatus = C.UserCourseStatusID
AND (C.DateCreated BETWEEN @quizDateFrom AND @quizDateTo)
AND C.CourseStatusID = case @courseModuleStatus
when @CONST_COMPLETE then 2   -- Complete
when @CONST_INCOMPLETE then 1 -- InComplete
end
AND A.UserID = D.UserID
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
LEFT JOIN tblUnitHierarchy F ON F.UnitID = A.UnitID
WHERE
--If classification is Any (0), This will find users of any Custom Classification
(@classificationID =0 OR tblUserClassification.classificationID = @classificationID)
AND A.UserID IN (select UserID from tblUser where OrganisationID = @organisationID and Active = 1)
ORDER BY
F.HierarchyName, A.LastName, A.FirstName
END -- completed / -- InComplete


if @courseModuleStatus = @CONST_FAILD or @courseModuleStatus = @CONST_EXPIRED_TIMELAPSED or @courseModuleStatus = @CONST_EXPIRED_NEWCONTENT
begin -- Failed
--------------------
-- Failed  --
--------------------
-- When "Course/Module Status" is set to "Failed"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND took a quiz, for a Module within the selected Course, within the date range and failed it
--  - AND who currently have a status other than "Passed" for that same quiz
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
)A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID

INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID = case @courseModuleStatus
when @CONST_FAILD then 3   -- Failed
when @CONST_EXPIRED_TIMELAPSED then 4 -- Expired time lapsed
when @CONST_EXPIRED_NEWCONTENT then 5 -- Expired new content
end

--Get Data in report format
SELECT
DISTINCT A.UserID, C.HierarchyName, B.FirstName, B.LastName + case when B.Active <> 1 then ''(i)'' else '''' end as ''LastName'',
dbo.udfUTCtoDaylightSavingTime(B.DateCreated, @OrganisationID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime(B.DateArchived, @OrganisationID) as DateArchived
FROM
(select
distinct userid, moduleid
from
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D, tblUnitHierarchy C
WHERE
A.UserID = B.UserID
AND B.UnitID = C.UnitID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
ORDER BY
C.HierarchyName, B.LastName + case when B.Active <> 1 then ''(i)'' else '''' end, B.FirstName
end --/ Failed


-- Not started --

if @courseModuleStatus = @CONST_NOTSTARTED
begin -- Not started - Any
--------------------
-- Not started  --
--------------------
-- When "Course/Module Status" is set to "Not Started"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND who have not started ANY of the quizes they have access to in this course
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
) A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID
AND (B.DateCreated BETWEEN @quizDateFrom AND @quizDateTo)

--select * from @UsersNQuizStatus

--Get User with Quiz NOT STARTED
INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID NOT IN (2,3)
AND UserID NOT IN (SELECT UserID FROM @UsersNQuizStatus WHERE QuizStatusID IN (2,3))

--select * from @UsersQuizStatusNOTSTARTED
--select distinct userid,moduleid from @UsersQuizStatusNOTSTARTED

--Get Data in report format
SELECT
DISTINCT A.UserID, B.HierarchyName, A.LastName+ case when A.Active <> 1 then ''(i)'' else '''' end as ''LastName'',
A.FirstName,
dbo.udfUTCtoDaylightSavingTime(A.DateCreated, @OrganisationID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime(A.DateArchived, @OrganisationID) as DateArchived
FROM
(SELECT
DISTINCT A.UserID, B.UnitID, B.FirstName, B.LastName, B.active, B.DateCreated, B.DateArchived, courseid
FROM
(SELECT
DISTINCT userid, moduleid
FROM
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D
WHERE
A.UserID = B.UserID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
LEFT JOIN tblUnitHierarchy B ON B.UnitID = A.UnitID
WHERE
--If classification is Any (0), This will find users of any Custom Classification
@classificationID =0 OR tblUserClassification.classificationID = @classificationID
ORDER BY
B.HierarchyName, A.LastName+ case when A.Active <> 1 then ''(i)'' else '''' end, A.FirstName

end --/ Not started - Any


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_EmailReportToAdministrators]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Get a list of users that will appear in the administrtors email list

Returns:
AdminUserID,UserUnitID,Administrator Email,Administrator Name, Administrator''s Unit, User Unit, User name
AdminUserID,UserUnitID,Administrator Email,Administrator Name, Administrator''s Unit, User Unit, User name
AdminUserID,UserUnitID,Administrator Email,Administrator Name, Administrator''s Unit, User Unit, User name
AdminUserID,UserUnitID,Administrator Email,Administrator Name, Administrator''s Unit, User Unit, User name
AdminUserID,UserUnitID,Administrator Email,Administrator Name, Administrator''s Unit, User Unit, User name

order by AdminUserID,UserUnitID

Called By: Email report
Calls:

Remarks:

Sending to Administrators
If "Administrators" was selected as the Recipient Type, then the email will be sent to the administrators of the user''s Units.

If a user belongs to a Unit that does not have its own administrator, the email will go to the Organisation Administrators.

Only one email will be sent to each administrator.

Within the body of the email for each administrator will be the list of users who are in the Units which they administer. (See Appendix A).
The list will group the users into Units and have the Unit name as the heading for each group.



Author:Jack Liu
Date Created: 27 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcReport_EmailReportToAdministrators 3, ''42,48,11''

select * from tbluser where userID = 42

--------------------

**/

CREATE Proc [prcReport_EmailReportToAdministrators]
(
@organisationID int,
@unitIDs 			varchar(MAX),
@courseIDs 			varchar(8000),
@classificationID 	int,
@courseModuleStatus	int,
@quizDateFrom 		datetime,
@quizDateTo 		datetime,
@includeInactive	int
)

AS

Set Nocount On
DECLARE @quizDateFromOrg 		datetime
DECLARE @quizDateToOrg 		datetime
SET @quizDateFromOrg = dbo.udfDaylightSavingTimeToUTC(@quizDateFrom,@OrganisationID)
SET @quizDateToOrg = dbo.udfDaylightSavingTimeToUTC(@quizDateTo,@OrganisationID)

declare @tblUserUnit table
(
UserID int,
UnitID int
)


declare @tblUnit table
(
unitID int
)

declare @tblUnitAdministrator table
(
unitID int,
AdminUserID int
)
Set Nocount On
Declare
@CONST_INCOMPLETE     	int,
@CONST_COMPLETE     	int,
@CONST_FAILD            int,
@CONST_NOTSTARTED 	    int,
@CONST_UNKNOWN 	        int,
@CONST_EXPIRED_TIMELAPSED int,
@CONST_EXPIRED_NEWCONTENT int

set @CONST_INCOMPLETE	= 0
set @CONST_COMPLETE	    = 1
set @CONST_FAILD		= 2
set @CONST_NOTSTARTED	= 3
set @CONST_EXPIRED_TIMELAPSED	= 4
set @CONST_EXPIRED_NEWCONTENT  = 5

DECLARE @Units TABLE (UnitID INT)
DECLARE @Courses TABLE (CourseID INT)
DECLARE @CoursesWithAccess TABLE (CourseID INT PRIMARY KEY, [name] nvarchar(100))
DECLARE @UserModuleWithAccess TABLE (UserID INT, ModuleID INT, UnitID INT, PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE (ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE (UserID INT, UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @UsersQuizStatusNOTSTARTED TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

INSERT INTO
@Courses
SELECT
*
FROM
dbo.udfCsvToInt(@courseIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

--Get Rid of courses which do not have access to specified org
INSERT INTO
@CoursesWithAccess
SELECT
A.CourseID, [name]
FROM
@Courses A, tblOrganisationCourseAccess B, tblCourse C
WHERE
A.CourseID = B.GrantedCourseID
AND B.OrganisationID = @organisationID
AND A.CourseID = C.CourseID
AND C.Active = 1

--Get All the users for all specfied units
INSERT INTO
@Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
join  @Units B on A.UnitID = B.UnitID
join  tblUnit C on B.UnitID = C.UnitID  AND C.Active = 1
WHERE
@includeinactive =1 or A.Active = 1 -- show all or only active users



if @courseModuleStatus = @CONST_COMPLETE or @courseModuleStatus = @CONST_INCOMPLETE
begin -- completed / -- InComplete
--------------------
-- Completed --
--------------------
-- A user is completed if they became complete and remained completed in the period of interest
-- the query only needs to check to see status at the max date in this period as a line item
-- as tblUserCourseStatus is only writen to when an event occours that would
-- change the status.
-- When "Course/Module Status" is set to "Complete"
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question
--------------------
-- InComplete
--------------------
-- A user is in-completed if for any reason they are not complete but do have access to the course
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Incomplete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question

INSERT INTO @tblUserUnit(UserID, UnitID)
SELECT
DISTINCT A.UserID, A.UnitID
FROM
(SELECT
A.UserID, D.UnitID
FROM
(SELECT
A.UserID, A.CourseID, MAX(A.UserCourseStatusID) AS ''LatestCourseStatus''
FROM
tblUserCourseStatus A, @CoursesWithAccess B
WHERE
A.DateCreated < DATEADD(DD, 1, @quizDateToOrg)
and A.CourseID = B.CourseID
GROUP BY
A.UserID, A.CourseID
) A, @Users B, tblUserCourseStatus C, tblUser D
WHERE
A.UserID = B.UserID
AND B.UserID = C.UserID
AND A.LatestCourseStatus = C.UserCourseStatusID
AND (C.DateCreated BETWEEN @quizDateFromOrg AND @quizDateToOrg)
AND C.CourseStatusID = case @courseModuleStatus
when @CONST_COMPLETE then 2   -- Complete
when @CONST_INCOMPLETE then 1 -- InComplete
end
AND A.UserID = D.UserID
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
WHERE
--If classification is Any (0), This will find users of any Custom Classification
(@classificationID =0 OR tblUserClassification.classificationID = @classificationID)
AND A.UserID IN (select UserID from tblUser where OrganisationID = @organisationID and Active = 1)
ORDER BY
A.UserID, A.UnitID
END -- completed / -- InComplete


if @courseModuleStatus = @CONST_FAILD or @courseModuleStatus = @CONST_EXPIRED_TIMELAPSED or @courseModuleStatus = @CONST_EXPIRED_NEWCONTENT
begin -- Failed
--------------------
-- Failed  --
--------------------
-- When "Course/Module Status" is set to "Failed"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND took a quiz, for a Module within the selected Course, within the date range and failed it
--  - AND who currently have a status other than "Passed" for that same quiz
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
)A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID

INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID = case @courseModuleStatus
when @CONST_FAILD then 3   -- Failed
when @CONST_EXPIRED_TIMELAPSED then 4 -- Expired time lapsed
when @CONST_EXPIRED_NEWCONTENT then 5 -- Expired new content
end

--Get Data in report format
INSERT INTO @tblUserUnit(UserID, UnitID)
SELECT
DISTINCT A.UserID, UnitID
FROM
(select
distinct userid, moduleid
from
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D
WHERE
A.UserID = B.UserID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
ORDER BY
A.UserID, UnitID
end --/ Failed


-- Not started --

if @courseModuleStatus = @CONST_NOTSTARTED
begin -- Not started - Any
--------------------
-- Not started  --
--------------------
-- When "Course/Module Status" is set to "Not Started"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND who have not started ANY of the quizes they have access to in this course
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
) A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID
AND (B.DateCreated BETWEEN @quizDateFromOrg AND @quizDateToOrg)

--select * from @UsersNQuizStatus

--Get User with Quiz NOT STARTED
INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID NOT IN (2,3)
AND UserID NOT IN (SELECT UserID FROM @UsersNQuizStatus WHERE QuizStatusID IN (2,3))

--select * from @UsersQuizStatusNOTSTARTED
--select distinct userid,moduleid from @UsersQuizStatusNOTSTARTED

--Get Data in report format
INSERT INTO @tblUserUnit(UserID, UnitID)
SELECT
A.UserID, UnitID
FROM
(SELECT
DISTINCT A.UserID, B.UnitID
FROM
(SELECT
DISTINCT userid, moduleid
FROM
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D
WHERE
A.UserID = B.UserID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
WHERE
--If classification is Any (0), This will find users of any Custom Classification
@classificationID =0 OR tblUserClassification.classificationID = @classificationID
ORDER BY
A.UserID, UnitID

end --/ Not started - Any


insert into @tblUnit(UnitID)
select distinct UnitID
from @tblUserUnit

---If "Administrators" was selected as the Recipient Type, then the email will be sent to the administrators of the users Units.
insert into @tblUnitAdministrator (UnitID, AdminUserID)
select u.UnitID, ua.UserID
from @tblUnit u
inner join tblUnitAdministrator ua
on ua.UnitID = u.UnitID
inner join tblUser us
on us.UserID = ua.UserID and us.UserTypeID = 3 --Unit Administrator

--If a user belongs to a Unit that does not have its own administrator, the email will go to the Organisation Administrators.
insert into @tblUnitAdministrator (UnitID, AdminUserID)
select u.UnitID, us.UserID
from tblUser us
cross join @tblUnit u
where us.OrganisationID = @organisationID
and us.UserTypeID = 2 -- Organisation Administrator
and u.UnitID not in (select UnitID from @tblUnitAdministrator)
and us.Active = 1


-- Tidy up the results
SELECT
DISTINCT adminuserid userid, hierarchyname, lastname, firstname,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @OrganisationID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime(DateArchived, @OrganisationID) as DateArchived,
NULL courseid
FROM
@tblunitadministrator a
INNER JOIN tbluser u ON userid = a.adminuserid
INNER JOIN tblunithierarchy h ON h.unitid = u.unitid
WHERE
u.active = 1
ORDER BY
hierarchyname, adminuserid
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_EmailReportUserSearch]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
The e-mail report allows an administrator to e-mail users
who have failed or not completed their quizzes.
It can also email administrators notifying them of
users that they are responsible for who have failed or not
completed their quizzes.

Quiz Status
QuizStatusID Status
------------ --------------------------------------------------
0            Unassigned
1            Not Started
2            Passed
3            Failed
4            Expired (Time Elapsed)
5            Expired (New Content)

Course Status
CourseStatusID Status
-------------- --------------------------------------------------
0              Unassigned
1              InComplete
2              Complete

CourseModuleStatus enum
--------------------------------------------------
Complete	= 1,
Failed		= 2,
NotStarted	= 3,
Unknown		= 4

When "Course/Module Status" is set to "Complete"
This will find users that:
- Belong to any of the Units in @unitIDs
- AND are currently assigned Modules from the selected Course
- AND have the Custom Classification option
- AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
- AND the event that made them complete happened some time in the time-period in question

exec prcReport_EmailReportUserSearch
@organisationID = 3,
@unitIDs = ''5,6,7'',
@courseID = 5,
@classificationID = 1,
@courseModuleStatus = 0,
@quizDateFrom = ''Jan  1 2004 12:00:00:000AM'',
@quizDateTo = ''Sep 17 2004 11:59:59:000PM''

exec prcReport_EmailReportUserSearch
@organisationID = 3,
@unitIDs = ''5,6,7'',
@courseID = 5,
@classificationID = 1,
@courseModuleStatus = 3,
@quizDateFrom = ''Jan  1 2004 12:00:00:000AM'',
@quizDateTo = ''Sep 17 2004 11:59:59:000PM''


*/
CREATE        Proc [prcReport_EmailReportUserSearch]
(
@organisationID		int,
@unitIDs 			varchar(MAX),
@courseIDs 			varchar(8000),
@classificationID 	int,
@courseModuleStatus	int,
@quizDateFromOrg 		datetime,
@quizDateToOrg 		datetime,
@includeInactive	int
)
AS
------------------------------------------
Set Nocount On
DECLARE @quizDateFrom 		datetime
DECLARE @quizDateTo 		datetime
SET @quizDateFrom = dbo.udfDaylightSavingTimeToUTC(@quizDateFromOrg,@OrganisationID)
SET @quizDateTo = dbo.udfDaylightSavingTimeToUTC(@quizDateToOrg,@OrganisationID)


Declare
@CONST_INCOMPLETE     	int,
@CONST_COMPLETE     	int,
@CONST_FAILD            int,
@CONST_NOTSTARTED 	    int,
@CONST_UNKNOWN 	        int,
@CONST_EXPIRED_TIMELAPSED int,
@CONST_EXPIRED_NEWCONTENT int

set @CONST_INCOMPLETE	= 0
set @CONST_COMPLETE	    = 1
set @CONST_FAILD		= 2
set @CONST_NOTSTARTED	= 3
set @CONST_EXPIRED_TIMELAPSED	= 4
set @CONST_EXPIRED_NEWCONTENT  = 5

DECLARE @Units TABLE (UnitID INT)
DECLARE @Courses TABLE (CourseID INT)
DECLARE @CoursesWithAccess TABLE (CourseID INT PRIMARY KEY, [name] nvarchar(100))
DECLARE @UserModuleWithAccess TABLE (UserID INT, ModuleID INT, UnitID INT, PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE (ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE (UserID INT, UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @UsersQuizStatusNOTSTARTED TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

INSERT INTO
@Courses
SELECT
*
FROM
dbo.udfCsvToInt(@courseIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

--Get Rid of courses which do not have access to specified org
INSERT INTO
@CoursesWithAccess
SELECT
A.CourseID, [name]
FROM
@Courses A, tblOrganisationCourseAccess B, tblCourse C
WHERE
A.CourseID = B.GrantedCourseID
AND B.OrganisationID = @organisationID
AND A.CourseID = C.CourseID
AND C.Active = 1

--Get All the users for all specfied units
INSERT INTO
@Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
join  @Units B on A.UnitID = B.UnitID
join  tblUnit C on B.UnitID = C.UnitID  AND C.Active = 1
WHERE
@includeinactive =1 or A.Active = 1 -- show all or only active users



if @courseModuleStatus = @CONST_COMPLETE or @courseModuleStatus = @CONST_INCOMPLETE
begin -- completed / -- InComplete
--------------------
-- Completed --
--------------------
-- A user is completed if they became complete and remained completed in the period of interest
-- the query only needs to check to see status at the max date in this period as a line item
-- as tblUserCourseStatus is only writen to when an event occours that would
-- change the status.
-- When "Course/Module Status" is set to "Complete"
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question
--------------------
-- InComplete
--------------------
-- A user is in-completed if for any reason they are not complete but do have access to the course
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Incomplete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question

SELECT
DISTINCT cast(A.UserID AS varchar(10)) + '':'' + cast(A.courseid AS varchar(10)) userid
FROM
(SELECT
A.UserID, D.UnitID, D.FirstName, D.LastName + case when D.Active <> 1 then ''(i)'' else '''' end as ''LastName'',
dbo.udfUTCtoDaylightSavingTime(D.DateCreated, @organisationID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime(D.DateArchived, @organisationID) as DateArchived, A.CourseID
FROM
(SELECT
A.UserID, A.CourseID, MAX(A.UserCourseStatusID) AS ''LatestCourseStatus''
FROM
tblUserCourseStatus A, @CoursesWithAccess B
WHERE
A.DateCreated < DATEADD(DD, 1, @quizDateTo)
and A.CourseID = B.CourseID
GROUP BY
A.UserID, A.CourseID
) A, @Users B, tblUserCourseStatus C, tblUser D
WHERE
A.UserID = B.UserID
AND B.UserID = C.UserID
AND A.LatestCourseStatus = C.UserCourseStatusID
AND (C.DateCreated BETWEEN @quizDateFrom AND @quizDateTo)
AND C.CourseStatusID = case @courseModuleStatus
when @CONST_COMPLETE then 2   -- Complete
when @CONST_INCOMPLETE then 1 -- InComplete
end
AND A.UserID = D.UserID
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
LEFT JOIN tblUnitHierarchy F ON F.UnitID = A.UnitID
WHERE
--If classification is Any (0), This will find users of any Custom Classification
(@classificationID =0 OR tblUserClassification.classificationID = @classificationID)
AND A.UserID IN (select UserID from tblUser where OrganisationID = @organisationID and Active = 1)
END -- completed / -- InComplete


if @courseModuleStatus = @CONST_FAILD or @courseModuleStatus = @CONST_EXPIRED_TIMELAPSED or @courseModuleStatus = @CONST_EXPIRED_NEWCONTENT
begin -- Failed
--------------------
-- Failed  --
--------------------
-- When "Course/Module Status" is set to "Failed"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND took a quiz, for a Module within the selected Course, within the date range and failed it
--  - AND who currently have a status other than "Passed" for that same quiz
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
)A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID

INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID = case @courseModuleStatus
when @CONST_FAILD then 3   -- Failed
when @CONST_EXPIRED_TIMELAPSED then 4 -- Expired time lapsed
when @CONST_EXPIRED_NEWCONTENT then 5 -- Expired new content
end

--Get Data in report format
SELECT
DISTINCT cast(A.UserID AS varchar(10)) + '':'' + cast(courseid AS varchar(10)) userid
FROM
(select
distinct userid, moduleid
from
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D, tblUnitHierarchy C
WHERE
A.UserID = B.UserID
AND B.UnitID = C.UnitID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
end --/ Failed


-- Not started --

if @courseModuleStatus = @CONST_NOTSTARTED
begin -- Not started - Any
--------------------
-- Not started  --
--------------------
-- When "Course/Module Status" is set to "Not Started"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND who have not started ANY of the quizes they have access to in this course
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
) A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID
AND (B.DateCreated BETWEEN @quizDateFrom AND @quizDateTo)

--select * from @UsersNQuizStatus

--Get User with Quiz NOT STARTED
INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID NOT IN (2,3)
AND UserID NOT IN (SELECT UserID FROM @UsersNQuizStatus WHERE QuizStatusID IN (2,3))

--select * from @UsersQuizStatusNOTSTARTED
--select distinct userid,moduleid from @UsersQuizStatusNOTSTARTED

--Get Data in report format
SELECT
DISTINCT cast(A.UserID AS varchar(10)) + '':'' + cast(courseid AS varchar(10)) userid
FROM
(SELECT
DISTINCT A.UserID, B.UnitID, B.FirstName, B.LastName, B.active,
dbo.udfUTCtoDaylightSavingTime(B.DateCreated, @OrganisationID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime(B.DateArchived, @OrganisationID) as DateArchived,
courseid
FROM
(SELECT
DISTINCT userid, moduleid
FROM
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D
WHERE
A.UserID = B.UserID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
LEFT JOIN tblUnitHierarchy B ON B.UnitID = A.UnitID
WHERE
--If classification is Any (0), This will find users of any Custom Classification
@classificationID =0 OR tblUserClassification.classificationID = @classificationID

end --/ Not started - Any


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetCPDReportName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE   Procedure [prcReport_GetCPDReportName]
(
@OrgID int
)

As

select CPDReportName from tblorganisation where OrganisationID= @OrgID
' 
END
GO


SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetNextOnceOnlyReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcReport_GetNextOnceOnlyReport]

AS
BEGIN
	-- NextRun is saved in the ORGs timezone so that when an ORG goes into daylight saving the Report is run at the correct time.
	-- ALL other times are saved in the ORGs timezone to reduce load on the GUI when the ORGs timezone is changed
	-- NextRun is never null
	SET NOCOUNT ON
	DECLARE @ScheduleID int,
	@RunDate datetime, 
	@ReportStartDate datetime, 
	@ReportFrequencyPeriod char(1), 
	@ReportFrequency int, 
	@OrgID int	,
	@ReportFromDate datetime,
	@ReportPeriodType int,
	@NumberDelivered int,
	@ReportID int,
	@DateFrom DateTime
	SELECT @ScheduleID = ScheduleID
	FROM tblReportSchedule
	INNER JOIN tblReportInterface ON tblReportSchedule.ReportID = tblReportInterface.ReportID
	INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID  AND tblUser.Active = 1
	INNER JOIN tblOrganisation ON tblOrganisation.OrganisationID = tblReportSchedule.ParamOrganisationID
	WHERE  CourseStatusLastUpdated > dbo.udfGetSaltOrgMidnight(tblUser.OrganisationID)
	AND (NextRun <= dbo.udfUTCtoDaylightSavingTime(GETUTCDATE(),tblReportSchedule.ParamOrganisationID))
	AND (TerminatedNormally = 0)
	AND (IsPeriodic = ''O'')


	DECLARE @OnBehalfOf nvarchar(255)
	DECLARE @ReplyTo nvarchar(255)
	DECLARE @FromDate DateTime = CAST(''1 Jan 2002'' as datetime)

	IF (@ScheduleID IS NOT NULL)
	BEGIN
		DECLARE @NextRun datetime
		SELECT @NextRun = NextRun,
		@ReportStartDate = ReportStartDate,
		@ReportFrequencyPeriod = ReportFrequencyPeriod,
		@ReportFrequency = ReportFrequency,
		@OrgID = ParamOrganisationID,
		@ReportFromDate = ReportFromDate,
		@NumberDelivered = NumberDelivered,
		@ReportPeriodType = coalesce(ReportPeriodType ,3),
		@ReportID = ReportID,
		@DateFrom = ParamDateFrom
		FROM tblReportSchedule WHERE ScheduleID = @ScheduleID

		SET @RunDate = @NextRun


		SET @NextRun = dbo.udfReportSchedule_IncrementNextRunDate -- get the new NexrRun value
		(
			@RunDate , 
			@ReportStartDate , 
			@ReportFrequencyPeriod , 
			@ReportFrequency , 
			@OrgID 	
		)


		
		-- update the Report Schedule
		UPDATE tblReportSchedule -- Move NextRun,Lastrun forward by one period
		SET NumberDelivered = NumberDelivered + 1,
		TerminatedNormally = 1,
		NextRun = cast(''1 jan 2050'' as datetime),
		LastRun = @RunDate,
		LastUpdatedBy=0,
		Lastupdated=getUTCdate()
		
		WHERE ScheduleID = @ScheduleID

		-- get the Report period (we know the ''to'' date - just need to calculate the ''from'' date)
		IF ((@ReportPeriodType <> 2) AND (@ReportPeriodType <> 3))
		BEGIN
			SET @FromDate = CAST(''1 Jan 2002'' as datetime)
		END
		
		IF (@ReportPeriodType = 3) 
		BEGIN
			SET @FromDate = @ReportFromDate 
		END
		
		IF (@ReportPeriodType = 2) 
		BEGIN
			SET @FromDate =
		CASE 
			WHEN (@ReportFrequencyPeriod=''Y'') THEN DATEADD(YEAR,-@ReportFrequency,@RunDate)
			WHEN (@ReportFrequencyPeriod=''M'') THEN DATEADD(MONTH,-@ReportFrequency,@RunDate)
			WHEN (@ReportFrequencyPeriod=''W'') THEN DATEADD(WEEK,-@ReportFrequency,@RunDate)
			WHEN (@ReportFrequencyPeriod=''D'') THEN DATEADD(DAY,-@ReportFrequency,@RunDate)
			WHEN (@ReportFrequencyPeriod=''H'') THEN DATEADD(HOUR,-@ReportFrequency,@RunDate)
		END	

		END
		
		IF (@ReportID=10) OR (@ReportID=22) OR (@ReportID=23) OR (@ReportID=24)
		BEGIN
			SET @FromDate = @DateFrom
		END
				
		SELECT @OnBehalfOf = dbo.udfGetEmailOnBehalfOf (0)	
	END -- IF ScheduleID is not null


	-- return the results
	SET NOCOUNT OFF
	SELECT TOP (1) [ScheduleID]
	,RS.UserID
	,RS.ReportID
	,[LastRun]
	,[ReportStartDate]
	,[ReportFrequency]
	,[ReportFrequencyPeriod]
	,[DocumentType]
	,[ParamOrganisationID]
	,[ParamCompleted]
	,[ParamStatus]
	,[ParamFailCount]
	,[ParamCourseIDs]
	,[ParamHistoricCourseIDs]
	,[ParamAllUnits]
	,[ParamTimeExpired]
	,[ParamTimeExpiredPeriod]
	,[ParamQuizStatus]
	,[ParamGroupBy]
	,[ParamGroupingOption]
	,[ParamFirstName]
	,[ParamLastName]
	,[ParamUserName]
	,[ParamEmail]
	,[ParamIncludeInactive]
	,[ParamSubject]
	,[ParamBody]
	,[ParamProfileID]
	,[ParamProfilePeriodID]
	,[ParamPolicyIDs]
    ,[ParamAcceptance]
	,[ParamOnlyUsersWithShortfall]
	,[ParamEffectiveDate]
	,[ParamSortBy]
	,[ParamClassificationID]
	,ParamLangInterfaceName
	, case
	when tblReportinterface.ReportID = 26 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.2''))
	when tblReportinterface.ReportID = 27 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.2''))
	when tblReportinterface.ReportID = 3 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.1''))
	when tblReportinterface.ReportID = 6 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.1''))
		when (tblReportinterface.ReportID = 22) or (tblReportinterface.ReportID = 23) or (tblReportinterface.ReportID = 24) or (tblReportinterface.ReportID = 10) 
		then 
		(
			select coalesce(LangEntryValue, (select coalesce(tblLangValue.LangEntryValue,''Missing Localisation'') FROM tblLangValue where tblLang.LangID = tblLangValue.LangID   AND (tblLangValue.Active = 1) and tblLangValue.LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''Report.Summary'') and tblLangValue.LangResourceID = tblLangResource.LangResourceID))
		)

	else coalesce(tblLangValue.LangEntryValue,''Missing Localisation'')
	end as ReportName
	,tblReportInterface.RDLname
	,tblUser.FirstName
	,tblUser.LastName
	,tblUser.Email
	,ParamUnitIDs
	,paramOrganisationID
	,RS.ParamLangCode
	,ParamLangCode
	,ParamLicensingPeriod
	,RS.ReportEndDate
	,RS.ReportTitle
	,RS.NumberOfReports
	,RS.ReportFromDate
,(dbo.udfGetCCList(RS.ScheduleID)) as CCList
	,RS.ReportPeriodType
	,dbo.udfGetEmailOnBehalfOf (ParamOrganisationID) as OnBehalfOf
	,RS.NextRun
	,RS.ReportFromDate
	,@FromDate as FromDate
	,dbo.udfGetEmailReplyTo (ParamOrganisationID,tblUser.FirstName + '' '' + tblUser.LastName + '' <'' + tblUser.Email + ''>'') as ReplyTo
	,CASE when exists (SELECT Value FROM  tblAppConfig WHERE (Name = ''SEND_AUTO_EMAILS'') AND (UPPER(Value) = ''YES'')) then 0 ELSE 1 END as StopEmails
	,CAST(convert( varchar(11), dbo.udfUTCtoDaylightSavingTime(DATEADD(d,1,GETUTCDATE()),@OrgID),113) AS DateTime) as Tomorrow
	,CASE when tblUser.usertypeid=4 then dbo.udfUser_GetAdministratorsEmailAddress (tblUser.UserID) else tblUser.Email end as SenderEmail
	,IsPeriodic
	FROM
	tblReportinterface
	inner join tblReportSchedule RS  on tblReportinterface.ReportID = RS.ReportID	
	INNER JOIN tblUser ON RS.UserID = tblUser.UserID
	LEFT OUTER JOIN tblLang ON tblLang.LangCode = RS.ParamLangCode
	LEFT OUTER JOIN tblLangInterface ON  paramlanginterfacename = tblLangInterface.langinterfacename
	LEFT OUTER JOIN tblLangResource ON  tblLangResource.langresourcename = ''rptreporttitle''
	LEFT OUTER JOIN tblLangValue ON tblLang.LangID = tblLangValue.LangID   AND (tblLangValue.Active = 1) and tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID and tblLangValue.LangResourceID = tblLangResource.LangResourceID

	WHERE ScheduleID = @ScheduleID


END
' 
END
GO




SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetNextReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcReport_GetNextReport]

AS
BEGIN
	-- NextRun is saved in the ORGs timezone so that when an ORG goes into daylight saving the Report is run at the correct time.
	-- ALL other times are saved in the ORGs timezone to reduce load on the GUI when the ORGs timezone is changed
	
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET TerminatedNormally = 1
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		WHERE (TerminatedNormally = 0)
		AND (IsPeriodic = ''M'')
		AND ReportEndDate IS NULL -- flag to indicate that NumberOfReports is being used
		AND NumberOfReports IS NOT NULL
		AND NumberDelivered >= NumberOfReports 
	)
	
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET TerminatedNormally = 0
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		WHERE (TerminatedNormally = 1)
		AND (IsPeriodic = ''M'')
		AND ReportEndDate IS NULL -- flag to indicate that NumberOfReports is being used
		AND NumberOfReports IS NOT NULL
		AND NumberDelivered < NumberOfReports 
	)
	


	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET 
	LastRun = ''1 Jan 1997'',
	NextRun = dbo.udfReportSchedule_CalcNextRunDate 
	(
		ReportStartDate, 
		ReportStartDate , 
		ReportFrequencyPeriod , 
		ReportFrequency , 
		ParamOrganisationID 	
	)
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID
		WHERE (TerminatedNormally = 0)
		AND (IsPeriodic != ''N'')
		AND (tblUser.Active = 1)
		AND LASTRUN IS NULL
		AND NEXTRUN IS NULL
	)

	
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET LastRun = ''1 Jan 2001''
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID
		WHERE (TerminatedNormally = 0)
		AND (IsPeriodic != ''N'')
		AND (tblUser.Active = 1)
		AND LASTRUN IS NULL
	)
	
		
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET NextRun = dbo.udfReportSchedule_CalcNextRunDate 
	(
		LastRun , 
		ReportStartDate , 
		ReportFrequencyPeriod , 
		ReportFrequency , 
		ParamOrganisationID 	
	)
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID
		--WHERE (TerminatedNormally = 0)
		AND (IsPeriodic != ''N'')
		AND (tblUser.Active = 1)
		AND NEXTRUN IS NULL
	)
	
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET TerminatedNormally = 1
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		WHERE (TerminatedNormally = 0)
		AND (IsPeriodic = ''M'')
		AND ReportEndDate IS NOT NULL
		AND NextRun > ReportEndDate
		AND NumberOfReports IS NULL
	)
	
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET TerminatedNormally = 0
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		WHERE (TerminatedNormally = 1)
		AND (IsPeriodic = ''M'')
		AND ReportEndDate IS NOT NULL
		AND NextRun <= ReportEndDate
		AND NumberOfReports IS NULL
	)	
		
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET TerminatedNormally = 0
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		WHERE (TerminatedNormally = 1)
		AND (IsPeriodic = ''M'')
		AND ReportEndDate IS NULL 
		AND NumberOfReports IS  NULL
	)
	
	
	-- NextRun is never null
	SET NOCOUNT ON
	DECLARE @ScheduleID int,
	@RunDate datetime, 
	@ReportStartDate datetime, 
	@ReportFrequencyPeriod char(1), 
	@ReportFrequency int, 
	@OrgID int	,
	@ReportFromDate datetime,
	@NumberDelivered int,
	@NumberOfReports int,
	@ReportEndDate datetime,
	@ReportPeriodType int,
	@ReportID int

	SELECT @ScheduleID =  ScheduleID
	FROM tblReportSchedule
	INNER JOIN tblReportInterface ON tblReportSchedule.ReportID = tblReportInterface.ReportID
	INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID AND tblUser.Active = 1
	INNER JOIN tblOrganisation ON tblOrganisation.OrganisationID = tblReportSchedule.ParamOrganisationID
	WHERE  CourseStatusLastUpdated > dbo.udfGetSaltOrgMidnight(tblUser.OrganisationID)
	AND (NextRun <= dbo.udfUTCtoDaylightSavingTime(GETUTCDATE(),tblReportSchedule.ParamOrganisationID))
	AND (TerminatedNormally = 0)
	AND (IsPeriodic = ''M'')


	DECLARE @OnBehalfOf nvarchar(255)
	DECLARE @ReplyTo nvarchar(255)
	DECLARE @FromDate DateTime = CAST(''1 Jan 1997'' as datetime)
	DECLARE @DateFrom DateTime

	IF (@ScheduleID IS NOT NULL)
	BEGIN
		DECLARE @NextRun datetime
		SELECT @NextRun = NextRun,
		@ReportStartDate = ReportStartDate,
		@ReportFrequencyPeriod = ReportFrequencyPeriod,
		@ReportFrequency = ReportFrequency,
		@OrgID = ParamOrganisationID,
		@ReportFromDate = ReportFromDate,
		@NumberDelivered = NumberDelivered, 
		@NumberOfReports = NumberOfReports, 
		@ReportEndDate = ReportEndDate ,
		@ReportPeriodType = coalesce(ReportPeriodType ,3),
		@ReportID = ReportID,
		@DateFrom = ParamDateFrom
		FROM tblReportSchedule WHERE ScheduleID = @ScheduleID

		SET @RunDate = dbo.udfReportSchedule_CalcNextRunDate -- may have missed a couple of reports if the server was down so just verify that NEXTRUN makes sense
		(
			@NextRun,  
			@ReportStartDate , 
			@ReportFrequencyPeriod,  
			@ReportFrequency, 
			@OrgID
		)

		SET @NextRun = dbo.udfReportSchedule_IncrementNextRunDate -- get the new NexrRun value
		(
			@RunDate , 
			@ReportStartDate , 
			@ReportFrequencyPeriod , 
			@ReportFrequency , 
			@OrgID 	
		)
		-- now look for termination conditions
		DECLARE @TerminatedNormally bit = 0

		IF  @ReportEndDate IS NOT NULL AND (@ReportEndDate < @NextRun) BEGIN SET @TerminatedNormally = 1  END
		IF @NumberOfReports IS NOT NULL AND (@NumberOfReports < (@NumberDelivered + 1)) BEGIN SET @TerminatedNormally = 1  END
		
		-- update the Report Schedule
		UPDATE tblReportSchedule -- Move NextRun,Lastrun forward by one period
		SET NumberDelivered = NumberDelivered + 1,
		TerminatedNormally = @TerminatedNormally,
		LastRun = @RunDate,
		NextRun = @NextRun,
		LastUpdatedBy=0,
		Lastupdated=getUTCdate()
		WHERE ScheduleID = @ScheduleID

		-- get the Report period (we know the ''to'' date - just need to calculate the ''from'' date)

		IF ((@ReportPeriodType <> 2) AND (@ReportPeriodType <> 3))
		BEGIN
			SET @FromDate = CAST(''1 Jan 1997'' as datetime)
		END
		
		IF (@ReportPeriodType = 3) 
		BEGIN
			SELECT @FromDate = @RunDate 
		END
		
		IF (@ReportPeriodType = 2) 
		BEGIN
			SET @FromDate =
			CASE 
				WHEN (@ReportFrequencyPeriod=''Y'') THEN DATEADD(YEAR,-@ReportFrequency,@RunDate)
				WHEN (@ReportFrequencyPeriod=''M'') THEN DATEADD(MONTH,-@ReportFrequency,@RunDate)
				WHEN (@ReportFrequencyPeriod=''W'') THEN DATEADD(WEEK,-@ReportFrequency,@RunDate)
				WHEN (@ReportFrequencyPeriod=''D'') THEN DATEADD(DAY,-@ReportFrequency,@RunDate)
				WHEN (@ReportFrequencyPeriod=''H'') THEN DATEADD(HOUR,-@ReportFrequency,@RunDate)
			END	
	    END
		IF (@ReportID=10) OR (@ReportID=22) OR (@ReportID=23) OR (@ReportID=24)
		BEGIN
			SET @FromDate = @DateFrom
		END
		
	SELECT @OnBehalfOf = dbo.udfGetEmailOnBehalfOf (@OrgID)	
	END -- IF ScheduleID is not null


	-- return the results
	SET NOCOUNT OFF
	SELECT TOP (1) [ScheduleID]
	,RS.UserID
	,RS.ReportID
	,[LastRun]
	,[ReportStartDate]
	,[ReportFrequency]
	,[ReportFrequencyPeriod]
	,[DocumentType]
	,[ParamOrganisationID]
	,[ParamCompleted]
	,[ParamStatus]
	,[ParamFailCount]
	,[ParamCourseIDs]
	,[ParamHistoricCourseIDs]
	,[ParamAllUnits]
	,[ParamTimeExpired]
	,[ParamTimeExpiredPeriod]
	,[ParamQuizStatus]
	,[ParamGroupBy]
	,[ParamGroupingOption]
	,[ParamFirstName]
	,[ParamLastName]
	,[ParamUserName]
	,[ParamEmail]
	,[ParamIncludeInactive]
	,[ParamSubject]
	,[ParamBody]
	,[ParamProfileID]
	,[ParamProfilePeriodID]
	,[ParamPolicyIDs]
    ,[ParamAcceptance]
	,[ParamOnlyUsersWithShortfall]
	,[ParamEffectiveDate]
	,[ParamSortBy]
	,[ParamClassificationID]
	,ParamLangInterfaceName
	, case
	when tblReportinterface.ReportID = 26 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.2''))
	when tblReportinterface.ReportID = 27 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.2''))
	when tblReportinterface.ReportID = 3 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.1''))
	when tblReportinterface.ReportID = 6 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.1''))
	when (tblReportinterface.ReportID = 22) or (tblReportinterface.ReportID = 23) or (tblReportinterface.ReportID = 24) or (tblReportinterface.ReportID = 10) 
	then 
		(
			select coalesce(LangEntryValue, (select coalesce(tblLangValue.LangEntryValue,''Missing Localisation'') FROM tblLangValue where tblLang.LangID = tblLangValue.LangID   AND (tblLangValue.Active = 1) and tblLangValue.LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''Report.Summary'') and tblLangValue.LangResourceID = tblLangResource.LangResourceID))
		)

	else coalesce(tblLangValue.LangEntryValue,''Missing Localisation'')
	end as ReportName
	,tblReportInterface.RDLname
	,tblUser.FirstName
	,tblUser.LastName
	,tblUser.Email
	,ParamUnitIDs
	,paramOrganisationID
	,RS.ParamLangCode
	,ParamLangCode
	,ParamLicensingPeriod
	,RS.ReportEndDate
	,RS.ReportTitle
	,RS.NumberOfReports
	,RS.ReportFromDate
,(dbo.udfGetCCList(RS.ScheduleID)) as CCList
	,RS.ReportPeriodType
	,dbo.udfGetEmailOnBehalfOf (ParamOrganisationID) as OnBehalfOf
	,RS.NextRun
	,@FromDate as FromDate
	,dbo.udfGetEmailReplyTo (ParamOrganisationID,tblUser.FirstName + '' '' + tblUser.LastName + '' <'' + tblUser.Email + ''>'') as ReplyTo
	,CASE when exists (SELECT Value FROM  tblAppConfig WHERE (Name = ''SEND_AUTO_EMAILS'') AND (UPPER(Value) = ''YES'')) then 0 ELSE 1 END as StopEmails
	,CAST(convert( varchar(11), dbo.udfUTCtoDaylightSavingTime(DATEADD(d,1,GETUTCDATE()),@OrgID),113) AS DateTime) as Tomorrow
,CASE when tblUser.usertypeid=4 then dbo.udfUser_GetAdministratorsEmailAddress (tblUser.UserID) else tblUser.Email end as SenderEmail
    ,IsPeriodic
	FROM
	tblReportinterface
	inner join tblReportSchedule RS  on tblReportinterface.ReportID = RS.ReportID
	INNER JOIN tblUser ON RS.UserID = tblUser.UserID
	LEFT OUTER JOIN tblLang ON tblLang.LangCode = RS.ParamLangCode
	LEFT OUTER JOIN tblLangInterface ON  paramlanginterfacename = tblLangInterface.langinterfacename
	LEFT OUTER JOIN tblLangResource ON  tblLangResource.langresourcename = ''rptreporttitle''
	LEFT OUTER JOIN tblLangValue ON tblLang.LangID = tblLangValue.LangID   AND (tblLangValue.Active = 1) and tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID and tblLangValue.LangResourceID = tblLangResource.LangResourceID

	WHERE ScheduleID = @ScheduleID


END
' 
END
GO




SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetNextUrgentReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [dbo].[prcReport_GetNextUrgentReport]

AS
BEGIN
-- Only returns NOW schedules - Send these first to give a greater sense of response by the application
-- NEXTRUN is always saved in UTC to reduce conversion times
-- NextRun is never null
SET NOCOUNT ON

DECLARE @ScheduleID int,
@RunDate datetime,
@ReportStartDate datetime,
@ReportFrequencyPeriod char(1),
@ReportFrequency int,
@OrgID int	,
@ReportFromDate datetime,
@NumberDelivered int,
@NumberOfReports int,
@ReportEndDate datetime,
@ReportPeriodType int,
@ReportID int,
@DateFrom DateTime

UPDATE tblReportSchedule -- remove schedules for inactive users
SET NumberDelivered = 0,
TerminatedNormally = 1,
LastRun = getUTCdate(),
NextRun = null
WHERE ScheduleID in
(
SELECT ScheduleID
FROM tblReportSchedule
INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID
WHERE (TerminatedNormally = 0)
AND (IsPeriodic = ''N'')
AND (tblUser.Active = 0)
)

SELECT @ScheduleID = ScheduleID
FROM tblReportSchedule
INNER JOIN tblReportInterface ON tblReportSchedule.ReportID = tblReportInterface.ReportID
INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID
INNER JOIN tblOrganisation ON tblOrganisation.OrganisationID = tblReportSchedule.ParamOrganisationID
WHERE  CourseStatusLastUpdated > dbo.udfGetSaltOrgMidnight(tblUser.OrganisationID)
AND (TerminatedNormally = 0)
AND (IsPeriodic = ''N'')
AND (tblUser.Active = 1)

DECLARE @OnBehalfOf nvarchar(255)
DECLARE @ReplyTo nvarchar(255)
DECLARE @FromDate DateTime = CAST(''1 Jan 2002'' as datetime)

IF (@ScheduleID IS NOT NULL)
BEGIN
DECLARE @NextRun datetime
SELECT @NextRun = NextRun,
@ReportStartDate = ReportStartDate,
@ReportFrequencyPeriod = ReportFrequencyPeriod,
@ReportFrequency = ReportFrequency,
@OrgID = ParamOrganisationID,
@ReportFromDate = ReportFromDate,
@NumberDelivered = NumberDelivered,
@NumberOfReports = NumberOfReports,
@ReportEndDate = ReportEndDate ,
@ReportPeriodType = coalesce(ReportPeriodType ,3),
@ReportID = ReportID,
@DateFrom = ParamDateFrom
FROM tblReportSchedule WHERE ScheduleID = @ScheduleID

-- we know the to date - just need to read the from date
SET @FromDate = @ReportStartDate

-- except if its these reports
IF (@ReportID=2) or (@ReportID = 25)
BEGIN
SET @FromDate = @DateFrom 
END




END -- IF ScheduleID is not null


-- return the results
SET NOCOUNT OFF
SELECT TOP (1) [ScheduleID]
,RS.UserID
,RS.ReportID
,RS.ParamDateTo as LastRun
,[ReportStartDate]
,[ReportFrequency]
,[ReportFrequencyPeriod]
,[DocumentType]
,[ParamOrganisationID]
,[ParamCompleted]
,[ParamStatus]
,[ParamFailCount]
,[ParamCourseIDs]
,[ParamHistoricCourseIDs]
,[ParamAllUnits]
,[ParamTimeExpired]
,[ParamTimeExpiredPeriod]
,[ParamQuizStatus]
,[ParamGroupBy]
,[ParamGroupingOption]
,[ParamFirstName]
,[ParamLastName]
,[ParamUserName]
,[ParamEmail]
,[ParamIncludeInactive]
,[ParamSubject]
,[ParamBody]
,[ParamProfileID]
,[ParamProfilePeriodID]
,[ParamPolicyIDs]
,[ParamAcceptance]
,[ParamOnlyUsersWithShortfall]
,[ParamEffectiveDate]
,[ParamSortBy]
,[ParamClassificationID]
,ParamLangInterfaceName
, case
when tblReportinterface.ReportID = 26 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.2''))
when tblReportinterface.ReportID = 27 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.2''))
when tblReportinterface.ReportID = 3 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.1''))
when tblReportinterface.ReportID = 6 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.1''))
when (tblReportinterface.ReportID = 22) or (tblReportinterface.ReportID = 23) or (tblReportinterface.ReportID = 24) or (tblReportinterface.ReportID = 10)
then
(
select coalesce(LangEntryValue, (select coalesce(tblLangValue.LangEntryValue,''Missing Localisation'') FROM tblLangValue where tblLang.LangID = tblLangValue.LangID   AND (tblLangValue.Active = 1) and tblLangValue.LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''Report.Summary'') and tblLangValue.LangResourceID = tblLangResource.LangResourceID))
)

else coalesce(tblLangValue.LangEntryValue,''Missing Localisation'')
end as ReportName
,tblReportInterface.RDLname
,tblUser.FirstName
,tblUser.LastName
,tblUser.Email
,ParamUnitIDs
,paramOrganisationID
,RS.ParamLangCode
,ParamLangCode
,ParamLicensingPeriod
,RS.ReportEndDate
,RS.ReportTitle
,RS.NumberOfReports
,RS.ReportFromDate
,(dbo.udfGetCCList(RS.ScheduleID)) as CCList
,RS.ReportPeriodType
,dbo.udfGetEmailOnBehalfOf (ParamOrganisationID) as OnBehalfOf
,RS.NextRun
,RS.ReportFromDate
,@FromDate as FromDate
,dbo.udfGetEmailReplyTo (ParamOrganisationID,tblUser.FirstName + '' '' + tblUser.LastName + '' <'' + tblUser.Email + ''>'') as ReplyTo
,CASE when exists (SELECT Value FROM  tblAppConfig WHERE (Name = ''SEND_AUTO_EMAILS'') AND (UPPER(Value) = ''YES'')) then 0 ELSE 1 END as StopEmails
,CAST(convert( varchar(11), dbo.udfUTCtoDaylightSavingTime(DATEADD(d,1,GETUTCDATE()),@OrgID),113) AS DateTime) as Tomorrow
,CASE when tblUser.usertypeid=4 then dbo.udfUser_GetAdministratorsEmailAddress (tblUser.UserID) else tblUser.Email end as SenderEmail
,IsPeriodic
FROM
tblReportinterface
inner join tblReportSchedule RS  on tblReportinterface.ReportID = RS.ReportID
INNER JOIN tblUser ON RS.UserID = tblUser.UserID
LEFT OUTER JOIN tblLang ON tblLang.LangCode = RS.ParamLangCode
LEFT OUTER JOIN tblLangInterface ON  paramlanginterfacename = tblLangInterface.langinterfacename
LEFT OUTER JOIN tblLangResource ON  tblLangResource.langresourcename = ''rptreporttitle''
LEFT OUTER JOIN tblLangValue ON tblLang.LangID = tblLangValue.LangID   AND (tblLangValue.Active = 1) and tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID and tblLangValue.LangResourceID = tblLangResource.LangResourceID

WHERE ScheduleID = @ScheduleID


-- remove spent "NOW" Schedule to reduce size of table
DELETE FROM tblReportSchedule
WHERE ScheduleID = @ScheduleID

END
' 
END



GO




SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetReportRequiredParameters]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcReport_GetReportRequiredParameters]
@ReportID int
AS
BEGIN
SELECT [ReportID]
,[ReportName]
,[RDLname]
,[RequiresParamCompleted]
,[RequiresParamStatus]
,[RequiresParamFailCount]
,[RequiresParamCourseID]
,[RequiresParamCourseIDs]
,[RequiresParamHistoricCourseIDs]
,[RequiresParamUnitIDs]
,[RequiresParamAllUnits]
,[RequiresParamTimeExpired]
,[RequiresParamTimeExpiredPeriod]
,[RequiresParamQuizStatus]
,[RequiresParamGroupBy]
,[RequiresParamGroupingOption]
,[RequiresParamFirstName]
,[RequiresParamLastName]
,[RequiresParamUserName]
,[RequiresParamEmail]
,[RequiresParamIncludeInactive]
,[RequiresParamSubject]
,[RequiresParamBody]
,[RequiresParamDateTo]
,[RequiresParamDateFrom]
,[RequiresParamProfileID]
,[RequiresParamProfilePeriodID]
,[RequiresParamPolicyIDs]
,[RequiresParamAcceptanceStatus]
,[RequiresParamOnlyUsersWithShortfall]
,[ParamLangInterfaceName]
,[RequiresParamEffectiveDate]
,[RequiresParamSortBy]
,[RequiresParamClassificationID]
,[RequiresParamServerURL]
,[RequiresParamToDate]
,[RequiresParamFromDate]
,[RequiresParamUserID]
,[RequiresParamAdminUserID]
,[RequiresParamOrganisationID]

FROM tblReportInterface
WHERE ReportID = @ReportID
end
' 
END
GO




SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetTypeFromID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 10/11/2011
-- Description:	Gets report type name from report id
-- =============================================
CREATE PROCEDURE [prcReport_GetTypeFromID] 
	-- Add the parameters for the stored procedure here
	@ReportId int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT ReportName FROM tblReportInterface
		WHERE ReportID = @ReportId
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetTypeFromScheduleId]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 10/11/2011
-- Description:	Gets report type id from schedule id
-- =============================================
CREATE PROCEDURE [prcReport_GetTypeFromScheduleId] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT ReportName FROM tblReportSchedule rs
		JOIN tblReportInterface ri ON  rs.ReportID = ri.ReportID
		WHERE rs.ScheduleID = @ScheduleId
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Individual]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Given a user id returns the list of courses / modules and the latest results for that user
If the User id is ommited it returns results for all users
Returns:
Course ID

Called By:
Home.aspx via Businessservices.Report.GetIndividualReport
Calls:
udfReport_IndividualDetails
Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Peter Kneale	8/3/04			Modified, removed two level tier report format



--------------------

**/

CREATE       Proc [prcReport_Individual]
(
@userID int = null -- the user ID
)
AS
------------------------------------------
Set Nocount On

Select

UserID
, CourseID
, CourseName
, ModuleID
, ModuleName
, LessonID
, tLS.Status as ''LessonStatus''
, tQS.Status as ''QuizStatus''
, QuizScore
, QuizPassMark
, [Sequence]

From
udfReport_IndividualDetails(@userID) tID
--< inner join onto lesson status to get the name of the status>--
inner join tblLessonStatus tLS
on tLS.LessonStatusID = tID.LessonStatus
inner join tblQuizStatus tQS
on tQS.QuizStatusID =  tID.QuizStatus

Order by userid, CourseID, [Sequence]
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Licensing]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE Procedure [prcReport_Licensing]
(
@strCourseLicensingID varchar(8000),
@OrganisationID int
)
AS

BEGIN

IF (@strCourseLicensingID = ''0'')
BEGIN
SELECT
Header.Name as CourseName,
Header.LicenseNumber,
Header.Period,
Header.LicensesRemaining,
tblUnitHierarchy.HierarchyName as UnitPathway,
tblUser.FirstName + '' '' + tblUser.LastName AS FullName,
tblUser.ExternalID,
tblUser.Email,
dbo.udfUTCtoDaylightSavingTime(tblUser.DateCreated, @OrganisationID) as DateCreated,
tblUser.Active,
CASE
WHEN (tblUser.Active = 0 AND DateArchived IS NULL) THEN ''YES''
ELSE CONVERT(varchar, dbo.udfUTCtoDaylightSavingTime(DateArchived, @OrganisationID), 103)
END AS DateArchive,
Header.LicensesUsed
FROM tblCourseLicensingUser
INNER JOIN tblUser ON tblCourseLicensingUser.UserID = tblUser.UserID
INNER JOIN tblUnitHierarchy ON tblUser.UnitID = tblUnitHierarchy.UnitID
RIGHT JOIN tblCourseLicensing ON tblCourseLicensingUser.CourseLicensingID = tblCourseLicensing.CourseLicensingID
and tblCourseLicensing.OrganisationID = @OrganisationID
RIGHT JOIN (
SELECT	tblCourseLicensing.CourseLicensingID,
tblCourse.Name,
tblCourseLicensing.LicenseNumber,
CONVERT(varchar, dbo.udfUTCtoDaylightSavingTime(tblCourseLicensing.DateStart, @OrganisationID), 103) + '' - '' + CONVERT(varchar, dbo.udfUTCtoDaylightSavingTime(tblCourseLicensing.DateEnd, @OrganisationID), 103) AS Period,
tblCourseLicensing.LicenseNumber - coalesce(COUNT(tblCourseLicensingUser.CourseLicensingUserID),0) AS LicensesRemaining,
coalesce(COUNT(tblCourseLicensingUser.CourseLicensingUserID),0) AS LicensesUsed
FROM tblCourseLicensingUser AS tblCourseLicensingUser
RIGHT JOIN tblCourseLicensing ON  tblCourseLicensingUser.CourseLicensingID = tblCourseLicensing.CourseLicensingID
and tblCourseLicensing.OrganisationID = @OrganisationID
INNER JOIN tblCourse ON tblCourseLicensing.CourseID = tblCourse.CourseID
WHERE tblCourseLicensing.OrganisationID = @OrganisationID
GROUP BY tblCourse.Name, tblCourseLicensing.LicenseNumber, tblCourseLicensing.DateStart,
tblCourseLicensing.DateEnd, tblCourseLicensing.CourseLicensingID
HAVING      (tblCourseLicensing.DateStart < GETUTCDATE()) AND (dateadd(d,1,tblCourseLicensing.DateEnd) > GETUTCDATE())
) AS Header ON tblCourseLicensing.CourseLicensingID = Header.CourseLicensingID
order by tblUnitHierarchy.HierarchyName,Header.Name,tblUser.FirstName + '' '' + tblUser.LastName

END
ELSE
BEGIN
SELECT
Header.Name as CourseName,
Header.LicenseNumber,
Header.Period,
Header.LicensesRemaining,
tblUnitHierarchy.HierarchyName as UnitPathway,
tblUser.FirstName + '' '' + tblUser.LastName AS FullName,
tblUser.ExternalID,
tblUser.Email,
dbo.udfUTCtoDaylightSavingTime(tblUser.DateCreated, @OrganisationID) as DateCreated,
tblUser.Active,
CASE
WHEN (tblUser.Active = 0 AND DateArchived IS NULL) THEN ''YES''
ELSE CONVERT(varchar, dbo.udfUTCtoDaylightSavingTime(DateArchived, @OrganisationID), 103)
END AS DateArchive,
Header.LicensesUsed
FROM tblCourseLicensingUser
INNER JOIN tblUser ON tblCourseLicensingUser.UserID = tblUser.UserID
INNER JOIN tblUnitHierarchy ON tblUser.UnitID = tblUnitHierarchy.UnitID
RIGHT JOIN tblCourseLicensing ON tblCourseLicensingUser.CourseLicensingID = tblCourseLicensing.CourseLicensingID
and tblCourseLicensing.OrganisationID = @OrganisationID
RIGHT JOIN (
SELECT	tblCourseLicensing.CourseLicensingID,
tblCourse.Name,
tblCourseLicensing.LicenseNumber,
CONVERT(varchar, dbo.udfUTCtoDaylightSavingTime(tblCourseLicensing.DateStart, @OrganisationID), 103) + '' - '' + CONVERT(varchar, dbo.udfUTCtoDaylightSavingTime(tblCourseLicensing.DateEnd, @OrganisationID), 103) AS Period,
tblCourseLicensing.LicenseNumber - coalesce(COUNT(tblCourseLicensingUser.CourseLicensingUserID),0) AS LicensesRemaining,
coalesce(COUNT(tblCourseLicensingUser.CourseLicensingUserID),0) AS LicensesUsed
FROM tblCourseLicensingUser AS tblCourseLicensingUser
RIGHT JOIN tblCourseLicensing ON tblCourseLicensingUser.CourseLicensingID = tblCourseLicensing.CourseLicensingID
and tblCourseLicensing.OrganisationID = @OrganisationID
INNER JOIN tblCourse ON tblCourseLicensing.CourseID = tblCourse.CourseID
inner join dbo.udfCsvToInt(@strCourseLicensingID) as CourseLicensing on CourseLicensing.IntValue= tblCourseLicensing.CourseLicensingID
WHERE tblCourseLicensing.OrganisationID = @OrganisationID
GROUP BY tblCourse.Name, tblCourseLicensing.LicenseNumber, dbo.udfUTCtoDaylightSavingTime(tblCourseLicensing.DateStart, @OrganisationID),
dbo.udfUTCtoDaylightSavingTime(tblCourseLicensing.DateEnd, @OrganisationID), tblCourseLicensing.CourseLicensingID
) AS Header ON tblCourseLicensing.CourseLicensingID = Header.CourseLicensingID
order by tblUnitHierarchy.HierarchyName,Header.Name,tblUser.FirstName + '' '' + tblUser.LastName
END
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Policies]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/******************************************************************************
**		File: dbo.prcReport_Policies.PRC
**		Name: prcReport_Policies
**		Desc: For reporting of Policy acceptance by users
**
**		Return values:
**			Policy
**			UnitPathway
**			Lastname
**			Firstname
**			Email
**			Accepted
**			DateAccepted
**
**		Called by:
**
**		Parameters:
**			@organisationID Integer = ''0''
**			@policyIDs varchar(8000) = ''0''
**			@unitIDs varchar(8000) = ''0''
**			@dateFrom datetime = Null
**			@dateTo datetime = Null
**			@acceptanceStatus varchar(20) = ''BOTH''
**			@includeInactiveUsers varchar(5) = ''false''
**
**		Input							Output
**     ----------							-----------
**
**		Auth: Chris Plewright
**		Date: 31 Jul 2008
**
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		--------		--------				-------------------------------------------
**		14/08/2009		Mark Donald				More detail in Order By clause
**												+ extra column (userid) in result set
**		09/06/2011		J hedlefs				tIMEZONE
*******************************************************************************/
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.

CREATE Procedure [dbo].[prcReport_Policies]
@organisationID Integer = ''0'',
@policyIDs varchar(8000) = ''0'',
@unitIDs varchar(max) = ''0'',
@dateFromOrg datetime = Null,
@dateToOrg datetime = Null,
@acceptanceStatus varchar(20) = ''BOTH'',
@includeInactiveUsers varchar(5) = ''false''
AS

BEGIN

SET NOCOUNT ON;
DECLARE @dateFrom 		datetime
DECLARE @dateTo 		datetime
SET @dateFrom = dbo.udfDaylightSavingTimeToUTC(@dateFromOrg,@OrganisationID)
SET @dateTo = dbo.udfDaylightSavingTimeToUTC(@dateToOrg,@OrganisationID)

select
Policy = pol.PolicyName + '' ('' + pol.PolicyFileName + '')'',
UnitPathway = tblUnitHierarchy.HierarchyName,
--tblUser.Lastname,
CASE
WHEN tblUser.Active = 0 then LastName + '' (I)''
ELSE LastName
END AS LastName,
tblUser.Firstname,
tblUser.Email,
tblUser.userid,
Accepted = case when ua1.Accepted = 1  and (ua1.DateAccepted >= @dateFrom and ua1.DateAccepted <= @dateTo) then ''Yes'' else ''No'' end,
case when ua1.DateAccepted >= @dateFrom and ua1.DateAccepted <= @dateTo then  dbo.udfUTCtoDaylightSavingTime(ua1.DateAccepted,@OrganisationID)  else null end as DateAccepted
from tblPolicy pol
join tblOrganisation org on org.OrganisationID = pol.Organisationid and org.OrganisationID = @OrganisationID
join tblUser on tblUser.OrganisationID = org.OrganisationID and (@includeInactiveUsers=''true'' or tblUser.Active=1) and tblUser.UnitID in (select IntValue from dbo.udfCsvToInt(@unitIDs))
join tblUserPolicyAccepted ua1 on pol.PolicyID = ua1.PolicyID and tblUser.UserID = ua1.UserID
join tblUnitHierarchy on tblUser.UnitID = tblUnitHierarchy.UnitID
left join tblUserPolicyAccess upa on upa.PolicyID = pol.PolicyID and upa.UserID = tblUser.Userid
where upa.granted = 1 and pol.Active = 1 and pol.Deleted = 0 and pol.uploaddate between @dateFrom and @dateTo
and pol.PolicyID in ( select IntValue from dbo.udfCsvToInt(@policyIDs ) )
and (
--Condition A - ACCEPTED
( @acceptanceStatus=''ACCEPTED'' and exists(select * from tblUserPolicyAccepted where pol.PolicyID = tblUserPolicyAccepted.PolicyID and tblUser.UserID = tblUserPolicyAccepted.UserID and tblUserPolicyAccepted.DateAccepted >= @dateFrom and tblUserPolicyAccepted.DateAccepted <= @dateTo and tblUserPolicyAccepted.Accepted = 1 ) )
or
--Condition B - NOT_ACCEPTED
( @acceptanceStatus=''NOT_ACCEPTED'' and not exists(select * from tblUserPolicyAccepted where pol.PolicyID = tblUserPolicyAccepted.PolicyID and tblUser.UserID = tblUserPolicyAccepted.UserID and tblUserPolicyAccepted.DateAccepted >= @dateFrom and tblUserPolicyAccepted.DateAccepted <= @dateTo and tblUserPolicyAccepted.Accepted = 1) )
or
--Condition C - BOTH
@acceptanceStatus=''BOTH''
)
--and (@includeInactiveUsers=''true'' and exists )
ORDER BY policy, unitpathway, lastname, firstname

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_PoliciesGrandTotal]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/******************************************************************************
**		File: dbo.prcReport_PoliciesGrandTotal.PRC
**		Name: prcReport_PoliciesGrandTotal
**		Desc: counts total distinct users in policies report - basically, it''s a copy
**				of that report with the selects changed to return a total instead of data
**
**		Parameters:
**			@organisationID Integer = ''0''
**			@policyIDs varchar(8000) = ''0''
**			@unitIDs varchar(8000) = ''0''
**			@dateFrom datetime = Null
**			@dateTo datetime = Null
**			@acceptanceStatus varchar(20) = ''BOTH''
**			@includeInactiveUsers varchar(5) = ''false''
**
**		Input							Output
**     ----------							-----------
**
**		Auth: Mark Donald
**		Date: 27 Aug 2009
**
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		--------		--------				-------------------------------------------
**		09/06/2011	j hedlefs			timezone
*******************************************************************************/
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
CREATE Procedure [dbo].[prcReport_PoliciesGrandTotal]
@organisationID Integer = ''0'',
@policyIDs varchar(8000) = ''0'',
@unitIDs varchar(max) = ''0'',
@dateFromOrg datetime = Null,
@dateToOrg datetime = Null,
@acceptanceStatus varchar(20) = ''BOTH'',
@includeInactiveUsers varchar(5) = ''false''
AS
BEGIN
SET NOCOUNT ON;
DECLARE @dateFrom 		datetime
DECLARE @dateTo 		datetime
SET @dateFrom = dbo.udfDaylightSavingTimeToUTC(@dateFromOrg,@OrganisationID)
SET @dateTo = dbo.udfDaylightSavingTimeToUTC(@dateToOrg,@OrganisationID)

select
count(distinct tblUser.userid) as TotalDistinctUsers
from tblPolicy pol
join tblOrganisation org on org.OrganisationID = pol.Organisationid and org.OrganisationID = @OrganisationID
join tblUser on tblUser.OrganisationID = org.OrganisationID and (@includeInactiveUsers=''true'' or tblUser.Active=1) and tblUser.UnitID in (select IntValue from dbo.udfCsvToInt(@unitIDs))
join tblUserPolicyAccepted ua1 on pol.PolicyID = ua1.PolicyID and tblUser.UserID = ua1.UserID
join tblUnitHierarchy on tblUser.UnitID = tblUnitHierarchy.UnitID
left join tblUserPolicyAccess upa on upa.PolicyID = pol.PolicyID and upa.UserID = tblUser.Userid
where upa.granted = 1 and pol.Active = 1 and pol.Deleted = 0 and pol.uploaddate between @dateFrom and @dateTo
and pol.PolicyID in ( select IntValue from dbo.udfCsvToInt(@policyIDs ) )
and (
--Condition A - ACCEPTED
( @acceptanceStatus=''ACCEPTED'' and exists(select * from tblUserPolicyAccepted where pol.PolicyID = tblUserPolicyAccepted.PolicyID and tblUser.UserID = tblUserPolicyAccepted.UserID and tblUserPolicyAccepted.DateAccepted >= @dateFrom and tblUserPolicyAccepted.DateAccepted <= @dateTo and tblUserPolicyAccepted.Accepted = 1 ) )
or
--Condition B - NOT_ACCEPTED
( @acceptanceStatus=''NOT_ACCEPTED'' and not exists(select * from tblUserPolicyAccepted where pol.PolicyID = tblUserPolicyAccepted.PolicyID and tblUser.UserID = tblUserPolicyAccepted.UserID and tblUserPolicyAccepted.DateAccepted >= @dateFrom and tblUserPolicyAccepted.DateAccepted <= @dateTo and tblUserPolicyAccepted.Accepted = 1) )
or
--Condition C - BOTH
@acceptanceStatus=''BOTH''
)
--and (@includeInactiveUsers=''true'' and exists )

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_PoliciesTotals]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/******************************************************************************
**		File: dbo.prcReport_PoliciesTotals.PRC
**		Name: prcReport_PoliciesTotals
**		Desc: For counting user policy acceptance by policy
**
**		Return values:
**			Policy
**			UnitPathway
**			Lastname
**			Firstname
**			Email
**			UserID
**			Accepted
**			DateAccepted
**
**		Called by:
**
**		Parameters:
**			@organisationID Integer = ''0''
**			@policyIDs varchar(8000) = ''0''
**			@unitIDs varchar(8000) = ''0''
**			@dateFrom datetime = Null
**			@dateTo datetime = Null
**			@acceptanceStatus varchar(20) = ''BOTH''
**			@includeInactiveUsers varchar(5) = ''false''
**
**		Input							Output
**     ----------							-----------
**
**		Auth: Mark Donald
**		Date: 14 Aug 2009
**
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		--------		--------				-------------------------------------------
**
*******************************************************************************/

CREATE PROCEDURE [prcReport_PoliciesTotals]
@organisationID Integer = 0,
@policyIDs varchar(8000) = ''0'',
@unitIDs varchar(max) = ''0'',
@dateFromOrg datetime = Null,
@dateToOrg datetime = Null,
@acceptanceStatus varchar(20) = ''BOTH'',
@includeInactiveUsers varchar(5) = ''false''
AS
BEGIN
DECLARE @dateFrom 		datetime
DECLARE @dateTo 		datetime
SET @dateFrom = dbo.udfDaylightSavingTimeToUTC(@dateFromOrg,@OrganisationID)
SET @dateTo = dbo.udfDaylightSavingTimeToUTC(@dateToOrg,@OrganisationID)


SET NOCOUNT ON;
select
pol.PolicyName AS policy,
count (*) as totalusers,
sum(CASE WHEN ua1.Accepted = 1  and (ua1.DateAccepted >= @dateFrom and ua1.DateAccepted <= @dateTo) THEN 1 ELSE 0 END) AS totalaccepted,
sum(CASE WHEN ua1.Accepted = 1  and (ua1.DateAccepted >= @dateFrom and ua1.DateAccepted <= @dateTo) THEN 0 ELSE 1 END) AS totalnotaccepted
from tblPolicy pol
join tblOrganisation org on org.OrganisationID = pol.Organisationid and org.OrganisationID = @OrganisationID
join tblUser on tblUser.OrganisationID = org.OrganisationID and (@includeInactiveUsers=''true'' or tblUser.Active=1) and tblUser.UnitID in (select IntValue from dbo.udfCsvToInt(@unitIDs))
join tblUserPolicyAccepted ua1 on pol.PolicyID = ua1.PolicyID and tblUser.UserID = ua1.UserID
join tblUnitHierarchy on tblUser.UnitID = tblUnitHierarchy.UnitID
left join tblUserPolicyAccess upa on upa.PolicyID = pol.PolicyID and upa.UserID = tblUser.Userid
where upa.granted = 1 and pol.Active = 1 and pol.Deleted = 0 and pol.uploaddate between @dateFrom and @dateTo
and pol.PolicyID in ( select IntValue from dbo.udfCsvToInt(@policyIDs ) )
and (
--Condition A - ACCEPTED
( @acceptanceStatus=''ACCEPTED'' and exists(select * from tblUserPolicyAccepted where pol.PolicyID = tblUserPolicyAccepted.PolicyID and tblUser.UserID = tblUserPolicyAccepted.UserID and tblUserPolicyAccepted.DateAccepted >= @dateFrom and tblUserPolicyAccepted.DateAccepted <= @dateTo and tblUserPolicyAccepted.Accepted = 1 ) )
or
--Condition B - NOT_ACCEPTED
( @acceptanceStatus=''NOT_ACCEPTED'' and not exists(select * from tblUserPolicyAccepted where pol.PolicyID = tblUserPolicyAccepted.PolicyID and tblUser.UserID = tblUserPolicyAccepted.UserID and tblUserPolicyAccepted.DateAccepted >= @dateFrom and tblUserPolicyAccepted.DateAccepted <= @dateTo and tblUserPolicyAccepted.Accepted = 1) )
or
--Condition C - BOTH
@acceptanceStatus=''BOTH''
)
--and (@includeInactiveUsers=''true'' and exists )
group by pol.PolicyName
--ORDER BY policy, unitpathway, lastname, firstname

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Progress]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		Name: prcReport_Progress
**
**		Called by:
**
**		Auth: Mark Donald
**		Date: 11 Jan 2010
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**
*******************************************************************************/


CREATE PROCEDURE [dbo].[prcReport_Progress]
(
@organisationID int,
@unitIDs varchar(max),
@courseIDs varchar(8000),
@includeInactive int,
@classificationID int
)
AS
SET NOCOUNT ON;
BEGIN
DECLARE @currentstatus TABLE (usercoursestatusid int)
INSERT INTO @currentstatus
SELECT
max(usercoursestatusid) usercoursestatusid
FROM
tblusercoursestatus
GROUP BY
userid, courseid

SELECT
hierarchyname ''unitpathway'', lastname, firstname, CASE u.active WHEN 1 THEN NULL ELSE ''(i)'' END flag,
c.name coursename, externalid, email, username, [status] currentstatus, previousstatus, (
SELECT
convert(varchar(10), dbo.udfUTCtoDaylightSavingTime(max(datecreated),@OrganisationID), 103)
FROM
tblusercoursestatus
WHERE
userid = s.userid
AND courseid = s.courseid
AND coursestatusid = 2
) AS lastcompletiondate
FROM
tblusercoursestatus s
INNER JOIN tblcourse c ON
c.courseid = s.courseid
AND c.courseid IN (SELECT IntValue FROM dbo.udfCsvToInt(@courseIDs))
INNER JOIN tbluser u ON
u.userid = s.userid
AND u.unitid IN (SELECT IntValue FROM dbo.udfCsvToInt(@unitIDs))
LEFT JOIN (
SELECT
userid, courseid, max(usercoursestatusid) usercoursestatusid -- 2nd most recent record
FROM
tblusercoursestatus
WHERE
usercoursestatusid NOT IN (SELECT usercoursestatusid FROM @currentstatus)
GROUP BY
userid, courseid
) AS p ON
s.userid = p.userid
AND s.courseid = p.courseid
LEFT JOIN (
SELECT
usercoursestatusid, v.coursestatusid, [status] previousstatus
FROM
tblusercoursestatus v
INNER JOIN tblcoursestatus z ON
v.coursestatusid = z.coursestatusid
WHERE
z.coursestatusid > 0
) AS def2 ON
def2.usercoursestatusid = p.usercoursestatusid
LEFT JOIN tbluserclassification g ON
g.userid = u.userid,
tblunithierarchy h,
tblcoursestatus def,
@currentstatus r
WHERE
h.unitid = u.unitid
AND def.coursestatusid = s.coursestatusid
AND s.usercoursestatusid = r.usercoursestatusid
AND u.organisationid = @organisationID
AND (@includeInactive = 1 OR u.active = 1)
AND (@classificationID = 0 OR classificationID = @classificationID)
ORDER BY
unitpathway, lastname, firstname, coursename
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_ProgressGrandTotal]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		Name: prcReport_ProgressGrandTotal
**		Desc: a cut down copy of prcreport_Progress, with select statements
**				altered to return a total, instead of a list of data.
**
**		Return values: Grand Total distinct users in Progress report
**
**		Auth: Mark Donald
**		Date: 11 Jan 2010
**
*******************************************************************************/


CREATE       Procedure [dbo].[prcReport_ProgressGrandTotal]
(
@organisationID		int,
@unitIDs 		varchar(max),
@courseIDs 		varchar(8000),
@includeInactive int,
@classificationID int
)
AS
SET NOCOUNT ON;
BEGIN
SELECT
count(DISTINCT u.userid) TotalDistinctUsers
FROM
tblusercoursestatus s
INNER JOIN tblcourse c ON
c.courseid = s.courseid
AND c.courseid IN (SELECT IntValue FROM dbo.udfCsvToInt(@courseIDs))
INNER JOIN tbluser u ON
u.userid = s.userid
AND u.unitid IN (SELECT IntValue FROM dbo.udfCsvToInt(@unitIDs))
LEFT JOIN tbluserclassification g ON
g.userid = u.userid
WHERE
u.organisationid = @organisationID
AND (@includeInactive = 1 OR u.active = 1)
AND (@classificationID = 0 OR classificationID = @classificationID)
END

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_ReassignReportInactive]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 14/12/2011
-- Description:	Reassigns owner or cc for the periodic report
-- =============================================
CREATE PROCEDURE [prcReport_ReassignReportInactive] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int = 0, 
	@FromUser int = 0,
	@ToUser int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF EXISTS (SELECT * FROM tblReportSchedule 
		WHERE ScheduleID = @ScheduleId AND UserID = @FromUser)
	BEGIN
		UPDATE tblReportSchedule SET UserID = @ToUser
			WHERE ScheduleID = @ScheduleId
	END
	
	IF EXISTS (SELECT * FROM tblCCList
		WHERE ScheduleId = @ScheduleId AND UserID = @FromUser)
	BEGIN
		UPDATE tblCCList SET UserID = @ToUser
			WHERE ScheduleID = @ScheduleId
	END
	
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_SaveCCUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 6/12/2011
-- Description:	Saves the CC users for periodic report
-- =============================================
CREATE PROCEDURE [prcReport_SaveCCUser] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int = 0, 
	@UserId int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF NOT EXISTS (SELECT * FROM tblCCList WHERE ScheduleId = @ScheduleId AND UserID = @UserId)
	BEGIN
INSERT INTO tblCCList (UserID,ScheduleID) VALUES (@UserId, @ScheduleId)
	END

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Summary]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
This Report provides a high level summary information.
It shows how many users in each unit are complete or incomplete in each course.
The results can be views as a bar graph

Called By:
SummaryReport in Reporting Services

Calls:
udfReport_CompletUsers_logic
udfReport_IncompletUsers_logic
Remarks:


Author:
Jack Liu
Date Created: 31 March 2005

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
Mark Donald	23/07/2009		Add @classificationID parameter and use it
to filter insert into #result table

prcReport_Summary 8, ''19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,84'' ,7, null

prcReport_Summary 8, ''19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,84'' ,7, ''20041130''

--------------------

**/

CREATE  Proc [dbo].[prcReport_Summary]
(
@organisationID Integer,	-- Organisation of the current user
@unitIDs varchar(max) = '''',	-- string of unit id''s
@courseID int,			-- course ID to restrict search to
@effectiveDateOrg datetime = Null,	-- Effective date as at when to run the report
@classificationID int
)

AS
------------------------------------------
Set Nocount On
DECLARE @effectiveDate 		datetime
SET @effectiveDate = dbo.udfDaylightSavingTimeToUTC(@effectiveDateOrg,@OrganisationID)
CREATE TABLE #result
(
UnitID		Int,
UnitPathway 	nVarchar(4000),
Complete	int,
Incomplete	int
)
declare @rowCount as integer

insert into #result
select
UnitID,
min(UnitPathway) as UnitPathway,
sum(Complete) as Complete,
sum(Incomplete) as Incomplete
from (Select
UnitID,
UnitPathWay,
1 as Complete,
0 as Incomplete,
UserID
From	dbo.udfReport_CompleteUsersLogic(@organisationID, @unitIDs, @courseID,@effectiveDate)
Union all
Select
UnitID,
UnitPathWay,
0 as Complete,
1 as Incomplete,
UserID
from  dbo.udfReport_IncompleteUsersLogic(@organisationID, @unitIDs, @courseID,@effectiveDate)
) as Users
LEFT JOIN tblUserClassification c ON c.UserID  = Users.UserID
WHERE
((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification
group by UnitID
Order By UnitPathway

set @rowCount=@@rowcount

if (@rowCount>1)
begin
insert into #result
select 0,
''Total'',
Sum(Complete),
Sum(Incomplete)
from #result

set @rowCount = @rowCount+1
end

select *,
@rowCount  as Count
from #result

drop table #result
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Trend]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
refer to section 16.5.5.2 of Func. Spec. returns avg. score
and num of user per module for a selected course and unit

Called By: Report.cs, TrendReport.aspx.cs
Calls: udfCsvToInt

Remarks: Raises an error if a parameter is null

Author: Claude Nehme
Date Created: 16th of February 2004

prcReport_Trend "1,2,3", 1,1

Modification History
-----------------------------------------------------------
v#	Author			Date			Description
#1	Peter Kneale 	03/03/04		Added ''Passed or Failed Users only''
#2	Jack Liu		05/03/04		Remove the hierarchy unit, change to flat file
#3	Jack Liu		14/09/05		Order the result by Module
and order by most recent(the last recorded status with specified passmark)
#4	Usman Tjiudri	11 Nov 2005		Include BoldMark indicator for the latest PassMark record.
#5	j hedlefs		09/06/2011		timezone

*/

CREATE     Procedure [dbo].[prcReport_Trend]
(
@organisationID integer = null,
@unitIDs varchar(max) = null,
@courseID integer = null,
@fromDateOrg datetime,
@toDateOrg datetime
)

as
DECLARE @fromDate 		datetime
DECLARE @toDate 		datetime
SET @fromDate = dbo.udfDaylightSavingTimeToUTC(@fromDateOrg,@OrganisationID)
SET @toDate = dbo.udfDaylightSavingTimeToUTC(@toDateOrg,@OrganisationID)

Set NoCount On

If @courseID Is Null
Begin
Raiserror(''The Parameter @courseID was null.  @courseID does not accept Null values.'', 16, 1)
Return
End

-- Temporary table to store the query for further data manipulation.
Declare @tblResult Table
(
Unit		nVarchar(200),
UnitID		Int,
Course		nVarchar(100),
CourseID	Int,
Module		nVarchar(100),
ModuleID	Int,
NumOfUsers	Int,
QuizCount int,
QuizPassMark	Int,
AvgScore	Int,
LastUserQuizStatusID Int,
BoldMark	Bit -- Indicator whether current record should be bold or not
)

If @unitIDs Is Null
Begin
Insert Into @tblResult
(
Unit,
UnitID,
Course,
CourseID,
Module,
ModuleID,
NumOfUsers,
QuizCount,
QuizPassMark,
AvgScore,
LastUserQuizStatusID
)
Select 	dbo.udfGetUnitPathway(un.UnitID) as Unit,
un.UnitID,
min(co.Name) as  Course,
co.CourseID,
min(mo.Name) as Module,
mo.ModuleID,
count(DISTINCT usr.UserID) as NumOfUsers,
count(usr.UserID) as QuizCount,
uqs.QuizPassMark,
avg(uqs.QuizScore) as AvgScore,
max(uqs.UserQuizStatusID) as LastUserQuizStatusID
From
tblUser usr
inner join tblUnit un on un.UnitID = usr.UnitID
inner join tblUserQuizStatus uqs on usr.UserID = uqs.UserID
and (uqs.QuizStatusID = 2 or uqs.QuizStatusID = 3) 	-- Passed or Failed Users only
and uqs.DateCreated between @fromDate and dateadd(dd,1,@toDate)
inner join tblModule mo on mo.ModuleID = uqs.ModuleID
inner join tblCourse co on mo.CourseID = co.CourseID and co.CourseID = @courseID
Where
usr.UnitID is not null
and 	usr.Active = 1
and 	un.OrganisationID = @organisationID
Group By
un.UnitID,
co.CourseID,
mo.ModuleID,
uqs.QuizPassMark
Order By
Unit,
Course,
Module,
LastUserQuizStatusID desc

End
Else
Begin
Insert Into @tblResult
(
Unit,
UnitID,
Course,
CourseID,
Module,
ModuleID,
NumOfUsers,
QuizCount,
QuizPassMark,
AvgScore,
LastUserQuizStatusID
)
Select	dbo.udfGetUnitPathway(un.UnitID) as Unit,
un.UnitID,
min(co.Name) as  Course,
co.CourseID,
min(mo.Name) as Module,
mo.ModuleID,
count(DISTINCT usr.UserID) as NumOfUsers,
count(usr.UserID) as QuizCount,
uqs.QuizPassMark,
avg(uqs.QuizScore) as AvgScore,
max(uqs.UserQuizStatusID) as LastUserQuizStatusID
From
tblUser usr
inner join tblUnit un on un.UnitID = usr.UnitID
inner join dbo.udfCsvToInt(@unitIDs) as selectedUnit on selectedUnit.IntValue= un.UnitID
inner join tblUserQuizStatus uqs on usr.UserID = uqs.UserID
and (uqs.QuizStatusID = 2 or uqs.QuizStatusID = 3) 	-- Passed or Failed Users only
and uqs.DateCreated between @fromDate and dateadd(dd,1,@toDate)
inner join tblModule mo on mo.ModuleID = uqs.ModuleID
inner join tblCourse co on mo.CourseID = co.CourseID and co.CourseID = @courseID
Where
usr.UnitID is not null
and 	usr.Active = 1
Group By
un.UnitID,
co.CourseID,
mo.ModuleID,
uqs.QuizPassMark
Order By
Unit,
Course,
Module,
LastUserQuizStatusID desc
End

-- Update BoldMark field for group of records (by Unit, Course and Module) with more than one version of pass mark.
Update @tblResult
Set BoldMark = 1
Where LastUserQuizStatusID In (
Select tb.QuizStatusID From
(Select UnitID, CourseID, ModuleID, Max(LastUserQuizStatusID) As QuizStatusID from @tblResult Group by UnitID, CourseID, ModuleID having count(*) > 1) As tb
)

-- Returning records to callers
Select * From @tblResult

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_UnitAdministrators]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/**

Summary:		Get a list of existing unit administrators for an organisation, by unit.

Returns:		Result set

Called By:		UnitAdministratorReport.rdl

Example call:	execute prcReport_UnitAdministrators 109
(use this for testing inside SQL management studio)

Author:			Mark Donald

Date Created:	30/07/2009

Modification History
-----------------------------------------------------------
Author		Date			Description



**/
CREATE PROCEDURE [dbo].[prcReport_UnitAdministrators]
(
@organisationID	int,
@IncludeInactive int,
@UnitIDs varchar(max)
)

AS

set nocount on

SELECT
dbo.udfGetUnitPathway(t.unitid) AS unitpathway,
lastname,
firstname,
CASE WHEN u.active = 1 THEN '''' ELSE ''(i)'' END AS flag,
username,
email,
externalid,
groupby,
[value]
FROM
tblunitadministrator ua, tblunit t, tbluser u
LEFT JOIN (
SELECT userid, ct.[name] as groupby, c.[value]
FROM tbluserclassification uc, tblclassification c, tblclassificationtype ct
WHERE c.classificationid = uc.classificationid
AND c.classificationtypeid = ct.classificationtypeid
) AS i ON i.userid = u.userid
WHERE
ua.userid = u.userid AND t.unitid = ua.unitid
AND usertypeid=3 --Unit administrator(3)
AND t.organisationid = @organisationID
AND (@IncludeInactive = 1 OR u.active = 1)
AND t.unitid IN (SELECT * FROM dbo.udfCsvToInt(@UnitIDs))
ORDER BY
unitpathway, lastname, firstname

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_UnitCompliance]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/**

Summary:		Get the compliance rules for all the modules attached to selected units.
Called by:		UnitComplianceReport.rdl
Example call:	exec prcreport_unitcompliance 109, 0, ''4463,4464,4465''

Author:			Mark Donald
Date created:	05/01/2010

Modification history
-----------------------------------------------------------
Author		Date			Description



**/
CREATE PROCEDURE [dbo].[prcReport_UnitCompliance]
(
@organisationID	int,
@IncludeInactive int,
@UnitIDs varchar(max)
)

AS

SET NOCOUNT ON

SELECT
hierarchyname as unitpathway, c.[name] as coursename, r.[name] AS modulename,
CASE lessonfrequency WHEN 0 THEN NULL ELSE lessonfrequency END AS lessonfrequency,
CASE quizfrequency WHEN 0 THEN NULL ELSE quizfrequency END AS quizfrequency,
lessoncompletiondate AS lessonexpirydate,
quizcompletiondate AS quizexpirydate,
quizpassmark AS passmark,
CASE usingdefault WHEN 1 THEN ''Yes'' ELSE ''No'' END AS ''default''
FROM
vwunitmodulerule r
LEFT JOIN tblunitmoduleaccess a ON a.unitid = r.unitid AND r.moduleid = deniedmoduleid,
tblunit u,
tblunithierarchy h,
tblcourse c,
tblModule m
WHERE
h.unitid = u.unitid
AND r.unitid = u.unitid
AND c.courseid = r.courseid
AND r.moduleid = m.moduleid
AND u.organisationid = @organisationid
AND (@includeinactive = 1 OR u.active = 1)
AND a.unitid IS NULL
AND u.unitid IN (SELECT * FROM dbo.udfcsvtoint(@unitids))
ORDER BY
unitpathway, coursename, [sequence], modulename


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_UnitPath]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE Procedure [dbo].[prcReport_UnitPath]
(
@OrganisationID int,
@IncludeInactiveUnits int,
@UnitIDs varchar(max)
)
AS
begin
if @IncludeInactiveUnits = 1
BEGIN
select

UnitID ,
dbo.udfGetUnitPathway(tblUnit.UnitID) as ''UnitPathway'',
dbo.udfGetUnitIDPathway(tblUnit.UnitID) as ''UnitIDPathway'',

CASE
WHEN Active = 0  THEN [Name] + '' (I)''
ELSE [Name]
END as [Name]



from

tblUnit

where

tblUnit.OrganisationID = @OrganisationID
and tblUnit.UnitID in (SELECT * FROM dbo.udfCsvToInt(@unitIDs) tU)


order by

dbo.udfGetUnitPathway(tblUnit.UnitID)
END
else
BEGIN
select

UnitID,

dbo.udfGetUnitPathway(tblUnit.UnitID) as ''UnitPathway'',

dbo.udfGetUnitIDPathway(tblUnit.UnitID) as ''UnitIDPathway'',

Name



from

tblUnit

where

tblUnit.OrganisationID = @OrganisationID
and tblUnit.UnitID in (SELECT * FROM dbo.udfCsvToInt(@unitIDs) tU)
and tblUnit.Active = 1

order by

dbo.udfGetUnitPathway(tblUnit.UnitID)
END
end
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_UserDetails]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE  PROCEDURE [dbo].[prcReport_UserDetails]
(
@OrganisationID int,
@IncludeInactiveUsers int,
@UnitIDs varchar(max)
)
AS
SET NOCOUNT ON

IF (@IncludeInactiveUsers=0)
BEGIN

SELECT
uh.HierarchyName as UnitPathway,
u.UserID,
FirstName,
LastName,
u.UnitID,
Email,
UserName,
ExternalID,
ct.Name as GroupBy,
c.Value as Value
FROM
tblUser u
LEFT JOIN tblUserClassification uc on u.UserID = uc.UserID
LEFT JOIN tblClassification c on uc.ClassificationID = c.ClassificationID
LEFT JOIN tblClassificationType ct on c.ClassificationTypeID = ct.ClassificationTypeID
LEFT JOIN tblUnitHierarchy uh on u.UnitID = uh.UnitID
WHERE
u.Active = 1
AND
u.OrganisationID = @OrganisationID
AND
u.UnitID IN (SELECT * FROM dbo.udfCsvToInt(@UnitIDs) as tblUnitIDs)

ORDER BY
uh.HierarchyName, LastName

END

ELSE
BEGIN
SELECT
uh.HierarchyName as UnitPathway,
u.UserID,
FirstName,
CASE
WHEN u.Active = 0 then u.LastName + '' (I)''
ELSE u.LastName
END AS LastName,
u.UnitID,
Email,
UserName,
ExternalID,
ct.Name as GroupBy ,
c.Value as Value
FROM
tblUser u
LEFT JOIN tblUserClassification uc on u.UserID = uc.UserID
LEFT JOIN tblClassification c on uc.ClassificationID = c.ClassificationID
LEFT JOIN tblClassificationType ct on c.ClassificationTypeID = ct.ClassificationTypeID
LEFT JOIN tblUnitHierarchy uh on u.UnitID = uh.UnitID
WHERE

u.OrganisationID = @OrganisationID
AND
u.UnitID IN (SELECT * FROM dbo.udfCsvToInt(@UnitIDs) as tblUnitIDs)

--Active = (IsNull(@Active,1))

ORDER BY
uh.HierarchyName, LastName

END

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Warning]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		Name: prcReport_Warning
**
**		Called by:
**
**		Auth: Mark Donald
**		Date: 7 Dec 2009
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**
*******************************************************************************/


CREATE PROCEDURE [dbo].[prcReport_Warning]
(
@organisationID int,
@unitIDs varchar(max),
@courseIDs varchar(8000),
@classificationID int,
@warningPeriod int,
@warningUnit varchar(2),
@IncludeInactive int
)
AS
SET NOCOUNT ON;

DECLARE @Units TABLE (UnitID INT PRIMARY KEY(UnitID))
DECLARE @Courses TABLE(CourseID INT PRIMARY KEY(CourseID))
DECLARE @CoursesWithAccess 	TABLE (CourseID INT PRIMARY KEY(CourseID))
DECLARE @Users TABLE(UserID INT , UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @tblCurrentAssignedModules TABLE (
CourseID int,
UserID int,
UnitID int,
ModuleID int,
QuizFrequency int,
QuizCompletionDate datetime
)
DECLARE @tblStartedModules TABLE (
UserID int,
ModuleID int,
DateTimeCompleted datetime
)

INSERT INTO
@Courses
SELECT
*
FROM
dbo.udfCsvToInt(@courseIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

-- Get users for specfied units, matching Custom Classification option (if provided)
INSERT INTO @Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
JOIN @Units B on A.UnitID = B.UnitID
JOIN tblUnit C on B.UnitID = C.UnitID AND C.Active = 1
LEFT JOIN tblUserClassification uc ON uc.UserID  = A.UserID
WHERE
A.Active = (case when @includeinactive = 0 then 1 else A.active end )
AND ((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification

-- Get compliance rules for in-scope modules
INSERT INTO @tblCurrentAssignedModules
SELECT
CourseID, UserID, um.UnitID, um.ModuleID, QuizFrequency, QuizCompletionDate
FROM
(SELECT
tU.UserID, tU.UnitID, tM.ModuleID
FROM
dbo.tblUser tU
INNER JOIN dbo.tblOrganisationCourseAccess tOCA ON tOCA.OrganisationID = tU.OrganisationID
INNER JOIN dbo.tblCourse tC ON tC.CourseID = tOCA.GrantedCourseID
INNER JOIN dbo.tblModule tM ON tM.CourseID = tC.CourseID AND tM.Active = 1
LEFT OUTER JOIN dbo.tblUserModuleAccess tUsrMA ON tUsrMA.UserID = tU.UserID
AND tUsrMA.ModuleID = tM.ModuleID
LEFT OUTER JOIN dbo.tblUnitModuleAccess tUnitMA ON tUnitMA.UnitID = tU.UnitID
AND tUnitMA.DeniedModuleID = tM.ModuleID
WHERE
tU.OrganisationID = @organisationID
AND	tU.Active = (case when @includeinactive = 0 then 1 else tU.Active end )
AND tu.UnitID IS NOT NULL
AND dbo.udfUserCourseComplete(tu.userid, tm.courseid) = 1
AND ((tUnitMA.DeniedModuleID IS NULL AND tUsrMA.ModuleID IS NULL)
OR tUsrMA.Granted=1)
) um
INNER JOIN (
SELECT
u.UnitID, m.CourseID, m.ModuleID,
CASE
WHEN (
ur.QuizFrequency IS NULL
AND ur.QuizCompletionDate IS NULL
AND o.DefaultQuizCompletionDate IS NULL
) THEN
o.DefaultQuizFrequency
ELSE
ur.QuizFrequency
END AS QuizFrequency,
CASE
WHEN (
ur.QuizFrequency IS NULL
AND ur.QuizCompletionDate IS NULL
AND o.DefaultQuizCompletionDate IS NOT NULL
) THEN
o.DefaultQuizCompletionDate
ELSE
ur.QuizCompletionDate
END AS QuizCompletionDate
FROM
tblOrganisationCourseAccess c
INNER JOIN tblModule m ON m.CourseID = c.GrantedCourseID
INNER JOIN tblOrganisation o ON o.OrganisationID = c.OrganisationID -- default compliance rules
INNER JOIN tblUnit u ON u.OrganisationID = c.OrganisationID
LEFT JOIN tblUnitRule ur ON ur.ModuleID = m.ModuleID AND ur.UnitID = u.unitID -- unit specific rules
WHERE o.OrganisationID = @organisationID
) umr ON umr.ModuleID  = um.ModuleID
AND umr.UnitID = um.UnitID
AND um.UnitID IN (SELECT DISTINCT UnitID FROM @users)
AND um.UserID IN (SELECT DISTINCT UserID FROM @users)
AND umr.CourseID IN (SELECT CourseID FROM @courses)

-- Get module completion details
INSERT INTO @tblStartedModules
SELECT
um.userID, um.moduleID, qs.DateTimeCompleted
FROM
@tblCurrentAssignedModules um
INNER JOIN (
SELECT
um.userID, um.moduleID, max(DateTimeCompleted) AS DateTimeCompleted
FROM
@tblCurrentAssignedModules um
INNER JOIN tblQuiz q ON q.ModuleID = um.ModuleID
INNER JOIN tblQuizSession qs ON qs.QuizID= q.quizID
AND qs.userID = um.userID
AND qs.DateTimeCompleted IS NOT NULL
GROUP BY
um.userID, um.moduleID
) AS LastQuizDate ON
LastQuizDate.userID = um.userID
AND LastQuizDate.ModuleID = um.ModuleID
INNER JOIN tblQuiz q ON q.ModuleID = um.ModuleID
INNER JOIN tblQuizSession qs ON
qs.QuizID= q.quizID
AND qs.userID = um.userID
AND qs.DateTimeCompleted = LastQuizDate.DateTimeCompleted

-- User/course combos where the courses are about to be marked incomplete due to module expiry
BEGIN
SELECT
c.[name] as CourseName,
HierarchyName AS UnitPathway,
LastName,
FirstName,
case when u.Active = 1 then ''''  else ''(i)'' end as Flag,
ExternalID,
Email,
UserName,
dbo.udfUTCtoDaylightSavingTime(max(DateTimeCompleted), @organisationID) AS CompletionDate,
dbo.udfUTCtoDaylightSavingTime(min(isnull(QuizCompletionDate, dateadd(month, QuizFrequency, DateTimeCompleted))), @organisationID) AS ExpiryDate
FROM
@tblCurrentAssignedModules cam
INNER JOIN @tblStartedModules sm ON sm.UserID = cam.UserID AND sm.ModuleID = cam.ModuleID,
tblCourse c,
tblUser u,
tblUnitHierarchy h
WHERE
c.CourseID = cam.CourseID
AND u.UserID = cam.UserID
AND h.UnitID = cam.UnitID
GROUP BY
c.[name], HierarchyName,  LastName, FirstName, ExternalID, Email, Username, u.Active
HAVING
min(isnull(
QuizCompletionDate,
dateadd(month, QuizFrequency, DateTimeCompleted)
)) < CASE @warningUnit
WHEN ''mm'' THEN
dateadd(mm, @warningPeriod, getutcdate())
ELSE
dateadd(dd, @warningPeriod, getutcdate())
END
ORDER BY
CourseName, UnitPathway, LastName, FirstName
END

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_WarningGrandTotal]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		Name: prcReport_WarningGrandTotal
**		Desc: a copy of prcreport_Warning, but with select statements
**				altered to return a total, instead of a list of data.
**
**		Return values: Grand Total distinct users in Warning report
**
**		Auth: Mark Donald
**		Date: 17 Nov 2009
**
*******************************************************************************/

CREATE       Procedure [dbo].[prcReport_WarningGrandTotal]
(
@organisationID		int,
@unitIDs 		varchar(max),
@courseIDs 		varchar(8000),
@classificationID int,
@warningPeriod int,
@warningUnit varchar(2),
@IncludeInactive int
)
AS
SET NOCOUNT ON;

DECLARE @Units TABLE (UnitID INT PRIMARY KEY(UnitID))
DECLARE @Courses TABLE(CourseID INT PRIMARY KEY(CourseID))
DECLARE @CoursesWithAccess 	TABLE (CourseID INT PRIMARY KEY(CourseID))
DECLARE @Users TABLE(UserID INT , UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @tblCurrentAssignedModules TABLE (
CourseID int,
UserID int,
UnitID int,
ModuleID int,
QuizFrequency int,
QuizCompletionDate datetime
)
DECLARE @tblStartedModules TABLE (
UserID int,
ModuleID int,
DateTimeCompleted datetime
)

INSERT INTO
@Courses
SELECT
*
FROM
dbo.udfCsvToInt(@courseIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

-- Get users for specfied units, matching Custom Classification option (if provided)
INSERT INTO @Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
JOIN @Units B on A.UnitID = B.UnitID
JOIN tblUnit C on B.UnitID = C.UnitID AND C.Active = 1
LEFT JOIN tblUserClassification uc ON uc.UserID  = A.UserID
WHERE
A.Active = 1
AND ((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification

-- Get compliance rules for in-scope modules
INSERT INTO @tblCurrentAssignedModules
SELECT
CourseID, UserID, um.UnitID, um.ModuleID, QuizFrequency, QuizCompletionDate
FROM
(SELECT
tU.UserID, tU.UnitID, tM.ModuleID
FROM
dbo.tblUser tU
INNER JOIN dbo.tblOrganisationCourseAccess tOCA ON tOCA.OrganisationID = tU.OrganisationID
INNER JOIN dbo.tblCourse tC ON tC.CourseID = tOCA.GrantedCourseID
INNER JOIN dbo.tblModule tM ON tM.CourseID = tC.CourseID AND tM.Active = 1
LEFT OUTER JOIN dbo.tblUserModuleAccess tUsrMA ON tUsrMA.UserID = tU.UserID
AND tUsrMA.ModuleID = tM.ModuleID
LEFT OUTER JOIN dbo.tblUnitModuleAccess tUnitMA ON tUnitMA.UnitID = tU.UnitID
AND tUnitMA.DeniedModuleID = tM.ModuleID
WHERE
tU.OrganisationID = @organisationID
AND	tU.Active = 1
AND tu.UnitID IS NOT NULL
AND dbo.udfUserCourseComplete(tu.userid, tm.courseid) = 1
AND ((tUnitMA.DeniedModuleID IS NULL AND tUsrMA.ModuleID IS NULL)
OR tUsrMA.Granted=1)
) um
INNER JOIN (
SELECT
u.UnitID, m.CourseID, m.ModuleID,
CASE
WHEN (
ur.QuizFrequency IS NULL
AND ur.QuizCompletionDate IS NULL
AND o.DefaultQuizCompletionDate IS NULL
) THEN
o.DefaultQuizFrequency
ELSE
ur.QuizFrequency
END AS QuizFrequency,
CASE
WHEN (
ur.QuizFrequency IS NULL
AND ur.QuizCompletionDate IS NULL
AND o.DefaultQuizCompletionDate IS NOT NULL
) THEN
o.DefaultQuizCompletionDate
ELSE
ur.QuizCompletionDate
END AS QuizCompletionDate
FROM
tblOrganisationCourseAccess c
INNER JOIN tblModule m ON m.CourseID = c.GrantedCourseID
INNER JOIN tblOrganisation o ON o.OrganisationID = c.OrganisationID -- default compliance rules
INNER JOIN tblUnit u ON u.OrganisationID = c.OrganisationID
LEFT JOIN tblUnitRule ur ON ur.ModuleID = m.ModuleID AND ur.UnitID = u.unitID -- unit specific rules
WHERE o.OrganisationID = @organisationID
) umr ON umr.ModuleID  = um.ModuleID
AND umr.UnitID = um.UnitID
AND um.UnitID IN (SELECT DISTINCT UnitID FROM @users)
AND um.UserID IN (SELECT DISTINCT UserID FROM @users)
AND umr.CourseID IN (SELECT CourseID FROM @courses)

-- Get module completion details
INSERT INTO @tblStartedModules
SELECT
um.userID, um.moduleID, qs.DateTimeCompleted
FROM
@tblCurrentAssignedModules um
INNER JOIN (
SELECT
um.userID, um.moduleID, max(DateTimeCompleted) AS DateTimeCompleted
FROM
@tblCurrentAssignedModules um
INNER JOIN tblQuiz q ON q.ModuleID = um.ModuleID
INNER JOIN tblQuizSession qs ON qs.QuizID= q.quizID
AND qs.userID = um.userID
AND qs.DateTimeCompleted IS NOT NULL
GROUP BY
um.userID, um.moduleID
) AS LastQuizDate ON
LastQuizDate.userID = um.userID
AND LastQuizDate.ModuleID = um.ModuleID
INNER JOIN tblQuiz q ON q.ModuleID = um.ModuleID
INNER JOIN tblQuizSession qs ON
qs.QuizID= q.quizID
AND qs.userID = um.userID
AND qs.DateTimeCompleted = LastQuizDate.DateTimeCompleted

BEGIN
SELECT
count(DISTINCT UserID) AS TotalDistinctUsers
FROM
-- User/course combos where the courses are about to be marked incomplete due to module expiry
(SELECT
cam.UserID, max(DateTimeCompleted) AS CompletionDate,
min(isnull(QuizCompletionDate, dateadd(month, QuizFrequency, DateTimeCompleted))) AS ExpiryDate
FROM
@tblCurrentAssignedModules cam
INNER JOIN @tblStartedModules sm ON sm.UserID = cam.UserID AND sm.ModuleID = cam.ModuleID
GROUP BY
cam.UserID
HAVING
min(isnull(
QuizCompletionDate,
dateadd(month, QuizFrequency, DateTimeCompleted)
)) < CASE @warningUnit
WHEN ''mm'' THEN
dateadd(mm, @warningPeriod, getutcdate())
ELSE
dateadd(dd, @warningPeriod, getutcdate())
END) AS warning_report
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcRequiresDateFromDateTo]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 9/11/2011
-- Description:	checks if report contains datefrom and dateto controls to disable when more than once control is selected for periodic report
-- =============================================
CREATE PROCEDURE [prcRequiresDateFromDateTo] 
	-- Add the parameters for the stored procedure here
	@ReportId int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    SELECT RequiresParamDateFrom & RequiresParamDateTo FROM tblReportInterface WHERE ReportID=@ReportId
     
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcRequiresEffectiveDate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 9/11/2011
-- Description:	Checks if report type requires effective date in order to decide whether the parent page of periodic control has to disable effective date
-- =============================================
CREATE PROCEDURE [prcRequiresEffectiveDate] 
	-- Add the parameters for the stored procedure here
	@ReportId int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT RequiresParamEffectiveDate FROM tblReportInterface
		WHERE ReportID=@ReportId	
 
END
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSalt_GrantPermission]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Grant all required permission to the website user
User don''t need to be an dbowner
Required Permission
1. Execute permission to all procedures
2. Select permission to all tables and views that are used in dynamic query
That permission is not required, all dynamic query need to be reviewed before set this permission

Parameters:
Returns:

Called By:
Calls:

Remarks:

Author: Jack Liu
Date Created: 25th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcSalt_GrantPermission ''Salt_user''


select * from sysobjects
where xtype=''p''
order by name

prcSalt_GrantPermission
*/


CREATE   procedure [prcSalt_GrantPermission]
(
@login sysname
)
as
declare @userName sysname

declare @name varchar(100), @sql varchar(1000)

set nocount on

--1. Check whether the login has been granted access permission to this database
--If not, grant access permission
select @userName = u.name
from sysusers u
inner join master.dbo.syslogins  l
on u.sid = l.sid
where u.uid < 16382
and l.name=@login

if @userName is null
begin
-- If the db user name is used by other login, drop it
If exists(select 1 from sysusers where name=@login)
begin
EXEC sp_revokedbaccess @login
end

EXEC sp_grantdbaccess @login, @userName output
end


--2. Grant minimum permission
DECLARE Proc_Cursor CURSOR FOR
select name from sysobjects where xtype=''p'' and Category=0
OPEN Proc_Cursor
FETCH NEXT FROM Proc_Cursor
into @name
WHILE @@FETCH_STATUS = 0
BEGIN
set @sql=''GRANT execute ON [''+ @name + ''] TO ''+  @userName
exec(@sql)
FETCH NEXT FROM Proc_Cursor
into @name
END
CLOSE Proc_Cursor
DEALLOCATE Proc_Cursor

EXEC sp_droprolemember ''db_owner'', @userName




' 
END
GO


/****** Object:  StoredProcedure [dbo].[prcSCORMdeleteDME]    Script Date: 12/19/2012 15:23:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSCORMdeleteDME]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'create proc [prcSCORMdeleteDME](@StudentID int,@LessonID int)
as begin

	delete from tblScormDME where UserID =@StudentID and LessonID = @LessonID

End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSCORMgetSession]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE PROCEDURE [prcSCORMgetSession] (
             @StudentID int,
             @LessonID int,
            @isLesson bit  
           )  
AS
BEGIN
	SET NOCOUNT ON;
DECLARE @RC int
DECLARE @OrganisationID int
DECLARE @NumQuestions int
DECLARE @quizpassmark int
DECLARE @Name nvarchar(255)
SET @Name = N''Number_Of_Quiz_Questions''
SELECT @OrganisationID = OrganisationID FROM tblUser WHERE UserID = @StudentID
SELECT @quizpassmark = DefaultQuizPassMark FROM tblOrganisation WHERE OrganisationID = @organisationID 
--EXECUTE @NumQuestions = prcOrganisationConfig_GetOne  @organisationID = @OrganisationID, @name = @Name



If Exists (Select OrganisationID From tblOrganisationConfig Where OrganisationID = @organisationID And [Name]	= @Name)
Begin
	Select @NumQuestions = value from tblOrganisationConfig Where OrganisationID	= @OrganisationID And [Name]		= @Name 
End
Else
Begin
	Select @NumQuestions = Value From tblOrganisationConfig Where OrganisationID	is null And  [Name]		= @Name 
End


	-- delete then insert these as we dont want duplicates
	delete from tblScormDME 
	where UserID  =@StudentID and LessonID =@LessonID
	and DME in (''cmi.core.student_id'',''cmi.core.student_name'',''cmi.core.version'',''cmi.core.numrandom'',''cmi.core.quizpassmark'',''salt.lessonorquiz'',''salt.training.QuizURL2'')
	and DME NOT LIKE ''cmi.interactions%''
		

	INSERT INTO  tblScormDME (UserID,LessonID,DME,[value]) VALUES(@StudentID,@LessonID,''cmi.core.student_id'' ,''Salt™''+CAST(@StudentID AS varchar(20)))
	INSERT INTO  tblScormDME (UserID,LessonID,DME,[value]) VALUES(@StudentID,@LessonID,''cmi.core.student_name'' ,(SELECT FirstName FROM tblUser WHERE UserID = @StudentID))
	INSERT INTO  tblScormDME (UserID,LessonID,DME,[value]) VALUES(@StudentID,@LessonID,''cmi.core.version'' ,''3.4'')
	INSERT INTO  tblScormDME (UserID,LessonID,DME,[value]) VALUES(@StudentID,@LessonID,''cmi.core.numrandom'' ,@NumQuestions ) 
	INSERT INTO  tblScormDME (UserID,LessonID,DME,[value]) VALUES(@StudentID,@LessonID,''cmi.core.quizpassmark'' ,@quizpassmark)

   if @isLesson = 1
   begin   
		-- quiz bookmark
		
		DECLARE @VarRunningPageCount nvarchar(255)		
		DECLARE @LessonLocation nvarchar(255)
		DECLARE @VarPageInChapter nvarchar(255)
		DECLARE @VarPagesInChapter nvarchar(255)
		DECLARE @CurrentPage nvarchar(255)
        DECLARE @LectoraBookmark nvarchar(100) 

        SELECT @LectoraBookmark = ''''
		SELECT @VarRunningPageCount = ''''
		SELECT @LessonLocation = ''''
		SELECT @VarPageInChapter = ''''
		SELECT @VarPagesInChapter = ''''
		SELECT @CurrentPage = ''''
		SELECT @LectoraBookmark = ''''        
        
        SELECT @VarRunningPageCount = value 
		     FROM  tblScormDME
			   WHERE UserID = @StudentID
				and LessonID = @LessonID
				and DME = ''salt.variables.VarRunningPageCount''
		
        if @VarRunningPageCount like ''Quiz%'' or @VarRunningPageCount like ''Page 1 %''
        BEGIN
            SELECT @VarRunningPageCount = ''''
        END
        ELSE
        BEGIN
			SELECT @LessonLocation = value 
				 FROM  tblScormDME
				 WHERE UserID = @StudentID
					and LessonID = @LessonID
					and DME = ''cmi.core.lesson_location''
			SELECT @VarPageInChapter = value 
				 FROM  tblScormDME
				 WHERE UserID = @StudentID
					and LessonID = @LessonID
					and DME = ''salt.variables.VarPageInChapter''
			SELECT @VarPagesInChapter = value 
				 FROM  tblScormDME
				 WHERE UserID = @StudentID
					and LessonID = @LessonID
					and DME = ''salt.variables.VarPagesInChapter''

			SELECT @CurrentPage = value 
				 FROM  tblScormDME
				 WHERE UserID = @StudentID
					and LessonID = @LessonID
					and DME = ''salt.currentpage''
					
            SELECT @LectoraBookmark = Q.lectoraBookmark 
                FROM tblLesson L 
				inner join tblQuiz Q on L.ModuleID =  Q.ModuleID 
				WHERE L.Active = 1 and Q.Active = 1 and L.moduleID = @lessonID   
		END		
		SELECT DME,value FROM  tblScormDME
			   WHERE UserID = @StudentID
				and LessonID = @LessonID
				and DME not in (''salt.variables.VarRunningPageCount''
								, ''cmi.core.lesson_location''
								,''salt.variables.VarPageInChapter''
								,''salt.variables.VarPagesInChapter''
								,''salt.currentpage'')
				
		UNION SELECT ''salt.lessonorquiz'' as DME, ''lesson'' as [value]		
		UNION SELECT ''salt.training.QuizURL2'' as DME, @LectoraBookmark as [value]
		UNION SELECT ''salt.variables.VarRunningPageCount'' as DME, @VarRunningPageCount as [value]
		UNION SELECT ''cmi.core.lesson_location'' as DME, @LessonLocation as [value]
		UNION SELECT ''salt.variables.VarPageInChapter'' as DME, @VarPageInChapter as [value]
		UNION SELECT ''salt.variables.VarPagesInChapter'' as DME, @VarPagesInChapter as [value]
		UNION SELECT ''salt.currentpage'' as DME, @CurrentPage as [value]
		
	end
	else
	begin
		
		-- delete the existing quiz dmes
		delete from tblScormDME 
		where UserID  =@StudentID and LessonID =@LessonID
		and DME in (''cmi.suspend_data'',''cmi.core.lesson_location'')
						
		
	    Declare @QuizBookmark varchar(1000)
		SELECT @QuizBookmark =   Q.lectoraBookmark from tblLesson L 
				inner join tblQuiz Q on L.ModuleID =  Q.ModuleID where L.Active = 1 and Q.Active = 1 and L.moduleID = @lessonID  		
		SELECT DME,value FROM  tblScormDME
				 WHERE UserID = @StudentID
					and LessonID = @LessonID				
		UNION SELECT ''cmi.core.lesson_location'' AS DME, @QuizBookmark as [value]
		UNION SELECT ''salt.lessonorquiz'' as DME, ''quiz'' as [value]	
	end

END

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSCORMgetValue]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [dbo].[prcSCORMgetValue] (
             @StudentID int,
             @LessonID int,
             @DME  varchar(50)
           )  
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
if @DME=''cmi.core.lesson_location''
begin
		SELECT  Q.lectoraBookmark from tblLesson L 
		inner join tblQuiz Q on L.ModuleID =  Q.ModuleID where L.Active = 1 and Q.Active = 1 and L.lessonID = @lessonID
end
else
begin
	if not exists(	SELECT [value] FROM  tblScormDME WHERE UserID = @StudentID and LessonID = @LessonID and DME = @DME)
	begin 
		select ''''
	end
	else
	begin 
		SELECT [value] FROM  tblScormDME
		WHERE UserID = @StudentID
		and LessonID = @LessonID
		and DME = @DME
	end
end
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSCORMimport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcSCORMimport]
@intModuleID integer,
@strToolLocation varchar(100),
@strQFSLocation varchar(100),
@DatePublished datetime,
@intUserID integer,
@SCORMsource varchar(100)
AS
BEGIN
--Set @intLessonID 	= dbo.udfGetLessonIDByToolbookIDAndModuleID (@strToolbookID,@intModuleID)


Declare @LWorkSiteID nvarchar(50)
Declare @QFWorkSiteID nvarchar(50)
Declare @intLessonID integer
Declare @intquizID integer

Select @LWorkSiteID = LWorkSiteID, @QFWorkSiteID = QFWorkSiteID From tblLesson Where LessonID = @intLessonID

---- Deactivate the existing lesson if it exists
Begin
Update
tblLesson
Set
Active = 0
Where
ModuleID = @intModuleID
End


-- Create the new lesson
Insert Into tblLesson
(
ModuleID,
ToolbookID,
ToolbookLocation,
QFSlocation,
DatePublished,
LoadedBy,
DateLoaded,
Active,
LWorkSiteID,
QFWorkSiteID,
Scorm1_2
)
-- With the values from the old lesson
VALUES
(
@intModuleID,
''SCOnew'',
@strToolLocation,
@strQFSLocation,
@DatePublished,
@intUserID,		-- Loaded By
GETDATE(),		-- Date Loaded
1,				-- Active
@LWorkSiteID,
@QFWorkSiteID,
1
)
-- Get the new lesson id
SELECT 	@intLessonID =  LessonID FROM tblLesson where Active = 1 AND ModuleID = @intModuleID

UPDATE tblLesson set ToolbookID = ''SCO'' + CAST(LessonID as varchar(9)) WHERE LessonID = @intLessonID

-- Insert the new lesson pages
Insert Into tblLessonPage
(
LessonID,
ToolbookPageID,
Title
)

Select
@intLessonID,
''SCORM 1.2 lesson'',
''IFRAME 1.2''

--delete bookmarks to old content
DELETE FROM tblScormDME where lessonID = @intModuleID

Declare @QuizLaunchPoint nvarchar(100)
SELECT @QuizLaunchPoint =   COALESCE(QuizLaunchPoint,'' '') FROM tblSCORMcontent WHERE LessonLaunchPoint = @SCORMsource 
IF @QuizLaunchPoint <> '' ''
BEGIN

    Declare @strToolLocationReverse varchar(100)
    Declare  @strToolDirectory varchar(100)
    SELECT @strToolLocationReverse = reverse (@strToolLocation)
    SELECT @strToolDirectory = substring(@strToolLocation,1, LEN(@strToolLocation)-CHARINDEX ( ''/'' ,@strToolLocationReverse)  ) 
	Update tblQuiz Set Active = 0 Where ModuleID = @intModuleID
	INSERT INTO tblQuiz
           ([ModuleID]
           ,[ToolbookID]
           ,[ToolbookLocation]
           ,[DatePublished]
           ,[LoadedBy]
           ,[DateLoaded]
           ,[Active]
           ,[WorksiteID]
           ,Scorm1_2
           ,LectoraBookmark    )
     VALUES
           (@intModuleID
           ,''SCO''
           ,@strToolLocation 
           -- ,@strToolDirectory +''/''+@QuizLaunchPoint
           ,@DatePublished
           ,1
           ,getUTCdate()
           ,1
           ,null,1
           ,@QuizLaunchPoint  )
         SELECT 	@intquizID =  quizID FROM tblQuiz where Active = 1 AND ModuleID = @intModuleID

UPDATE tblQuiz set ToolbookID = ''SCO'' + CAST(quizID as varchar(9)) WHERE quizID = @intquizID  
END

SELECT @intLessonID
END
' 
END
GO


/****** Object:  StoredProcedure [dbo].[prcSCORMpublishcontent]    Script Date: 12/19/2012 15:23:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSCORMpublishcontent]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcSCORMpublishcontent]
	@LessonLaunchPoint nvarchar(100) ,
	@QFS nvarchar(100) ,
	@QuizLaunchPoint [nvarchar](100) ,
	@CourseName [nvarchar](100) ,
	@ModuleName [nvarchar](100) 
AS
BEGIN

INSERT INTO tblSCORMcontent
           ([LessonLaunchPoint]
           ,[QFS]
           ,[QuizLaunchPoint]
           ,[CourseName]
           ,[ModuleName])
     VALUES
           (@LessonLaunchPoint
           ,@QFS
           ,@QuizLaunchPoint
           ,@CourseName
           ,@ModuleName)
END
' 
END
GO


/****** Object:  StoredProcedure [dbo].[prcSCORMpublishedcontent]    Script Date: 12/19/2012 15:23:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSCORMpublishedcontent]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE  [prcSCORMpublishedcontent]

AS
BEGIN
SELECT LessonLaunchPoint + ''?QFS='' + QFS as  launchpoint,''"''+CourseName + ''" - '' + ModuleName + '' ''+ CAST(contentID AS varchar(9)) AS title FROM tblSCORMcontent order by contentID DESC
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSCORMsetValue]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcSCORMsetValue] (
             @StudentID int,
             @LessonID int,
             @DME  varchar(50),
             @value  varchar(4000)
           )  
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
    DELETE FROM tblScormDME where UserID = @StudentID and LessonID = @LessonID and DME = @DME
    DECLARE @quizAnswer varchar(100)
    SET @quizAnswer = @DME 

    IF LEN(@quizAnswer) >= 14  set @quizAnswer =	SUBSTRING(@quizAnswer,1,15)

    if (@quizAnswer <> ''cmi.interaction'')
    BEGIN  
	INSERT INTO tblScormDME
           (UserID
           ,LessonID
           ,DME
           ,[value])
     VALUES (
           @StudentID,
           @LessonID, 
           @DME, 
           @value)
      END     
END

' 
END
GO


 SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSCORMtrainQandA]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE Procedure [prcSCORMtrainQandA] 
(
	@StudentID int,
    @intModuleID Int,
    @intAskedQuestion Int,
    @intWeighting Int,
    @strLatency NVarChar(100),
    @strTime NVarChar(100),
    @strText NVarChar(1000), 
    @strCorrectResponse NVarChar(1000), 
    @strStudentResponse NVarChar(1000), 
    @strType NVarChar(100), 
    @strID NVarChar(100), 
    @isCorrect Bit,
    @strQuizSessionID nvarchar(200)
)
as
begin
		
		IF (@strQuizSessionID IS NOT NULL)
		BEGIN
			declare @intQuizID int;

			set @intQuizID = (
					select top 1 QuizID
					from tblQuiz
					where moduleID = @intModuleID
						and Active = 1
					)

			declare @QuizQuestionID int

			select @QuizQuestionID = (
					select top 1 QuizQuestionID
					from tblQuizQuestion
					where QuizID = @intQuizID
						and ToolbookPageID = @strID
						and Question = @strText
					)

			if (@QuizQuestionID is null)
			begin
				delete
				from tblQuizQuestion
				where QuizID = @intQuizID
					and ToolbookPageID = @strID

				insert tblQuizQuestion (
					QuizID
					,ToolbookPageID
					,Question
					)
				values (
					@intQuizID
					,@strID
					,@strText
					)
				select @QuizQuestionID = @@IDENTITY
			end

			declare @QuizAnswerID int
			--
			select @QuizAnswerID = (
					select top 1 QuizAnswerID
					from tblQuizAnswer
					where QuizQuestionID = @QuizQuestionID
						and ToolbookAnswerID = SUBSTRING(@strStudentResponse,0,49)
						and Answer = @strStudentResponse
					)

			if (@QuizAnswerID is null)
			begin
				delete
				from tblQuizAnswer
				where QuizQuestionID = @QuizQuestionID
					and ToolbookAnswerID = SUBSTRING(@strStudentResponse,0,49)

				insert tblQuizAnswer (
					QuizQuestionID
					,ToolbookAnswerID
					,Answer
					,correct
					)
				values (
					@QuizQuestionID
					,SUBSTRING(@strStudentResponse,0,49)
					,@strStudentResponse
					,@isCorrect
					)
				select @QuizAnswerID = @@IDENTITY
			end
			
			declare @QuizCorrectAnswerID int
			select @QuizCorrectAnswerID = (
					select top 1 QuizAnswerID
					from tblQuizAnswer
					where QuizQuestionID = @QuizQuestionID
						and ToolbookAnswerID = SUBSTRING(@strCorrectResponse,0,49)
						and Answer = @strCorrectResponse
					)

			if (@QuizCorrectAnswerID is null)
			begin
				delete
				from tblQuizAnswer
				where QuizQuestionID = @QuizQuestionID
					and ToolbookAnswerID = SUBSTRING(@strCorrectResponse,0,49)

				insert tblQuizAnswer (
					QuizQuestionID
					,ToolbookAnswerID
					,Answer
					,correct
					)
				values (
					@QuizQuestionID
					,SUBSTRING(@strCorrectResponse,0,49)
					,@strCorrectResponse
					,1
					)
				select @QuizCorrectAnswerID = @@IDENTITY
					
			end
			
			IF NOT EXISTS (SELECT * FROM tblQuizQuestionAudit WHERE QuizSessionID = @strQuizSessionID AND QuizQuestionID = @QuizQuestionID)
			BEGIN
				INSERT INTO tblQuizQuestionAudit( QuizSessionID,QuizQuestionID,Duration,DateAccessed)
				VALUES  (@strQuizSessionID, @QuizQuestionID, 46664, getUTCdate())
			END
			if not exists (SELECT * FROM tblQuizAnswerAudit WHERE QuizSessionID = @strQuizSessionID AND QuizQuestionID = @QuizQuestionID AND QuizAnswerID = @QuizAnswerID)
			BEGIN
				INSERT INTO tblQuizAnswerAudit (QuizSessionID,QuizQuestionID,QuizAnswerID)
				values (@strQuizSessionID,@QuizQuestionID,@QuizAnswerID) 
			END
		END

 end

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSearchAdminUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 27/10/2011
-- Description:	Searches the Unit and Org Admins with First name and last name
-- =============================================
CREATE PROCEDURE [prcSearchAdminUsers] 
(
	-- Add the parameters for the stored procedure here
	@OrgID int,
	@Firstname varchar(100), 
	@LastName varchar(100)
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

If @Firstname is null
Set @Firstname = ''''

Set @Firstname =rtrim(@firstName)

If @LastName is null
Set @LastName = ''''

Set @LastName =rtrim(@lastName)

	SELECT UserID, FirstName, LastName, UserName, Email, ut.Type
		FROM tblUser u JOIN tblUserType ut ON u.UserTypeID = ut.UserTypeID
		WHERE FirstName like @Firstname + ''%'' 
		AND LastName like @LastName +''%'' AND OrganisationID=@OrgID
		AND u.UserTypeID <> 4 
		AND u.Active = 1
END' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSearchUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 27/10/2011
-- Description:	Searches the Users with First name and last name
-- =============================================
CREATE PROCEDURE [prcSearchUsers] 
(
	-- Add the parameters for the stored procedure here
	@OrgID int,
	@Firstname varchar(100), 
	@LastName varchar(100),
	@ScheduleId int
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

If @Firstname is null
Set @Firstname = ''''

Set @Firstname =rtrim(@firstName)

If @LastName is null
Set @LastName = ''''

Set @LastName =rtrim(@lastName)

	SELECT UserID, 
		CASE u.Active WHEN 1 THEN FirstName WHEN 0 THEN FirstName + ''(I)'' END AS FirstName, 
		LastName, UserName, Email
		FROM tblUser u JOIN tblUserType ut ON u.UserTypeID = ut.UserTypeID
		WHERE FirstName like @Firstname + ''%'' 
		AND LastName like @LastName +''%'' AND OrganisationID=@OrgID
--		AND u.UserTypeID <> 4 
--		AND u.UserID NOT IN (SELECT UserID FROM tblCCList WHERE ScheduleId = @ScheduleId)
END' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSetPeriodicFields]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 27/10/2011
-- Description:	Sets the periodicity related fields for a periodic report
-- =============================================
CREATE PROCEDURE [prcSetPeriodicFields] 
(
	@ScheduleId int,
	@ReportTitle nvarchar(100),
	@IsPeriodic char(1),
	@ReportStartDate datetime,
	@ReportFrequency int, 
	@ReportFrequencyPeriod char(1),
	@ReportEndDate datetime,
	@NumberOfReports int,
	@ReportPeriodType int,
	@ReportFromDate datetime
)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	IF NOT EXISTS (SELECT ScheduleId FROM tblReportSchedule WHERE ScheduleId = @ScheduleId)
	BEGIN
		INSERT INTO tblReportSchedule(ReportTitle, IsPeriodic, ReportStartDate, ReportFrequency, ReportFrequencyPeriod, ReportEndDate, NumberOfReports, ReportPeriodType, ReportFromDate, NextRun)
			VALUES (@ReportTitle, @IsPeriodic, @ReportStartDate, @ReportFrequency, @ReportFrequencyPeriod, @ReportEndDate, @NumberOfReports, @ReportPeriodType, @ReportFromDate, NULL)
	END
	ELSE
	BEGIN
		 UPDATE tblReportSchedule SET ReportTitle=@ReportTitle, IsPeriodic=@IsPeriodic, ReportStartDate=@ReportStartDate, ReportFrequency=@ReportFrequency, 
			ReportFrequencyPeriod=@ReportFrequencyPeriod, ReportEndDate=@ReportEndDate, NumberOfReports=@NumberOfReports, ReportPeriodType=@ReportPeriodType, ReportFromDate=@ReportFromDate,
			NextRun=NULL WHERE ScheduleID=@ScheduleId
	END 
END' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSqlAgentRunningStatus_Get]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
return teh running state of the SQLServerAgent
Returns:
sclaer

Called By:
Bdw.Application.Salt.BusinessServices.Application.GetSqlAgentRunningStatus
Calls:
master..xp_servicecontrol
Remarks:
- May not work if permissions are insuficient

Author:
Stephen Kennedy-Clark
Date Created: 10 May 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



--------------------
prcSqlAgentRunningStatus_Get

**/
CREATE Procedure [prcSqlAgentRunningStatus_Get]

AS


EXEC master..xp_servicecontrol ''QUERYSTATE'', ''SQLServerAgent''

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZoneRule_add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcTimeZoneRule_add]
(
@WrittenName NVarChar(60),
@OffsetDaylight Int,
@year_start Int,
@year_end  Int,
@StartTimeOfDay Int,
@day_start Int,
@week_start Int,
@StartMonth Int,
@EndTimeOfDay Int,
@EndDayOfWeek Int,
@EndWeek Int,
@EndMonth Int,
@Error bit output
)
AS
BEGIN

DECLARE @TimezoneID int
DECLARE @Period_start datetime, @Period_end datetime
exec prcTimeZone_GetTimeZoneID @WrittenName, @TimezoneID out
IF (@year_start < 1970) set @year_start = 1970  -- UNIX EPOCH
IF (@year_end > 2999) set @year_end = 2999		-- Y3K BUG?



-- the first_start_date and last_end_date may cover a period of decades so we now have to decide if the rule is applied at the datetime given
-- so calculate the exact start and end dates and times for the relevant daylight saving period (in the year being considered)


-- start with a period (@Period_start datetime, @period_end datetime) that just has the correct year digits


--if  (@startmonth > @endmonth) set @year_start = @year_start - 1   -- rule spans december 31 so adjust

IF(@startmonth > @endmonth)  set @year_end = @year_end + 1  -- rule spans december 31 so adjust






-- Calculate the earlist start date and the last finish date
set @Period_start = ''1 jan 2000'' -- start with a known datetime
Set @Period_start = DATEADD(year,@year_start- 2000,@Period_start) -- then adjust it to match the definition
Set @Period_start = DATEADD(month,@StartMonth-1,@Period_start)
Set @Period_start = DATEADD(week,@week_start-1,@Period_start)
Declare @day_offset int
if (@day_start >=  DatePart(weekday,@Period_start) ) set @day_offset = @day_start -  DatePart(weekday,@Period_start) else  set @day_offset = @day_start -  DatePart(weekday,@Period_start) + 7
Set @Period_start = DATEADD(day,@day_offset,@Period_start)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_start) > @StartMonth) set @Period_start = DATEADD(week,-1,@Period_start)
SET @Period_start = DATEADD(minute, @StartTimeOfDay, @Period_start)

set @Period_end = ''1 jan 2000'' -- start with a known datetime
Set @Period_end = DATEADD(year,@year_end- 2000,@Period_end) -- then adjust it to match the definition
Set @Period_end = DATEADD(month,@EndMonth-1,@Period_end)
Set @Period_end = DATEADD(week,@EndWeek-1,@Period_end)
if (@EndDayOfWeek >=  DatePart(weekday,@Period_end) ) set @day_offset = @EndDayOfWeek -  DatePart(weekday,@Period_end) else  set @day_offset = @EndDayOfWeek -  DatePart(weekday,@Period_end) + 7
Set @Period_end = DATEADD(day,@day_offset,@Period_end)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_end) > @EndMonth) set @Period_end = DATEADD(week,-1,@Period_end)
SET @Period_end = DATEADD(minute, @EndTimeOfDay, @Period_end)

DECLARE @Existing int

SELECT @Existing = COUNT(*) FROM tblTimeZoneDaylightSavingRules
WHERE (first_start_date < @Period_end) AND (last_end_date > @Period_start)
AND TimezoneID = @TimezoneID

IF (@Existing <> 0)
BEGIN
SET @Error = 1
END
ELSE
BEGIN
INSERT INTO tblTimeZoneDaylightSavingRules
([TimezoneID]
,[offset_mins]
,[start_year]
,[end_year]
,[hours_start]
,[day_start]
,[week_start]
,[month_start]
,[hours_end]
,[day_end]
,[week_end]
,[month_end]
,[first_start_date]
,[last_end_date]
)
VALUES
(@TimezoneID,
@OffsetDaylight,
@year_start,
@year_end,
@StartTimeOfDay,
@day_start,
@week_start ,
@StartMonth ,
@EndTimeOfDay ,
@EndDayOfWeek ,
@EndWeek ,
@EndMonth,
@Period_start,
@Period_end
)
SET @Error = 0
END

SELECT @Error

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZoneRule_update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 18/06/2011
-- Description:	Updates the daylight saving rule for timeaone
-- =============================================
CREATE PROCEDURE [prcTimeZoneRule_update]
(
@RuleID int,
@WrittenName NVarChar(60),
@OffsetDaylight Int,
@year_start Int,
@year_end  Int,
@StartTimeOfDay Int,
@day_start Int,
@week_start Int,
@StartMonth Int,
@EndTimeOfDay Int,
@EndDayOfWeek Int,
@EndWeek Int,
@EndMonth Int,
@Error bit output
)
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

DECLARE @TimezoneID int
DECLARE @Period_start datetime, @Period_end datetime
exec prcTimeZone_GetTimeZoneID @WrittenName, @TimezoneID out
IF (@year_start < 1970) set @year_start = 1970  -- UNIX EPOCH
IF (@year_end > 2999) set @year_end = 2999		-- Y3K BUG?

-- Calculate the earlist start date and the last finish date
set @Period_start = ''1 jan 2000'' -- start with a known datetime
Set @Period_start = DATEADD(year,@year_start- 2000,@Period_start) -- then adjust it to match the definition
Set @Period_start = DATEADD(month,@StartMonth-1,@Period_start)
Set @Period_start = DATEADD(week,@week_start-1,@Period_start)
Declare @day_offset int
if (@day_start >=  DatePart(weekday,@Period_start) ) set @day_offset = @day_start -  DatePart(weekday,@Period_start) else  set @day_offset = @day_start -  DatePart(weekday,@Period_start) + 7
Set @Period_start = DATEADD(day,@day_offset,@Period_start)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_start) > @StartMonth) set @Period_start = DATEADD(week,-1,@Period_start)
SET @Period_start = DATEADD(minute, @StartTimeOfDay, @Period_start)

set @Period_end = ''1 jan 2000'' -- start with a known datetime
Set @Period_end = DATEADD(year,@year_end- 2000,@Period_end) -- then adjust it to match the definition
Set @Period_end = DATEADD(month,@EndMonth-1,@Period_end)
Set @Period_end = DATEADD(week,@EndWeek-1,@Period_end)
if (@EndDayOfWeek >=  DatePart(weekday,@Period_end) ) set @day_offset = @EndDayOfWeek -  DatePart(weekday,@Period_end) else  set @day_offset = @EndDayOfWeek -  DatePart(weekday,@Period_end) + 7
Set @Period_end = DATEADD(day,@day_offset,@Period_end)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_end) > @EndMonth) set @Period_end = DATEADD(week,-1,@Period_end)
SET @Period_end = DATEADD(minute, @EndTimeOfDay, @Period_end)

DECLARE @Existing int

SELECT @Existing = COUNT(*) FROM tblTimeZoneDaylightSavingRules
WHERE (first_start_date < @Period_end) AND (last_end_date > @Period_start)
AND TimezoneID = @TimezoneID AND TimezoneRuleID <> @RuleID

IF (@Existing <> 0)
BEGIN
SET @Error = 1
END
ELSE
BEGIN
UPDATE tblTimeZoneDaylightSavingRules SET
offset_mins=@OffsetDaylight
, start_year=@year_start
, end_year=@year_end
, hours_start=@StartTimeOfDay
, day_start=@day_start
, week_start=@week_start
, month_start=@StartMonth
, hours_end=@EndTimeOfDay
, day_end=@EndDayOfWeek
, week_end=@EndWeek
, month_end=@EndMonth
, first_start_date=@Period_start
, last_end_date=@Period_end
WHERE TimezoneID=@TimezoneID AND TimezoneRuleID=@RuleID

SET @Error = 0
END

SELECT @Error
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE procedure [prcTimeZone_add]
(
@WrittenName nvarchar(60),
@OffsetUTC int,
@FLB_Name nvarchar(60)
)
as
DELETE FROM tblTimeZone
WHERE WrittenName = @WrittenName
DECLARE @TimezoneID int
exec prcTimeZone_GetTimeZoneID @WrittenName, @TimezoneID out
DELETE FROM tblTimeZoneDaylightSavingRules
WHERE TimezoneID = @TimezoneID
INSERT INTO tblTimeZone
(WrittenName
,OffsetUTC
,FLB_Name
,Active)
VALUES
(@WrittenName
,@OffsetUTC
,@FLB_Name
,''true'')
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetFLBNamefromTZID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra
-- Create date: 29/06/2011
-- Description:	Gets the FLB Name of timezone from id
-- =============================================
CREATE PROCEDURE [prcTimeZone_GetFLBNamefromTZID]
@TimezoneID int
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

SELECT FLB_Name FROM tblTimeZone WHERE TimeZoneID=@TimezoneID

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE Procedure [prcTimeZone_GetList]

As

SELECT TimeZoneID
,WrittenName
,OffsetUTC
,FLB_Name
FROM tblTimeZone
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetTimeZoneFLBName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE Procedure [prcTimeZone_GetTimeZoneFLBName]
(
@TimeZoneID int
)

As

select FLB_Name from tblTimeZone where TimeZoneID = @TimeZoneID
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetTimeZoneID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



CREATE Procedure [prcTimeZone_GetTimeZoneID]
(
@WrittenName varchar(60),
@TimeZoneID int output
)

As

select @TimeZoneID = coalesce(TimeZoneID,1) from tblTimeZone where upper(WrittenName) = upper(@WrittenName)
select @TimeZoneID

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetTimeZoneWrittenName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



CREATE Procedure [prcTimeZone_GetTimeZoneWrittenName]
(
@TimeZoneID int
)

As

select WrittenName from tblTimeZone where TimeZoneID = @TimeZoneID




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetTZIDfromFLBName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra
-- Create date: 27/06/2011
-- Description:	Gets the timezone id from its display name
-- =============================================
CREATE PROCEDURE [prcTimeZone_GetTZIDfromFLBName]
@FLBName nvarchar(240)
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

SELECT TimeZoneID FROM tblTimeZone WHERE FLB_Name LIKE ''%'' + @FLBName + ''%''

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcToolbook_Import]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Uploads the details from an XML document to the tblLesson,tblLessonPage,tblQuiz, tblQuizQuestion, tblQuizAnswer table
Parameters:
@strXMLData Text = null, 	        	-- XML document
@intUserID Integer = null,          		-- ID of user inporting the xmlData
@intModuleID Integer = null,        		 -- Module Id that this quiz or lesson is associated with.
@intCourseID Integer = null,         	-- Course Id that this quiz or lesson is associated with.
@strToolLocation Varchar(500) = Null	-- Relative path to the toolbook content
Returns:
two Result sets

-- Return Results
One: The first result set has the totals for the Upload
The Upload Type - Lesson or Quiz
The time the upload took place.
The LessonID or the Quiz ID

Two: The second result set holds the detail of the records that were inserted


Called By:
Toolbook.cs
Calls:
sp_xml_preparedocument -- system stored procedure to ALTER  an internal representation of the XML document.
udfGetQuizIDByToolbookIDAndModuleID
udfGetLessonIDByToolbookIDAndModuleID

Remarks: The XML document must be well formed otherwise the process will fail.

Author: Peter Kneale
Date Created: 23rd of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Jack Liu	12/09/2005		Comment out the update answer correct status if the quiz is CORRECTION
For Quiz CORRECTION, the correct answer can''t be changed, this is validated in the prcToolbook_preview
#2	mikev		4/5/2007		Added worksiteIDs for Quiz and Lesson and that the value is copied from the old quiz/lesson to the new one.
#3	mike		4/5/2007		There is no longer a concept of corrections. All uploads are now considered updates. I have removed the updatetype variable, update statement logic and the insert logic remains.

*/
CREATE  Procedure [prcToolbook_Import]
(
@strXMLData NText = null, 	        	-- XML document
@intUserID Integer = null,          		-- ID of user inporting the xmlData
@intModuleID Integer = null,        		 -- Module Id that this quiz or lesson is associated with.
@intCourseID Integer = null,         	-- Course Id that this quiz or lesson is associated with.
@strToolLocation Varchar(500) = Null	-- Relative path to the toolbook content
)

As
Set NoCount On
Set Xact_Abort On

-- Check if the XML document was passed.
If(@strXMLData Is Null)
Begin
Raiserror(''The @strXMLData parameter was Null.  You must supply a valid XML document.'', 16, 1)
Return
End

-- Check if the ID was passed.
If(@intUserID Is Null)
Begin
Raiserror(''The @intUserID parameter was Null.  You must supply a value.'', 16, 1)
Return
End

-- Check if the Module ID was passed.
If(@intModuleID Is Null)
Begin
Raiserror(''The @intModuleID parameter was Null.  You must supply a value.'', 16, 1)
Return
End

-- Check if the Course ID was passed.
If(@intCourseID Is Null)
Begin
Raiserror(''The @intCourseID parameter was Null.  You must supply a value.'', 16, 1)
Return
End

-- Check if the Toolbook Location was passed.
If(@strToolLocation Is Null)
Begin
Raiserror(''The @strToolLocation parameter was Null.  You must supply a value.'', 16, 1)
Return
End




Declare @intDocHeader			 	Integer
Declare @strRowPattern 				nVarchar(50)
Declare @strToolbookType 			nVarchar(50)
Declare	@strUploadType				nVarchar(50)
Declare @strToolbookID				Varchar(50)
Declare @DatePublished				DateTime
Declare @intXMLUpdates				Integer

-- Quiz Specific
Declare @intQuizID				Integer
Declare @intDocQuizQuestions			Integer
Declare @intDocQuizAnswers			Integer
Declare @intQuestions				Integer
Declare @intAnswers				Integer

-- Lesson
Declare @intLessonID				Integer
Declare @intDocLessons				Integer
Declare @intLessons				Integer

-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
----------- Create Necessary Temporary Tables
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------
-------- Create Imaginary Table for Quiz Answers
----------------------------------------------------------------------------
Create Table #xmlUploadQuizAnswers
(
ToolbookQuestionID	Varchar(50),	-- The toolbook Question ID of from the new content
ToolbookAnswerID	Varchar(50),	-- The toolbook Answer ID of from the new content
Correct 		Varchar(255),	-- ''True'' or ''False'' indicating if the answer is correct
bCorrect 		bit,		-- 0 or 1 indicating if the answer is correct, this is derived from the Correct Column
AnswerText		nVarchar(1000),	-- The textual answer
QuizQuestionID		Integer		-- The QuizQuestion ID from the Salt Database.
)

----------------------------------------------------------------------------
-------- Create Temporary Table for Quiz Questions
----------------------------------------------------------------------------
Create Table #xmlUploadQuizQuestions
(
ToolbookPageID	Varchar(50),
PageTitle 		nVarchar(1000),
)

----------------------------------------------------------------------------
-------- Create Imaginary Table for Quiz Answers
----------------------------------------------------------------------------
Create Table #xmlUploadLessons
(
ToolbookPageID	Varchar(50),
PageTitle 		nVarchar(1000),
)

----------------------------------------------------------------------------
-------- Create Imaginary Table for Upload Information
----------------------------------------------------------------------------
Create Table #xmlUploadHeader
(
ToolBookID		Varchar(50),
ToolBookType 		Varchar(50),
NumberOfPages 		Integer,
DatePublished		DateTime,
UploadType		Varchar(50)
)


Begin Transaction

----------------------------------------------------------------------------
-------- Insert Upload Information Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload''
Exec sp_xml_preparedocument @intDocHeader Output, @strXMLData

Insert into #xmlUploadHeader
(
ToolBookID,
ToolBookType,
NumberOfPages,
DatePublished,
UploadType
)

Select
ToolBookID,
ToolBookType,
NumberOfPages,
DatePublished,
UploadType
From

OpenXml
(@intDocHeader, @strRowPattern)
With
(
ToolBookID		Varchar(50) 	''ToolBookID'',
ToolBookType		Varchar(50)	''ToolBookType'',
NumberOfPages		Integer		''NumberOfPages'',
DatePublished		DateTime	''DatePublished'',
UploadType		Varchar(50)	''UploadType''
)

----------------------------------------------------------------------------
-------- Insert Lessons Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload/Pages/Page''
Exec sp_xml_preparedocument @intDocLessons Output, @strXMLData

Insert into #xmlUploadLessons
(
ToolbookPageID,
PageTitle
)

Select
ToolbookPageID,
PageTitle
From

OpenXml
(@intDocLessons, @strRowPattern)
With
(
ToolbookPageID	Varchar(50) 	''@ID'',
PageTitle	nVarchar(1000)	''PageTitle''
)


----------------------------------------------------------------------------
-------- Insert Quiz Questions Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload/Pages/Page''
Exec sp_xml_preparedocument @intDocQuizQuestions Output, @strXMLData

Insert into #xmlUploadQuizQuestions
(
ToolbookPageID,
PageTitle

)

Select
ToolbookPageID,
PageTitle
From

OpenXml
(@intDocQuizQuestions, @strRowPattern)
With
(
ToolbookPageID	Varchar(50) 	''@ID'',
PageTitle	nVarchar(1000)	''PageTitle''
)



----------------------------------------------------------------------------
-------- Insert Quiz Answers Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload/Pages/Page/Answers/Answer''
Exec sp_xml_preparedocument @intDocQuizAnswers Output, @strXMLData

Insert into #xmlUploadQuizAnswers
(
ToolbookQuestionID,
ToolbookAnswerID,
AnswerText,
Correct
)
Select
ToolbookQuestionID,
ToolbookAnswerID,
AnswerText,
Correct
From

OpenXml
(@intDocQuizAnswers, @strRowPattern)
With
(
ToolbookQuestionID	Varchar(50) 	''../../@ID'',	-- Navigate back up to the question Id from this grandchild node
ToolbookAnswerID	Varchar(50) 	''@ID'',
AnswerText		nVarchar(1000)	''AnswerText'',
Correct			Varchar(255)	''@correct''
)

----------------------------------------------------------------------------------------------------
-------- Determine if we are uploading a Quiz or a Lesson and whether its an update or a correction
----------------------------------------------------------------------------------------------------

Select
@strToolbookType 	= ToolBookType 	-- ''Quiz or Lesson''
From
#xmlUploadHeader

-- Get Toolbook ID
Select
@strToolbookID = ToolBookID
From
#xmlUploadHeader

-- Get Date Published
Select
@DatePublished = DatePublished
From
#xmlUploadHeader




























-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
----------- Process Upload from Imaginary Tables
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------



If (ltrim(rtrim(@strToolbookType)) = ''QUIZ'')
Begin
-- Get the quiz ID if it exists
Set 	@intQuizID 		= dbo.udfGetQuizIDByToolbookIDAndModuleID (@strToolbookID,@intModuleID)


-------------------------------------------------------------------------------------------------------------------------------------
----------- Perform an update
-------------------------------------------------------------------------------------------------------------------------------------

Declare @WorksiteID nvarchar(50)

Select @WorksiteID = WorksiteID From tblQuiz Where QuizID = @intQuizID

---- Deactivate the existing quiz if it exists
Update
tblQuiz
Set
Active = 0
Where
ModuleID = @intModuleID


INSERT INTO
tblQuiz
(
ModuleID,
ToolbookID,
ToolbookLocation,
DatePublished,
LoadedBy,
DateLoaded,
Active,
WorkSiteID
)
VALUES
(
@intModuleID,
@strToolbookID,
@strToolLocation,
@DatePublished,
@intUserID,     -- Loaded By
GETDATE(),      -- Date Loaded
1,              -- Active
@WorksiteID
)

-- With the new values


-- Get the new quiz ID for the active quiz
Set 	@intQuizID 		= dbo.udfGetQuizIDByToolbookIDAndModuleID (@strToolbookID,@intModuleID)
-- Verify that the new quiz was inserted
If (@intQuizID = null)
Begin
Select ''Could not find the new Quiz to provide questions and answers for.'' as ''Error''
Goto ErrorHandler
End

-- Insert the new questions
Insert Into tblQuizQuestion
(
QuizID,
ToolbookPageID,
Question
)

Select
@intQuizID,
ToolbookPageID,
PageTitle
From
#xmlUploadQuizQuestions


-------------------------------------------------------------------------------------------------------------------------------------
----------- Update this temporary table with the appropriate quiz question ids to simplify the update
-------------------------------------------------------------------------------------------------------------------------------------
Update
LogicalTable
Set
LogicalTable.QuizQuestionID = PhysicalTable.QuizQuestionID
From
tblQuizQuestion PhysicalTable
Inner Join
#xmlUploadQuizAnswers LogicalTable
On
PhysicalTable.QuizID = @intQuizID
And
PhysicalTable.ToolbookPageID = LogicalTable.ToolbookQuestionID

-- Update the table with boolean 0 and 1 instead of the string ''True'' and ''False''
Update
#xmlUploadQuizAnswers
set
bCorrect = 1
Where
Correct like ''%true%''

-- Update the table with boolean 0 and 1 instead of the string ''True'' and ''False''
Update
#xmlUploadQuizAnswers
set
bCorrect = 0
Where
Correct like ''%false%''


-- Insert new answers
Insert Into tblQuizAnswer
(
QuizQuestionID,
ToolbookAnswerID,
Answer,
Correct
)
Select
QuizQuestionID,
ToolbookAnswerID,
AnswerText,
bCorrect
From
#xmlUploadQuizAnswers



-- Return message
Select @strUploadType as ''Message'', GETDATE() as ''Time now'', @intQuizID


-- Return Results
Select
#xmlUploadQuizQuestions.PageTitle as ''Corrected Question'',
#xmlUploadQuizAnswers.AnswerText  as ''Corrected Answer''
From
#xmlUploadQuizQuestions,#xmlUploadQuizAnswers
Where
#xmlUploadQuizAnswers.ToolbookQuestionID = #xmlUploadQuizQuestions.ToolbookPageID

End   -- End Quiz























-- Lesson
If (ltrim(rtrim(@strToolbookType)) = ''LESSON'')
Begin
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
----------- Process Upload from Imaginary Tables
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------

-- Get the new lesson ID for the active lesson
Set @intLessonID 	= dbo.udfGetLessonIDByToolbookIDAndModuleID (@strToolbookID,@intModuleID)

-------------------------------------------------------------------------------------------------------------------------------------
----------- Perform an update
-------------------------------------------------------------------------------------------------------------------------------------

-- mikev(2)
Declare @LWorkSiteID nvarchar(50)
Declare @QFWorkSiteID nvarchar(50)

Select @LWorkSiteID = LWorkSiteID, @QFWorkSiteID = QFWorkSiteID From tblLesson Where LessonID = @intLessonID

---- Deactive the existing lesson if it exists
Begin
Update
tblLesson
Set
Active = 0
Where
ModuleID = @intModuleID
End

-- mikev(2)
-- Create the new lesson
Insert Into tblLesson
(
ModuleID,
ToolbookID,
ToolbookLocation,
DatePublished,
LoadedBy,
DateLoaded,
Active,
LWorkSiteID,
QFWorkSiteID
)
-- With the values from the old lesson
VALUES
(
@intModuleID,
@strToolbookID,
@strToolLocation,
@DatePublished,
@intUserID,		-- Loaded By
GETDATE(),		-- Date Loaded
1,				-- Active
@LWorkSiteID,
@QFWorkSiteID
)
-- Get the new lesson id
Set 	@intLessonID 		= dbo.udfGetLessonIDByToolbookIDAndModuleID (@strToolbookID,@intModuleID)

-- Verify that the new lesson was created
If (@intLessonID = null)
Begin
Select ''Could not find the new Lesson to provide pages for.'' as ''Error''
Goto ErrorHandler
End

-- Insert the new lesson pages
Insert Into tblLessonPage
(
LessonID,
ToolbookPageID,
Title
)

Select
@intLessonID,
ToolbookPageID,
PageTitle
From
#xmlUploadLessons


-- Return message
Select @strUploadType as ''Message'', GETDATE() as ''Time now'',@intLessonID as ''Lesson ID''

-- Return Results
Select
#xmlUploadLessons.PageTitle as ''Corrected Lesson''
From
#xmlUploadLessons
End



Commit

Return


--------------------------------------------------------------------
-----------------
--------------------------------------------------------------------

ErrorHandler:

Rollback
Return
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcToolbook_Preview]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Displays a preview of the data from an XML document before inserting it into the tblLesson,tblLessonPage,tblQuiz, tblQuizQuestion, tblQuizAnswer table
Parameters:
@strXMLData Text = null, 	-- XML document
@intModuleID	Integer		-- Module Id of the module
Returns:
two Result sets

-- Return Results
One: The first result set has the totals for the Upload
The Upload Type - Correction or Update
The Toolbook Type - Lesson or Quiz

Two: The second result set holds the detail of the records that will be inserted if spImportToolbook is called.


Called By:
Toolbook.cs
Calls:
sp_xml_preparedocument -- system stored procedure to ALTER  an internal representation of the XML document.
udfGetQuizIDByToolbookIDAndModuleID
udfGetLessonIDByToolbookIDAndModuleID

Remarks: The XML document must be well formed otherwise the process will fail.

Author: Peter Kneale
Date Created: 23rd of February 2004

Modification History
-----------------------------------------------------------
v#	Author			Date			Description
#1	Jack Liu		12/09/2005		Add extra validation for Quiz CORRECTION
For Quiz CORRECTION, the correct answer can''t be changed.
#2	Liz Dionisio	28/09/2005		Modified Quiz Correction validation
#3	mikev			4/5/2007		Removed correction logic
*/
CREATE Procedure [prcToolbook_Preview]
(
@strXMLData     NText = null, 	-- XML document
@intModuleID	Integer       = null,		-- Module Id of the module
@intUserID int
)

As
Set NoCount On
Set Xact_Abort On

-- Check if the XML document was passed.
If(@strXMLData Is Null)
Begin
Raiserror(''The @strXMLData parameter was Null.  You must supply a valid XML document.'', 16, 1)
Return
End
If(@intModuleID Is Null)
Begin
Raiserror(''The @intModuleID parameter was Null.  You must supply a valid XML document.'', 16, 1)
Return
End



Begin Transaction

Declare @intDocHeader			 	Integer		--
Declare @strRowPattern 				Varchar(50)	-- Pattern to match on when calling OpenXML
Declare @strToolbookType 			Varchar(50)	-- Lesson or Quiz
Declare @strUploadType				Varchar(50)	-- Correction or Update
Declare @strToolbookID				Varchar(50)	-- Toolbook ID
Declare @DatePublished				DateTime	-- Date new content was published
Declare @intXMLUpdates				Integer		-- Number of updates contained in the XML file.

-- Quiz specific
Declare @intQuizID				Integer		-- Salt QuizID
Declare @intQuestions				Integer		-- Number of Questions
Declare @intAnswers				Integer		-- Number of Answers
Declare @intDocQuizQuestions			Integer		-- Number of Questions in new content
Declare @intDocQuizAnswers			Integer		-- Number of Answer in new content

-- Lesson specific
Declare @intLessonID				Integer		-- Salt Lesson ID
Declare @intLessons				Integer		-- Number of Lesson pages
Declare @intDocLessons				Integer		-- Number of Lesson pages in new content

-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
----------- Create Necessary Temporary Tables
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------
-------- Create Temporary Table for Quiz Questions
----------------------------------------------------------------------------
Create Table #xmlUploadQuizQuestions
(
ToolbookPageID	Varchar(50),		-- Toolbook Page ID for new Quiz Question
PageTitle 		Varchar(255)		-- Toolbook Question for new Quiz Question
)

----------------------------------------------------------------------------
-------- Create Imaginary Table for Quiz Answers
----------------------------------------------------------------------------
Create Table #xmlUploadQuizAnswers
(
ToolbookQuestionID	Varchar(50),		-- Toolbook Question ID for new Quiz Answer
ToolbookAnswerID	Varchar(50),		-- Toolbook Answer ID for new Quiz Answer
Correct 		Varchar(255),		-- ''True'' or ''False'' indicating whether this answer is correct or not
bCorrect 		bit,			-- 0 or 1 indicating if the answer is correct, this is derived from the Correct Column
AnswerText		Varchar(255),		-- The answer
QuizQuestionID		Integer			-- Salt Quiz Question ID column is a placeholder but is later populated to assist in the upload
)

----------------------------------------------------------------------------
-------- Create Imaginary Table for Lessons
----------------------------------------------------------------------------
Create Table #xmlUploadLessons
(
ToolbookPageID	Varchar(50),		    -- Toolbook Page ID for new Lesson
PageTitle 	Varchar(255)		    -- Toolbook Page Title for new Lesson
)
----------------------------------------------------------------------------
-------- Create Imaginary Table for Upload Information
----------------------------------------------------------------------------
Create Table #xmlUploadHeader
(
ToolBookID		Varchar(50),		    	-- Toolbook ID for new Content
ToolBookType 		Varchar(50),		    	-- Toolbook type, Quiz or Lesson
NumberOfPages 	   	Integer,			-- Number of Pages in new content
DatePublished		DateTime,		        -- Date new content was published
UploadType		Varchar(50)		        -- New Content type, ''Correction'' , ''Update''
)

-- Temporary Tables used for validating the number of questions and answers in the
-- new content compared to the old content
Declare @xmlExisting Table
(
QuizQuestionID	Varchar(50),		-- Toolbook Page ID for new Quiz Question
Answers 	Varchar(255)		-- Toolbook Question for new Quiz Question
)
Declare @xmlNew Table
(
QuizQuestionID	Varchar(50),		-- Toolbook Page ID for new Quiz Question
Answers 	Varchar(255)		-- Toolbook Question for new Quiz Question
)


----------------------------------------------------------------------------
-------- Insert Upload Information Into Imaginary Table

----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload''
Exec sp_xml_preparedocument @intDocHeader Output, @strXMLData

Insert into #xmlUploadHeader
(
ToolBookID,
ToolBookType,
NumberOfPages,
DatePublished,
UploadType
)

Select
ToolBookID,
ToolBookType,
NumberOfPages,
DatePublished,
UploadType
From

OpenXml
(@intDocHeader, @strRowPattern)
With
(
ToolBookID		Varchar(50) 	''ToolBookID'',
ToolBookType		Varchar(50)		''ToolBookType'',
NumberOfPages		Integer			''NumberOfPages'',
DatePublished		DateTime		''DatePublished'',
UploadType		Varchar(50)		''UploadType''
)


----------------------------------------------------------------------------
-------- Insert Lessons Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload/Pages/Page''
Exec sp_xml_preparedocument @intDocLessons Output, @strXMLData

Insert into #xmlUploadLessons
(
ToolbookPageID,
PageTitle
)


Select
ToolbookPageID,
PageTitle
From

OpenXml
(@intDocLessons, @strRowPattern)
With
(
ToolbookPageID	Varchar(50) 	''@ID'',
PageTitle		Varchar(255)	''PageTitle''
)

----------------------------------------------------------------------------
-------- Insert Quiz Questions Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload/Pages/Page''
Exec sp_xml_preparedocument @intDocQuizQuestions Output, @strXMLData

Insert into #xmlUploadQuizQuestions
(
ToolbookPageID,
PageTitle
)

Select

ToolbookPageID,
PageTitle
From

OpenXml
(@intDocQuizQuestions, @strRowPattern)
With
(
ToolbookPageID	Varchar(50) 	''@ID'',
PageTitle		Varchar(255)	''PageTitle''
)

----------------------------------------------------------------------------
-------- Insert Quiz Answers Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload/Pages/Page/Answers/Answer''
Exec sp_xml_preparedocument @intDocQuizAnswers Output, @strXMLData

Insert into #xmlUploadQuizAnswers
(
ToolbookQuestionID,
ToolbookAnswerID,
AnswerText,
Correct
)
Select
ToolbookQuestionID,
ToolbookAnswerID,
AnswerText,
Correct
From

OpenXml
(@intDocQuizAnswers, @strRowPattern)
With
(
ToolbookQuestionID	Varchar(50) 	''../../@ID'',  -- navigate back up to the question
ToolbookAnswerID	Varchar(50) 	''@ID'',
AnswerText			Varchar(255)	''AnswerText'',
Correct				Varchar(255)	''@correct''
)



----------------------------------------------------------------------------------------------------
-------- Determine if we are uploading a Quiz or a Lesson and whether its an update or a correction
----------------------------------------------------------------------------------------------------
Select
@strToolbookType = ToolBookType, @strUploadType = UploadType
From
#xmlUploadHeader



If (ltrim(rtrim(@strToolbookType)) = ''quiz'')
Begin
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
----------- Process Upload from Imaginary Tables
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
Select 	@strToolbookID 	= ToolBookID From #xmlUploadHeader
Select 	@DatePublished 	= DatePublished From #xmlUploadHeader
Set 	@intQuizID 		= dbo.udfGetQuizIDByToolbookIDAndModuleID (@strToolbookID,@intModuleID)

-------------------------------------------------------------------------------------------------------------------------------------
----------- Perform an update
-------------------------------------------------------------------------------------------------------------------------------------
-- Return message
Select @strUploadType as ''Message'', @strToolbookType as ''ToolbookType''

-- Return Results
Select
#xmlUploadQuizQuestions.PageTitle as ''Updated Questions'',
#xmlUploadQuizAnswers.AnswerText  as ''Updated Answers''
From
#xmlUploadQuizQuestions,#xmlUploadQuizAnswers
Where
#xmlUploadQuizAnswers.ToolbookQuestionID = #xmlUploadQuizQuestions.ToolbookPageID

End   -- End Quiz




-- Lesson
If (ltrim(rtrim(@strToolbookType)) = ''LESSON'')
Begin
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
----------- Process Upload from Imaginary Tables
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
Select
@strToolbookID = ToolBookID
From
#xmlUploadHeader
Select
@DatePublished = DatePublished
From
#xmlUploadHeader

-- Get the lesson ID
Set 	@intLessonID 		= dbo.udfGetLessonIDByToolbookIDAndModuleID (@strToolbookID,@intModuleID)


-------------------------------------------------------------------------------------------------------------------------------------
----------- Perform an update
-------------------------------------------------------------------------------------------------------------------------------------
-- Return message
Select
@strUploadType 	as ''Message'',
@strToolbookType 	as ''ToolbookType'',
GETDATE() 		as ''Time now'',
@intLessonID

-- Return Results
Select
#xmlUploadLessons.PageTitle as ''Updated Lesson''
From
#xmlUploadLessons


End



Commit
Return

ErrorHandler:
rollback
Return
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTotalNumberofMails]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [prcTotalNumberofMails]
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

SELECT COUNT(*) FROM tblEmail

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_AddAdministrator]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Add a user as administrator of a unit
and all sub units (if the "administer sub-units" is flaged)

Called By: Unit.cs
Calls: None

Remarks:
"Administer Sub-units" checkbox
When this is flagged for a Unit Administrator, it means they will automatically also become a Unit Administrator privileges to all Sub-Units (and sub-sub-units etc) within this Unit.

Changing User Statuses
When a SALT User is selected as an Administrator of a Unit, their User Role is updated to Unit Administrator.



Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_AddAdministrator 1, 46,1,46

*/

CREATE  Procedure [prcUnit_AddAdministrator]
(
@unitID Int,
@userID int,
@adminSubUnit bit,
@adminUserID int
)

As

set nocount on


set xact_abort on
Begin Tran

declare @strHierarchy varchar(100), @intLevel int, @intOrganisationID int

declare @strErrorMessage varchar(500)

declare @intUserTypeID int

select @intUserTypeID = UserTypeID
from tblUser
where userID = @adminUserID

set @strErrorMessage=''''

-------------- 1. Permission Checking ----------------
--Salt Administrator (1), Organisation Administrator (2): full permission to access all units
--Salt User (4): No permission
if (@intUserTypeID=4)
begin
set @strErrorMessage = ''You are not the administrator of the system''
end


if @strErrorMessage=''''
begin
select 	@strHierarchy =u.Hierarchy,
@intLevel = u.[Level],
@intOrganisationID = u.OrganisationID
from tblUnit u
where u.unitID = @unitID


--Remove existing permissions for this user
--1. If the new permission is administer sub-units, remove existing permissions from all sub-units
if (@adminSubUnit=1)
begin
delete tblUnitAdministrator
from tblUnitAdministrator ua
inner join tblUnit u
on ua.UnitID=u.UnitID
where ua.UserID=@userID
and charindex(@strHierarchy+'','', u.hierarchy+'','')=1

insert into tblUnitAdministrator(UnitID, UserID,propagate, CreatedBy)
select unitID, @userID, 1, @adminUserID
from tblUnit u
where charindex(@strHierarchy+'','', u.hierarchy+'','')=1
end
--2. If the new permission is only applied to this units(Not administer sub-units), remove existing permissions from all sub-units only it is flaged to "Propagate"
else
begin
exec prcUnit_RemoveAdministrator @unitID, @userID, @adminUserID
insert into tblUnitAdministrator(UnitID, UserID,propagate, CreatedBy)
values( @unitID, @userID,0, @adminUserID)
end

--Changing User Statuses
--When a SALT User is selected as an Administrator of a Unit, their User Role is updated to "Unit Administrator".
--2. Check and Update user role
exec prcOrganisation_CheckUserRole @intOrganisationID

select 0 as Error,  '''' as ErrorMessage
end
else
begin
select 10 as Error,  @strErrorMessage as ErrorMessage
end

commit TRAN

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_Create]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Add a unit.
Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:
--Create a unit
--Propagate all unit admininstrators from parent (with propagate flag)

Validation:
Exception:
0: Succeed
1.RecordNotFound
2.FK constraint
3.PKViolationException
4.UniqueViolationException
10.BusinessServiceException (General)


Author: Jack Liu
Date Created: 11 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE PROCEDURE [prcUnit_Create]
(
@organisationID	int,
@parentUnitID	int,
@name 	nvarchar(100),
@active	bit,
@createdByUserID int
)

AS

set nocount on

set xact_abort on
Begin Tran
--Validation
declare @strErrorMessage varchar(500)

declare @blnParentStatus bit
declare @strParentHierarchy varchar(500)
declare @intParentLevel int

declare @intUnitID int

set @strErrorMessage=''''

if (@parentUnitID<=0)
set @parentUnitID=null

--Create sub-unit
if (@parentUnitID>0)
begin
select @blnParentStatus = active,
@strParentHierarchy=  Hierarchy,
@intParentLevel = [level]
from tblUnit
where UnitID = @parentUnitID

--If parent unit is inactive, the new unit must be inactive
if (@blnParentStatus=0 and @active=1)
Begin
if exists(select UnitID from tblUnit where unitID=@parentUnitID  and active=0)
BEGIN
set @strErrorMessage = ''You cannot create an active unit whose parent unit is inactive.''
end
end
end
--Create top level unit
else
begin
set @strParentHierarchy= null
set @intParentLevel = 0

end

if (@strErrorMessage='''')
begin
--1. Create a unit
Insert into tblUnit(OrganisationID, ParentUnitID, Name, [Level], active,  createdBy, dateCreated, DateUpdated)
values	(@organisationID, @parentUnitID, @name, @intParentLevel+1,@active, @createdByUserID, getutcdate(), getutcdate())

set @intUnitID=@@identity
update tblUnit
set Hierarchy = IsNull(@strParentHierarchy + '','','''') + cast(@intUnitID as varchar)
where UnitID=@intUnitID
--2. Propagate all unit admininstrators from parent (with propagate flag)
insert into tblUnitAdministrator(UnitID, UserID, Propagate, createdBy, DateCreated)
select @intUnitID, UserID, 1 , @createdByUserID, getutcdate()
from tblUnitAdministrator
where unitID = @parentUnitID
and Propagate=1

select 0 as Error, cast(@intUnitID as varchar) as ErrorMessage
end
else
begin
select 10 as Error,  @strErrorMessage as ErrorMessage
end

commit TRAN

-- Get ProfilePeriodID''s for Organisation
create table #ProfilePeriod
(
ProfilePeriodID int
)

insert into #ProfilePeriod
select ProfilePeriodID
from tblProfilePeriod  pp
join tblprofile p
on pp.profileid = p.profileid
where p.organisationid = @OrganisationID

-- insert unit into profileperiodaccess against all profileperiodid''s
-- for the organisation
insert into tblUnitProfilePeriodAccess
select ProfilePeriodID, @intUnitID, 0 from #ProfilePeriod

drop table #ProfilePeriod

-- is a child unit
if (@parentUnitID <> 0)
begin
--	 get list of profile periods the parent unit has access to
create table #ProfilePeriodTemp
(
ProfilePeriodID int
)

insert into #ProfilePeriodTemp
select ProfilePeriodID from tblUnitProfilePeriodAccess
where UnitID = @parentUnitID
and Granted = 1

--	 set profile period access for these units
update tblUnitProfilePeriodAccess set granted = 1
where UnitID = @intUnitID
and ProfilePeriodID in (select ProfilePeriodID from #ProfilePeriodTemp)

drop table #ProfilePeriodTemp
end
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetAdministrableUnitsByUserID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Get all units administrable by any administrator by the userID

Returns:
Table of unitID''s


Called By:
Calls:

Remarks:

UserTypeID  Type
----------- --------------------------------------------------
1           Salt Administrator
2           Organisation Administrator
3           Unit Administrator
4           User

Author:
Stephen Kennedy-Clark
Date Created: 26 Aug 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


-- prcUnit_GetAdministrableUnitsByUserID 14, 3
-- prcUnit_GetAdministrableUnitsByUserID 1, 3

select * from tblUser

-- select * from tblUnitAdministrator
**/


Create procedure [prcUnit_GetAdministrableUnitsByUserID]
(
@userID int,                      -- Users ID
@organisationID int = null    -- Organisation ID
)

as
set nocount on

Declare @intUserTypeID int -- Users (Administrator) Type




-- Get the Users (Administrator) Type
select
@intUserTypeID = UserTypeID
From
tblUser
where
UserID = @userID

-------------------------------------------------------------------------
-- If the user is a normal user then they dont have access to anythign
-------------------------------------------------------------------------
if @intUserTypeID = 4 -- user
begin
declare @NullTable table
(
UnitID int
)
select UnitID from @NullTable

return 0 -- exit proceadure with sucess
end


-------------------------------------------------------------------------
-- If the user is a salt administrator then they have access to everything
-------------------------------------------------------------------------
if @intUserTypeID = 1 -- Salt Administrator
begin
select UnitID from tblUnit where Organisationid = isnull(@organisationID, organisationid)

return 0  -- exit proceadure with sucess
end


-------------------------------------------------------------------------
-- If the user is an organisation administrator then they have access to
-- all units in their org
-------------------------------------------------------------------------
if @intUserTypeID = 2 -- Organisation Administrator
begin
select
tblUnit.UnitID
from
tblUnit
--< as an xtra security check ensure that the Org admin is in the organisation >--
inner join tblUser
on tblUnit.OrganisationID = tblUser.OrganisationID
and tblUser.UserID = @userID
and tblUser.OrganisationID = @organisationID

return 0  -- exit proceadure with sucess
end

-------------------------------------------------------------------------
-- If the user is an Unit administrator then they have access to units
-- defined in tblUnitAdministrator
-------------------------------------------------------------------------
if @intUserTypeID = 3 -- Unit Administrator
begin
select
u.UnitID
from
tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
--< as an xtra security check ensure that the administrator is in the organisation >--
inner join tblUser usr
on u.OrganisationID = usr.OrganisationID
and usr.UserID = @userID
and usr.OrganisationID = @organisationID

return 0  -- exit proceadure with sucess
end


-- code should never get here
declare @strErrorMessage varchar(200)
set @strErrorMessage = ''Procedure prcUnit_GetAdministrableUnitsByUserID encountered the userType ('' + cast(@intUserTypeID as varchar(5)) + '') that should not exist''
RAISERROR (@strErrorMessage, 16, 1)
return 1 -- exit proceadure with error

--<end>--




SET QUOTED_IDENTIFIER ON
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetAdministrators]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get a list of existing unit administrators for a unit.
Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:
1. Permission Checking:

Exception:


Author: Jack Liu
Date Created: 12 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcUnit_GetAdministrators 1

**/
CREATE PROCEDURE [prcUnit_GetAdministrators]
(
@unitID	int
)

AS

set nocount on

Select 	u.UserID,
u.UserName,
u.FirstName,
u.LastName,
u.Email,
u.Active
from tblUnitAdministrator ua
inner join tblUser u on ua.userID = u.UserID
where ua.unitID=@unitID
and u.usertypeID=3 --Unit administrator(3)
order by u.LastName




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetAdministratorsEmailAddress]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'




CREATE PROCEDURE [prcUnit_GetAdministratorsEmailAddress]
(
@unitID	int
)

AS

select coalesce(
-- try to get the closest unit admin then search further afield
(Select top 1	u.Email
from tblUnitAdministrator ua
inner join tblUser u on ua.userID = u.UserID
where ua.unitID=@unitID
and u.usertypeID=3 --Unit administrator(3)
and u.unitID=@unitID
and u.Email is not null),


(Select top 1	u.Email
from tblUnitAdministrator ua
inner join tblUser u on ua.userID = u.UserID
where ua.unitID=@unitID
and u.usertypeID=3 --Unit administrator(3)
and u.Email is not null),

(Select top 1	u.Email
from tblUser u inner join tblUnit un on un.OrganisationID = u.OrganisationID
where un.unitID=@unitID
and UserTypeID = 2
and Email is not null),


(Select top 1	u.Email
from tblUser u inner join tblUnit un on un.OrganisationID = u.OrganisationID
where un.unitID=@unitID
and UserTypeID = 1
and Email is not null),

--all else failed so get the salt admin
(Select top 1	u.Email
from tblUser u
where UserTypeID = 1
and Email is not null))




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetModuleAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/****** Object:  Stored Procedure dbo.prcUnit_GetModuleAccess    Script Date: 30/03/2004 3:56:31 PM ******/
/*
Summary:
Gets unit module access settings

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Peter Kneale 30/3/04        Filtered out inactive modules

prcUnit_GetModuleAccess 30, 1

*/

CREATE   Procedure [prcUnit_GetModuleAccess]
(
@unitID Int,
@courseID int
)

As

set nocount on

Select 	m.ModuleID,
m.Name,
case
when uma.unitID is null then 1
else 0
end as Granted
From tblModule m
left join tblUnitModuleAccess uma
on m.ModuleID = uma.DeniedModuleID
and uma.UnitID=@unitID
where
m.CourseId= @courseID
and
m.Active = 1
order by m.Sequence







' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetModuleRule]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary:
Gets unit module compliance rules

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 18th of February 2004


Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_GetModuleRule 1, 1

*/

CREATE  Procedure [prcUnit_GetModuleRule]
(
@unitID Int,
@courseID int
)

As

set nocount on

Select 	m.ModuleID,
m.Name,
umr.UsingDefault,
isnull(umr.LessonFrequency, 0) as LessonFrequency,
isnull(umr.QuizFrequency, 0) as QuizFrequency,
umr.QuizPassMark,
dbo.udfUTCtoDaylightSavingTime(umr.LessonCompletionDate, u.OrganisationID) as LessonCompletionDate,
dbo.udfUTCtoDaylightSavingTime(umr.QuizCompletionDate, u.OrganisationID) as QuizCompletionDate
From vwUnitModuleRule umr
inner join tblModule m 	on m.ModuleID=  umr.ModuleID
join tblUnit u on u.UnitID = umr.UnitID
where umr.UnitID = @unitID
and umr.CourseId= @courseID
order by m.Sequence
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets details of one Unit

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcUnit_GetOne]
(
@unitID Integer = null
)

As

If @unitID Is Null
Begin
Raiserror(''The Parameter @unitID was null.  @unitID does not accept Null values.'', 16, 1)
Return
End

Select
u.UnitID,
u.Name,
u.ParentUnitID,
u.Hierarchy,
dbo.udfGetUnitPathway(u.UnitID) as Pathway,
u.Active,
u.OrganisationID,
o.OrganisationName as Organisation,
u.CreatedBy,
dbo.udfUTCtoDaylightSavingTime(u.DateCreated, u.OrganisationID) as DateCreated,
u.UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(u.DateUpdated, u.OrganisationID) as DateUpdated
From
tblUnit u
left join tblOrganisation o
on u.OrganisationID = o.OrganisationID
Where	u.UnitID = @unitID
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetPermission]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get unit administering permission
Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:



Author: Jack Liu
Date Created: 18 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE PROCEDURE [prcUnit_GetPermission]
(
@unitID		int,
@adminUserID 	int,
@permission  	char(1)=null output
)

AS

set nocount on

Declare @intUnitOrganisationID int
declare @intUserTypeID int, @intUserOrganisationID int


select @intUnitOrganisationID = OrganisationID
from tblUnit
where UnitID=@unitID

select @intUserTypeID = UserTypeID,
@intUserOrganisationID = OrganisationID
from tblUser
where userID = @adminUserID


if (@intUnitOrganisationID is not null)
begin
--1. Salt Admin
if (@intUserTypeID=1)
begin
select @permission = ''F''
end
--2. Org admin
else if (@intUserTypeID=2)
begin
--If the admin user is in the same organisation as the unit, it has Full permission
--otherwise no permission
if (@intUnitOrganisationID = @intUserOrganisationID)
select @permission = ''F''
else
select @permission = ''''
end
--3. Unit admin, User must be administrator of that unit
else if (@intUserTypeID=3)
begin
select @permission =
case
when Propagate = 0 then ''A''
when Propagate =1 then ''P''
else ''''
end
from tblUnitAdministrator
where UnitID =@unitID
and UserID =@adminUserID
end
end

if (@permission is null)
select @permission = ''''
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUnitNames]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary:
Convert unit IDs  array such as  ''''1,2,5,7'''' to Unit names array  ''''Unit 1, Unit 1 > Unit 2 > Unit 5 > Unit 7, Unit 1 > Unit 2 > Unit 5 > Unit 7''''

Called By:

Calls:

Remarks:


Author: Jack Liu
Date Created: 1 Apr 2005

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

exec prcUnit_GetUnitNames ''''19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,84''''

**/
CREATE  Procedure [prcUnit_GetUnitNames]
(
@unitIDs varchar(4000)
)
as
declare	@unitNames varchar(8000)

select @UnitIDs='',''+@UnitIDs+'',''

--Convert unit IDs  ''''1,2,5,7'''' to Unit names ''''Unit 1, Unit 1 > Unit 2 > Unit 5 > Unit 7, Unit 1 > Unit 2 > Unit 5 > Unit 7''''


--dbo.udfGetUnitPathway(u.UnitID) as Pathway,

--char(13)+char(10)
select @unitNames=IsNull(@unitNames+'' , '','''')+dbo.udfGetUnitPathway(tblUnit.UnitID)
from tblUnit
where charindex(@UnitIDs, '',''+cast(UnitID as varchar)+'','')>0
order by Hierarchy

select @unitNames as UnitNames
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUnitsByOrganisation]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get all units in the specified organisation

Returns:
Flat  hierarchy table


Called By:
Calls:

Remarks:
This procedure will be used by many other procedures to get unit tree for special purpose.
The @disabledUnitIDs, @selectedUnitIDs, @expandedUnitIDs parameters are comma delimited string, such as ''1,34,67''
These strings will be different according different criteria.
For example: For unit administrators, they only have permission to manage the units  that the administrator  has administration rights

if  @parentUnitID is not null, it will show all sub units of this unit

The returned flat  hierarchy table will be used by UnitTreeConvert.xslt to convert to hierarchy tree document.
The standard tree document can be used by TreeView  Control

Author:
Jack Liu
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcUnit_GetUnitsByOrganisation 3,'''','''','''',1
prcUnit_GetUnitsByOrganisation 3, ''1,4,5''

**/

CREATE  PROC [prcUnit_GetUnitsByOrganisation]
(
@organisationID  int,
@disabledUnitIDs varchar(4000)=null,
@selectedUnitIDs varchar(4000)=null,
@expandedUnitIDs varchar(4000)=null,
@parentUnitID	int =null,
@includingInactiveUnits bit = 0
)

AS


set nocount on
declare @strParentHierarchy varchar(500)

set @disabledUnitIDs = '','' + @disabledUnitIDs  + '',''
set @selectedUnitIDs = '','' + @selectedUnitIDs + '',''
set @expandedUnitIDs= '','' + @expandedUnitIDs + '',''

if (@includingInactiveUnits = 1)
begin
-- Return Only Units that are currently active
if (@parentUnitID>0)
select @strParentHierarchy = Hierarchy +'',%''
from tblUnit
where UnitID=@parentUnitID
else
set @strParentHierarchy=''%'';

SELECT 	UnitID,
case
when ParentUnitID = @parentUnitID then null
else ParentUnitID
end as ParentUnitID,

case
when Active=0 then [Name] +'' (I)''
else [Name]
end as Name,

case
when charindex('','' + cast(UnitID as varchar)+'','', @disabledUnitIDs)>0 then 1
else 0
end as Disabled,
case
when charindex('','' + cast(UnitID as varchar)+'','', @selectedUnitIDs)>0 then 1
else 0
end as Selected,
case
when charindex('','' + cast(UnitID as varchar)+'','', @expandedUnitIDs)>0 then 1
else 0
end as Expanded
from tblUnit as Unit
where OrganisationID =@organisationID
and Hierarchy like @strParentHierarchy
order by Hierarchy
end
else
begin
if (@parentUnitID>0)
select @strParentHierarchy = Hierarchy +'',%''
from tblUnit
where UnitID=@parentUnitID
else
set @strParentHierarchy=''%'';

SELECT 	UnitID,
case
when ParentUnitID = @parentUnitID then null
else ParentUnitID
end as ParentUnitID,

[Name],

case
when charindex('','' + cast(UnitID as varchar)+'','', @disabledUnitIDs)>0 then 1
else 0
end as Disabled,
case
when charindex('','' + cast(UnitID as varchar)+'','', @selectedUnitIDs)>0 then 1
else 0
end as Selected,
case
when charindex('','' + cast(UnitID as varchar)+'','', @expandedUnitIDs)>0 then 1
else 0
end as Expanded
from tblUnit as Unit
where OrganisationID =@organisationID
and Hierarchy like @strParentHierarchy
and Active = 1
order by Hierarchy
end
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUnitsTreeByUserID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Get all units in the specified organisation and can be selected by the specified user

Returns:
Flat hierarchy table


Called By:
Calls:

Remarks:

@permission:
A: [A]dministrator
P: Administrator with [P]ropagating right
S: Administrator of the Unit and all of its [S]ub-units
Empty or null: All units, no permission needed

Author:
Jack Liu
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcUnit_GetUnitsTreeByUserID 3, 5,''S''


**/

CREATE   PROC [prcUnit_GetUnitsTreeByUserID]
(
@organisationID  int,
@userID int,
@permission char(1)=''A'',
@includingInactiveUnits bit = 0
)

AS

set nocount on

declare @intUserTypeID int
declare @strDisabledUnitIDs varchar(4000)

if @permission is null
set @permission=''''

select @intUserTypeID = UserTypeID
from tblUser
where userID = @userID

declare @EnableUnit table
(
UnitID int
)

--Salt Administrator, Organisation Administrator has permission to access all units
if (@intUserTypeID=1 or @intUserTypeID=2 or @permission='''')
begin
insert 	into @EnableUnit(UnitID)
select 	u.UnitID
from 	tblUnit as u
where 	(u.organisationID=@organisationID)
end
--A: Unit Administrator only has permission to those that he is administrator
else if @permission=''A''
begin
--Get a list of unit id that the user is  the administrator
insert into @EnableUnit(UnitID)
select 	u.UnitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@organisationID)

end
--P: Administrator with [P]ropagating right
else if @permission=''P''
begin
--Get a list of unit id that the user has [P]ropagating right
insert into @EnableUnit(UnitID)
select 	u.UnitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
and (ua.propagate=1)
where 	(u.organisationID=@organisationID)
end
--S: Administrator of the Unit and all of its [S]ub-units
else if @permission=''S''
begin

insert into @EnableUnit(UnitID)
select 	u.UnitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@organisationID)
and not exists(
select su.unitid
from tblUnit su --sub-units
left join tblUnitAdministrator ua
on su.unitID=ua.unitID
and ua.userID = @userID
where su.hierarchy+'','' like u.hierarchy+'',%'' --Current Unit and all sub-units
and ua.unitID is null	--Not administrator
)--Administrator of all sub-units
end

--Get a list of unit id that the user dn''t have permission
select 	@strDisabledUnitIDs= isNull(@strDisabledUnitIDs + '','','''')+ cast(u.unitID as varchar)
from 	tblUnit as u
left join @EnableUnit as eu
on (u.unitID=eu.unitID)
where 	(u.organisationID=@organisationID)
and eu.UnitID is null

-- If @includingInactiveUnits = 1 then return all units even those that are inactive
-- By default only return those that are active
if @includingInactiveUnits = 1
select 
un.unitid ''UnitID'',
un.parentunitid ''ParentUnitID'',
un.name ''Name'',
case when eu.unitid is null then 1 else 0 end ''Disabled'',
0 ''Selected'',
0 ''Expanded''
from tblUnit un
left join @EnableUnit as eu
on (un.unitID=eu.unitID)
where 	(un.organisationID=@organisationID)
order by un.hierarchy

else

select 
un.unitid ''UnitID'',
un.parentunitid ''ParentUnitID'',
un.name ''Name'',
case when eu.unitid is null then 1 else 0 end ''Disabled'',
0 ''Selected'',
0 ''Expanded''
from tblUnit un
left join @EnableUnit as eu
on (un.unitID=eu.unitID)
where 	(un.organisationID=@organisationID)
and un.active=1
order by un.hierarchy









' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUnitsTreeByUserIDAndSelect]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get all units in the specified organisation and can be selected by the specified user.
The default selected unit is passed in via the @selectedUnitID parameter.
All parents of the selected unit back up the the root of the tree will be expanded.

Returns:
Flat hierarchy table


Called By:
User.cls
Calls:
prcUnit_GetUnitsByOrganisation
Remarks:

@permission:
A: [A]dministrator
P: Administrator with [P]ropagating right
S: Administrator of the Unit and all of its [S]ub-units
Empty or null: All units, no permission needed

Author:
Peter Kneale
Date Created: 2 Mar 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcUnit_GetUnitsTreeByUserID 3, 5,''S''


**/

CREATE Procedure [prcUnit_GetUnitsTreeByUserIDAndSelect]
(
@organisationID  	Integer,		-- Organisation ID of the calling user
@userID 		Integer, 		-- User ID of the calling user
@permission 		Char(1)=''A'',	-- Permission as described above
@selectedUnitID 	Integer		-- Unit ID of the unit that is to be selected initially
)

AS

set nocount on

-- Declarations

Declare @intUserTypeID	 	Integer		-- User Type of the calling user
Declare @strDisabledUnitIDs 	Varchar(4000)	-- CSV List of disabled units
Declare @strExpandedUnitID 	Varchar(4000)	-- CSV List of expanded Units

Declare @EnableUnit Table
(
UnitID Integer
)
-- Replace null permission with empty string
If @permission is null
Begin
Set @permission=''''
End

-- Get user type
Select
@intUserTypeID = UserTypeID
from
tblUser
where
userID = @userID



--Salt Administrator, Organisation Administrator has permission to access all units
If (@intUserTypeID=1 or @intUserTypeID=2 or @permission='''')
Begin
Insert 	Into
@EnableUnit(UnitID)
Select
u.UnitID
From
tblUnit as u
Where
(u.organisationID=@organisationID)
End

--A: Unit Administrator only has permission to those that he is administrator
Else If @permission=''A''
Begin
--Get a list of unit id that the user is  the administrator
Insert Into
@EnableUnit(UnitID)
Select 	u.UnitID
From 	tblUnit as u
Inner join tblUnitAdministrator as ua
On (u.unitID=ua.unitID)
and (ua.userID = @userID)
Where 	(u.organisationID=@organisationID)

End

--P: Administrator with [P]ropagating right
Else If @permission=''P''
Begin
--Get a list of unit id that the user has [P]ropagating right
Insert Into @EnableUnit(UnitID)
Select 	u.UnitID
From 	tblUnit as u
Inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
and (ua.propagate=1)
Where 	(u.organisationID=@organisationID)
End
--S: Administrator of the Unit and all of its [S]ub-units
Else If @permission=''S''
Begin
Insert Into @EnableUnit(UnitID)
Select
u.UnitID
From 	tblUnit as u
Inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
Where 	(u.organisationID=@organisationID)
and not exists(
select su.unitid
from tblUnit su --sub-units
left join tblUnitAdministrator ua
on su.unitID=ua.unitID
and ua.userID = @userID
where su.hierarchy+'','' like u.hierarchy+'',%'' --Current Unit and all sub-units
and ua.unitID is null	--Not administrator
)--Administrator of all sub-units
end

--Get a list of unit id that the user dn''t have permission
Select
@strDisabledUnitIDs= isNull(@strDisabledUnitIDs + '','','''')+ cast(u.unitID as varchar)
From
tblUnit as u
left join @EnableUnit as eu
on (u.unitID=eu.unitID)
Where
(u.organisationID=@organisationID)
and eu.UnitID is null

-- Get the hierarchy in CSV format down to this unit so that they can be expanded and make the
-- selected unit visible
Select
@strExpandedUnitID = Hierarchy
From
tblUnit
Where
UnitID = @selectedUnitID

-- Get the Tree
Exec prcUnit_GetUnitsByOrganisation @organisationID, @strDisabledUnitIDs,@selectedUnitID, @strExpandedUnitID
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Gets a list of users from a specific Unit

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcUnit_GetUsers]
(
@unitID Integer = null,
@includeInactiveUsers bit = 0
)

As

If @unitID Is Null
Begin
Raiserror(''The Parameter @unitID was null.  @unitID does not accept Null values.'', 16, 1)
Return
End
if (@includeInactiveUsers = 0)
Begin
Select 	UserID,
UserName,
FirstName,
LastName,
Email,
Active
From tblUser
Where UnitID = @unitID
And
Active = 1
order by LastName
End
Else
Begin
Select 	UserID,
UserName,
FirstName,
LastName,
Email,
Active
From tblUser
Where UnitID = @unitID

order by LastName
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_Move]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Move a  unit to a new parent
Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:
1. Permission Checking:
1.1. "From" unit permision: Administrator of this unit and all sub-units
1.2. "To" unit permision: "Propagate" administrator of this unit

2. Validation:
2.1. "From" unit is not the same as "To" unit
2.2. "From" and "To" unit are in the same organisation
2.3. "From" unit is not the parent of "To" unit
2.4  "To" unit is the direct parent of "From" unit


Moving permissions:
When a Unit is moved into to another Unit, all of its current administrators will be removed,
and it will inherit its new administrators from its new place in the hierarchy,
according to the "Administer Sub-units" rights of the existing administrators.



Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
10.BusinessServiceException (General)


Author: Jack Liu
Date Created: 11 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE PROCEDURE [prcUnit_Move]
(
@fromUnitID	int,
@toUnitID	int,
@adminUserID 	int
)

AS

set nocount on

set xact_abort on
Begin Tran
declare @strErrorMessage varchar(500)
declare @intErrorNumber int

declare @intUserTypeID int

declare @intFromOrganisationID int, @intToOrganisationID int
declare @strFromHierarchy nvarchar(500),@strToHierarchy nvarchar(500)
declare @intFromParentUnitID int

select @intUserTypeID = UserTypeID
from tblUser
where userID = @adminUserID

select @intFromOrganisationID = OrganisationID,
@strFromHierarchy = Hierarchy,
@intFromParentUnitID = parentUnitID
from tblUnit
where unitID=@fromUnitID

select @intToOrganisationID = OrganisationID,
@strToHierarchy = Hierarchy
from tblUnit
where unitID=@toUnitID


set @strErrorMessage=''''

-------------- 1. Permission Checking ----------------

--Salt Administrator (1), Organisation Administrator (2): full permission to access all units
--Salt User (4): No permission
if (@intUserTypeID=4)
begin
set @strErrorMessage = ''You are not the administrator of the system''
set @intErrorNumber = 1
end
--Unit Administrator (3): limited permission
else if (@intUserTypeID=3)
begin
--	1.1. "From" unit permision: Administrator of this unit and all sub-units
if 	exists(select su.unitid
from tblUnit su --sub-units
left join tblUnitAdministrator ua
on su.unitID=ua.unitID
and ua.userID = @adminUserID
where su.hierarchy+'','' like @strFromHierarchy+'',%'' --"From" Unit and all its sub-units
and ua.unitID is null)	--Not administrator
begin
set @strErrorMessage = ''You are not administrator of the "From" unit and all its sub-units''
set @intErrorNumber = 11
end
--	1.2. "To" unit permision: "Propagate" administrator of this unit
else 	if not exists(select unitid from tblUnitAdministrator where unitID=@toUnitID and userID = @adminUserID and propagate=1)
begin
set @strErrorMessage = ''You don''''t have permission to administer sub-units of the "To" unit''
set @intErrorNumber = 12
end
end

-----------------2. Validation -----------------------------
if (@strErrorMessage='''')
begin
--	2.1. "From" unit is not the same as "To" unit
if (@fromUnitID=@toUnitID)
begin
set @strErrorMessage = ''The "From" unit can''''t be the same as the "To" unit''
set @intErrorNumber = 13
end
--	2.2. "From" and "To" unit are in the same organisation
else if (@intFromOrganisationID<>@intToOrganisationID)
begin
set @strErrorMessage = ''The "From" and the "To" unit should be in the same organisation''
set @intErrorNumber = 14
end
--	2.3. "From" unit is not the parent of "To" unit
else if (charindex( @strFromHierarchy+'','', @strToHierarchy)=1)
begin
set @strErrorMessage = ''The "From" unit can''''t be the parent of the "To" unit''
set @intErrorNumber = 15
end
--	2.4  "To" unit is the direct parent of "From" unit
else if (@intFromParentUnitID=@toUnitID)
begin
set @strErrorMessage = ''The "To" unit can''''t be the direct parent of the "From" unit''
set @intErrorNumber = 16
end
end

if (@strErrorMessage='''')
begin
--1. Update hierarchy and rebuild the unit tree
Update tblUnit
set parentUnitID=@toUnitID,
UpdatedBy = @adminUserID,
DateUpdated = getutcdate()
where unitID=@fromUnitID

exec prcOrganisation_CheckUnitTree @intToOrganisationID

--2. Moving permissions
--2.1 Get the new hierarchy
select 	@strFromHierarchy = Hierarchy
from tblUnit
where unitID=@fromUnitID
--2.2 Remove all current administrators from the unit and  its sub-units
Delete
from tblUnitAdministrator
where unitID in (select unitID
from tblUnit
where hierarchy+'','' like @strFromHierarchy+'',%'') --Current Unit and its sub-units


--2.3 Propagate all unit admininstrators from parent (with propagate flag)
insert into tblUnitAdministrator(UnitID, UserID, Propagate, createdBy)
select 	u.UnitID, ua.UserID, 1 , @adminUserID
from 	tblUnitAdministrator ua
cross join  tblUnit u
where 	ua.unitID = @toUnitID
and ua.Propagate=1
and u.hierarchy+'','' like @strFromHierarchy+'',%''

--2.4 Check and Update user role
exec prcOrganisation_CheckUserRole @intToOrganisationID

select 0 as Error, '''' as ErrorMessage
end
else
begin
select @intErrorNumber as Error,  @strErrorMessage as ErrorMessage
end

commit TRAN
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_MoveToTopLevel]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Move a unit to top level.
Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:


Exception:
0: Succeed
1.RecordNotFound
2.FK constraint
3.PKViolationException
4.UniqueViolationException
10.BusinessServiceException (General)


Author: Jack Liu
Date Created: 11 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE PROCEDURE [prcUnit_MoveToTopLevel]
(
@fromUnitID	int,
@adminUserID 	int
)

AS

set nocount on

set xact_abort on
Begin Tran
declare @strErrorMessage varchar(500)
declare @intErrorNumber int

declare @intUserTypeID int

declare @intFromOrganisationID int
declare @strFromHierarchy nvarchar(500)
declare @intFromParentUnitID int

select @intUserTypeID = UserTypeID
from tblUser
where userID = @adminUserID

select @intFromOrganisationID = OrganisationID,
@strFromHierarchy = Hierarchy,
@intFromParentUnitID = parentUnitID
from tblUnit
where unitID=@fromUnitID


set @strErrorMessage=''''

-------------- 1. Permission Checking ----------------
--Only Salt Administrator (1), Organisation Administrator (2) can move a unit to top level
If (@intUserTypeID>2)
begin
set @strErrorMessage = ''You do not have permission to move a unit to the top level.''
set @intErrorNumber = 1
end

-----------------2. Validation -----------------------------
if (@strErrorMessage='''')
begin
--	2.1. "From" unit is in top level
if (@intFromParentUnitID is null)
begin
set @strErrorMessage = ''The ''''From'''' unit already exists at the top level.''
set @intErrorNumber = 11
end
end

if (@strErrorMessage='''')
begin
--1. Update hierarchy and rebuild the unit tree
Update tblUnit
set parentUnitID=null,
UpdatedBy = @adminUserID,
DateUpdated = getutcdate()
where unitID=@fromUnitID

--rebuild the unit tree
exec prcOrganisation_CheckUnitTree @intFromOrganisationID

--2. Keep the exsiting administrators
select 0 as Error, '''' as ErrorMessage
end
else
begin
select @intErrorNumber as Error,  @strErrorMessage as ErrorMessage
end

commit TRAN
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_RemoveAdministrator]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Remove a unit administrator from a unit.

They will also be removed from any sub-units that they had administrator rights to
by virtue of any Administer sub-units functions.

Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:
1. Permission Checking:
1.1. "From" unit permision: Administrator of this unit and all sub-units


Their user role will also change back to that of SALT User, if they no longer manage any Units.

Exception:
0: Succeed
1.RecordNotFound
2.FK constraint
3.PKViolationException
4.UniqueViolationException
10.BusinessServiceException (General)


Author: Jack Liu
Date Created: 11 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_RemoveAdministrator 14, 46, 46
**/
CREATE PROCEDURE [prcUnit_RemoveAdministrator]
(
@unitID	int,
@removedUserID	int,
@adminUserID 	int
)

AS

set nocount on

set xact_abort on
Begin Tran
declare @strErrorMessage varchar(500)

declare @intUserTypeID int

select @intUserTypeID = UserTypeID
from tblUser
where userID = @adminUserID

set @strErrorMessage=''''

-------------- 1. Permission Checking ----------------
--Salt Administrator (1), Organisation Administrator (2): full permission to access all units
--Salt User (4): No permission
if (@intUserTypeID=4)
begin
set @strErrorMessage = ''You are not the administrator of the system''
end
--Unit Administrator (3): limited permission
--else if (@intUserTypeID=3)
--begin
--	 --Unit Administrator (3): limited permission
--
--end

if @strErrorMessage=''''
begin

declare @blnPropagate bit, @strHierarchy varchar(100), @intLevel int, @intOrganisationID int

select @blnPropagate =ua.propagate,
@strHierarchy =u.Hierarchy,
@intLevel = u.[Level],
@intOrganisationID = u.OrganisationID
from tblUnit u
inner join tblUnitAdministrator ua
on u.UnitID=ua.UnitID and ua.userID=@removedUserID
where u.unitID = @unitID
--1. Remove this administrator from the specified Unit
--1.1 Can''t administer sub-units, just remove from this unit
if (@blnPropagate=0)
begin
Delete
from tblUnitAdministrator
where unitID = 	@unitID
and	UserID = @removedUserID
end
--1.2 Can administer sub-units, remove from all sub-units
else if (@blnPropagate=1)
begin
/*
They will also be removed from any sub-units that they had administrator rights to
by virtue of any "Administer sub-units" functions.
*/
delete tblUnitAdministrator
from tblUnitAdministrator cua --child unit administrator
inner join tblUnit cu --child unit
on cu.UnitID=cua.UnitID and cua.userID=@removedUserID and cua.propagate=1
where 	charindex(@strHierarchy+'','', cu.hierarchy+'','')=1
--Administrator(propagate flag) of all parent units(up to current unit) of a child unit
and not exists(
select pua.*
from tblUnit pu --parent unit
left join tblUnitAdministrator pua --Parent Unit Administrator
on pu.UnitID=pua.UnitID and pua.userID=@removedUserID and pua.propagate=1
where charindex(pu.hierarchy+'','',  cu.hierarchy+'','')=1 --parent unit of a child unit
and pu.level>=@intLevel --Up to the current unit
and pua.UnitID is null) -- Administrator
end


/*
Their user role will also change back to that of SALT User, if they no longer manage any Units.
*/

--2. Check and Update user role
exec prcOrganisation_CheckUserRole @intOrganisationID

select 0 as Error,  '''' as ErrorMessage
end
else
begin
select 10 as Error,  @strErrorMessage as ErrorMessage
end

commit TRAN
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SaveModuleAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Saves unit module access settings
This will overwrite the module access settings of users (Remove individual settings)

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_SaveModuleAccess 2, 1, ''1,2''


select * from tblModule


*/

CREATE  Procedure [prcUnit_SaveModuleAccess]
(
@unitID Int,
@courseID int,
@grantedModuleIDs varchar(500)
)

As

set nocount on

set xact_abort on
Begin Tran

-- Remove existing settings
Delete tblUnitModuleAccess
from  tblUnitModuleAccess uma
inner join tblModule m
on uma.DeniedModuleID=m.ModuleID
where 	uma.UnitID=@unitID
and m.courseID = @courseID

-- Overwrite the module access settings of users (Remove individual settings)
Delete tblUserModuleAccess
from  tblUserModuleAccess uma
inner join tblUser u
on uma.UserID = u.UserID
inner join tblModule m
on uma.ModuleID=m.ModuleID
where 	u.UnitID=@unitID
and m.courseID = @courseID

--Insert new settings
insert into tblUnitModuleAccess
(UnitID,
DeniedModuleID
)
select @unitID,
m.ModuleID
From tblModule m
left join dbo.udfCsvToInt(@grantedModuleIDs) as  g
on g.IntValue=m.moduleID
where CourseId= @courseID
and g.IntValue is null



-- update course status for users
declare @intOldCourseStatus int
declare @intNewCourseStatus int
declare @ModuleID int
declare @userID int

declare userIDCursor cursor
for SELECT DISTINCT u.UserID
FROM tblUser AS u
INNER JOIN tblUserCourseStatus AS ucs
ON u.UserID = ucs.UserID
WHERE (ucs.CourseID = @CourseID) AND (u.UnitID = @UnitID)

open userIDCursor

fetch next from userIDCursor into @userID while (@@FETCH_STATUS <> -1) begin if (@@FETCH_STATUS <> -2) begin exec @intOldCourseStatus = prcUserCourseStatus_GetStatus @courseID, @userID exec @intNewCourseStatus = prcUserCourseStatus_Calculate @courseID, @userID

if (@intOldCourseStatus = -1) or (@intOldCourseStatus <> @intNewCourseStatus) begin set @moduleID = (select top 1 m.moduleId from tblModule m left join dbo.udfCsvToInt(@grantedModuleIDs) as g on g.IntValue=m.moduleID where CourseID = @courseID) exec prcUserCourseStatus_Insert @userID, @ModuleID, @intNewCourseStatus end end fetch next from userIDCursor into @userID end close userIDCursor deallocate userIDCursor



Commit tran


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SaveModuleAccess1]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Saves unit module access settings
This will overwrite the module access settings of users (Remove individual settings)

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_SaveModuleAccess 2, 1, ''1,2''


select * from tblModule


*/

CREATE  Procedure [prcUnit_SaveModuleAccess1]
(
@unitID Int,
@courseID int,
@grantedModuleIDs varchar(500)
)

As

set nocount on

set xact_abort on
Begin Tran

-- Remove existing settings
Delete tblUnitModuleAccess
from  tblUnitModuleAccess uma
inner join tblModule m
on uma.DeniedModuleID=m.ModuleID
where 	uma.UnitID=@unitID
and m.courseID = @courseID

-- Overwrite the module access settings of users (Remove individual settings)
Delete tblUserModuleAccess
from  tblUserModuleAccess uma
inner join tblUser u
on uma.UserID = u.UserID
inner join tblModule m
on uma.ModuleID=m.ModuleID
where 	u.UnitID=@unitID
and m.courseID = @courseID

--Insert new settings
insert into tblUnitModuleAccess
(UnitID,
DeniedModuleID
)
select @unitID,
m.ModuleID
From tblModule m
left join dbo.udfCsvToInt(@grantedModuleIDs) as  g
on g.IntValue=m.moduleID
where CourseId= @courseID
and g.IntValue is null


/*
-- update course status for users
declare @intOldCourseStatus int
declare @intNewCourseStatus int
declare @ModuleID int
declare @userID int

declare userIDCursor cursor
for SELECT DISTINCT u.UserID
FROM tblUser AS u
INNER JOIN tblUserCourseStatus AS ucs
ON u.UserID = ucs.UserID
WHERE (ucs.CourseID = @CourseID) AND (u.UnitID = @UnitID)

open userIDCursor

fetch next from userIDCursor into @userID while (@@FETCH_STATUS <> -1) begin if (@@FETCH_STATUS <> -2) begin exec @intOldCourseStatus = prcUserCourseStatus_GetStatus @courseID, @userID exec @intNewCourseStatus = prcUserCourseStatus_Calculate @courseID, @userID

if (@intOldCourseStatus = -1) or (@intOldCourseStatus <> @intNewCourseStatus) begin set @moduleID = (select top 1 m.moduleId from tblModule m left join dbo.udfCsvToInt(@grantedModuleIDs) as g on g.IntValue=m.moduleID where CourseID = @courseID) exec prcUserCourseStatus_Insert @userID, @ModuleID, @intNewCourseStatus end end fetch next from userIDCursor into @userID end close userIDCursor deallocate userIDCursor


*/
Commit tran


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SaveModuleRule]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Populate the compliance rules to an individual module

Called By: Unit.cs
Calls: None

Remarks:

Author: Jack Liu
Date Created: 18th of February 2004


Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_SaveModuleRule 1, 1

*/

CREATE  Procedure [prcUnit_SaveModuleRule]
(
@unitID Int,
@moduleID int,
@usingDefault bit,
@lessonFrequency int,
@quizFrequency int,
@quizPassMark int,
@lessonCompletionDate datetime,
@quizCompletionDate datetime,
@adminUserID int,
@OrgID int
)

As

set nocount on

set @lessonCompletionDate = dbo.udfDaylightSavingTimeToUTC(@lessonCompletionDate, @OrgID)
set @quizCompletionDate = dbo.udfDaylightSavingTimeToUTC(@quizCompletionDate, @OrgID)

--1. If the module uses default rules, delete the existing individual rule
if (@usingDefault=1)
begin
Delete
from tblUnitRule
where UnitID=@unitID
and moduleID= @moduleID
end
--2. If the module contains individual rule, update the existing individual rule
else if exists(select ModuleID
from tblUnitRule
where UnitID=@unitID
and moduleID= @moduleID)
begin
Update tblUnitRule
set 	LessonFrequency = @LessonFrequency,
QuizFrequency = @QuizFrequency,
QuizPassMark = @QuizPassMark,
LessonCompletionDate = @lessonCompletionDate,
QuizCompletionDate = @quizCompletionDate,
UpdatedBy = @adminUserID,
DateUpdated =  GETUTCDATE()
where UnitID=@unitID
and moduleID= @moduleID

end
--3. If the module doesn''t contain any individual rule, add the new rule
else
begin
insert into tblUnitRule
(
UnitID,
ModuleID,
LessonFrequency,
QuizFrequency,
QuizPassMark,
LessonCompletionDate,
QuizCompletionDate,
CreatedBy,
DateCreated
)
values (
@unitID,
@moduleID,
@lessonFrequency,
@quizFrequency,
@quizPassMark,
@lessonCompletionDate,
@quizCompletionDate,
@adminUserID,
GETUTCDATE()
)

end





' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SaveModuleRuleToAll]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Populate the compliance rules to all modules in the course

Called By: Unit.cs
Calls: None

Remarks:

Author: Jack Liu
Date Created: 18th of February 2004


Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_SaveModuleRuleToAll 1, 1

*/

CREATE  Procedure [prcUnit_SaveModuleRuleToAll]
(
@unitID Int,
@courseID int,
@lessonFrequency int,
@quizFrequency int,
@quizPassMark int,
@lessonCompletionDate DateTime = Null, -- Lesson completion date
@quizCompletionDate DateTime = Null, -- Quiz completion date
@adminUserID int,
@OrgID int
)

As

set nocount on

set xact_abort on
Begin Tran

set @lessonCompletionDate = dbo.udfDaylightSavingTimeToUTC(@lessonCompletionDate, @OrgID)
set @quizCompletionDate = dbo.udfDaylightSavingTimeToUTC(@quizCompletionDate, @OrgID)

Delete tblUnitRule
from tblUnitRule ur
inner join tblModule m
on  ur.ModuleID  = m.ModuleID
where ur.UnitID=@unitID
and m.CourseId= @courseID

insert into tblUnitRule
(
UnitID,
ModuleID,
LessonFrequency,
QuizFrequency,
QuizPassMark,
LessonCompletionDate,
QuizCompletionDate,
CreatedBy,
DateCreated
)
Select 	@unitID,
m.ModuleID,
@lessonFrequency,
@quizFrequency,
@quizPassMark,
@lessonCompletionDate,
@quizCompletionDate,
@adminUserID,
GETUTCDATE()
From tblModule m
where m.CourseId= @courseID

commit tran





' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_Search]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
The procedure will search within the selected Parent Units for those Units whose name contains the entered text.
(If not Parent Units have been selected, the system will search across the whole organisation.)

Returns:
Unit Name
Full pathway


Called By:
Calls:

Remarks:
The searching units will include all children and grandchildren
Only return units that user has permission to see


Author: Jack Liu
Date Created: 9 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Aaron		27/03/2007		@parentUnitIDs type modified from Varchar(500)



prcUnit_Search 3,'''',''unit'''' '',4

**/

CREATE  PROCEDURE [dbo].[prcUnit_Search]
(

@organisationID  int,
@parentUnitIDs  varchar(max),
@unitID int = 0,
@unitName	nvarchar(100),
@userID		int,
@includingInactiveUnits bit = 0
)
as
set nocount on

declare @intUserTypeID int

select @intUserTypeID = UserTypeID
from tblUser
where userID = @userID

--Check Data
if @parentUnitIDs is null
set @parentUnitIDs =''''

if @unitName is null
set @unitName = ''''

set @unitName =rtrim(@unitName)

-- Return all units even those that are inactive
if (@includingInactiveUnits = 1)
Begin

select 	u.UnitID,
case
when u.Active=1 then u.Name
else u.Name + ''(I)''
end as Name,
dbo.udfGetUnitPathway(u.UnitID) as Pathway
from tblUnit u
left join dbo.udfCsvToInt(@parentUnitIDs) as pu on u.UnitID=pu.intValue
where (u.OrganisationID = @organisationID)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
and (
pu.intValue is not null
or (@parentUnitIDs='''')
)
--2. Unit name contains the entered text
and (
(name like ''%''+ @unitName + ''%'')
or (name ='''')
)
--3. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (u.UnitID in (select UnitID from tblUnitAdministrator where UserID=@userID))
)
order by name
End
Else
Begin
-- Return only active units
select 	u.UnitID,
u.Name,
dbo.udfGetUnitPathway(u.UnitID) as Pathway
from tblUnit u
left join dbo.udfCsvToInt(@parentUnitIDs) as pu on u.UnitID=pu.intValue
where (u.OrganisationID = @organisationID)
-- Active Units Only
and
(u.Active = 1)
and (
pu.intValue is not null
or (@parentUnitIDs='''')
)
--2. Unit name contains the entered text
and (
(name like ''%''+ @unitName + ''%'')
or (name ='''')
)
--3. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (u.UnitID in (select UnitID from tblUnitAdministrator where UserID=@userID))
)
-- 4. Unit ID
and (
(@unitID != 0 and u.unitid = @unitID ) or (@unitID = 0 and u.unitid > 0)
)
order by name
End



' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SearchUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Gets a list of users from a specific Unit which conform to the criteria
and who have a User Role which is lower than or equal to the specified user type id or the logged-in administrator''s user role.

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcUnit_SearchUsers]
(
@unitID Int,
@firstName nvarchar(50),
@lastName nvarchar(50),
@userTypeID int =null,
@adminUserID int,
@includeInactiveUsers bit = 0
)

As

set nocount off

--Check data
if (@userTypeID is null or @userTypeID<=0)
begin
select @userTypeID = UserTypeID
from tblUser
where userID = @adminUserID
end

if @firstName is null
set @firstName=''''
if @lastName is null
set @lastName=''''

if (@includeInactiveUsers=0)
Begin
Select 	UserID,
UserName,
FirstName,
LastName,
Email,
Active
From tblUser
Where UnitID = @unitID
and firstName like ''%''+ @firstName +''%''
and lastName like ''%'' + @lastName +''%''
and UserTypeID >=@userTypeID
and Active = 1
order by LastName
End
Else
Begin
Select 	UserID,
UserName,
FirstName,
LastName,
Email,
Active
From tblUser
Where UnitID = @unitID
and firstName like ''%''+ @firstName +''%''
and lastName like ''%'' + @lastName +''%''
and UserTypeID >=@userTypeID
order by LastName
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Updates a unit details.
Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:
Validation:
1. Integrity Violation
The Unit''s details have been updated by another user (since the data are retrieved)

2. Deactivate a Unit
.There are no users in this unit
.There are no active sub-units in this units

3. Activate a Unit
.Parent unit must be active

Exception:
0. Succeed
1. RecordNotFound
4. UniqueViolationException
5. MissingParameterException
6. PermissionDeniedException
7. IntegrityViolationException
10. BusinessServiceException (General)


Author: Jack Liu
Date Created: 10 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE PROCEDURE [prcUnit_Update]
(
@unitID	int,
@name 	nvarchar(100),
@active	bit,
@updatedByUserID int,
@originalDateUpdated DateTime,
@OrgID int
)
AS

set nocount on

set xact_abort on
Begin Tran

--Validation
Declare @intErrorNumber Integer -- Holds the error number
Declare @strErrorMessage Varchar(200) -- Holds the error message

declare @blnExistingStatus bit
declare @strHierarchy nvarchar(500)
declare @intParentUnitID int
declare @dteDateUpdated datetime


select @blnExistingStatus = active,
@strHierarchy=  Hierarchy +'',%'',
@intParentUnitID = ParentUnitID,
@dteDateUpdated = dbo.udfUTCtoDaylightSavingTime(DateUpdated, @OrgID)
from tblUnit
where UnitID = @unitID

set @intErrorNumber=0
set @strErrorMessage=''''

--1. Integrity Violation
--The Unit''s details have been updated by another user (since the data are retrieved)

if (@dteDateUpdated>@originalDateUpdated)
Begin
Set @intErrorNumber = 7
Set @strErrorMessage = ''The unit''''s details have been updated by another user, you will need to refresh the unit''''s details and re-enter your changes.  <a href="[Url]">Click here</a> to refresh.''
Goto Finalise
End

--2. Deactivate unit
--.There are no users in this unit
--.There are no active sub-units in this units
if (@blnExistingStatus=1 and @active=0)
Begin
if exists(select UserID from tblUser where UnitID=@unitID)
BEGIN
Set @intErrorNumber = 10
set @strErrorMessage = ''You can not deactivate a unit which contains users.  Please move the users to another unit.''
Goto Finalise
end

if exists(select UnitID from tblUnit where hierarchy like @strHierarchy  and active=1)
BEGIN
Set @intErrorNumber = 101
set @strErrorMessage = ''You can not deactivate a unit which contains active sub-units.''
Goto Finalise
end
end

--3. Activate a Unit
--.Parent unit must be active
else if (@blnExistingStatus=0 and @active=1)
Begin
if exists(select UnitID from tblUnit where unitID=@intParentUnitID  and active=0)
BEGIN
Set @intErrorNumber = 102
set @strErrorMessage = ''You cannot activate a unit whose parent unit is inactive.''
Goto Finalise
end
end


if (@intErrorNumber=0)
begin
UPDATE 	tblUnit
SET 	Name		= 	@name,
Active		= 	@active,
UpdatedBy	= 	@updatedByUserID,
DateUpdated	= 	GETUTCDATE()
WHERE 	UnitID = @unitID
end


Finalise:
If(@intErrorNumber > 0)
Begin
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
Rollback Transaction
End
Else
Begin
Select
0 As ''ErrorNumber'',
''Successfully Updated'' As ''ErrorMessage''
Commit Transaction
End


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUpdateOrgDeliquency]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra
-- Create date: 17/06/2011
-- Description:	Update Delinquency settings for Organisation
-- =============================================
CREATE PROCEDURE [prcUpdateOrgDeliquency]

@OrgID int,
@WarnMgrsofDeliquentUsers bit,
@WarnUsersofDelinquency bit,
@NumberOfReminders int,
@DelinquencyPeriod int,
@DelinquencyReminderPeriod int,
@DaysWarningBeforeExpiry int,
@IncludeLogo bit,
@QuizDueDate datetime

AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

UPDATE tblOrganisation SET --WarnMgrsofDeliquentUsers = @WarnMgrsofDeliquentUsers,
--WarnUsersofDelinquency = @WarnUsersofDelinquency,
--NumberOfReminders = @NumberOfReminders,
--DelinquencyPeriod = @DelinquencyPeriod,
--DelinquencyReminderPeriod = @DelinquencyReminderPeriod,
--DaysWarningBeforeExpiry = @DaysWarningBeforeExpiry,
IncludeLogoOnCorrespondence = @IncludeLogo,
QuizDueDate = @QuizDueDate
WHERE OrganisationID = @OrgID
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUpdateReminderEscalation]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

create procedure  [prcUpdateReminderEscalation](@remescid int, @act int)
as
begin

if @act = 0  begin
update tblReminderEscalation set DateEnabled = case when DateEnabled IS null then GETUTCDATE() else null end where RemEscId = @remescid
end
else if @act = 1 begin
delete from tblReminderEscalation where RemEscId = @remescid
end


end

' 
END
GO
 

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_Calc]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Calculate the latest course status for a user - course

Returns:
int CourseID

Called By:
prcQuizSession_GetEndQuizInfo
Calls:
Stored procedure

Remarks:

QuizStatusID Status
------------ --------------------------------------------------
0            Unassigned
1            Not Started
2            Passed
3            Failed
4            Expired (Time Elapsed)
5            Expired (New Content)


CourseStatusID Status
-------------- --------------------------------------------------
0              Unassigned
1              InComplete
2              Complete

Author: Li Zhang
Date Created: 13-10-2006
Modification History
-----------------------------------------------------------
v#	Author		Date			Description
3.0.24 Li Zhang		19-01-2007		Avoid use the row count result of vwUserQuizStatus and vwUserModule in calculating the user course status
3.0.25 Aaron Cripps	8/5/2007		Remove vwUserQuizStatus from join  replace with temp table using @UserID and @ModuleID filtering
**/



CREATE PROCEDURE [prcUserCourseStatus_Calc]
(
@CourseID int	-- The course ID
, @UserID int 	-- The user ID
, @NewQuizStatus int	-- New quiz status for calculating latest course status
, @ModuleID int -- quiz module ID
)
AS
------------------------------------
SET Nocount On

BEGIN

DECLARE @intStatus int, -- Return Value
@intRowCount int,
@intQuizFrequency int

DECLARE	@tblUserQuizStatus TABLE
(
ModuleID    int
, QuizStatusID int
)

--< select all user quiz status details before update >--
--< table to hold Quiz Status results > --
DECLARE @tblQuizStatus TABLE
(

UserID int,
ModuleID int,
CourseID int,
QuizStatusID int
)

insert into
@tblQuizStatus
(
UserID,
ModuleID,
CourseID,
QuizStatusID
)
--< select modification of vwUserQuizStatus but with additional filter for UserID and ModuleID >--
--< returns a greatly reduced number of rows in a shorter time >--
SELECT      QuizStatus.UserID, QuizStatus.ModuleID, m.CourseID, QuizStatus.QuizStatusID
FROM         dbo.tblUserQuizStatus AS QuizStatus INNER JOIN
dbo.tblModule AS m ON m.ModuleID = QuizStatus.ModuleID INNER JOIN
(SELECT     MAX(UserQuizStatusID) AS UserQuizStatusID
FROM          dbo.tblUserQuizStatus where UserID = @UserID
GROUP BY UserID, ModuleID ) AS currentStatus ON QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
WHERE     (m.Active = 1)


INSERT INTO
@tblUserQuizStatus
(
ModuleID
, QuizStatusID
)
SELECT
vUQS.ModuleID
, vUQS.QuizStatusID
FROM @tblQuizStatus vUQS
INNER JOIN vwUserModuleAccess vUMA
ON
vUQS.ModuleID = vUMA.ModuleID
AND vUMA.Userid = @UserID
AND vUMA.CourseID = @CourseID
AND vUQS.CourseID = @CourseID
AND vUQS.UserID = @UserID

--< get the rowcount >--

SET @intRowCount = @@RowCount

--< update the @tblUserQuizStatus with the latest user quiz details >--
--< when user sit the course for the first time >--
IF @intRowCount = 0
BEGIN

INSERT  INTO @tblUserQuizStatus
(	ModuleID
, QuizStatusID
)
VALUES
(
@ModuleID
, @NewQuizStatus
)
END

--< user who had sat some modules in the course >--
IF @intRowCount <> 0
BEGIN
--< user resit the same module >--
IF EXISTS (SELECT QuizStatusID FROM @tblUserQuizStatus WHERE ModuleID = @ModuleID)
BEGIN
--< quiz record exists, update quiz status >--
UPDATE @tblUserQuizStatus SET QuizStatusID = @NewQuizStatus WHERE ModuleID = @ModuleID
END
ELSE
BEGIN
INSERT  INTO @tblUserQuizStatus
(	ModuleID
, QuizStatusID
)
VALUES
(
@ModuleID
, @NewQuizStatus
)
END
END

--< star to calculate the latest course status >--
--< if there are any results for anything other than passed then the course is incomplete >--

IF EXISTS (SELECT ModuleID FROM @tblUserQuizStatus WHERE QuizStatusID <> 2)
BEGIN
--< Course status: Incomplete >--
RETURN  1
END

--< Get number of modules that the user has access to >--
select * into #tblTemp from vwUserModuleAccess where userID = @UserID and courseID=@CourseID
SET @intRowCount = @@RowCount

--<  all the quizes are passed then the course is complete >--
IF  (SELECT COUNT(ModuleID) FROM @tblUserQuizStatus WHERE QuizStatusID = 2) = @intRowCount
BEGIN
--< Course status: Complete >--
drop table #tblTemp
RETURN 2
END

--< User doesnt have access to any module in the course>--
IF (@intRowCount = 0)
BEGIN
RETURN 0
END

--< otherwise course incomplete >--
RETURN 1

END
' 
END
GO


SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_Calculate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Returns the current course status for a user - course

Returns:
int CourseStatusID

Called By:
trgUserQuizStatus
Calls:
trigger

Remarks:

QuizStatusID Status
------------ --------------------------------------------------
0            Unassigned
1            Not Started
2            Passed
3            Failed
4            Expired (Time Elapsed)
5            Expired (New Content)


CourseStatusID Status
-------------- --------------------------------------------------
0              Unassigned
1              InComplete
2              Complete

Author: Stepehn Clark
Date Created: 24 March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1 S K-Clark	7 March 2005	Access to a course but no modules in it is now considered for compliance as no access to the course
3.0.24 Li Zhang		09-02-2007		Avoid use the row count result of vwUserQuizStatus and vwUserModule in calculating the user course status
 Chris Plewright	20-11-2013		Check for expiry, and return incomplete.

exec @intCurrentCourseStatus = prcUserCourseStatus_GetStatus @CourseID = @intCourseID, @UserID = @int@UserID
exec @intNewCourseStatus = prcUserCourseStatus_Calculate @CourseID = @intCourseID, @UserID = @intUserID

DECLARE @return_status int
EXEC @return_status = prcUserCourseStatus_Calculate @CourseID = 19, @userID = 1108
SELECT ''Return Status'' = @return_status


**/



CREATE       Procedure [dbo].[prcUserCourseStatus_Calculate]
(
@CourseID int	-- The course ID
, @UserID int 	-- The user ID
)
AS
------------------------------------
Set Nocount On

--< if all the users results for this quiz are passed then the course was completed >--
Declare @intStatus int, -- Return Value
@intRowCount int

declare @tblUserQuizStatus table
(
ModuleID    int
, QuizStatusID int
, QuizFrequency int
, QuizPassMark int
, QuizScore   int
, DateCreated  datetime
, DateLastReset datetime
)

insert into
@tblUserQuizStatus
(
ModuleID
, QuizStatusID
, QuizFrequency
, QuizPassMark
, QuizScore
, DateCreated
, DateLastReset
)
select
vUQS.ModuleID
, vUQS.QuizStatusID
, vUQS.QuizFrequency
, vUQS.QuizPassMark
, vUQS.QuizScore
, vUQS.DateCreated
, vUQS.DateLastReset
from
(
	select
	QuizStatus.UserQuizStatusID
	, QuizStatus.UserID
	, QuizStatus.ModuleID
	, m.CourseID
	, QuizStatus.QuizStatusID
	, QuizStatus.QuizFrequency
	, QuizStatus.QuizPassMark
	, QuizStatus.QuizSessionID
	, QuizStatus.QuizScore
	, QuizStatus.DateCreated
	, QuizStatus.DateLastReset
	from
	tblUserQuizStatus QuizStatus
	inner join tblModule m on m.ModuleID = QuizStatus.ModuleID AND m.CourseID = @CourseID
	inner join
		(
		select
		max(UserQuizStatusID) UserQuizStatusID --UserQuizStatusID is identity
		from
		tblUserQuizStatus
		WHERE
		tblUserQuizStatus.UserID = @userID
		group by
		UserID,moduleID
		) currentStatus
	on QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
	where m.active = 1
) vUQS
inner join
(
	Select
	tU.UserID
	, tU.FirstName
	, tU.LastName
	, tU.UnitID
	, tU.OrganisationID
	, tM.ModuleID
	, tM.CourseID
	, tC.Name ''CourseName''
	, tM.Name
	, tM.Sequence
	, tM.Description
	From
	dbo.tblUser tU
	--< get the courses a user has access to >--
	Inner Join dbo.tblOrganisationCourseAccess tOCA
	On  tOCA.OrganisationID = tU.OrganisationID
	--< get the course details >--
	Inner join dbo.tblCourse tC
	On tC.CourseID = tOCA.GrantedCourseID
	--< get the Active modules in a course >--
	inner join dbo.tblModule tM
	On tM.CourseID = tC.CourseID
	and tM.Active = 1
	--< get the details on which moduels a user is configured to access >--
	Left Outer join dbo.tblUserModuleAccess tUsrMA
	On  tUsrMA.UserID = tU.UserID
	And tUsrMA.ModuleID = tM.ModuleID
	--< get the details on which moduels a users Unit is excluded from  >--
	Left Outer Join dbo.tblUnitModuleAccess tUnitMA
	On  tUnitMA.UnitID = tU.UnitID
	And tUnitMA.DeniedModuleID = tM.ModuleID
	Where
	tC.CourseID = @CourseID AND tU.UserID = @UserID
	--AND tU.Active = 1
	--< Active users only >--
	and tu.UnitID is not null
	--< Get the modules that the users Unit is not denied >--
	and (tUnitMA.DeniedModuleID  is null
	--<  and the user does not have special access to  it>--
	And tUsrMA.ModuleID is null)
	--< or Get modules that the user has been specially  granted
	or tUsrMA.Granted=1
) vUMA
on
vUQS.ModuleID = vUMA.ModuleID
and vUQS.CourseID = @CourseID
and vUQS.UserID = @userID
and vUMA.CourseID = @CourseID
and vUMA.UserID = @userID



-- get the rowcount
set @intRowCount = @@RowCount

-- if nothing was returned then there is something wrong (scheduled task has not been run ??)

if @intRowCount = 0
Begin --1
/***** this logic has been changed
Previoulsy:
If a person had access to a course but not to any modules
in the course then they still have access to the the course as far as compliance is concerned
Now:
If a person does not have access to any modules in a course then from the point of view of
compliance reporting they do not have access to the course
*/
return 0 -- unassigned ?
End --/1

-- if there are any results for anything other than passed then the course is incomplete
if exists (select ModuleID from @tblUserQuizStatus where QuizStatusID <> 2)
Begin --4
return  1 --Incomplete
End --/4

-- if there are ANY passes, but NONE of them were created AFTER the expiry or quiz reset dates, then return as Incomplete.
-- this is needed because the user may have passed the course initially, but was later unassigned from the module, 
--  and so didnt get marked as unassigned during the time when the course was expired or quiz reset.  
--  then the user may have been re-assigned to the module, but is still left with a previous completed 
--  status from a course that would have expired if they were active at that time of expiry or quiz reset.
if exists (select ModuleID from @tblUserQuizStatus where QuizStatusID = 2)
begin
	---there were passes, BUT - quiz reset date so incomplete...
	if exists ( select ModuleID from @tblUserQuizStatus where QuizStatusID = 2 and  DateLastReset is not null)
	Begin 
	  return  1 --Incomplete
	End
	
	-- check expiry...
	declare @intQuizFrequency int
	SELECT @intQuizFrequency = (
		SELECT  TOP 1   ISNULL(ur.QuizFrequency, o.DefaultQuizFrequency)
		FROM   	tblUnitRule AS ur 
		RIGHT JOIN tblUser AS u ON ur.UnitID = u.UnitID
		INNER JOIN tblOrganisation AS o ON u.OrganisationID = o.OrganisationID
		WHERE	u.UserID = @UserID
		)

	declare @dtmQuizCompletionDate datetime 
	set @dtmQuizCompletionDate = null
	SET @dtmQuizCompletionDate = (
		SELECT  TOP 1	ISNULL(ur.QuizCompletionDate, o.DefaultQuizCompletionDate)
		FROM   	tblUnitRule AS ur 
		RIGHT JOIN tblUser AS u ON ur.UnitID = u.UnitID
		INNER JOIN tblOrganisation AS o ON u.OrganisationID = o.OrganisationID
		WHERE	u.UserID = @UserID
		)

	if (@dtmQuizCompletionDate is null and @intQuizFrequency is not null)
	begin
	  select @dtmQuizCompletionDate  = ISNULL(@dtmQuizCompletionDate , dateadd(mm,0-@intQuizFrequency,GETDATE()))
	end
   
	if @dtmQuizCompletionDate is not null AND not exists ( select ModuleID from @tblUserQuizStatus where QuizStatusID = 2 and DateCreated > @dtmQuizCompletionDate )
	Begin 
	  return  1 --Incomplete
	End 
end

---

select * into #tblTemp from
(
Select
tU.UserID
, tU.FirstName
, tU.LastName
, tU.UnitID
, tU.OrganisationID
, tM.ModuleID
, tM.CourseID
, tC.Name ''CourseName''
, tM.Name
, tM.Sequence
, tM.Description
From
dbo.tblUser tU
--< get the courses a user has access to >--
Inner Join dbo.tblOrganisationCourseAccess tOCA
On  tOCA.OrganisationID = tU.OrganisationID
--< get the course details >--
Inner join dbo.tblCourse tC
On tC.CourseID = tOCA.GrantedCourseID
--< get the Active modules in a course >--
inner join dbo.tblModule tM
On tM.CourseID = tC.CourseID
and tM.Active = 1
--< get the details on which moduels a user is configured to access >--
Left Outer join dbo.tblUserModuleAccess tUsrMA
On  tUsrMA.UserID = tU.UserID
And tUsrMA.ModuleID = tM.ModuleID
--< get the details on which moduels a users Unit is excluded from  >--
Left Outer Join dbo.tblUnitModuleAccess tUnitMA
On  tUnitMA.UnitID = tU.UnitID
And tUnitMA.DeniedModuleID = tM.ModuleID
Where
tC.CourseID = @CourseID AND tU.UserID = @UserID
-- AND tU.Active = 1
--< Active users only >--
and tu.UnitID is not null
--< Get the modules that the users Unit is not denied >--
and (tUnitMA.DeniedModuleID  is null
--<  and the user does not have special access to  it>--
And tUsrMA.ModuleID is null)
--< or Get modules that the user has been specially  granted
or tUsrMA.Granted=1
) as vwUserModuleAccess where userID = @UserID and courseID=@CourseID
SET @intRowCount = @@RowCount
--  all the quizes are passed then the course is complete
if  (select count(ModuleID) from @tblUserQuizStatus where QuizStatusID = 2) = @intRowCount
Begin --5
return 2 --Complete
End --/5
drop table #tblTemp

-- Code should never fall through to here, but just in case
return 1 -- Incomplete


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'




/*
Summary: Gets othe details of one Organisation
Parameters: 	@courseID integer
@userID integer
Returns:

Called By: User.cs
Calls: None

Remarks: Raises an error if either of the input parameters are null

Author: Gavin Buddis
Date Created: 2/4/04

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcUserCourseStatus_GetOne]
(
@userID int, 	-- The User ID
@courseID int, 	-- the Course ID
@OrgID int
)

As

If @courseID Is Null
Begin
Raiserror(''The Parameter @courseID was null.  @courseID does not accept Null values.'', 16, 1)
Return
End

If @userID Is Null
Begin
Raiserror(''The Parameter @userID was null.  @userID does not accept Null values.'', 16, 1)
Return
End

DECLARE
@modulesassigned varchar(1000), -- sql2000 doesn''t allow the naked column value (modulesassigned) to be used as a param for a table udf that''s used in a join
@coursestatusid int

SELECT
TOP 1 @modulesassigned = modulesassigned, @coursestatusid = coursestatusid
FROM
tblusercoursestatus
WHERE
userid = @userid
AND courseid = @courseid
ORDER BY
datecreated DESC

SELECT
TOP 1 @userid userid, @courseid courseid, @coursestatusid coursestatusid, @modulesassigned modulesassigned, dbo.udfUTCtoDaylightSavingTime(datecreated, @OrgID) as datecreated
FROM
tbluserquizstatus,
dbo.udfCsvToInt(@modulesassigned)
WHERE
moduleid = intvalue
AND userid = @userid
AND quizstatusid = 2 -- passed
ORDER BY
datecreated DESC

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_GetStatus]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/****** Object:  Stored Procedure dbo.prcUserCourseStatus_GetStatus    Script Date: 31/03/2004 2:11:11 PM ******/


/*Summary:
gets the latest status for a user for a course

Returns:
table - single row, single column - integer or null

Called By:
trgUserQuizStatus
Calls:

Remarks:




Author: Stepehn Clark
Date Created: 24 March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

exec prcUserCourseStatus @UserID = @intUserID, @ModuleID = @intModuleID, @StatusID = @intNewCourseStatus

prcUserCourseStatus_GetStatus @CourseID = 19, @UserID = 113
QuizStatusID Status
------------ --------------------------------------------------
0            Unassigned
1            Not Started
2            Passed
3            Failed
4            Expired (Time Elapsed)
5            Expired (New Content)
**/
CREATE    procedure [prcUserCourseStatus_GetStatus]
(
@CourseID int -- the Course ID
, @UserID   int -- The User ID

)
As
------------------------
declare @intCourseStatus int -- the course status id to be returned
set @intCourseStatus =
(
select top 1
CourseStatusID -- could be null?
from
tblUserCourseStatus
where
CourseID = @CourseID
and UserID = @UserID

order by DateCreated desc
)
if @intCourseStatus is null
begin
set @intCourseStatus = -1
end
return  @intCourseStatus




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_insert]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
Inserts a new line in the tblUserCourseStatus

Returns:
null

Called By:
trgUserQuizStatus
Calls:

Remarks:




Author: Stepehn Clark
Date Created: 24 March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	JH			07 Oct 2011		add error logging, allow updates to courses after all modules in those courses have been made inactive


**/
CREATE    procedure [prcUserCourseStatus_insert]
(
@UserID   int -- The User ID
, @ModuleID int -- The Module ID
, @StatusID int -- The Status ID Completed = 1 Incomplete = 0
)
As
------------------------

Declare @intCourse int,
@intInactiveCourse int
, @strModuleIDs varchar(200)
DECLARE @Err integer
IF @StatusID in (0,1) 
BEGIN 
	set @intCourse = (select top 1 CourseID from tblModule where ModuleID = @ModuleID and active = 1) --If no modules active don''t set status to "Not Started"
	if @intCourse is null
	begin
		--Raiserror (''error in prcUserCourseStatus_insert, module is inactive!'', 16, 1)
		--INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated]) VALUES(''prcUserCourseStatus_insert'',''prcUserCourseStatus_GetStatus'',''UserID=''+CAST(@UserID AS varchar(10)),''error - no active course!'',''ModuleID = ''+CAST(@ModuleID AS VARCHAR(10))+'', StatusID = ''+CAST(@StatusID AS VARCHAR(10)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) 
		return
	end
END
ELSE 
BEGIN
	set @intCourse = (select top 1 CourseID from tblModule where ModuleID = @ModuleID)   --Some quiz results but now all modules inactive so save the results
	if @intCourse is null
	begin
		Raiserror (''error in prcUserCourseStatus_insert, course does not exist!'', 16, 1)
		INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated]) VALUES(''prcUserCourseStatus_insert'',''prcUserCourseStatus_GetStatus'',''UserID=''+CAST(@UserID AS varchar(10)),''error - no active course!'',''ModuleID = ''+CAST(@ModuleID AS VARCHAR(10))+'', StatusID = ''+CAST(@StatusID AS VARCHAR(10)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) 
		return
	end
END
-------------------------------------------------------
--- Get the ModulesID''s as a comma seperated string
-------------------------------------------------------
set @strModuleIDs = '''' -- string to hold moduelids
select
@strModuleIDs = cast(ModuleID as varchar) + '','' + @strModuleIDs
from
(
Select
tU.UserID
, tU.FirstName
, tU.LastName
, tU.UnitID
, tU.OrganisationID
, tM.ModuleID
, tM.CourseID
, tC.Name ''CourseName''
, tM.Name
, tM.Sequence
, tM.Description
From
dbo.tblUser tU
--< get the courses a user has access to >--
Inner Join dbo.tblOrganisationCourseAccess tOCA
On  tOCA.OrganisationID = tU.OrganisationID
--< get the course details >--
Inner join dbo.tblCourse tC
On tC.CourseID = tOCA.GrantedCourseID
--< get the Active modules in a course >--
inner join dbo.tblModule tM
On tM.CourseID = tC.CourseID
and tM.Active = 1
--< get the details on which moduels a user is configured to access >--
Left Outer join dbo.tblUserModuleAccess tUsrMA
On  tUsrMA.UserID = tU.UserID
And tUsrMA.ModuleID = tM.ModuleID
--< get the details on which moduels a user''s Unit is excluded from  >--
Left Outer Join dbo.tblUnitModuleAccess tUnitMA
On  tUnitMA.UnitID = tU.UnitID
And tUnitMA.DeniedModuleID = tM.ModuleID
Where
tC.CourseID = @intCourse AND tU.UserID = @UserID AND
tU.Active = 1
--< Active users only >--
and tu.UnitID is not null
--< Get the modules that the user''s Unit is not denied >--
and (tUnitMA.DeniedModuleID  is null
--<  and the user does not have special access to  it>--
And tUsrMA.ModuleID is null)
--< or Get modules that the user has been specially  granted
or tUsrMA.Granted=1
) as tempTable
where
CourseID = @intCourse
and  UserID = @UserID
-------------------------------------------------------
--- insert the new values
-------------------------------------------------------

INSERT INTO
tblUserCourseStatus
(
UserID,
CourseID,
CourseStatusID,
ModulesAssigned,
DateCreated
)
VALUES
(
@UserID
, @intCourse
, @StatusID
, @strModuleIDs
, GETUTCDATE()
)
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserCourseStatus_insert'',''INSERT INTO tblUserCourseStatus'',''UserID=''+CAST(@UserID AS varchar(10)),''CourseID = ''+CAST(@intCourse AS VARCHAR(10)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) END




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_REMOVEDUPLICATESTATUS]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE procedure [prcUserCourseStatus_REMOVEDUPLICATESTATUS]
AS
-- prcUserCourseStatus_REMOVEDUPLICATESTATUS
--Remove duplicated unassigned status records due to a bug inside the tblUserQuizStatus trigger

select UserID, courseID,min(UserCourseStatusID) as minID, max(UserCourseStatusID) as maxID
into #Duplicated
from tblUserCourseStatus
where  CourseStatusID=0
group by UserID, courseID
having min(UserCourseStatusID)<>max(UserCourseStatusID)
order by UserID, courseID


--Don''t delete the following records if there are any other status between unassigned status
select d.*
into #DuplicatedError
from #Duplicated d
inner join tblUserCourseStatus s on s.UserID=d.UserID and s.CourseID=d.CourseID and s.UserCourseStatusID>=d.minID and s.UserCourseStatusID<=d.MaxID
where s.CourseStatusID<>0

delete #Duplicated
from #Duplicated d
inner join tblUserCourseStatus s on s.UserID=d.UserID and s.CourseID=d.CourseID and s.UserCourseStatusID>=d.minID and s.UserCourseStatusID<=d.MaxID
where s.CourseStatusID<>0


--Removed duplicated records, leave the first record
delete tblUserCourseStatus
from tblUserCourseStatus s
inner join #Duplicated d on s.UserID=d.UserID and s.CourseID=d.CourseID and s.UserCourseStatusID>d.minID and s.UserCourseStatusID<=d.MaxID
where s.CourseStatusID=0

select cast(@@rowCount as varchar) + '' duplicated status have been removed''

if (select count(*) from #DuplicatedError)>0
begin
select ''The following user course status need to be manually removed''
select * from #DuplicatedError
end

drop table #Duplicated
drop table #DuplicatedError




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourse_GetCompletionDate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
summary: get completion date for the last required component in a course is completed
parameters: userID int, courseID int
returns: datetimecompleted datetime

called by:
Author: Li Zhang
Date Created:

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/
CREATE Procedure [prcUserCourse_GetCompletionDate]
(@userID int,
@courseID int,
@OrgID int,
@courseCompletionDate datetime=null output
)
AS

Set Nocount On

/*
select
um.UserID,
um.ModuleID
into #tblCurrentAssignedModules
from vwUserModuleAccess um
inner join
vwUnitModuleRule umr
on umr.moduleID = um.moduleID
and umr.unitID = um.unitId
inner join
tblmodule m
on um.moduleId= m.moduleID
where
um.userID = @userID
and m.courseID = @courseID

--select * from #tblCurrentAssignedModules

select
um.userID,
um.moduleID,
qs.DateTimeCompleted
into
#tblStartedModules
from
#tblCurrentAssignedModules um
inner join
(
select
um.userID,
um.moduleID,
max(DateTimeCompleted) as DateTimeCompleted
from
#tblCurrentAssignedModules um
inner join tblQuiz q
on q.moduleID = um.ModuleID
inner join tblQuizSession qs
on qs.QuizID = q.quizID
and qs.userID = um.userId
and qs.datetimecompleted is not null
group by um.userID, um.moduleID
)as lastQuizDate
on lastquizdate.userID = um.userID
and lastquizdate.moduleID = um.moduleID
inner join tblQuiz q
on
q.moduleID = um.moduleID
inner join tblQuizSession qs
on qs.quizid = q.quizid
and qs.userid = um.userid
and qs.datetimecompleted = lastquizdate.datetimecompleted

select @courseCompletionDate = max(DateTimeCompleted) from #tblstartedmodules

*/


select top 1 @courseCompletionDate = dbo.udfUTCtoDaylightSavingTime(DateCreated, @OrgID) from tblUserCourseStatus where CourseID = @courseID and UserID = @userID and CourseStatusID = 2 order by DateCreated desc
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE Procedure [prcUserLessonStatus_Update]
AS
Set Nocount On


declare @cursor_OrgID	    int

DECLARE OrgList CURSOR
FOR
SELECT OrganisationID from tblOrganisation order by OrganisationID desc

Open OrgList

FETCH NEXT FROM OrgList
Into
@cursor_OrgID

WHILE @@FETCH_STATUS = 0
BEGIN

exec prcUserLessonStatus_Update_Quick @cursor_OrgID

FETCH NEXT FROM OrgList Into @cursor_OrgID
END

CLOSE OrgList
DEALLOCATE OrgList


' 
END
GO


/****** Object:  StoredProcedure [dbo].[prcUserLessonStatus_Update_NO_TRIGGER]    Script Date: 12/19/2012 15:23:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_NO_TRIGGER]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

create Procedure [prcUserLessonStatus_Update_NO_TRIGGER]
AS
Set Nocount On


declare @cursor_OrgID	    int

DECLARE OrgList CURSOR
FOR
SELECT OrganisationID from tblOrganisation order by OrganisationID desc

Open OrgList

FETCH NEXT FROM OrgList
Into
@cursor_OrgID

WHILE @@FETCH_STATUS = 0
BEGIN

exec prcUserLessonStatus_Update_NO_TRIGGER_Quick @cursor_OrgID

FETCH NEXT FROM OrgList Into @cursor_OrgID
END

CLOSE OrgList
DEALLOCATE OrgList


' 
END
GO


/****** Object:  StoredProcedure [dbo].[prcUserLessonStatus_Update_NO_TRIGGER_CurrentStatus]    Script Date: 12/19/2012 15:23:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_NO_TRIGGER_CurrentStatus]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE Procedure [prcUserLessonStatus_Update_NO_TRIGGER_CurrentStatus]
AS
Set Nocount On


declare @cursor_OrgID	    int

DECLARE OrgList CURSOR
FOR
SELECT OrganisationID from tblOrganisation order by OrganisationID desc

Open OrgList

FETCH NEXT FROM OrgList
Into
@cursor_OrgID

WHILE @@FETCH_STATUS = 0
BEGIN

exec prcUserLessonStatus_Update_NO_TRIGGER_CurrentStatus_Quick @cursor_OrgID

FETCH NEXT FROM OrgList Into @cursor_OrgID
END

CLOSE OrgList
DEALLOCATE OrgList


' 
END
GO


/****** Object:  StoredProcedure [dbo].[prcUserLessonStatus_Update_NO_TRIGGER_CurrentStatus_Quick]    Script Date: 12/19/2012 15:23:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_NO_TRIGGER_CurrentStatus_Quick]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/* Summary:
Update lesson status for each user
This schedule task only updates three status:
Unassigned Modules (0)
New Assigned Modules (Not Started(1))
Expired Modules (Time Elapsed)(4)

Returns:

Called By:

Calls:
Nothing

Remarks:
This is a schedule job running every night to check there are any changes in the user lesson status based on current compliance rules.
If they are the same as the current status, ignore it, otherwise a new status will be created.

If a module is assigned to a user, and there is no activity for this module, the status will be  ''''Not started''''.
If a module is unassigned from a user, the status will be ''''unassinged"(There are records in status table, but the module is not assigned to this user now)
If a module is set to inactive, the status will be ''''unassinged''''

------------ Decision Processes -------------

1. Get CurrentAssignedModules and PreviousAssignedModules
1.1  CurrentAssignedModules
Get all modules that are currently assigned to each users
and compliance rules

1.2  PreviousAssignedModules
Get a list of modules that is in the lesson status table that the last statuses are not Unassigned (0)

2. Add New lesson status
2.1. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)

2.2. New Assigned Modules (Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)

2.3. Expired Modules (Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson date/frequency, the new status is Expired (Time Expired)(4)



------------ Data need to be recorded -------------

LessonFrequency
0  Unassigned:  		-
1  Not Started: 		Y
4  Expired (Time Elapsed): 	Y


Author: Jack Liu
Date Created: 21 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		1/5/2007		Added LessonCompletionDate

prcUserLessonStatus_Update

**/
CREATE Procedure [prcUserLessonStatus_Update_NO_TRIGGER_CurrentStatus_Quick]
(
@OrgID int	-- comma separated organisationID
)
AS
Set Nocount On



--##################################################################################################################
/*
2. Add New lesson status

2.1.     N O T      A S S I G N E D      M O D U L E S
(0) (PreviousAssignedModules - CurrentAssignedModules)
Add record of 0 (unassigned) to tblUserLessonStatus for each User-Module that has been started but now has no Course access or is specifically excluded at unit/user level
*/
--##################################################################################################################
insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID
)
select pam.UserID,
pam.ModuleID,
0  as QuizStatusID --Unassigned (0)
from  

(
		SELECT LessonStatus.UserID, LessonStatus.ModuleID
		FROM  dbo.tblUserCurrentLessonStatus as LessonStatus 
		inner join tblUser on tblUser.UserID = LessonStatus.UserID and tblUser.OrganisationID = @OrgID 
		WHERE  (LessonStatus.Excluded = 0) OR (LessonStatus.Excluded IS NULL)
		AND (LessonStatus.UserLessonStatusID <> 0)
        and 	LessonStatus.LessonStatusID<>0 --not Unassigned (0)
)  pam
 

left join (SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL) 
               THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND 
               ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL)) 
               THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
FROM  dbo.tblUser AS tU INNER JOIN
tblUnit on tU.UnitID = tblUnit.UnitID and tblUnit.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
               dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
               dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
               (tUsrMA.Granted = 1)) cam -- Current Assigned Modules
               
on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where cam.moduleID is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)



--##################################################################################################################
/*
2.2.      N E W     A S S I G N E D     M O D U L E S
(Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)
*/
--##################################################################################################################


insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency, 
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
1  as LessonStatusID,--Not Started(1)
cam.LessonFrequency, 
cam.LessonCompletionDate
from 
(
		SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL) 
               THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND 
               ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL)) 
               THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
		FROM  dbo.tblUser AS tU INNER JOIN
		tblUnit on tU.UnitID = tblUnit.UnitID and tblUnit.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
               dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
               dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
               (tUsrMA.Granted = 1)
 ) cam 
left join 
(
		SELECT LessonStatus.UserID, LessonStatus.ModuleID
		FROM  dbo.tblUserCurrentLessonStatus as LessonStatus 
		inner join tblUser on tblUser.UserID = LessonStatus.UserID and tblUser.OrganisationID = @OrgID 
		WHERE  (LessonStatus.Excluded = 0) OR (LessonStatus.Excluded IS NULL)
		AND (LessonStatus.UserLessonStatusID <> 0)
        and 	LessonStatus.LessonStatusID<>0 --not Unassigned (0)
)  pam
on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where pam.moduleID is null



--##################################################################################################################
/*
2.3.       E X P I R E D    M O D U L E S
 (Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson frequency, the new status is Expired (Time Expired)(4)
*/
--##################################################################################################################




insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency, 
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
4  as LessonStatusID, --(Time Elapsed)(4)
cam.LessonFrequency, cam.LessonCompletionDate
from (
	select 	max(LastStarted.UserLessonStatusID) LastStartedStatusID
	from tblUserLessonStatus LastStarted
	inner join 
	(
		SELECT LessonStatus.UserLessonStatusID, LessonStatus.UserID, LessonStatus.ModuleID, m.CourseID, LessonStatus.LessonStatusID, LessonStatus.LessonFrequency, 
					   LessonStatus.DateCreated
		FROM  dbo.tblUserCurrentLessonStatus as LessonStatus 
		inner join tblUser on tblUser.UserID = LessonStatus.UserID and tblUser.OrganisationID = @OrgID 
		inner join tblModule m on m.ModuleID = LessonStatus.ModuleID
							
		WHERE  (LessonStatus.Excluded = 0) OR (LessonStatus.Excluded IS NULL)
	) CurrentStatus
	on  LastStarted.UserID = CurrentStatus.UserID
	and  LastStarted.ModuleID = CurrentStatus.ModuleID
	and CurrentStatus.LessonStatusID in (2,3)
	where LastStarted.LessonStatusID = 2
	and LastStarted.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
	group by LastStarted.UserID, LastStarted.moduleID
) lss
inner join tblUserLessonStatus uls
on uls.UserLessonStatusID = lss.LastStartedStatusID
inner join (SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL) 
               THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND 
               ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL)) 
               THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
FROM  dbo.tblUser AS tU INNER JOIN
               dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
               dbo.tblUnit AS u ON u.OrganisationID = tU.OrganisationID and u.UnitID = tU.UnitID INNER JOIN
               dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
               dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
               (tUsrMA.Granted = 1)) cam
on cam.UserID = uls.UserID
and cam.ModuleID = uls.ModuleID
where
	(
		cam.LessonCompletionDate is null 
		and DateDiff(day,getdate(), dateadd(month, cam.LessonFrequency, uls.DateCreated)) <= 0
	)
	or 
	(
		isnull(DateDiff(day, getdate(), cam.LessonCompletionDate), 1) <= 0
	)
	and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
--Expired





--##################################################################################################################
-- Extend completion dates
	update tblOrganisation 
		set DefaultLessonCompletionDate = dateadd(year, 1, [DefaultLessonCompletionDate])
		where DefaultLessonCompletionDate < getdate() and OrganisationID = @OrgID

--##################################################################################################################
	update tblUnitRule
		set LessonCompletionDate = dateadd(year, 1, [LessonCompletionDate])
		where LessonCompletionDate < getdate() and UnitID IN (select UnitID from tblUnit where OrganisationID = @OrgID)
-- /Extend completion dates
--##################################################################################################################
	
	
	

SET QUOTED_IDENTIFIER ON 


' 
END
GO


/****** Object:  StoredProcedure [dbo].[prcUserLessonStatus_Update_NO_TRIGGER_Quick]    Script Date: 12/19/2012 15:23:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_NO_TRIGGER_Quick]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/* Summary:
Update lesson status for each user
This schedule task only updates three status:
Unassigned Modules (0)
New Assigned Modules (Not Started(1))
Expired Modules (Time Elapsed)(4)

Returns:

Called By:

Calls:
Nothing

Remarks:
This is a schedule job running every night to check there are any changes in the user lesson status based on current compliance rules.
If they are the same as the current status, ignore it, otherwise a new status will be created.

If a module is assigned to a user, and there is no activity for this module, the status will be  ''''Not started''''.
If a module is unassigned from a user, the status will be ''''unassinged"(There are records in status table, but the module is not assigned to this user now)
If a module is set to inactive, the status will be ''''unassinged''''

------------ Decision Processes -------------

1. Get CurrentAssignedModules and PreviousAssignedModules
1.1  CurrentAssignedModules
Get all modules that are currently assigned to each users
and compliance rules

1.2  PreviousAssignedModules
Get a list of modules that is in the lesson status table that the last statuses are not Unassigned (0)

2. Add New lesson status
2.1. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)

2.2. New Assigned Modules (Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)

2.3. Expired Modules (Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson date/frequency, the new status is Expired (Time Expired)(4)



------------ Data need to be recorded -------------

LessonFrequency
0  Unassigned:  		-
1  Not Started: 		Y
4  Expired (Time Elapsed): 	Y


Author: Jack Liu
Date Created: 21 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		1/5/2007		Added LessonCompletionDate

prcUserLessonStatus_Update

**/
create Procedure [prcUserLessonStatus_Update_NO_TRIGGER_Quick]
(
@OrgID int	-- comma separated organisationID
)
AS
Set Nocount On



--##################################################################################################################
/*
2. Add New lesson status

2.1.     N O T      A S S I G N E D      M O D U L E S
(0) (PreviousAssignedModules - CurrentAssignedModules)
Add record of 0 (unassigned) to tblUserLessonStatus for each User-Module that has been started but now has no Course access or is specifically excluded at unit/user level
*/
--##################################################################################################################
insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID
)
select pam.UserID,
pam.ModuleID,
0  as QuizStatusID --Unassigned (0)
from  (
		SELECT LessonStatus.UserID, LessonStatus.ModuleID
		FROM  tblUser inner join dbo.tblUserLessonStatus AS LessonStatus on tbluser.UserID = LessonStatus.UserID and tblUser.OrganisationID = @OrgID INNER JOIN
					   dbo.tblModule AS m ON m.ModuleID = LessonStatus.ModuleID INNER JOIN
						   (SELECT MAX(UserLessonStatusID) AS UserLessonStatusID
							FROM   dbo.tblUserLessonStatus
							GROUP BY UserID, ModuleID) AS currentStatus ON LessonStatus.UserLessonStatusID = currentStatus.UserLessonStatusID
		WHERE ((LessonStatus.Excluded = 0) or (LessonStatus.Excluded is null)) AND (LessonStatus.UserLessonStatusID <> 0)
        and 	LessonStatus.LessonStatusID<>0 --not Unassigned (0)
) pam   --   PREVIOUS ASSIGNED MODULES
 

left join (SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL) 
               THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND 
               ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL)) 
               THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
FROM  dbo.tblUser AS tU INNER JOIN
tblUnit on tU.UnitID = tblUnit.UnitID and tblUnit.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
               dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
               dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
               (tUsrMA.Granted = 1)) cam -- Current Assigned Modules
               
on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where cam.moduleID is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)



--##################################################################################################################
/*
2.2.      N E W     A S S I G N E D     M O D U L E S
(Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)
*/
--##################################################################################################################


insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency, 
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
1  as LessonStatusID,--Not Started(1)
cam.LessonFrequency, 
cam.LessonCompletionDate
from 
(
		SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL) 
               THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND 
               ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL)) 
               THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
		FROM  dbo.tblUser AS tU INNER JOIN
		tblUnit on tU.UnitID = tblUnit.UnitID and tblUnit.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
               dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
               dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
               (tUsrMA.Granted = 1)
 ) cam 
left join 
(
		SELECT LessonStatus.UserID, LessonStatus.ModuleID
		FROM  tblUser inner join dbo.tblUserLessonStatus AS LessonStatus on tbluser.UserID = LessonStatus.UserID and tblUser.OrganisationID = @OrgID INNER JOIN
					   dbo.tblModule AS m ON m.ModuleID = LessonStatus.ModuleID INNER JOIN
						   (SELECT MAX(UserLessonStatusID) AS UserLessonStatusID
							FROM   dbo.tblUserLessonStatus
							GROUP BY UserID, ModuleID) AS currentStatus ON LessonStatus.UserLessonStatusID = currentStatus.UserLessonStatusID
		WHERE ((LessonStatus.Excluded = 0) or (LessonStatus.Excluded is null)) AND (LessonStatus.UserLessonStatusID <> 0)
        and 	LessonStatus.LessonStatusID<>0 --not Unassigned (0)
)  pam
on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where pam.moduleID is null



--##################################################################################################################
/*
2.3.       E X P I R E D    M O D U L E S
 (Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson frequency, the new status is Expired (Time Expired)(4)
*/
--##################################################################################################################




insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency, 
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
4  as LessonStatusID, --(Time Elapsed)(4)
cam.LessonFrequency, cam.LessonCompletionDate
from (
	select 	max(LastStarted.UserLessonStatusID) LastStartedStatusID
	from tblUserLessonStatus LastStarted
	inner join 
	(
		SELECT LessonStatus.UserLessonStatusID, LessonStatus.UserID, LessonStatus.ModuleID, m.CourseID, LessonStatus.LessonStatusID, LessonStatus.LessonFrequency, 
					   LessonStatus.DateCreated
		FROM  dbo.tblUserLessonStatus AS LessonStatus INNER JOIN
					   dbo.tblModule AS m ON m.ModuleID = LessonStatus.ModuleID INNER JOIN
						   (SELECT MAX(UserLessonStatusID) AS UserLessonStatusID
							FROM   dbo.tblUserLessonStatus inner join tblUser on tblUser.UserID = tblUserLessonStatus.UserID and tblUser.OrganisationID = @OrgID 
							GROUP BY tblUserLessonStatus.UserID, ModuleID) AS currentStatus ON LessonStatus.UserLessonStatusID = currentStatus.UserLessonStatusID
		WHERE  (LessonStatus.Excluded = 0) OR (LessonStatus.Excluded IS NULL)
	) CurrentStatus
	on  LastStarted.UserID = CurrentStatus.UserID
	and  LastStarted.ModuleID = CurrentStatus.ModuleID
	and CurrentStatus.LessonStatusID in (2,3)
	where LastStarted.LessonStatusID = 2
	and LastStarted.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
	group by LastStarted.UserID, LastStarted.moduleID
) lss
inner join tblUserLessonStatus uls
on uls.UserLessonStatusID = lss.LastStartedStatusID
inner join (SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL) 
               THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND 
               ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL)) 
               THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
FROM  dbo.tblUser AS tU INNER JOIN
               dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
               dbo.tblUnit AS u ON u.OrganisationID = tU.OrganisationID and u.UnitID = tU.UnitID INNER JOIN
               dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
               dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
               (tUsrMA.Granted = 1)) cam
on cam.UserID = uls.UserID
and cam.ModuleID = uls.ModuleID
where
	(
		cam.LessonCompletionDate is null 
		and DateDiff(day,getdate(), dateadd(month, cam.LessonFrequency, uls.DateCreated)) <= 0
	)
	or 
	(
		isnull(DateDiff(day, getdate(), cam.LessonCompletionDate), 1) <= 0
	)
	and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
--Expired





--##################################################################################################################
-- Extend completion dates
	update tblOrganisation 
		set DefaultLessonCompletionDate = dateadd(year, 1, [DefaultLessonCompletionDate])
		where DefaultLessonCompletionDate < getdate() and OrganisationID = @OrgID

--##################################################################################################################
	update tblUnitRule
		set LessonCompletionDate = dateadd(year, 1, [LessonCompletionDate])
		where LessonCompletionDate < getdate() and UnitID IN (select UnitID from tblUnit where OrganisationID = @OrgID)
-- /Extend completion dates
--##################################################################################################################
	
	
	

SET QUOTED_IDENTIFIER ON 


' 
END
GO


/****** Object:  StoredProcedure [dbo].[prcUserLessonStatus_Update_old_Quick]    Script Date: 12/19/2012 15:23:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_old_Quick]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/* Summary:
Update lesson status for each user
This schedule task only updates three status:
Unassigned Modules (0)
New Assigned Modules (Not Started(1))
Expired Modules (Time Elapsed)(4)

Returns:

Called By:

Calls:
Nothing

Remarks:
This is a schedule job running every night to check there are any changes in the user lesson status based on current compliance rules.
If they are the same as the current status, ignore it, otherwise a new status will be created.

If a module is assigned to a user, and there is no activity for this module, the status will be  ''Not started''.
If a module is unassigned from a user, the status will be ''unassinged"(There are records in status table, but the module is not assigned to this user now)
If a module is set to inactive, the status will be ''unassinged''

------------ Decision Processes -------------

1. Get CurrentAssignedModules and PreviousAssignedModules
1.1  CurrentAssignedModules
Get all modules that are currently assigned to each users
and compliance rules

1.2  PreviousAssignedModules
Get a list of modules that is in the lesson status table that the last statuses are not Unassigned (0)

2. Add New lesson status
2.1. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)

2.2. New Assigned Modules (Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)

2.3. Expired Modules (Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson date/frequency, the new status is Expired (Time Expired)(4)



------------ Data need to be recorded -------------

LessonFrequency
0  Unassigned:  		-
1  Not Started: 		Y
4  Expired (Time Elapsed): 	Y


Author: Jack Liu
Date Created: 21 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		1/5/2007		Added LessonCompletionDate

prcUserLessonStatus_Update

**/
CREATE Procedure [prcUserLessonStatus_Update_old_Quick]
(
@OrgID int	-- comma separated organisationID
)
AS
Set Nocount On

/*

1. Get CurrentAssignedModules and PreviousAssignedModules
1.1  CurrentAssignedModules
Get all modules that are currently assigned to each users
and compliance rules
*/

-- mikev(1): added lessonCompletionDate
select 	um.UserID,
um.ModuleID,
umr.LessonFrequency,
umr.LessonCompletionDate
into #tblCurrentAssignedModules
from vwUserModuleAccess um
inner join vwUnitModuleRule umr
on umr.ModuleID  = um.ModuleID
and umr.UnitID = um.UnitID
where um.UnitID in (select UnitID from tblUnit where OrganisationID = @OrgID)
and um.UserID IN (select UserID from tblUser where OrganisationID = @OrgID)


-- select * from #tblCurrentAssignedModules
/*
1.2  PreviousAssignedModules
Get a list of modules that is in the lesson status table that the last statuses are not Unassigned (0)

*/

select 	uls.UserID,
uls.ModuleID
into #PreviousAssignedModules
from vwUserLessonStatus uls
where 	uls.LessonStatusID<>0 --not Unassigned (0)
and uls.UserID IN (select UserID from tblUser where OrganisationID = @OrgID)

/*
2. Add New lesson status
2.1. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)
*/

insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID
)
select pam.UserID,
pam.ModuleID,
0  as QuizStatusID --Unassigned (0)
from #PreviousAssignedModules pam
left join #tblCurrentAssignedModules cam
on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where cam.moduleID is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)


/*
2.2. New Assigned Modules (Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)
*/

-- mikev(1): Added LessonCompletionDate
insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency,
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
1  as LessonStatusID,--Not Started(1)
cam.LessonFrequency, cam.LessonCompletionDate
from #tblCurrentAssignedModules cam
left join #PreviousAssignedModules pam
on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where pam.moduleID is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)

/*
2.3. Expired Modules (Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson frequency, the new status is Expired (Time Expired)(4)
*/

select 	max(LastStarted.UserLessonStatusID) LastStartedStatusID
into #tblLastStartedStatus
from tblUserLessonStatus LastStarted
inner join vwUserLessonStatus CurrentStatus
on  LastStarted.UserID = CurrentStatus.UserID
and  LastStarted.ModuleID = CurrentStatus.ModuleID
and CurrentStatus.LessonStatusID in (2,3)
where LastStarted.LessonStatusID = 2
and LastStarted.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
group by LastStarted.UserID, LastStarted.moduleID

-- mikev(1): added LessonCompletionDate
insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency,
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
4  as LessonStatusID, --(Time Elapsed)(4)
cam.LessonFrequency, cam.LessonCompletionDate
from #tblLastStartedStatus lss
inner join tblUserLessonStatus uls
on uls.UserLessonStatusID = lss.LastStartedStatusID
inner join #tblCurrentAssignedModules cam
on cam.UserID = uls.UserID
and cam.ModuleID = uls.ModuleID
where
(
cam.LessonCompletionDate is null
and DateDiff(day,GETUTCDATE(), dateadd(month, cam.LessonFrequency, uls.DateCreated)) <= 0
)
or
(
isnull(DateDiff(day, GETUTCDATE(), cam.LessonCompletionDate), 1) <= 0
)
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
--Expired

drop table #tblCurrentAssignedModules

drop table #PreviousAssignedModules

drop table #tblLastStartedStatus

-- Extend completion dates
update tblOrganisation
set DefaultLessonCompletionDate = dateadd(year, 1, [DefaultLessonCompletionDate])
where DefaultLessonCompletionDate < GETUTCDATE() and OrganisationID = @OrgID

update tblUnitRule
set LessonCompletionDate = dateadd(year, 1, [LessonCompletionDate])
where LessonCompletionDate < GETUTCDATE() and UnitID IN (select UnitID from tblUnit where OrganisationID = @OrgID)
-- /Extend completion dates


SET QUOTED_IDENTIFIER ON
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_Quick]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/* Summary:
Update lesson status for each user
This schedule task only updates three status:
Unassigned Modules (0)
New Assigned Modules (Not Started(1))
Expired Modules (Time Elapsed)(4)

Returns:

Called By:

Calls:
Nothing

Remarks:
This is a schedule job running every night to check there are any changes in the user lesson status based on current compliance rules.
If they are the same as the current status, ignore it, otherwise a new status will be created.

If a module is assigned to a user, and there is no activity for this module, the status will be  ''''Not started''''.
If a module is unassigned from a user, the status will be ''''unassinged"(There are records in status table, but the module is not assigned to this user now)
If a module is set to inactive, the status will be ''''unassinged''''

------------ Decision Processes -------------

1. Get CurrentAssignedModules and PreviousAssignedModules
1.1  CurrentAssignedModules
Get all modules that are currently assigned to each users
and compliance rules

1.2  PreviousAssignedModules
Get a list of modules that is in the lesson status table that the last statuses are not Unassigned (0)

2. Add New lesson status
2.1. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)

2.2. New Assigned Modules (Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)

2.3. Expired Modules (Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson date/frequency, the new status is Expired (Time Expired)(4)



------------ Data need to be recorded -------------

LessonFrequency
0  Unassigned:  		-
1  Not Started: 		Y
4  Expired (Time Elapsed): 	Y


Author: Jack Liu
Date Created: 21 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		1/5/2007		Added LessonCompletionDate

prcUserLessonStatus_Update

**/
CREATE Procedure [prcUserLessonStatus_Update_Quick]
(
@OrgID int	-- comma separated organisationID
)
AS
Set Nocount On



--##################################################################################################################
/*
2. Add New lesson status

2.1.     N O T      A S S I G N E D      M O D U L E S
(0) (PreviousAssignedModules - CurrentAssignedModules)
Add record of 0 (unassigned) to tblUserLessonStatus for each User-Module that has been started but now has no Course access or is specifically excluded at unit/user level
*/
--##################################################################################################################
insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID
)
select pam.UserID,
pam.ModuleID,
0  as QuizStatusID --Unassigned (0)
from

(
SELECT LessonStatus.UserID, LessonStatus.ModuleID
FROM  dbo.tblUserCurrentLessonStatus as LessonStatus
inner join tblUser on tblUser.UserID = LessonStatus.UserID and tblUser.OrganisationID = @OrgID
WHERE  (LessonStatus.Excluded = 0) OR (LessonStatus.Excluded IS NULL)
AND (LessonStatus.UserLessonStatusID <> 0)
and 	LessonStatus.LessonStatusID<>0 --not Unassigned (0)
)  pam


left join (SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL)
THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND
ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL))
THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
FROM  dbo.tblUser AS tU INNER JOIN
tblUnit on tU.UnitID = tblUnit.UnitID and tblUnit.OrganisationID = @OrgID INNER JOIN
dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
(tUsrMA.Granted = 1)) cam -- Current Assigned Modules

on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where cam.moduleID is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)



--##################################################################################################################
/*
2.2.      N E W     A S S I G N E D     M O D U L E S
(Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)
*/
--##################################################################################################################


insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency,
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
1  as LessonStatusID,--Not Started(1)
cam.LessonFrequency,
cam.LessonCompletionDate
from
(
SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL)
THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND
ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL))
THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
FROM  dbo.tblUser AS tU INNER JOIN
tblUnit on tU.UnitID = tblUnit.UnitID and tblUnit.OrganisationID = @OrgID INNER JOIN
dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
(tUsrMA.Granted = 1)
) cam
left join
(
SELECT LessonStatus.UserID, LessonStatus.ModuleID
FROM  dbo.tblUserCurrentLessonStatus as LessonStatus
inner join tblUser on tblUser.UserID = LessonStatus.UserID and tblUser.OrganisationID = @OrgID
WHERE  (LessonStatus.Excluded = 0) OR (LessonStatus.Excluded IS NULL)
AND (LessonStatus.UserLessonStatusID <> 0)
and 	LessonStatus.LessonStatusID<>0 --not Unassigned (0)
)  pam
on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where pam.moduleID is null



--##################################################################################################################
/*
2.3.       E X P I R E D    M O D U L E S
(Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson frequency, the new status is Expired (Time Expired)(4)
*/
--##################################################################################################################




insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency,
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
4  as LessonStatusID, --(Time Elapsed)(4)
cam.LessonFrequency, cam.LessonCompletionDate
from (
select 	max(LastStarted.UserLessonStatusID) LastStartedStatusID
from tblUserLessonStatus LastStarted
inner join
(
SELECT LessonStatus.UserLessonStatusID, LessonStatus.UserID, LessonStatus.ModuleID, m.CourseID, LessonStatus.LessonStatusID, LessonStatus.LessonFrequency,
LessonStatus.DateCreated
FROM  dbo.tblUserCurrentLessonStatus as LessonStatus
inner join tblUser on tblUser.UserID = LessonStatus.UserID and tblUser.OrganisationID = @OrgID
inner join tblModule m on m.ModuleID = LessonStatus.ModuleID

WHERE  (LessonStatus.Excluded = 0) OR (LessonStatus.Excluded IS NULL)
) CurrentStatus
on  LastStarted.UserID = CurrentStatus.UserID
and  LastStarted.ModuleID = CurrentStatus.ModuleID
and CurrentStatus.LessonStatusID in (2,3)
where LastStarted.LessonStatusID = 2
and LastStarted.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
group by LastStarted.UserID, LastStarted.moduleID
) lss
inner join tblUserLessonStatus uls
on uls.UserLessonStatusID = lss.LastStartedStatusID
inner join (SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL)
THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND
ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL))
THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
FROM  dbo.tblUser AS tU INNER JOIN
dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
dbo.tblUnit AS u ON u.OrganisationID = tU.OrganisationID and u.UnitID = tU.UnitID INNER JOIN
dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
(tUsrMA.Granted = 1)) cam
on cam.UserID = uls.UserID
and cam.ModuleID = uls.ModuleID
where
(
cam.LessonCompletionDate is null
and DateDiff(day,getutcdate(), dateadd(month, cam.LessonFrequency, uls.DateCreated)) <= 0
)
or
(
isnull(DateDiff(day, getutcdate(), cam.LessonCompletionDate), 1) <= 0
)
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
--Expired





--##################################################################################################################
-- Extend completion dates
update tblOrganisation
set DefaultLessonCompletionDate = dateadd(year, 1, [DefaultLessonCompletionDate])
where DefaultLessonCompletionDate < getutcdate() and OrganisationID = @OrgID

--##################################################################################################################
update tblUnitRule
set LessonCompletionDate = dateadd(year, 1, [LessonCompletionDate])
where LessonCompletionDate < getutcdate() and UnitID IN (select UnitID from tblUnit where OrganisationID = @OrgID)
-- /Extend completion dates
--##################################################################################################################




SET QUOTED_IDENTIFIER ON
' 
END
GO


/****** Object:  StoredProcedure [dbo].[prcUserLessonStatus_Update_SIMULATE_TRIGGERDATA]    Script Date: 12/19/2012 15:23:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_SIMULATE_TRIGGERDATA]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

create Procedure [prcUserLessonStatus_Update_SIMULATE_TRIGGERDATA]
AS
Set Nocount On


declare @cursor_OrgID	    int

DECLARE OrgList CURSOR
FOR
SELECT OrganisationID from tblOrganisation order by OrganisationID desc

Open OrgList

FETCH NEXT FROM OrgList
Into
@cursor_OrgID

WHILE @@FETCH_STATUS = 0
BEGIN

exec prcUserLessonStatus_Update_Quick_SIMULATE_TRIGGERDATA @cursor_OrgID

FETCH NEXT FROM OrgList Into @cursor_OrgID
END

CLOSE OrgList
DEALLOCATE OrgList


' 
END
GO


/****** Object:  StoredProcedure [dbo].[prcUserLessonStatus_Update_TRIGGER]    Script Date: 12/19/2012 15:23:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_TRIGGER]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

create Procedure [prcUserLessonStatus_Update_TRIGGER]
AS
Set Nocount On


declare @cursor_OrgID	    int

DECLARE OrgList CURSOR
FOR
SELECT OrganisationID from tblOrganisation order by OrganisationID desc

Open OrgList

FETCH NEXT FROM OrgList
Into
@cursor_OrgID

WHILE @@FETCH_STATUS = 0
BEGIN

exec prcUserLessonStatus_Update_TRIGGER_Quick @cursor_OrgID

FETCH NEXT FROM OrgList Into @cursor_OrgID
END

CLOSE OrgList
DEALLOCATE OrgList


' 
END
GO


/****** Object:  StoredProcedure [dbo].[prcUserLessonStatus_Update_TRIGGER_Quick]    Script Date: 12/19/2012 15:23:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_TRIGGER_Quick]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/* Summary:
Update lesson status for each user
This schedule task only updates three status:
Unassigned Modules (0)
New Assigned Modules (Not Started(1))
Expired Modules (Time Elapsed)(4)

Returns:

Called By:

Calls:
Nothing

Remarks:
This is a schedule job running every night to check there are any changes in the user lesson status based on current compliance rules.
If they are the same as the current status, ignore it, otherwise a new status will be created.

If a module is assigned to a user, and there is no activity for this module, the status will be  ''''Not started''''.
If a module is unassigned from a user, the status will be ''''unassinged"(There are records in status table, but the module is not assigned to this user now)
If a module is set to inactive, the status will be ''''unassinged''''

------------ Decision Processes -------------

1. Get CurrentAssignedModules and PreviousAssignedModules
1.1  CurrentAssignedModules
Get all modules that are currently assigned to each users
and compliance rules

1.2  PreviousAssignedModules
Get a list of modules that is in the lesson status table that the last statuses are not Unassigned (0)

2. Add New lesson status
2.1. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)

2.2. New Assigned Modules (Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)

2.3. Expired Modules (Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson date/frequency, the new status is Expired (Time Expired)(4)



------------ Data need to be recorded -------------

LessonFrequency
0  Unassigned:  		-
1  Not Started: 		Y
4  Expired (Time Elapsed): 	Y


Author: Jack Liu
Date Created: 21 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		1/5/2007		Added LessonCompletionDate

prcUserLessonStatus_Update

**/
CREATE Procedure [prcUserLessonStatus_Update_TRIGGER_Quick]
(
@OrgID int	-- comma separated organisationID
)
AS
Set Nocount On

declare @Started DateTime
set @Started = getdate()



--##################################################################################################################
/*
2. Add New lesson status

2.1.     N O T      A S S I G N E D      M O D U L E S
(0) (PreviousAssignedModules - CurrentAssignedModules)
Add record of 0 (unassigned) to tblUserLessonStatus for each User-Module that has been started but now has no Course access or is specifically excluded at unit/user level
*/
--##################################################################################################################
insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID
)
select pam.UserID,
pam.ModuleID,
0  as QuizStatusID --Unassigned (0)
from (select UserID,ModuleID FROM tblUserModuleChange where OrganisationID = @orgID  and ChangeTimeStamp < @Started group by  UserID,ModuleID ) delta INNER JOIN (
		SELECT LessonStatus.UserID, LessonStatus.ModuleID
		FROM  tblUser inner join dbo.tblUserLessonStatus AS LessonStatus on tbluser.UserID = LessonStatus.UserID and tblUser.OrganisationID = @OrgID INNER JOIN
					   dbo.tblModule AS m ON m.ModuleID = LessonStatus.ModuleID INNER JOIN
						   (SELECT MAX(UserLessonStatusID) AS UserLessonStatusID
							FROM   dbo.tblUserLessonStatus
							GROUP BY UserID, ModuleID) AS currentStatus ON LessonStatus.UserLessonStatusID = currentStatus.UserLessonStatusID
		WHERE ((LessonStatus.Excluded = 0) or (LessonStatus.Excluded is null)) AND (LessonStatus.UserLessonStatusID <> 0)
        and 	LessonStatus.LessonStatusID<>0 --not Unassigned (0)
) pam   --   PREVIOUS ASSIGNED MODULES
ON delta.UserID = pam.UserID and delta.ModuleID = pam.ModuleID 

left join (SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL) 
               THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND 
               ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL)) 
               THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
FROM  dbo.tblUser AS tU INNER JOIN
tblUnit on tU.UnitID = tblUnit.UnitID and tblUnit.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
               dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
               dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
               (tUsrMA.Granted = 1)) cam -- Current Assigned Modules
               
on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where cam.moduleID is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)



--##################################################################################################################
/*
2.2.      N E W     A S S I G N E D     M O D U L E S
(Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)
*/
--##################################################################################################################


insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency, 
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
1  as LessonStatusID,--Not Started(1)
cam.LessonFrequency, 
cam.LessonCompletionDate
from (select UserID,ModuleID FROM tblUserModuleChange where OrganisationID = @orgID  and ChangeTimeStamp < @Started group by  UserID,ModuleID ) delta INNER JOIN
(
		SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL) 
               THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND 
               ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL)) 
               THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
		FROM  dbo.tblUser AS tU INNER JOIN
		tblUnit on tU.UnitID = tblUnit.UnitID and tblUnit.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
               dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
               dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
               (tUsrMA.Granted = 1)
 ) cam ON delta.UserID = cam.UserID and delta.ModuleID = cam.ModuleID 
left join 
(
		SELECT LessonStatus.UserID, LessonStatus.ModuleID
		FROM  tblUser inner join dbo.tblUserLessonStatus AS LessonStatus on tbluser.UserID = LessonStatus.UserID and tblUser.OrganisationID = @OrgID INNER JOIN
					   dbo.tblModule AS m ON m.ModuleID = LessonStatus.ModuleID INNER JOIN
						   (SELECT MAX(UserLessonStatusID) AS UserLessonStatusID
							FROM   dbo.tblUserLessonStatus
							GROUP BY UserID, ModuleID) AS currentStatus ON LessonStatus.UserLessonStatusID = currentStatus.UserLessonStatusID
		WHERE ((LessonStatus.Excluded = 0) or (LessonStatus.Excluded is null)) AND (LessonStatus.UserLessonStatusID <> 0)
        and 	LessonStatus.LessonStatusID<>0 --not Unassigned (0)
)  pam
on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where pam.moduleID is null



--##################################################################################################################
/*
2.3.       E X P I R E D    M O D U L E S
 (Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson frequency, the new status is Expired (Time Expired)(4)
*/
--##################################################################################################################




insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency, 
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
4  as LessonStatusID, --(Time Elapsed)(4)
cam.LessonFrequency, cam.LessonCompletionDate
from (
	select 	max(LastStarted.UserLessonStatusID) LastStartedStatusID
	from tblUserLessonStatus LastStarted
	inner join 
	(
		SELECT LessonStatus.UserLessonStatusID, LessonStatus.UserID, LessonStatus.ModuleID, m.CourseID, LessonStatus.LessonStatusID, LessonStatus.LessonFrequency, 
					   LessonStatus.DateCreated
		FROM  dbo.tblUserLessonStatus AS LessonStatus INNER JOIN
					   dbo.tblModule AS m ON m.ModuleID = LessonStatus.ModuleID INNER JOIN
						   (SELECT MAX(UserLessonStatusID) AS UserLessonStatusID
							FROM   dbo.tblUserLessonStatus inner join tblUser on tblUser.UserID = tblUserLessonStatus.UserID and tblUser.OrganisationID = @OrgID 
							GROUP BY tblUserLessonStatus.UserID, ModuleID) AS currentStatus ON LessonStatus.UserLessonStatusID = currentStatus.UserLessonStatusID
		WHERE  (LessonStatus.Excluded = 0) OR (LessonStatus.Excluded IS NULL)
	) CurrentStatus
	on  LastStarted.UserID = CurrentStatus.UserID
	and  LastStarted.ModuleID = CurrentStatus.ModuleID
	and CurrentStatus.LessonStatusID in (2,3)
	where LastStarted.LessonStatusID = 2
	and LastStarted.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
	group by LastStarted.UserID, LastStarted.moduleID
) lss
inner join tblUserLessonStatus uls
on uls.UserLessonStatusID = lss.LastStartedStatusID
inner join (SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL) 
               THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND 
               ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL)) 
               THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
FROM  dbo.tblUser AS tU INNER JOIN
               dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
               dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
               dbo.tblUnit AS u ON u.OrganisationID = tU.OrganisationID and u.UnitID = tU.UnitID INNER JOIN
               dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
               dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
               dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
               (tUsrMA.Granted = 1)) cam
on cam.UserID = uls.UserID
and cam.ModuleID = uls.ModuleID
where
	(
		cam.LessonCompletionDate is null 
		and DateDiff(day,getdate(), dateadd(month, cam.LessonFrequency, uls.DateCreated)) <= 0
	)
	or 
	(
		isnull(DateDiff(day, getdate(), cam.LessonCompletionDate), 1) <= 0
	)
	and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
--Expired





--##################################################################################################################
-- Extend completion dates
	update tblOrganisation 
		set DefaultLessonCompletionDate = dateadd(year, 1, [DefaultLessonCompletionDate])
		where DefaultLessonCompletionDate < getdate() and OrganisationID = @OrgID

--##################################################################################################################
	update tblUnitRule
		set LessonCompletionDate = dateadd(year, 1, [LessonCompletionDate])
		where LessonCompletionDate < getdate() and UnitID IN (select UnitID from tblUnit where OrganisationID = @OrgID)
-- /Extend completion dates
--##################################################################################################################
	
	
	delete from tblUserModuleChange where ChangeTimeStamp < @Started	

SET QUOTED_IDENTIFIER ON 


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserModuleAccess_Validate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Validates that a user has Access to a lesson / quiz
Given User ID
Returns:
int
0 - (false) - indicates user does NOT have access
1 - (true)  - indicates user does have access

Called By: TooolBooLlistner.aspx
Calls:

Remarks:
Given the Module ID and UserID this proc returns true or false
Both paramaters are manditory
Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Jack Liu	23/02/2004		Get module access from view


prcUserModuleAccess_Validate @UserID = 11, @ModuleID = 1

**/

CREATE    PROC [prcUserModuleAccess_Validate]
(
@UserID int, -- the user ID
@ModuleID int-- the Module ID
)

AS
set nocount on

declare @Ret_Value int
if exists(select ModuleID
from vwUserModuleAccess
where UserID=@UserID
and ModuleID = @ModuleID)
Begin
set @Ret_Value = 1
end
else
Begin
set @Ret_Value = 0
End


Select @Ret_Value
Return




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_FIX]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE   Procedure [prcUserQuizStatus_FIX]
(
@orgID int
)
AS
Set Nocount On

/*
1.1  Get all modules that are currently assigned to each users (CurrentAssignedModules)
and current compliance rules
*/

select
um.UserID,
um.ModuleID,
umr.QuizFrequency,
umr.QuizPassMark
into
#tblCurrentAssignedModules
from
vwUserModuleAccess um
inner join
vwUnitModuleRule umr
on
umr.ModuleID  = um.ModuleID
and umr.UnitID = um.UnitID
where
um.OrganisationID = @orgID

/*
1.2. Get the last quiz activity for each user and module pair (StartedModules)
*/

select
um.userID,
um.moduleID,
q.active,
qs.QuizScore,
qs.QuizSessionID,
dbo.udfUTCtoDaylightSavingTime(qs.DateTimeCompleted, @orgID)
into
#tblStartedModules
from
#tblCurrentAssignedModules um
inner join
(
select
um.userID, um.moduleID, max(dbo.udfUTCtoDaylightSavingTime(DateTimeCompleted, @orgID))  as DateTimeCompleted
from
#tblCurrentAssignedModules um
inner join tblQuiz q
on q.ModuleID = um.ModuleID
inner join tblQuizSession qs
on
qs.QuizID=	q.quizID
and qs.userID = um.userID
and qs.DateTimeCompleted is not null
group by um.userID, um.moduleID
)
as LastQuizDate

on
LastQuizDate.userID = um.userID
and LastQuizDate.ModuleID = um.ModuleID

inner join tblQuiz q
on
q.ModuleID = um.ModuleID
inner join tblQuizSession qs
on
qs.QuizID=	q.quizID
and qs.userID = um.userID
and qs.DateTimeCompleted  = LastQuizDate.DateTimeCompleted

/*
1.3. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)
a) Get a list of modules that is in the quiz status table that the last statuses are not Unassigned (0)(PreviousAssignedModules)
b) Get rid off all modules that are currently assigned to the users (from step 1)
c)All modules left are Unassigned(0)
*/
--1. Get Current User Quiz status
CREATE TABLE #tblCurrentUserQuizStatus
(
UserID int NOT NULL ,
ModuleID int NOT NULL ,
QuizStatusID int not NULL ,
QuizFrequency int NULL ,
QuizPassMark int NULL ,
QuizScore int NULL,
QuizSessionID uniqueidentifier NULL
)

/*
1.5. Started Modules
a)If the last quiz is inactive, the status is Expired (New Content)(5)
b)If the last quiz is past the current quiz frequency, the status is Expired (Time Expired)(4)
c)If the last quiz is during the current quiz frequency, get the current pass mark, and check the quiz status
If user Failed the quiz, the status is Failed (3)
If user Passed the quiz, the status is Passed (2)
*/

-- a)If the last quiz is inactive, the status is Expired (New Content)(5)


insert into #tblCurrentUserQuizStatus
(
UserID,
ModuleID,
QuizStatusID,
QuizFrequency,
QuizPassMark
)
select
cam.UserID,
cam.ModuleID,
5  as QuizStatusID, --  Expired (New Content)(5)
cam.QuizFrequency,
cam.QuizPassMark
from
#tblCurrentAssignedModules cam
inner join
#tblStartedModules sm
on
sm.UserID = cam.UserID
and sm.ModuleID = cam.ModuleID
where
sm.active=0 --Inactive

-- select * from #tblCurrentUserQuizStatus order by userID

/*
2. Update User Quiz status
----------------------------
If the last quiz status for each user is not the same as the current status, add the new status
*/




declare @cursor_UserID 	        int
declare @cursor_ModuleID 	    int
declare @cursor_QuizStatusID 	int
declare @cursor_QuizFrequency 	int
declare @cursor_QuizPassMark	int
declare @cursor_QuizScore	    int
declare @cursor_QuizSessionID   varchar(50)
declare @cursor_UserQuizStatusID int
declare @int_rc int

DECLARE CurrentUserQuizStatus CURSOR
FOR


select
cs.UserID,
cs.ModuleID,
cs.QuizStatusID,
cs.QuizFrequency,
cs.QuizPassMark,
cs.QuizScore,
cs.QuizSessionID,
s.UserQuizStatusID
from
#tblCurrentUserQuizStatus cs
left join vwUserQuizStatus s
on cs.userID = s.UserID
and cs.ModuleID = s.ModuleID
and cs.QuizStatusID = s.QuizStatusID

Open CurrentUserQuizStatus

-- First Read testreportCursor
FETCH NEXT FROM CurrentUserQuizStatus
Into
@cursor_UserID,@cursor_ModuleID,@cursor_QuizStatusID,@cursor_QuizFrequency,
@cursor_QuizPassMark,@cursor_QuizScore,@cursor_QuizSessionID, @cursor_UserQuizStatusID

WHILE @@FETCH_STATUS = 0
BEGIN

--new user quiz status records

-- Eisting user quiz status records
EXEC prcUserQuizStatus_UpdateCourseStatus @cursor_UserID, @cursor_ModuleID

FETCH NEXT FROM CurrentUserQuizStatus
Into
@cursor_UserID,@cursor_ModuleID,@cursor_QuizStatusID,@cursor_QuizFrequency,
@cursor_QuizPassMark,@cursor_QuizScore,@cursor_QuizSessionID,@cursor_UserQuizStatusID
END
-- Finished CurrentUserQuizStatus
CLOSE CurrentUserQuizStatus
DEALLOCATE CurrentUserQuizStatus

drop table  #tblCurrentUserQuizStatus

drop table #tblCurrentAssignedModules

drop table #tblStartedModules

' 
END
GO


/****** Object:  StoredProcedure [dbo].[prcUserQuizStatus_InsertExpiry]    Script Date: 12/19/2012 15:23:41 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_InsertExpiry]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE PROCEDURE [prcUserQuizStatus_InsertExpiry]
(
@UserID int
, @ModuleID int
,@OrganisationID int
)
AS
SET nocount ON
insert tblExpiredNewContent (ModuleID,OrganisationID,UserID)
values (@ModuleID ,@OrganisationID,@UserID)

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*

CALLS prcUserQuizStatus_Update_Quick

**/
CREATE   Procedure [prcUserQuizStatus_Update]
AS
Set Nocount On
declare @intHistoryID int

insert into tblModuleStatusUpdateHistory(startTime) values(getutcdate());
set @intHistoryID = @@identity


declare @cursor_OrgID	    int

DECLARE OrgList CURSOR
FOR
SELECT OrganisationID
from tblOrganisation
WHERE DATEDIFF (d,CourseStatusLastUpdated,dbo.udfUTCtoDaylightSavingTime(getutcdate(),OrganisationID)) > 0
order by OrganisationID desc

Open OrgList

FETCH NEXT FROM OrgList
Into
@cursor_OrgID

WHILE @@FETCH_STATUS = 0
BEGIN

exec prcUserQuizStatus_Update_Quick @cursor_OrgID
exec prcUserLessonStatus_Update_Quick @cursor_OrgID
print ''Completed Organisation: '' + Cast(@cursor_OrgID as varchar)

FETCH NEXT FROM OrgList Into @cursor_OrgID
END

CLOSE OrgList
DEALLOCATE OrgList



update tblModuleStatusUpdateHistory
set FinishTime = getutcdate()
where ModuleStatusUpdateHistoryID = @intHistoryID
' 
END
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_UpdateCourseStatus]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserQuizStatus_UpdateCourseStatus]
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_UpdateCourseStatus]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
for the record just in the tblUserQuizStatus:
-- get the old course status in tblUserCourseStatus
-- calculate the new course status
-- insert new course status into tblUserCourseStatus if old and new course status are different

called by:
prcUserQuizStatus_Update

Author: Li Zhang
Date Created: 24-10-2006
*/

CREATE PROCEDURE [prcUserQuizStatus_UpdateCourseStatus]
(
@UserID int
, @ModuleID int
)
AS
SET nocount ON
--SET xact_abort ON

DECLARE @intOldCourseStatus int
DECLARE @intNewCourseStatus int
DECLARE @intCourseID int

SET @intCourseID = (select CourseID from tblModule where ModuleID = @ModuleID)
DECLARE @Err integer
EXEC @intOldCourseStatus = prcUserCourseStatus_GetStatus @intCourseID, @UserID
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_UpdateCourseStatus'',''prcUserCourseStatus_GetStatus'',''UserID=''+CAST(@UserID AS varchar(10)),CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) END

IF @Err = 0
BEGIN
EXEC @intNewCourseStatus = prcUserCourseStatus_Calculate @intCourseID, @UserID
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_UpdateCourseStatus'',''prcUserCourseStatus_Calculate'',''UserID=''+CAST(@UserID AS varchar(10)),CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) END

IF @Err = 0
BEGIN
IF (@intOldCourseStatus = -1) or (@intOldCourseStatus <> @intNewCourseStatus)
BEGIN
EXEC prcUserCourseStatus_Insert @UserID, @ModuleID, @intNewCourseStatus
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_UpdateCourseStatus'',''prcUserCourseStatus_Insert'',''UserID=''+CAST(@UserID AS varchar(10)),CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) END

END
ELSE
BEGIN
IF NOT EXISTS (
Select
tU.UserID
From
dbo.tblUser tU
--< get the courses a user has access to >--
Inner Join dbo.tblOrganisationCourseAccess tOCA
On  tOCA.OrganisationID = tU.OrganisationID
--< get the course details >--
Inner join dbo.tblCourse tC
On tC.CourseID = tOCA.GrantedCourseID
--< get the Active modules in a course >--
inner join dbo.tblModule tM
On tM.CourseID = tC.CourseID
and tM.Active = 1
--< get the details on which moduels a user is configured to access >--
Left Outer join dbo.tblUserModuleAccess tUsrMA
On  tUsrMA.UserID = tU.UserID
And tUsrMA.ModuleID = tM.ModuleID
--< get the details on which moduels a user''s Unit is excluded from  >--
Left Outer Join dbo.tblUnitModuleAccess tUnitMA
On  tUnitMA.UnitID = tU.UnitID
And tUnitMA.DeniedModuleID = tM.ModuleID
Where
tC.CourseID = @intCourseID AND tU.UserID = @UserID AND
tU.Active = 1
--< Active users only >--
and tu.UnitID is not null
--< Get the modules that the user''s Unit is not denied >--
and (tUnitMA.DeniedModuleID  is null
--<  and the user does not have special access to  it>--
And tUsrMA.ModuleID is null)
--< or Get modules that the user has been specially  granted
or tUsrMA.Granted=1
)
AND EXISTS (SELECT UserCourseStatusID FROM tblUserCourseStatus WHERE UserID = @UserID AND CourseID = @intCourseID AND CourseStatusID <> 0)
BEGIN
EXEC prcUserCourseStatus_Insert @UserID, @ModuleID, @StatusID = 0
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_UpdateCourseStatus'',''prcUserCourseStatus_Insert'',''UserID=''+CAST(@UserID AS varchar(10)),CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) END
IF (@intOldCourseStatus <> 1) and ( @intNewCourseStatus = 1)
BEGIN
UPDATE   tblUserCourseDetails
SET  LastDelinquencyNotification = null, LastDelNoteToMgr = 0, NumberOfDelinquencyNotifications = 0
WHERE UserID = @UserID AND CourseID = @intCourseID
END
END
END
END
END

' 
END
GO




SET ANSI_NULLS ON 
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_Update_Quick]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/* Summary:
Update quiz status for each user

Returns:

Called By:

Calls:
Nothing

Remarks:
This is a schedule job running every night to check there are any changes in the user quiz status based on current compliance rules.
If they are the same as the current status, ignore it, otherwise a new status will be created.

If a module is assigned to a user, and there is no activity for this module, the status will be  ''Not started''.
If a module is unassigned from a user, the status will be ''unassinged"(There are records in status table, but the module is not assigned to this user now)
If a module is set to inactive, the status will be ''unassinged''

All user-module pair need to be re-evaluated, as compliance rules may be changed since the user''s last toolbook activity.

------------ Decision Processes -------------

1. Get Current User Quiz status
-----------------------------------
1.1  Get all modules that are currently assigned to each users (CurrentAssignedModules)
and compliance rules

1.2. Get the last quiz activity for each user and module pair (StartedModules)

1.3. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)
a) Get a list of modules that is in the quiz status table that the last statuses are not Unassigned (0)(PreviousAssignedModules)
b) Get rid off all modules that are currently assigned to the users (from step 1)
c)All modules left are Unassigned(0)

1.4. Not Started Modules (1) (CurrentAssignedModules- StartedModules)
All currently assigned modules that don''t have any activity is Not Started (1)

1.5. Started Modules
a)If the last quiz is inactive, the status is Expired (New Content)(5)
b)If the last quiz is past the current quiz date/frequency, the status is Expired (Time Expired)(4)
c)If the last quiz is during the current quiz frequency, get the current pass mark, and check the quiz status
If user Failed the quiz, the status is Failed (3)
If user Passed the quiz, the status is Passed (2)

2. Update User Quiz status
----------------------------
If the last quiz status for each user is not the same as the current status, add the new status



------------ Data need to be recorded -------------

QuizFrequency	QuizPassMark	QuizScore
0  Unassigned:  		-		-		-
1  Not Started: 		Y		Y		-
2  Passed: 	 		Y		Y		Y
3  Failed: 	 		Y		Y		Y
4  Expired (Time Elapsed): 	Y		Y		-
5  Expired (New Content): 	Y		Y		-


Author: Jack Liu
Date Created: 20 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		1/5/2007		Added logic for new fields LessonCompletionStatus & QuizCompletionStatus
#2	mikev		9/5/2007		Added course completion logic. If a module is marked active or not active; to calculate if the course is complete.
#3	Mark Donald	21/9/2009		Added OrganisationName (control character) to License Warning emails
  Chris Plewright  21/11/2013   fixed for incorrect for No of Post Expiry notifications being sent.
   
prcUserQuizStatus_Update_Quick

**/
CREATE   Procedure [dbo].[prcUserQuizStatus_Update_Quick]
(
@OrgID int	-- comma separated organisationID
)
AS
Set Nocount On
declare @intHistoryID int

insert into tblModuleStatusUpdateHistory(startTime) values(getUTCdate());
set @intHistoryID = @@identity

--1. Get Current User Quiz status
--mikev : added QuizCompletionDate
/* UNITTEST: CurrentAssignedModules */
CREATE TABLE #tblCurrentUserQuizStatus
(
UserID int NOT NULL ,
ModuleID int NOT NULL ,
QuizStatusID int not NULL ,
QuizFrequency int NULL ,
QuizPassMark int NULL ,
QuizCompletionDate DateTime NULL,
QuizScore int NULL,
QuizSessionID uniqueidentifier NULL
)


/*
1.1  Get all modules that are currently assigned to each users (CurrentAssignedModules)
and current compliance rules
*/
-- mikev(1): added completion date

select
um.UserID,
um.ModuleID,
umr.QuizFrequency,
umr.QuizPassMark,
umr.QuizCompletionDate
into
#tblCurrentAssignedModules
from
(
Select
tU.UserID
, tU.UnitID
, tU.OrganisationID
, tM.ModuleID


From
dbo.tblUser tU
--< get the courses a user has access to >--
Inner Join dbo.tblOrganisationCourseAccess tOCA
On  tOCA.OrganisationID = tU.OrganisationID
--< get the course details >--
Inner join dbo.tblCourse tC
On tC.CourseID = tOCA.GrantedCourseID
--< get the Active modules in a course >--
inner join dbo.tblModule tM
On tM.CourseID = tC.CourseID
and tM.Active = 1
--< get the details on which moduels a user is configured to access >--
Left Outer join dbo.tblUserModuleAccess tUsrMA
On  tUsrMA.UserID = tU.UserID
And tUsrMA.ModuleID = tM.ModuleID
--< get the details on which moduels a user''s Unit is excluded from  >--
Left Outer Join dbo.tblUnitModuleAccess tUnitMA
On  tUnitMA.UnitID = tU.UnitID
And tUnitMA.DeniedModuleID = tM.ModuleID
Where
tU.OrganisationID = @OrgID AND
tU.Active = 1
--< Active users only >--
and tu.UnitID is not null
--< Get the modules that the user''s Unit is not denied >--
and (tUnitMA.DeniedModuleID  is null
--<  and the user does not have special access to  it>--
And tUsrMA.ModuleID is null)
--< or Get modules that the user has been specially  granted
or tUsrMA.Granted=1
) um
inner join
(
Select 	u.UnitID,
m.CourseID,
m.ModuleID,
case
when ur.unitID is null then cast(1 as bit)
else cast(0 as bit)
end as UsingDefault,
case
when (ur.LessonFrequency is null and ur.LessonCompletionDate is null and o.DefaultLessonCompletionDate is null) then
o.DefaultLessonFrequency
else
ur.LessonFrequency
end
as LessonFrequency,
case
when (ur.QuizFrequency is null and ur.QuizCompletionDate is null and o.DefaultQuizCompletionDate is null) then
o.DefaultQuizFrequency
else
ur.QuizFrequency
end
as QuizFrequency,
isNull(ur.QuizPassMark, o.DefaultQuizPassMark) as QuizPassMark,
case
when (ur.LessonFrequency is null and ur.LessonCompletionDate is null and not(o.DefaultLessonCompletionDate is null)) then
o.DefaultLessonCompletionDate
else
ur.LessonCompletionDate
end
as LessonCompletionDate,
case
when (ur.QuizFrequency is null and ur.QuizCompletionDate is null and not(o.DefaultQuizCompletionDate is null)) then
o.DefaultQuizCompletionDate
else
ur.QuizCompletionDate
end
as QuizCompletionDate
From tblOrganisationCourseAccess c
inner join tblModule m
on m.CourseID = c.GrantedCourseID
inner join tblOrganisation o  -- Get default compliance rules
on o.OrganisationID = c.OrganisationID
inner join tblUnit u
on u.OrganisationID = c.OrganisationID
left join tblUnitRule ur --Get the unit specific rules
on ur.ModuleID = m.ModuleID
and ur.UnitID=u.unitID
WHERE o.OrganisationID = @OrgID
) umr
on
umr.ModuleID  = um.ModuleID
and umr.UnitID = um.UnitID
and um.UnitID in (select UnitID from tblUnit where OrganisationID = @OrgID)
and um.UserID IN (select UserID from tblUser where OrganisationID = @OrgID)
/* /UNITTEST: CurrentAssignedModules */

-- select * from #tblCurrentAssignedModules
/*
1.2. Get the last quiz activity for each user and module pair (StartedModules)
*/
/* UNITTEST: StartedModules */
select
um.userID,
um.moduleID,
q.active,
qs.QuizScore,
qs.QuizSessionID,
qs.DateTimeCompleted
into
#tblStartedModules
from
#tblCurrentAssignedModules um
inner join
(
select
um.userID, um.moduleID, max(DateTimeCompleted)  as DateTimeCompleted
from
#tblCurrentAssignedModules um
inner join tblQuiz q
on q.ModuleID = um.ModuleID
inner join tblQuizSession qs
on
qs.QuizID=	q.quizID
and qs.userID = um.userID
and qs.DateTimeCompleted is not null
group by um.userID, um.moduleID
)
as LastQuizDate

on
LastQuizDate.userID = um.userID
and LastQuizDate.ModuleID = um.ModuleID

inner join tblQuiz q
on
q.ModuleID = um.ModuleID
inner join tblQuizSession qs
on
qs.QuizID=	q.quizID
and qs.userID = um.userID
and qs.DateTimeCompleted  = LastQuizDate.DateTimeCompleted
/* /UNITTEST: StartedModules */


-- select * from #tblStartedModules

/*
1.3. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)
a) Get a list of modules that is in the quiz status table that the last statuses are not Unassigned (0)(PreviousAssignedModules)
b) Get rid off all modules that are currently assigned to the users (from step 1)
c)All modules left are Unassigned(0)
*/

/* UNITTEST: Status_Unassigned */
insert into #tblCurrentUserQuizStatus
(
UserID,
ModuleID,
QuizStatusID
)
select
uqs.UserID,
uqs.ModuleID,
0  as QuizStatusID --Unassigned (0)
from
(
select
QuizStatus.UserQuizStatusID
, QuizStatus.UserID
, QuizStatus.ModuleID
, m.CourseID
, QuizStatus.QuizStatusID
, QuizStatus.QuizFrequency
, QuizStatus.QuizPassMark
, QuizStatus.QuizSessionID
, QuizStatus.QuizScore
, QuizStatus.DateCreated

from
tblUserQuizStatus QuizStatus
inner join tblModule m on m.ModuleID = QuizStatus.ModuleID
inner join
(
select
max(UserQuizStatusID) UserQuizStatusID --UserQuizStatusID is identity
from
tblUserQuizStatus
WHERE
tblUserQuizStatus.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
group by
UserID,moduleID
) currentStatus
on QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
where m.active = 1
) uqs
left join
#tblCurrentAssignedModules cam
on
cam.UserID = uqs.UserID
and cam.ModuleID = uqs.ModuleID
where
uqs.QuizStatusID<>0 --not Unassigned (0)
and cam.moduleID is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
/* /UNITTEST: Status_Unassigned */

/*
1.4. Not Started Modules (1) (CurrentAssignedModules- StartedModules)
All currently assigned modules that don''t have any activity is Not Started (1)
*/
-- mikev(1): added QuizCompletionDate
/* UNITTEST: Status_NotStarted */
insert into
#tblCurrentUserQuizStatus
(
UserID,
ModuleID,
QuizStatusID,
QuizFrequency,
QuizPassMark,
QuizCompletionDate
)
select
cam.UserID,
cam.ModuleID,
1  as QuizStatusID, --Not Started (1)
cam.QuizFrequency,
cam.QuizPassMark,
cam.QuizCompletionDate
from
#tblCurrentAssignedModules cam
left join
#tblStartedModules sm
on
sm.UserID = cam.UserID
and sm.ModuleID = cam.ModuleID
where
sm.moduleID is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
/* /UNITTEST: Status_NotStarted */
/*
EXPIRED NEW CONTENT IS NOW A MANUAL PROCESS
1.5. Started Modules
a)If the last quiz is inactive, the status is Expired (New Content)(5)
b)If the last quiz is past the current quiz frequency, the status is Expired (Time Expired)(4)
c)If the last quiz is during the current quiz frequency, get the current pass mark, and check the quiz status
If user Failed the quiz, the status is Failed (3)
If user Passed the quiz, the status is Passed (2)
*/

--	  	a)If the last quiz is inactive, the status is Expired (New Content)(5)


--		b)If the last quiz is past the current quiz frequency, the status is Expired (Time Expired)(4)
-- mikev(1): added QuizCompletionDate. Added criteria
/* UNITTEST: Status_TimeExpired */
insert into #tblCurrentUserQuizStatus
(
UserID,
ModuleID,
QuizStatusID,
QuizFrequency,
QuizPassMark,
QuizCompletionDate
)
select cam.UserID,
cam.ModuleID,
4  as QuizStatusID, --  Expired (Time Expired)(4)
cam.QuizFrequency,
cam.QuizPassMark,
cam.QuizCompletionDate
from #tblCurrentAssignedModules cam
inner join #tblStartedModules sm
on sm.UserID = cam.UserID
and sm.ModuleID = cam.ModuleID
where
(
(
cam.QuizCompletionDate is null
and DateDiff(day,dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID), dateadd(month, cam.QuizFrequency, dbo.udfUTCtoDaylightSavingTime(sm.DateTimeCompleted,@OrgID))) <= 0
)
or
(
isnull(DateDiff(day, getutcdate(), cam.QuizCompletionDate), 1) <= 0
)
)
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
/* /UNITTEST: Status_TimeExpired */

--		c)If the last quiz is during the current quiz frequency, get the current pass mark, and check the quiz status
--			If user Failed the quiz, the status is Failed (3)
--			If user Passed the quiz, the status is Passed (2)

-- mikev(1): added QuizCompletionDate and changed logic of criteria to use the date before the frequency
/* UNITTEST: Status_PassFail */
insert into #tblCurrentUserQuizStatus
(
UserID,
ModuleID,
QuizStatusID,
QuizFrequency,
QuizPassMark,
QuizCompletionDate,
QuizScore,
QuizSessionID
)
select cam.UserID,
cam.ModuleID,
case
when sm.QuizScore>=cam.QuizPassMark then 2 -- Passed (2)
else	3  --Failed (3)
end  as QuizStatusID,
cam.QuizFrequency,
cam.QuizPassMark,
cam.QuizCompletionDate,
sm.QuizScore,
sm.QuizSessionID
from #tblCurrentAssignedModules cam
inner join #tblStartedModules sm
on sm.UserID = cam.UserID
and sm.ModuleID = cam.ModuleID
where
not (
cam.QuizCompletionDate is null
and DateDiff(day,dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID), dateadd(month, cam.QuizFrequency, dbo.udfUTCtoDaylightSavingTime(sm.DateTimeCompleted,@OrgID))) <= 0
)
and cam.QuizCompletionDate is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
and (select top 1 QuizStatusID from tblUserQuizStatus where ModuleID = cam.ModuleID and UserID = cam.UserID order by UserQuizStatusID Desc) NOT IN (5)

/* /UNITTEST: Status_PassFail */
/*
2. Update User Quiz status
----------------------------
If the last quiz status for each user is not the same as the current status, add the new status
*/


/* UNITTEST: CourseStatus */
-- mikev(1): added cursor for quizcompletiondate
declare @cursor_UserID 	        int
declare @cursor_ModuleID 	    int
declare @cursor_QuizStatusID 	int
declare @cursor_QuizFrequency 	int
declare @cursor_QuizPassMark	int
declare @cursor_QuizCompletionDate	DateTime
declare @cursor_QuizScore	    int
declare @cursor_QuizSessionID   varchar(50)
declare @cursor_UserQuizStatusID int

-- mikev(1): added quizcompletiondate
declare @LastUser int
declare @LastModuleID int
declare @LastCourse int
declare @LastQuizStatusID int
declare @cursor_CourseID int
set @LastUser = -1
set @LastCourse = -1
set @LastQuizStatusID = -1
set  @LastModuleID = 0
DECLARE CurrentUserQuizStatus CURSOR
FOR


select
cs.UserID,
cs.ModuleID,
cs.QuizStatusID,
cs.QuizFrequency,
cs.QuizPassMark,
cs.QuizCompletionDate,
cs.QuizScore,
cs.QuizSessionID,
s.UserQuizStatusID,
Module.CourseID
from -- Any UserModules with current access but no tblUserQuizStatus record
#tblCurrentUserQuizStatus cs
inner join tblModule Module on module.moduleID = cs.ModuleID
left join
(  -- The UserModule quiz status for the latest quiz attempt
select
QuizStatus.UserQuizStatusID
, QuizStatus.UserID
, QuizStatus.ModuleID
, m.CourseID
, QuizStatus.QuizStatusID
, QuizStatus.QuizFrequency
, QuizStatus.QuizPassMark
, QuizStatus.QuizSessionID
, QuizStatus.QuizScore
, QuizStatus.DateCreated

from
tblUserQuizStatus QuizStatus
inner join tblModule m on m.ModuleID = QuizStatus.ModuleID
inner join
(
select
max(UserQuizStatusID) UserQuizStatusID --UserQuizStatusID is identity
from
tblUserQuizStatus
WHERE
tblUserQuizStatus.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
group by
UserID,moduleID
) currentStatus
on QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
where m.active = 1
) s
on cs.userID = s.UserID
and cs.ModuleID = s.ModuleID
and cs.QuizStatusID = s.QuizStatusID
where
s.UserQuizStatusID is null
order by cs.UserID,
case when (cs.QuizStatusID = 0) then 6 else cs.QuizStatusID end,
Module.CourseID
-- ordered so we can update course status on the last module in the course rather than for every module in the course

Open CurrentUserQuizStatus

FETCH NEXT FROM CurrentUserQuizStatus
Into
@cursor_UserID,@cursor_ModuleID,@cursor_QuizStatusID,@cursor_QuizFrequency,
@cursor_QuizPassMark,@cursor_QuizCompletionDate,@cursor_QuizScore,@cursor_QuizSessionID, @cursor_UserQuizStatusID, @cursor_CourseID
set @LastCourse = @cursor_CourseID
set @LastUser = @cursor_UserID
set @LastQuizStatusID = @cursor_QuizStatusID
set @LastModuleID = @cursor_ModuleID

DECLARE @Err integer
WHILE @@FETCH_STATUS = 0
BEGIN

insert into tblUserQuizStatus
(
UserID,
ModuleID,
QuizStatusID,
QuizFrequency,
QuizPassMark,
QuizCompletionDate,
QuizScore,
QuizSessionID
)
values
(
@cursor_UserID,
@cursor_ModuleID,
@cursor_QuizStatusID,
@cursor_QuizFrequency,
@cursor_QuizPassMark,
@cursor_QuizCompletionDate,
@cursor_QuizScore,
@cursor_QuizSessionID
)
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''insert into tblUserQuizStatus'',''UserID=''+CAST(@cursor_UserID AS varchar(10)),CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END

-- don''t update the course status for every module in the course - once per course is enough
-- do update the course status on every change in QuizStatus
if (@LastCourse != @cursor_CourseID) or (@LastUser != @cursor_UserID) or (@LastQuizStatusID != @cursor_QuizStatusID) EXEC prcUserQuizStatus_UpdateCourseStatus @LastUser, @LastModuleID

set @LastCourse = @cursor_CourseID
set @LastUser = @cursor_UserID
set @LastQuizStatusID = @cursor_QuizStatusID
set @LastModuleID = @cursor_ModuleID


FETCH NEXT FROM CurrentUserQuizStatus
Into
@cursor_UserID,@cursor_ModuleID,@cursor_QuizStatusID,@cursor_QuizFrequency,
@cursor_QuizPassMark,@cursor_QuizCompletionDate,@cursor_QuizScore,@cursor_QuizSessionID, @cursor_UserQuizStatusID, @cursor_CourseID


END
-- final course may not be done so update just to be safe
if (@LastUser != -1 ) EXEC prcUserQuizStatus_UpdateCourseStatus @cursor_UserID, @cursor_ModuleID
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''prcUserQuizStatus_UpdateCourseStatus'',''prcUserQuizStatus_UpdateCourseStatus'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END

-- Finished CurrentUserQuizStatus
CLOSE CurrentUserQuizStatus
DEALLOCATE CurrentUserQuizStatus




--              AT RISK OF EXPIRY



delete from tblQuizExpiryAtRisk
where OrganisationID = @OrgID   -- delete from ExpiryAtRisk those users who somehow are no longer at risk

and  not exists (
SELECT
@orgid,
QuizStatus.UserID,
QuizStatus.ModuleID ,
case when re.QuizExpiryWarn=0 then -1 else 0 end as preexpiry ,
0 as postexpiry,
case when quizstatus.QuizStatusID = 1 then
dateadd (d,re.daystocompletecourse,QuizStatus.DateCreated)
when QuizStatus.QuizStatusID>1 then
(
case when coalesce(ur.quizcompletiondate,o.DefaultQuizCompletionDate)  is not null then
coalesce(ur.quizcompletiondate,o.DefaultQuizCompletionDate)
else
DATEADD(M,coalesce(ur.quizfrequency,o.DefaultQuizFrequency),QuizStatus.DateCreated)
end
)
end
as expiry
FROM
tblUserQuizStatus AS QuizStatus
INNER JOIN dbo.tblModule AS m ON m.ModuleID = QuizStatus.ModuleID
INNER JOIN(SELECT     MAX(UserQuizStatusID) AS UserQuizStatusID,ModuleID,uqs.UserID
FROM          dbo.tblUserQuizStatus uqs
join tblUser u on u.UserID = uqs.UserID and u.OrganisationID = @orgid and u.Active = 1
GROUP BY ModuleID,uqs.UserID ) AS currentStatus ON QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID and currentStatus.ModuleID = m.ModuleID
join tblUser u on u.UserID =QuizStatus.UserID
join tblOrganisation o on o.OrganisationID = u.OrganisationID and o.OrganisationID = @orgid
join tblReminderEscalation re on m.CourseID = re.CourseId and re.OrgId = o.OrganisationID and re.DateEnabled<GETUTCDATE()
join vwUserModuleAccess uma on uma.UserID = u.UserID and uma.ModuleID = m.ModuleID
left join tblUnit unit on unit.UnitID = u.UnitID
left join tblUnitRule ur on ur.UnitID = u.UnitID and ur.ModuleID = m.ModuleID
WHERE     (m.Active = 1)
and
(
-- pre expiry initial enrolment
(
quizexpirywarn = 1  and
(RemindUsers = 1 and re.PreExpInitEnrolment = 1 and quizstatus.QuizStatusID = 1 and DATEDIFF (D,getutcdate(),(dateadd (d,re.daystocompletecourse,QuizStatus.DateCreated)))<=re.DaysQuizExpiry
or
--enable				--resit period reminder
(PreExpResitPeriod = 1	and QuizStatus.QuizStatusID>1 and
-- pre expiry resit period
(dateadd(M,case when coalesce(ur.quizfrequency ,o.DefaultQuizFrequency) = 0 then 99 else coalesce(ur.quizfrequency ,o.DefaultQuizFrequency) end , dateadd(d,-re.DaysQuizExpiry,  QuizStatus.DateCreated))<=GETDATE())
or
-- pre expiry resit period date
(DATEADD(yy,1,quizstatus.DateCreated)<= coalesce(ur.quizcompletiondate,o.DefaultQuizCompletionDate) and DATEADD(D,-re.DaysQuizExpiry,coalesce(ur.quizcompletiondate,o.DefaultQuizCompletionDate))<= getutcdate())
)
)
)
or
(
re.PostExpReminder = 1 and
-- post expiry initial reminder
(
(
RemindUsers = 1 and re.PostExpInitEnrolment = 1 and QuizStatus.QuizStatusID = 1 and (dateadd (d,re.daystocompletecourse,QuizStatus.DateCreated))<=GETUTCDATE()
)
or
-- post expiry resit period
(
re.PostExpResitPeriod = 1  and QuizStatus.QuizStatusID >1 and
(
-- post expiry resit period
(dateadd(M,case when coalesce(ur.quizfrequency ,o.DefaultQuizFrequency)= 0 then 99 else coalesce(ur.quizfrequency ,o.DefaultQuizFrequency) end , QuizStatus.DateCreated)<=GETDATE())
or
-- post expiry resit date
(DATEADD(Y,1,quizstatus.DateCreated)<= coalesce(ur.quizcompletiondate,o.DefaultQuizCompletionDate) and (coalesce(ur.quizcompletiondate,o.DefaultQuizCompletionDate)<= getutcdate() or DATEDIFF(MONTH,coalesce(ur.quizcompletiondate,o.DefaultQuizCompletionDate),QuizStatus.DateCreated)>12)) -- need to double check this in testing
)
)
)
)
)
)

SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''delete from tblQuizExpiryAtRisk'',''delete from tblQuizExpiryAtRisk'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END


insert into tblQuizExpiryAtRisk -- add users that are now AtRisk that were not already flagged as AtRisk
(
OrganisationID,
UserID,
ModuleID,
PreExpiryNotified,
ExpiryNotifications,
expirydate
)

SELECT
@orgid,
QuizStatus.UserID,
QuizStatus.ModuleID ,
case when re.QuizExpiryWarn=0 then -1 else 0 end as preexpiry ,
0 as postexpiry,
case when quizstatus.QuizStatusID = 1 then
dateadd (d,re.daystocompletecourse,QuizStatus.DateCreated)
when QuizStatus.QuizStatusID>1 then
(
case when coalesce(ur.quizcompletiondate,o.DefaultQuizCompletionDate)  is not null then
coalesce(ur.quizcompletiondate,o.DefaultQuizCompletionDate)
else
DATEADD(M,coalesce(ur.quizfrequency,o.DefaultQuizFrequency),QuizStatus.DateCreated)
end
)
end
as expiry
FROM
tblUserQuizStatus AS QuizStatus
INNER JOIN dbo.tblModule AS m ON m.ModuleID = QuizStatus.ModuleID
INNER JOIN(SELECT     MAX(UserQuizStatusID) AS UserQuizStatusID,ModuleID,uqs.UserID
FROM          dbo.tblUserQuizStatus uqs
join tblUser u on u.UserID = uqs.UserID and u.OrganisationID = @orgid and u.Active = 1
GROUP BY ModuleID,uqs.UserID ) AS currentStatus ON QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID and currentStatus.ModuleID = m.ModuleID
join tblUser u on u.UserID =QuizStatus.UserID
join tblOrganisation o on o.OrganisationID = u.OrganisationID and o.OrganisationID = @orgid
join tblReminderEscalation re on m.CourseID = re.CourseId and re.OrgId = o.OrganisationID and re.DateEnabled<GETUTCDATE()
join vwUserModuleAccess uma on uma.UserID = u.UserID and uma.ModuleID = m.ModuleID
left join tblUnit unit on unit.UnitID = u.UnitID
left join tblUnitRule ur on ur.UnitID = u.UnitID and ur.ModuleID = m.ModuleID
WHERE     (m.Active = 1)
--/*
and
(
-- pre expiry initial enrolment
(
quizexpirywarn = 1  and
(RemindUsers = 1 and re.PreExpInitEnrolment = 1 and quizstatus.QuizStatusID = 1 and DATEDIFF (D,getutcdate(),(dateadd (d,re.daystocompletecourse,QuizStatus.DateCreated)))<=re.DaysQuizExpiry
or
--enable				--resit period reminder
(PreExpResitPeriod = 1	and QuizStatus.QuizStatusID>1 and
-- pre expiry resit period
(dateadd(M,case when coalesce(ur.quizfrequency ,o.DefaultQuizFrequency) = 0 then 99 else coalesce(ur.quizfrequency,o.DefaultQuizFrequency) end , dateadd(d,-re.DaysQuizExpiry,  QuizStatus.DateCreated))<=GETUTCDATE())
or
-- pre expiry resit period date
(DATEADD(yy,1,quizstatus.DateCreated)<= coalesce(ur.quizcompletiondate,o.DefaultQuizCompletionDate) and DATEADD(D,-re.DaysQuizExpiry,coalesce(ur.quizcompletiondate,o.DefaultQuizCompletionDate))<= getutcdate())
)
)
)
or
(
re.PostExpReminder = 1 and
-- post expiry initial reminder
(
(
RemindUsers = 1 and re.PostExpInitEnrolment = 1 and QuizStatus.QuizStatusID = 1 and (dateadd (d,re.daystocompletecourse,QuizStatus.DateCreated))<=GETUTCDATE()
)
or
-- post expiry resit period
(
re.PostExpResitPeriod = 1  and QuizStatus.QuizStatusID >1 and
(
-- post expiry resit period
(dateadd(M,case when coalesce(ur.quizfrequency, o.DefaultQuizFrequency) = 0 then 99 else coalesce(ur.quizfrequency,o.DefaultQuizFrequency) end , QuizStatus.DateCreated)<=GETDATE())
or
-- post expiry resit date
(DATEADD(Y,1,quizstatus.DateCreated)<= coalesce(ur.quizcompletiondate,o.DefaultQuizCompletionDate) and coalesce(ur.quizcompletiondate,o.DefaultQuizCompletionDate)<= getutcdate())
)
)
)
)
)

and not exists
(SELECT * FROM tblQuizExpiryAtRisk
where 	tblQuizExpiryAtRisk.UserID = QuizStatus.UserID
and tblQuizExpiryAtRisk.ModuleID = QuizStatus.ModuleID
and tblQuizExpiryAtRisk.OrganisationID = @OrgID)



delete from tblQuizExpiryAtRisk
from tblOrganisation o
join tblQuizExpiryAtRisk ar on ar.OrganisationID = o.OrganisationID
join tblModule m on m.ModuleID = ar.ModuleID
join tblReminderEscalation re on re.CourseId = m.CourseID and ar.OrganisationID = re.OrgId
where re.DateEnabled>ar.ExpiryDate and o.OrganisationID = @OrgID


SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''insert into tblQuizExpiryAtRisk'',''insert into tblQuizExpiryAtRisk'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END



if OBJECT_ID(''tempdb..#tblCurrentUserQuizStatus'') is not null
begin
	drop table #tblCurrentUserQuizStatus
end


if OBJECT_ID(''tempdb..#tblCurrentAssignedModules'') is not null
begin
	drop table #tblCurrentAssignedModules
end


if OBJECT_ID(''tempdb..#tblStartedModules'') is not null
begin
	drop table #tblStartedModules
end




/* /UNITTEST: CourseStatus */


/* UNITTEST: Licensing */
EXEC prcDatabaseMail_SetupProfile -- incase email address etc has changed, re-setup.

-- Check who is missing license for current period, includes period turn over
declare @lic_CourseLicensingID int, @lic_UserID int
DECLARE LicensingLoop CURSOR
FOR
SELECT DISTINCT tblCourseLicensing.CourseLicensingID, vwUserModuleAccess.UserID
FROM tblCourseLicensing
INNER JOIN vwUserModuleAccess ON tblCourseLicensing.CourseID = vwUserModuleAccess.CourseID
AND tblCourseLicensing.OrganisationID = vwUserModuleAccess.OrganisationID
INNER JOIN tblUser ON vwUserModuleAccess.UserID = tblUser.UserID
LEFT OUTER JOIN	tblCourseLicensingUser ON tblCourseLicensing.CourseLicensingID = tblCourseLicensingUser.CourseLicensingID
WHERE tblCourseLicensing.DateStart <= GETUTCDATE()
AND tblCourseLicensing.DateEnd >= GETUTCDATE()
AND tblCourseLicensingUser.CourseLicensingID IS NULL
AND tblUser.Active = 1
AND vwUserModuleAccess.OrganisationID = @OrgID
Open LicensingLoop
FETCH NEXT FROM LicensingLoop
Into
@lic_CourseLicensingID, @lic_UserID
WHILE @@FETCH_STATUS = 0
BEGIN
IF NOT EXISTS(SELECT CourseLicensingID FROM tblCourseLicensingUser WHERE CourseLicensingID = @lic_CourseLicensingID and UserID = @lic_UserID)
BEGIN
INSERT INTO tblCourseLicensingUser(CourseLicensingID, UserID) VALUES (@lic_CourseLicensingID, @lic_UserID)
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''INSERT INTO tblCourseLicensingUser'',''INSERT INTO tblCourseLicensingUser'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END
END
FETCH NEXT FROM LicensingLoop
Into
@lic_CourseLicensingID, @lic_UserID
END

CLOSE LicensingLoop
DEALLOCATE LicensingLoop



-- WARNING EMAILS
-- License Warning
declare @licenseWarnEmail nvarchar(4000)
declare @licenseWarnEmail_Subject nvarchar(4000)
declare @emailLicenseWarnLicRecipients nvarchar(512)
declare @warn_lic_CourseName nvarchar(200),
@warn_lic_CourseLicensingID int,
@warn_lic_LicenseNumber int,
@warn_lic_LicenseWarnNumber int,
@warn_lic_RepNameSalt nvarchar(200),
@warn_lic_RepEmailSalt nvarchar(200),
@warn_lic_RepNameOrg nvarchar(200),
@warn_lic_RepEmailOrg nvarchar(200),
@warn_lic_LangCode nvarchar(10),
@warn_lic_LicensesUsed int,
@warn_lic_LicenseWarnEmail bit,
@warn_lic_OrganisationName nvarchar(50)

DECLARE LicenceNumberLoop CURSOR
FOR
SELECT
c.Name, l.CourseLicensingID, l.LicenseNumber, l.LicenseWarnNumber, l.RepNameSalt, l.RepEmailSalt,
l.RepNameOrg, l.RepEmailOrg, l.LangCode, COUNT(u.CourseLicensingUserID) AS LicensesUsed,
l.LicenseWarnEmail, OrganisationName
FROM
tblCourseLicensing l
INNER JOIN tblCourseLicensingUser u ON l.CourseLicensingID = u.CourseLicensingID
INNER JOIN tblCourse c ON l.CourseID = c.CourseID
LEFT JOIN tblOrganisation o ON l.OrganisationID = o.OrganisationID
WHERE
l.OrganisationID = @OrgID
GROUP BY
OrganisationName, l.CourseLicensingID, l.RepNameSalt, l.RepEmailSalt, l.RepNameOrg, l.RepEmailOrg, c.Name, l.LicenseNumber,
l.LicenseWarnNumber, l.LicenseWarnEmail, l.LangCode
HAVING
COUNT(u.CourseLicensingUserID) >= l.LicenseWarnNumber
AND l.LicenseWarnEmail = 1

Open LicenceNumberLoop
FETCH NEXT FROM LicenceNumberLoop
Into @warn_lic_CourseName,
@warn_lic_CourseLicensingID,
@warn_lic_LicenseNumber,
@warn_lic_LicenseWarnNumber,
@warn_lic_RepNameSalt,
@warn_lic_RepEmailSalt,
@warn_lic_RepNameOrg,
@warn_lic_RepEmailOrg,
@warn_lic_LangCode,
@warn_lic_LicensesUsed,
@warn_lic_LicenseWarnEmail,
@warn_lic_OrganisationName

WHILE @@FETCH_STATUS = 0
BEGIN
-- Get License Warning text in desired language.
SELECT     @licenseWarnEmail = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @warn_lic_LangCode) AND (tblLangInterface.LangInterfaceName = ''/ContentAdministration/Licensing/Default.aspx'') AND
(tblLangResource.LangResourceName = ''Email_LicenseWarn'') AND (tblLangValue.Active = 1)

SELECT     @licenseWarnEmail_Subject = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @warn_lic_LangCode) AND (tblLangInterface.LangInterfaceName = ''/ContentAdministration/Licensing/Default.aspx'') AND
(tblLangResource.LangResourceName = ''Email_LicenseWarn_Subject'') AND (tblLangValue.Active = 1)

-- {0} is receipient name, {1} is the license warning amount, {2} course name, {3} license limit, {4} name of contact person
-- {5} is organisation name
set @licenseWarnEmail = REPLACE(@licenseWarnEmail, ''{0}'', @warn_lic_RepNameOrg)
set @licenseWarnEmail = REPLACE(@licenseWarnEmail, ''{1}'', @warn_lic_LicenseWarnNumber)
set @licenseWarnEmail = REPLACE(@licenseWarnEmail, ''{2}'', @warn_lic_CourseName)
set @licenseWarnEmail = REPLACE(@licenseWarnEmail, ''{3}'', @warn_lic_LicenseNumber)
set @licenseWarnEmail = REPLACE(@licenseWarnEmail, ''{4}'', @warn_lic_RepNameSalt)
set @licenseWarnEmail = REPLACE(@licenseWarnEmail, ''{5}'', @warn_lic_OrganisationName)

set @licenseWarnEmail_Subject = REPLACE(@licenseWarnEmail_Subject, ''{0}'', @warn_lic_CourseName)
set @licenseWarnEmail_Subject = REPLACE(@licenseWarnEmail_Subject, ''{1}'', @warn_lic_OrganisationName)

select @emailLicenseWarnLicRecipients = @warn_lic_RepEmailOrg +'';''+@warn_lic_RepEmailSalt

EXEC msdb.dbo.sp_send_dbmail
@recipients = @emailLicenseWarnLicRecipients,
@body = @licenseWarnEmail,
@subject = @licenseWarnEmail_Subject,
@profile_name = ''Salt_MailAccount''

--Log emails sent
exec prcEMail_LogSentEmail @toEmail = @warn_lic_RepEmailOrg, @toName = null, @fromEmail = ''support@blakedawson.com'', @fromName = ''Blake Dawson'', @subject = @licenseWarnEmail_Subject, @body = @licenseWarnEmail, @organisationID = @OrgID
exec prcEMail_LogSentEmail @toEmail = @warn_lic_RepEmailSalt, @toName = null, @fromEmail = ''support@blakedawson.com'', @fromName = ''Blake Dawson'', @subject = @licenseWarnEmail_Subject, @body = @licenseWarnEmail, @organisationID = @OrgID

print ''queued numLics warning mail to : '' + @emailLicenseWarnLicRecipients

-- Unset flag and record date email sent
UPDATE tblCourseLicensing SET DateLicenseWarnEmailSent = getutcdate(), LicenseWarnEmail = 0 WHERE CourseLicensingID = @warn_lic_CourseLicensingID
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''UPDATE tblCourseLicensing'',''UPDATE tblCourseLicensing'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END

FETCH NEXT FROM LicenceNumberLoop
Into @warn_lic_CourseName,
@warn_lic_CourseLicensingID,
@warn_lic_LicenseNumber,
@warn_lic_LicenseWarnNumber,
@warn_lic_RepNameSalt,
@warn_lic_RepEmailSalt,
@warn_lic_RepNameOrg,
@warn_lic_RepEmailOrg,
@warn_lic_LangCode,
@warn_lic_LicensesUsed,
@warn_lic_LicenseWarnEmail,
@warn_lic_OrganisationName
END

CLOSE LicenceNumberLoop
DEALLOCATE LicenceNumberLoop
-- /License Warning


-- Expiry Warning
declare @expiryWarnEmail nvarchar(4000)
declare @expiryWarnEmail_Subject nvarchar(4000)
declare @emailLicenseWarnExpRecipients nvarchar(512)
DECLARE @warn_exp_CourseLicensingID int,
@warn_exp_CourseName nvarchar(200),
@warn_exp_DateWarn datetime,
@warn_exp_ExpiryWarnEmail bit,
@warn_exp_DateEnd datetime,
@warn_exp_RepNameSalt nvarchar(200),
@warn_exp_RepEmailSalt nvarchar(200),
@warn_exp_RepNameOrg nvarchar(200),
@warn_exp_RepEmailOrg nvarchar(200),
@warn_exp_LangCode nvarchar(10),
@warn_exp_OrganisationName nvarchar(50)

DECLARE LicenceExpiryLoop CURSOR
FOR
SELECT
l.CourseLicensingID, c.Name, l.DateWarn, l.ExpiryWarnEmail, l.DateEnd, l.RepNameSalt,
l.RepEmailSalt, l.RepNameOrg, l.RepEmailOrg, l.LangCode, OrganisationName
FROM
tblCourseLicensing l
INNER JOIN tblCourse c ON l.CourseID = c.CourseID
LEFT JOIN tblOrganisation o ON l.OrganisationID = o.OrganisationID
WHERE
l.DateWarn < GETUTCDATE()
AND l.ExpiryWarnEmail = 1
AND l.OrganisationID = @OrgID

Open LicenceExpiryLoop
FETCH NEXT FROM LicenceExpiryLoop
Into @warn_exp_CourseLicensingID,
@warn_exp_CourseName,
@warn_exp_DateWarn,
@warn_exp_ExpiryWarnEmail,
@warn_exp_DateEnd,
@warn_exp_RepNameSalt,
@warn_exp_RepEmailSalt,
@warn_exp_RepNameOrg,
@warn_exp_RepEmailOrg,
@warn_exp_LangCode,
@warn_exp_OrganisationName

WHILE @@FETCH_STATUS = 0
BEGIN
-- Get Expiry Warning text in desired language.
SELECT     @expiryWarnEmail = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @warn_exp_LangCode) AND (tblLangInterface.LangInterfaceName = ''/ContentAdministration/Licensing/Default.aspx'') AND
(tblLangResource.LangResourceName = ''Email_ExpiryWarn'') AND (tblLangValue.Active = 1)

SELECT     @expiryWarnEmail_Subject = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @warn_exp_LangCode) AND (tblLangInterface.LangInterfaceName = ''/ContentAdministration/Licensing/Default.aspx'') AND
(tblLangResource.LangResourceName = ''Email_ExpiryWarn_Subject'') AND (tblLangValue.Active = 1)

-- {0} Receipient Name, {1} number days till expiry, {2} course name, {3} expiry date, {4} Salt rep name
-- {5} Organisation Name
set @expiryWarnEmail = REPLACE(@expiryWarnEmail, ''{0}'', @warn_exp_RepNameOrg)
set @expiryWarnEmail = REPLACE(@expiryWarnEmail, ''{1}'', DATEDIFF(dd,dbo.udfUTCtoDaylightSavingTime(getUTCdate(),@OrgID),dbo.udfUTCtoDaylightSavingTime(@warn_exp_DateEnd,@OrgID)))
set @expiryWarnEmail = REPLACE(@expiryWarnEmail, ''{2}'', @warn_exp_CourseName)
set @expiryWarnEmail = REPLACE(@expiryWarnEmail, ''{3}'', CONVERT(CHAR(10), dbo.udfUTCtoDaylightSavingTime(@warn_exp_DateEnd,@OrgID), 103))
set @expiryWarnEmail = REPLACE(@expiryWarnEmail, ''{4}'', @warn_exp_RepNameSalt)
set @expiryWarnEmail = REPLACE(@expiryWarnEmail, ''{5}'', @warn_exp_OrganisationName)

set @expiryWarnEmail_Subject = REPLACE(@expiryWarnEmail_Subject, ''{0}'', @warn_exp_CourseName)
set @expiryWarnEmail_Subject = REPLACE(@expiryWarnEmail_Subject, ''{1}'', @warn_exp_OrganisationName)

select @emailLicenseWarnExpRecipients = @warn_exp_RepEmailOrg +'';''+@warn_exp_RepEmailSalt

EXEC msdb.dbo.sp_send_dbmail
@recipients = @emailLicenseWarnExpRecipients,
@body = @expiryWarnEmail,
@subject = @expiryWarnEmail_Subject,
@profile_name = ''Salt_MailAccount''

--Log emails sent
exec prcEMail_LogSentEmail @toEmail = @warn_exp_RepEmailOrg, @toName = null, @fromEmail = ''support@blakedawson.com'', @fromName = ''Blake Dawson'', @subject = @expiryWarnEmail_Subject, @body = @expiryWarnEmail, @organisationID = @OrgID
exec prcEMail_LogSentEmail @toEmail = @warn_exp_RepEmailSalt, @toName = null, @fromEmail = ''support@blakedawson.com'', @fromName = ''Blake Dawson'', @subject = @expiryWarnEmail_Subject, @body = @expiryWarnEmail, @organisationID = @OrgID

print ''queued expiry mail to : '' + @emailLicenseWarnExpRecipients
-- Unset flag and record date email sent
UPDATE tblCourseLicensing SET DateExpiryWarnEmailSent = getutcdate(), ExpiryWarnEmail = 0 WHERE CourseLicensingID = @warn_exp_CourseLicensingID
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''UPDATE tblCourseLicensing'',''UPDATE tblCourseLicensing'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END


FETCH NEXT FROM LicenceExpiryLoop
Into @warn_exp_CourseLicensingID,
@warn_exp_CourseName,
@warn_exp_DateWarn,
@warn_exp_ExpiryWarnEmail,
@warn_exp_DateEnd,
@warn_exp_RepNameSalt,
@warn_exp_RepEmailSalt,
@warn_exp_RepNameOrg,
@warn_exp_RepEmailOrg,
@warn_exp_LangCode,
@warn_exp_OrganisationName
END

CLOSE LicenceExpiryLoop
DEALLOCATE LicenceExpiryLoop
-- /Expiry Warning
/* /UNITTEST: Licensing */


/* UNITTEST: ModuleNightly */
-- START Course status reconcile. If a module has been made active or inactive to run through all user and ensure that their course status is correct.
-- AS PER BUSINESS requirement
-- Get all changed modules
declare @c_CourseID int, @c_ModuleID int
DECLARE UpdatedModuleLOOP CURSOR
FOR
SELECT CourseID, ModuleID FROM tblModule WHERE(DateUpdated > GETUTCDATE() - 2)
Open UpdatedModuleLOOP

FETCH NEXT FROM UpdatedModuleLOOP
Into
@c_CourseID, @c_ModuleID

WHILE @@FETCH_STATUS = 0
BEGIN
-- Get all users related to this module
declare @c_UserID int
DECLARE UserLOOP CURSOR
FOR
SELECT UserID FROM tblUserModuleAccess WHERE ModuleID = @c_ModuleID
Open UserLOOP


FETCH NEXT FROM UserLOOP
Into
@c_UserID

WHILE @@FETCH_STATUS = 0
BEGIN
EXEC prcUserQuizStatus_UpdateCourseStatus @c_UserID, @c_ModuleID
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''prcUserQuizStatus_UpdateCourseStatus'',''prcUserQuizStatus_UpdateCourseStatus'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END

FETCH NEXT FROM UserLOOP
Into
@c_UserID
END

CLOSE UserLOOP
DEALLOCATE UserLOOP

FETCH NEXT FROM UpdatedModuleLOOP
Into
@c_CourseID, @c_ModuleID
END

CLOSE UpdatedModuleLOOP
DEALLOCATE UpdatedModuleLOOP
/* /UNITTEST: ModuleNightly */


/* UNITTEST: ExtendComplianceDate */
update tblOrganisation
set DefaultQuizCompletionDate = dateadd(year, 1, [DefaultQuizCompletionDate])
where DefaultQuizCompletionDate < getutcdate() and OrganisationID = @OrgID

update tblUnitRule
set QuizCompletionDate = dateadd(year, 1, [QuizCompletionDate])
where QuizCompletionDate < getutcdate() and UnitID IN (select UnitID from tblUnit where OrganisationID = @OrgID)
/* /UNITTEST: ExtendComplianceDate */


-- END Course status reconcile.


update tblOrganisation set CourseStatusLastUpdated = dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID) where OrganisationID = @OrgID

update tblModuleStatusUpdateHistory
set FinishTime = getutcdate()
where ModuleStatusUpdateHistoryID = @intHistoryID
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUSER_ArchiveUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		File:
**		Name: Stored_Procedure_Name
**		Desc: Uses user defined function to return full unit path
**
**		This template can be customized:
**
**		Return values:
**
**		Called by:
**
**		Parameters:
**		Input							Output
**     ----------							-----------
**
**		Auth: Li Zhang
**		Date: July 2008
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		--------		--------				-------------------------------------------
**
*******************************************************************************/
CREATE PROCEDURE [prcUSER_ArchiveUsers]
(@userIDs varchar(1000),
@updatedBy int)
AS

UPDATE tblUser set Active = ''False'', DateArchived = getutcdate(), updatedBy = @updatedBy,
DateUpdated = getutcdate() WHERE UserID in ( SELECT * FROM dbo.udfCsvToInt(@userIDs))
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_AssignUnit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Updates a Users Unit, if no user is specified then it updates all unassigned users
to be members of the specified unit. This function does not ever update Salt Admin Type users

Parameters:
@userID		(Optional)
@unitID 		(Mandatory)
@updatedByUserID	(Mandatory)
@organisationID		(Mandatory)

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
User.cs.

Calls:
Nothing

Assumptions:
None

Logic:
Updates the user and includes them in the appropriate unit


Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
7. IntegrityConstraintException
10. BusinessServiceException (General)


Author: Peter Kneale
Date Created: 23 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Peter Kneale	27/2			Added Organisation ID parameter

**/
CREATE  Procedure [prcUser_AssignUnit]
(
@userID 		Integer = Null,		-- User ID that should be assigned to the unit
@unitID 		Integer = Null,		-- Unit ID that the user should be assigned to
@updatedByUserID 	Integer = Null,		-- UserID of the user performing the update
@organisationID		Integer = Null		-- Organisation ID that the user is to be assigned to.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) 		-- Holds the error message
Declare @intErrorNumber Integer 		-- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0


-- PARAMETER VALIDATION
--==============================================================

--Validate Parameter @unitID
If(@unitID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @unitID in stored procedure prcUser_UpdateUnit''
Goto Finalise
End

--Validate Parameter @updatedByUserID
If(@updatedByUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @updatedByUserID in stored procedure prcUser_UpdateUnit''
Goto Finalise
End

--Validate Parameter @organisationID
If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure prcUser_UpdateUnit''
Goto Finalise
End

-- Validate User Exists
--=========================================================
If Not (@userID is null)
Begin
If Not Exists(Select * From tblUser Where UserID = @userID)
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This user record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''
Goto Finalise
End
End
-- Validate Updated By User ID Exists
--=========================================================
If Not Exists(Select * From tblUser Where UserID = @updatedByUserID)
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This user record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''
Goto Finalise
End

-- Validate Organisation ID Exists
--=========================================================
If Not Exists(Select * From tblOrganisation Where OrganisationID = @organisationID)
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This user record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''
Goto Finalise
End

-- Validate Unit Exists
--=========================================================
If Not Exists(Select * From tblUnit Where UnitID = @unitID and Active=1)
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This unit record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''
Goto Finalise
End

If (@userID is null)
Begin
-- Update All Unassigned Active Users
--=======================
Update
tblUser
Set
UnitID = @unitID,
DateUpdated=getutcDate(),
UpdatedBy=@updatedByUserID
Where
UnitID = null
And Active = 1
And UserTypeID <> 1
And OrganisationID = @organisationID
End
Else
Begin
-- Update  a Single User
--=======================
Update
tblUser
Set
UnitID = @unitID,
DateUpdated=getutcDate(),
UpdatedBy=@updatedByUserID
Where
UserID = @userID
And OrganisationID = @organisationID
End




-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Updated''

-- Finalise the procedure
Goto Finalise


Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_ClassificationUpdate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'




/*Summary:
Updates a Users Classification details

Parameters:
@userID				(Mandatory)
@values				(Mandatory)

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
User.cs.

Calls:
Nothing


Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
7. IntegrityConstraintException
10. BusinessServiceException (General)

Assumptions:
Requires function udfCsvToInt

Author: John Crawford
Date Created: 18 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	John C		26-Feb-2004		Converted to user udfCsvToInt

**/
CREATE   Procedure [prcUser_ClassificationUpdate]
(
@userID Integer = Null,
@values nvarchar(4000) = Null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number


-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

-- PARAMETER VALIDATION
--==============================================================

--Validate Parameter @userID
If(@userID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcUser_Update''
Goto Finalise
End

-- Validate User Exists
--=========================================================
If Not Exists(Select * From tblUser Where UserID = @userID)
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''
Goto Finalise
End


-- Delete existing userclassifications
--====================================
Delete
From
tblUserClassification
Where
UserID = @userID


-- insert into the database
--===================================================
insert into tblUserClassification
(UserID,
ClassificationID
)
select @UserID,
c.ClassificationID
From tblClassification c
left join dbo.udfCsvToInt(@values) as  csv
on csv.IntValue=c.ClassificationID
where c.ClassificationID = csv.IntValue
and c.Active = 1


-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Updated''

-- Finalise the procedure
Goto Finalise


Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End





' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Create]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Inserts a new user.

Parameters:
@organisationID		(Mandatory)
@unitID 			(Mandatory)
@firstName 			(Mandatory)
@lastName			(Mandatory)
@userName			(Mandatory)
@email				(Mandatory)
@active			(Mandatory)
@userTypeID			(Mandatory)
@actionUserID			(Mandatory)
@password			(Mandatory)

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
User.cs.

Calls:
Nothing

Assumptions:
The majority of business logic related to password
lengths, confirmation passwords, valid emails etc.
are implemented through the UI.
Assumption is that the parameters when passed in
contain valid data.

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
7. IntegrityConstraintException
10. BusinessServiceException (General)


Author: Peter Vranich
Date Created: 20th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Jack Liu	15/09/2005		User name is only unique per organisation

**/
CREATE  Procedure [prcUser_Create]
(
@organisationID Integer = Null,
@unitID Integer = Null,
@firstName nvarchar(50) = Null,
@lastName nvarchar(50) = Null,
@userName nvarchar(100) = Null,
@email nvarchar(100) = null,
@active bit = null,
@userTypeID Integer = Null,
@actionUserID Integer = Null,
@password nvarchar(50) = Null,
@externalID nvarchar(50) = Null,
@TimeZoneID Integer = Null,
@DelinquencyManagerEmail nvarchar(100) = Null,
@NotifyMgr bit = 0,
@NotifyUnitAdmin bit = 0, 
@NotifyOrgAdmin bit = 0, 
@EbookNotification bit = 0
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number
Declare @UserID integer -- Holds the UserID once created

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

-- PARAMETER VALIDATION
--==============================================================

-- If user type is not SALT Administrator, check that a OrgID and UnitID has been supplied
If(@userTypeID <>1)
Begin
If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @unitID
If(@unitID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @unitID in stored procedure prcUser_Create''
Goto Finalise
End
End

--Validate Parameter @firstName
If(@firstName Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @firstName in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @lastName
If(@lastName Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @lastName in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @userName
If(@userName Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userName in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @email
If(@email Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @email in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @active
If(@active Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @userTypeID
If(@userTypeID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userTypeID in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @createdByUserID
If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @updatedByUserID in stored procedure prcUser_Create''
Goto Finalise
End

-- If a unit was specified make sure it exists
--=========================================================
If (@unitID Is Not Null)
Begin
If Not Exists(Select * From tblUnit Where UnitID = @unitID)
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''The specified unit could be found or may not be active.''
Goto Finalise
End
End

If(@userTypeID <>1)
begin
-- User name is unique per organisation
If Exists(Select * From tblUser Where Username = @userName and (organisationID=@organisationID or organisationID is null))
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = @userName
Goto Finalise
End
end
else
begin
If Exists(Select * From tblUser Where Username = @userName)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = @userName
Goto Finalise
End
end


If Exists(Select * From tblUser Where Email = @email)
Begin
Set @intErrorNumber = 41
Set @strErrorMessage = ''The email address '' + @email + '' already exists.  <BR>Please choose another email address.''
Goto Finalise
End

Insert Into tblUser
(
OrganisationID,
FirstName,
LastName,
UserName,
Password,
Email,
UnitID,
UserTypeID,
Active,
CreatedBy,
DateCreated,
ExternalID,
NewStarter,
TimeZoneID,
DelinquencyManagerEmail,
NotifyMgr,
NotifyUnitAdmin,
NotifyOrgAdmin,
EbookNotification
)
Values
(
@organisationID,
@firstName,
@lastName,
@userName,
@password,
@email,
@unitID,
@userTypeID,
@active,
@actionUserID,
GETUTCDATE(),
@externalID, -- http://bugs.salt.devbdw.com/edit_bug.aspx?id=274
1,
@TimeZoneID,
@DelinquencyManagerEmail,
@NotifyMgr,
@NotifyUnitAdmin, 
@NotifyOrgAdmin, 
@EbookNotification
)

update tblUser set DateArchived = getutcdate() where Active = 0 and DateArchived IS NULL AND UserID = @@Identity
update tblUser set DateArchived = null where Active = 1 and NOT(DateArchived IS NULL) AND UserID = @@Identity

-- Set the error message to successfull
Set @strErrorMessage = @@Identity
Set @UserID = @@Identity


-- Get ProfilePeriodID''s for Organisation
create table #ProfilePeriod
(
ProfilePeriodID int
)

insert into #ProfilePeriod
select ProfilePeriodID
from tblProfilePeriod  pp
join tblprofile p
on pp.profileid = p.profileid
where p.organisationid = @OrganisationID


-- insert user into profileperiodaccess against all profileperiodid''s
-- for the organisation
insert into tblUserProfilePeriodAccess
select
pp.ProfilePeriodID,
@UserID,
uppa.granted
from #ProfilePeriod pp
join tblUnitProfilePeriodAccess uppa
on uppa.ProfilePeriodID = pp.ProfilePeriodID
where uppa.UnitID = @UnitID

drop table #ProfilePeriod

-- Get Policies for Organisation
create table #Policy
(
PolicyID int,
Granted bit
)

insert into #Policy
select p.PolicyID,
case when (select distinct granted from tblUnitPolicyAccess where unitID = @unitID and policyid = p.policyid) is null then 0
else (select distinct granted from tblUnitPolicyAccess where unitID = @unitID and policyid = p.policyid) end
from tblPolicy p where
OrganisationID = @OrganisationID
and deleted = 0


-- insert user into policy for all policy''s associated with organisation
insert into tblUserPolicyAccepted (PolicyID, UserID, Accepted)
select PolicyID, @UserID, 0 from #Policy

-- insert user into policyaccess for all policies
insert into tblUserPolicyAccess (PolicyID, UserID, Granted)
select PolicyID, @UserID, Granted  from #Policy

drop table #Policy

-- Finalise the procedure
Goto Finalise


Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetAdministratorsEmailAddress]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 01/07/2011
-- Description:	Gets nearest admin for user
-- =============================================
CREATE PROCEDURE [prcUser_GetAdministratorsEmailAddress]
@UserId int
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

-- Insert statements for procedure here
SELECT dbo.udfUser_GetAdministratorsEmailAddress(@UserId)
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetAdminUnitsTree]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
This is a hierarchical list of the Units that this user has Unit Administrator rights to.
It is for display-only.


Returns:
Flat hierarchy table


Called By:
Calls:

Remarks:

Author:
Jack Liu
Date Created: 17 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcUser_GetAdminUnitsTree 143


**/

CREATE PROC [prcUser_GetAdminUnitsTree]
(
@userID int
)

AS

set nocount on

declare @intOrganisationID int
/*
declare @strSelectedUnitIDs varchar(4000)
declare @strExpandedUnitIDs varchar(4000)
declare @strDisabledUnitIDs varchar(4000)
*/
select 	@intOrganisationID = OrganisationID
from tblUser
where userID = @userID


/*
--1. Get a list of unit id that the user has permission
select 	@strSelectedUnitIDs= isNull(@strSelectedUnitIDs + '','','''')+ cast(u.unitID as varchar)
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@intOrganisationID)


--2. Expand the unit branch to the unitID that has admin permission
select 	@strExpandedUnitIDs= isNull(@strExpandedUnitIDs + '','','''')+  cast(tblUnit.unitID as varchar)
from 	tblUnit
where 	(tblUnit.organisationID=@intOrganisationID)
and exists (select U.UnitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@intOrganisationID)
and charindex(tblUnit.hierarchy +'','', u.hierarchy)=1
) --Get units whose child units can be administered

--select @strExpandedUnitIDs

--3. Disable the whole tree
select 	@strDisabledUnitIDs= isNull(@strDisabledUnitIDs + '','','''')+  cast(u.unitID as varchar)
from 	tblUnit as u
where 	(u.organisationID=@intOrganisationID)


exec prcUnit_GetUnitsByOrganisation @intOrganisationID, @strDisabledUnitIDs, @strSelectedUnitIDs,@strExpandedUnitIDs
*/

select
un.unitid ''UnitID'',
un.parentunitid ''ParentUnitID'',
un.name ''Name'',
case when ua.unitid is null then 1 else 0 end ''Disabled'',
case when ua.unitid is null then 0 else 1 end ''Selected'',
case when un2.unitid is null then 0 else 1 end ''Expanded''
from tblUnit un
left join tblUnitAdministrator ua
on un.unitid=ua.unitid and ua.userid=@userid
left join
(
select un.* from tblUnit un
inner join tblUnitAdministrator ua
on un.unitid=ua.unitid
where
ua.userid=@userid
) un2
on charindex(un2.hierarchy +'','', un.hierarchy)=1
where un.organisationid=@intOrganisationID
and un.active=1
order by un.hierarchy' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetArchiveUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
-- =============================================
-- Author:		Li Zhang
-- Create date: June 2008
-- Description:
-- =============================================
CREATE PROCEDURE [prcUser_GetArchiveUsers]
@fromDate datetime,
@inclNewUsers int,
@orgID int,
@userID int
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

set @fromDate = dbo.udfDaylightSavingTimeToUTC(@fromDate, @orgID)

declare @SelectedUnitIDs table
(unid int)

declare @usertype int
DECLARE @tblTemp table(
LastLogin nvarchar(200),
FirstName nvarchar(200),
LastName nvarchar(200),
Username nvarchar(200),
ExternalID nvarchar(50),
Email nvarchar(100),
UserID int)


-- Get user type
Select @UserType = UserTypeID from tblUser Where UserID = @UserID

-- salt and org admins
IF (@UserType in(1,2))
Begin
insert into @SelectedUnitIDs
select unitID
from
tblUnit Where OrganisationID = @orgID

end

-- unit admin
IF (@UserType = 3)
Begin
insert into @SelectedUnitIDs
select 	u.unitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@orgID)
end


-- get users haven''t login after @fromDate
insert into @tblTemp
select
dbo.udfUTCtoDaylightSavingTime(LastLogin, @orgID), FirstName, LastName, Username, ExternalID,Email, UserID
from
tblUser
join @SelectedUnitIDs on unid = unitid
where
LastLogin < @fromDate
and OrganisationID =  @orgID
and Active = ''true''




if @inclNewUsers = 1
begin
insert into @tblTemp
select
''Never'', FirstName, LastName, Username, ExternalID, Email, UserID
from
tblUser
join @SelectedUnitIDs on unid = unitid
where
LastLogin is null and DateUpdated < @fromDate
and OrganisationID =  @orgID and Active = ''true''
end


select * from @tblTemp

END



SET QUOTED_IDENTIFIER ON
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetClassification]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*
Summary: Gets a list of Classification Types for an Organisation
Parameters: OrganisationID
Returns: ClassificationID, ClassificationTypeID, Value, Active

Called By: Classification.cs
Calls: None

Remarks: None

Author: John Crawford
Date Created: 17th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcUser_GetClassification]
(
@userID Integer = Null -- ID of the Classification Type that you wish to get the Classification List For.
)

As

Select
UserID,
ClassificationID
From
tblUserClassification
Where
UserID = @UserID



' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetCourseList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Gets course List for User My Training page

Parameters:


Returns:


Called By:
User.cs.

Calls:


Assumptions:


Remarks:



Author: Aaron Cripps
Date Created: August 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description


**/

CREATE  Procedure [dbo].[prcUser_GetCourseList]
(
@UserID int,
@ProfileID int,
@CurrentCultureName NVarChar(40) = ''en-AU''
)

As

DECLARE @OrgID int

Select @OrgID = OrganisationID FROM tblUser where UserID = @UserID
create table #UserCourse
(
CourseID int,
[Name] nvarchar(100),
Notes nvarchar(1000),
Active bit,
CreatedBy int,
DateCreated datetime,
UpdatedBy int,
DateUpdated datetime
)

insert into #UserCourse
exec prcCourse_GetListByUser @UserID

Create table #CourseName
(
CourseID int,
[Name] nvarchar(100),
DateCreated datetime
)

Create Table #CourseStatus
(
CourseID int,
CourseStatusID int,
DateCreated datetime
)

insert into #CourseStatus
select
ucs.CourseID,
ucs.CourseStatusID,
max(ucs.DateCreated) as DateCreated
from
tblUserCourseStatus ucs
join #UserCourse uc	on  ucs.CourseID = uc.CourseID
where
ucs.UserID = @UserID
and not exists (select * from tblusercoursestatus ucs2
where ucs.courseid = ucs2.courseid
and ucs.userid = ucs2.userid
and ucs.datecreated <ucs2.datecreated )
group by
ucs.CourseID, ucs.CourseStatusID
order by
DateCreated desc

Create Table #CourseStatusTemp
(
CourseID int,
DateCreated datetime
)

insert into #CourseStatusTemp
select
CourseID,
max(DateCreated)
from
#CourseStatus
group by CourseID

Create Table #CourseList
(
CourseID int,
[Name] nvarchar(100),
CourseStatusID int,
Due varchar(11),
LastComp varchar(11),
Red char(1)
)

Declare @DefaultLessonCompletionDate Datetime
Declare @DefaultQuizCompletionDate Datetime
DECLARE @DefaultQuizFrequency integer

SELECT @DefaultQuizCompletionDate = DefaultQuizCompletionDate
,@DefaultLessonCompletionDate = DefaultLessonCompletionDate
,@DefaultQuizFrequency = DefaultQuizFrequency
FROM tblOrganisation where OrganisationID = (SELECT OrganisationID FROM tblUser WHERE UserID = @UserID)

declare @OrganisationID integer

select @OrganisationID = OrganisationID FROM tblUser WHERE UserID = @UserID







insert into #CourseList
select
uc.CourseID,
uc.[Name],
cs.CourseStatusID,
case

when cs.CourseStatusID = 2 and @DefaultQuizCompletionDate is  null  then '' ''
when cs.CourseStatusID = 2 and   @DefaultQuizCompletionDate is not null
then convert(varchar (11),dbo.udfUserUTCtoDaylightSavingTime(@DefaultQuizCompletionDate,@OrganisationID),113)
when cs.CourseStatusID <> 2 and (RemEsc.DaysToCompleteCourse is null OR ((RemEsc.NotifyMgr = 0) AND (RemEsc.RemindUsers = 0))) then ''-- ''
when cs.CourseStatusID <> 2 and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and CStart.DateCreated is null
then CAST(RemEsc.DaysToCompleteCourse AS VARCHAR(5))																																															-- course just added , overnight job has not caught up yet
+ (SELECT  '' ''+LangEntryValue  FROM tblLangValue
where LangInterfaceID = (SELECT  LangInterfaceID   FROM tblLangInterface WHERE LangInterfaceName = ''GLOBAL.MISC'')
and LangID =(SELECT LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName)
and LangResourceID = (SELECT LangResourceID  FROM tblLangResource where   LangResourceName = ''days'' ))

when cs.CourseStatusID <> 2 and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and CStart.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,CS.DateCreated,getUTCdate())) >= 0
then CAST(RemEsc.DaysToCompleteCourse -   DATEDIFF(day,CS.DateCreated,getUTCdate()) AS VARCHAR(5))
+ (SELECT  '' ''+LangEntryValue  FROM tblLangValue
where LangInterfaceID = (SELECT  LangInterfaceID   FROM tblLangInterface WHERE LangInterfaceName = ''GLOBAL.MISC'')
and LangID =(SELECT LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName)
and LangResourceID = (SELECT LangResourceID  FROM tblLangResource where   LangResourceName = ''days'' ))
when cs.CourseStatusID <> 2 and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and CStart.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,CS.DateCreated,getUTCdate())) < 0
then convert(varchar (11),DATEADD(day,RemEsc.DaysToCompleteCourse,dbo.udfUTCtoDaylightSavingTime(CS.DateCreated,@OrgID)),113)


end ,
case
when CPass.DateCreated is null then '' ''
when CPass.DateCreated is not null then convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(CPass.DateCreated,@OrgID),113)
end ,

case when cs.CourseStatusID <> 2 and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and CStart.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,CS.DateCreated,getUTCdate())) < 0		then 1 else 0 end

from
#UserCourse uc
left outer join #CourseStatus cs on uc.CourseID = cs.CourseID
left outer join (SELECT MIN(UserCourseStatusID) as UserCourseStatusID,[UserID] ,[CourseID] FROM tblUserCourseStatus LastAttempt where LastAttempt.UserID = @UserID and not exists (SELECT * FROM tblUserCourseStatus PreviousAttempt where PreviousAttempt.UserID = @UserID and PreviousAttempt.CourseStatusID = 0 and PreviousAttempt.UserCourseStatusID < LastAttempt.UserCourseStatusID and PreviousAttempt.CourseID = LastAttempt.CourseID and PreviousAttempt.UserID = LastAttempt.UserID) group by [UserID] ,[CourseID]
) CSID ON CSID.UserID = @UserID and CSID.courseID = cs.courseID
left outer join tblUserCourseStatus CStart ON CStart.UserID = @UserID and CStart.courseID = cs.courseID and CStart.UserCourseStatusID = CSID.UserCourseStatusID
left outer join tblReminderEscalation RemEsc on RemEsc.CourseId = cs.CourseID and RemEsc.orgID = @OrgID
--last passed course date
left outer join
(SELECT MAX(UserCourseStatusID) as UserCourseStatusID,[UserID] ,[CourseID] FROM tblUserCourseStatus PreviousAttempt where PreviousAttempt.userID = @UserID  and PreviousAttempt.CourseStatusID = 2 group by [UserID] ,[CourseID]
) CPSID ON CPSID.UserID = @UserID and CPSID.courseID = cs.courseID
left outer join tblUserCourseStatus CPass ON CPass.UserID = @UserID and CPass.courseID = cs.courseID and CPass.UserCourseStatusID = CPSID.UserCourseStatusID





--Now get points available for each course
Create Table #CoursePoints
(
CourseID int,
PointsAvailable numeric(10,1)
)

insert into #CoursePoints
select
cl.CourseID, sum(ppts.Points)
from
#CourseList cl
join tblModule m on m.CourseID = cl.CourseID
join tblProfilePoints ppts on m.ModuleID = ppts.TypeID
join tblProfilePeriod pp on ppts.ProfilePeriodID = pp.ProfilePeriodID
where
m.Active = 1 and ppts.Active = 1 and pp.ProfileID = @ProfileID
group by
cl.CourseID


select
@ProfileID as ProfileID,
cl.CourseID, cl.[Name],
coalesce(cl.CourseStatusID, 1) as CourseStatusID,
cp.PointsAvailable,
cl.Due ,
cl.LastComp,
cl.red
from
#CourseList cl
left join #CoursePoints cp on cl.CourseID = cp.CourseID
order by cl.[Name]


drop table #UserCourse
drop table #CourseName
drop table #CourseStatus
drop table #CourseStatusTemp
drop table #CourseList
drop table #CoursePoints


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetDetailsByEmailAndDomain]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets the details of one User by their email address
Parameters: @emailAddress varchar(100)
Returns: UserID, FirstName, LastName, UserName, Password, Email, ExternalID, OrganisationID, UnitID, UserTypeID, Active, CreatedBy, DateCreated, UpdatedBy, DateUpdated

Called By: User.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Gavin Buddis
Date Created: 10th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcUser_GetDetailsByEmailAndDomain]
(
@emailAddress varchar(100) = null, -- Email Address
@DomainName varchar(100)
)

As
Set NoCount On

If @emailAddress Is Null
Begin
Raiserror(''The Parameter @emailAddress was null.  @emailAddress does not accept Null values.'', 16, 1)
Return
End

Select TOP (1)
UserID,
FirstName,
LastName,
UserName,
Password,
Email,
ExternalID,
tblUSer.OrganisationID,
UnitID,
UserTypeID,
Active,
tblUser.CreatedBy,
dbo.udfUTCtoDaylightSavingTime(tblUser.DateCreated, tblOrganisation.OrganisationID),
tblUser.UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(tblUser.DateUpdated, tblOrganisation.OrganisationID)
From
tblUser
INNER JOIN tblOrganisation ON tblOrganisation.OrganisationID = tblUser.OrganisationID
Where
Email = @emailAddress
AND DomainName like @DomainName+''%''
AND tblUser.Active = 1
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetEmailAddress]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Gets a list of email addresses when passed a csv list of userid''s

Parameters:
@userIDs (mandatory)

Returns:
1, James@home.com
23, Bob@home.com.au
97, Harry@home.com

order by userID, Email

Called By:
Report.cs

Calls:
udfCsvToInt

Remarks:



Author:Peter Kneale
Date Created: 27 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



--------------------

**/


CREATE Proc [prcUser_GetEmailAddress]
(
@userIDs varchar(8000)		-- CSV list of user IDs that email addresses of are needed
)

As

Select
FirstName,
LastName,
UserID,
Email
From
tblUser
Where
userID in
(
Select
*
From
udfCsvToInt (@userIDs) 	-- Convert csv list of user id''s into rows
)
and active = 1
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetIdFromEmail]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 
-- Description:	
-- =============================================
CREATE PROCEDURE [prcUser_GetIdFromEmail] 
	-- Add the parameters for the stored procedure here
	@Email nvarchar(100) = null
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT UserID FROM tblUser WHERE Email = @Email
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetIdFromUsername]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 14/11/2011
-- Description:	Gets UserId from Username
-- =============================================
CREATE PROCEDURE [prcUser_GetIdFromUsername] 
	-- Add the parameters for the stored procedure here
	@Username nvarchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT UserID FROM tblUser WHERE  UserName = @Username
END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetModuleAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/****** Object:  Stored Procedure dbo.prcUser_GetModuleAccess    Script Date: 30/03/2004 4:01:35 PM ******/
/*
Summary:
Gets user module access settings

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Peter Kneale    30/3/04    Filtered out inactive modules

prcUser_GetModuleAccess 1, 1

*/

CREATE   Procedure [prcUser_GetModuleAccess]
(
@userID Int,
@courseID int
)

As

set nocount on

declare @intUnitID int
select @intUnitID = unitID
from tblUser
where UserID = @userID

Select 	m.ModuleID,
m.Name,
case
when ((unitma.DeniedModuleID  is null
And userma.ModuleID is null)
or userma.Granted=1)  then 1
else 0 end as Granted
From tblModule m
left join tblUnitModuleAccess unitma
on m.ModuleID = unitma.DeniedModuleID
and unitma.UnitID=@intUnitID
left join tblUserModuleAccess userma
on m.ModuleID = userma.ModuleID
and userma.UserID=@userID
where
m.CourseId= @courseID
and
m.Active = 1
order by m.Sequence








' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetNameBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'





/*Summary:
Given a SessionID
returns the users name (Firstname + " " + LastName) as Name
Returns:
scalar - string - user''s name

Called By:
TooolBooLlistner.aspx via Businessservices.Toolbook.GetUser
Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 4 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


--------------------


**/


CREATE   PROC [prcUser_GetNameBySessionID]
(
@SessionID varchar(50) -- Toolbook session ID - A GUID
)

AS

SET NOCOUNT ON

------------------------------------------
-- Declerations
------------------------------------------
Declare @userID int

------------------------------------------
-- get @userID from @lessonSessionID
------------------------------------------
SET @userID= dbo.udfGetUserIDBySessionID(@SessionID)

------------------------------------------
-- Return Scalar
------------------------------------------

SELECT top 1
[FirstName] + '' '' + [LastName] as ''Name''
FROM
tblUser
WHERE
UserID = @userID

return




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets the details of one User
Parameters: @userID integer
Returns: UserID, FirstName, LastName, UserName, Password, Email, ExternalID, OrganisationID, UnitID, UserTypeID, Active, CreatedBy, DateCreated, UpdatedBy, DateUpdated

Called By: User.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Gavin Buddis
Date Created: 10th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcUser_GetOne]
(
	@userID Integer = null -- User ID
)

As
begin 

	Set NoCount On

	If @userID Is Null
	Begin
		Raiserror(''The Parameter @userID was null.  @userID does not accept Null values.'', 16, 1)
		Return
	End

	Select
		UserID,
		FirstName,
		LastName,
		UserName,
		Password,
		Email,
		ExternalID,
		OrganisationID,
		UnitID,
		UserTypeID,
		Active,
		CreatedBy,
		dbo.udfUTCtoDaylightSavingTime(DateCreated, OrganisationID) as DateCreated,
		UpdatedBy,
		dbo.udfUTCtoDaylightSavingTime(DateUpdated, OrganisationID) as DateUpdated,
		dbo.udfUTCtoDaylightSavingTime(LastLogin, OrganisationID) as LastLogin,
		TimeZoneID,
		DelinquencyManagerEmail,
		NotifyMgr,
		NotifyUnitAdmin,
NotifyOrgAdmin,
EbookNotification
	From
		tblUser
	Where
		UserID = @userID
END



' 
END
GO


SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[prcUser_GetDetailsByEmail]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[prcUser_GetDetailsByEmail]
GO

/*
Summary: Gets the details of one User by their email address
Parameters: @emailAddress varchar(100)
Returns: UserID, FirstName, LastName, UserName, Password, Email, ExternalID, OrganisationID, UnitID, UserTypeID, Active, CreatedBy, DateCreated, UpdatedBy, DateUpdated

Called By: User.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Gavin Buddis
Date Created: 10th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	
*/

CREATE Procedure prcUser_GetDetailsByEmail
(
	@emailAddress varchar(100) = null -- Email Address
)

As
Set NoCount On

If @emailAddress Is Null
Begin
	Raiserror('The Parameter @emailAddress was null.  @emailAddress does not accept Null values.', 16, 1)
	Return
End

Select
	UserID,
	FirstName,
	LastName,
	UserName,
	Password,
	Email,
	ExternalID,
	OrganisationID,
	UnitID,
	UserTypeID,
	Active,
	CreatedBy,
	DateCreated,
	UpdatedBy,
	DateUpdated
From
	tblUser
Where
	Email = @emailAddress
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

 

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetOneWithOwnTime]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets the details of one User
Parameters: @userID integer
Returns: UserID, FirstName, LastName, UserName, Password, Email, ExternalID, OrganisationID, UnitID, UserTypeID, Active, CreatedBy, DateCreated, UpdatedBy, DateUpdated

Called By: User.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Gavin Buddis
Date Created: 10th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcUser_GetOneWithOwnTime]
(
@userID Integer = null -- User ID
)

As
Set NoCount On

If @userID Is Null
Begin
Raiserror(''The Parameter @userID was null.  @userID does not accept Null values.'', 16, 1)
Return
End

Select
UserID,
FirstName,
LastName,
UserName,
Password,
Email,
ExternalID,
OrganisationID,
UnitID,
UserTypeID,
Active,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, OrganisationID) as DateCreated,
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, OrganisationID) as DateUpdated,
dbo.udfUserUTCtoDaylightSavingTime(LastLogin, @userID) as LastLogin,
TimeZoneID,
DelinquencyManagerEmail

From
tblUser
Where
UserID = @userID




' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetPermission]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get user administering permission
Returns:
Nothing.

Called By:
User Class.

Calls:
Nothing
Remarks:



Author: Jack Liu
Date Created: 09 Mar 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE PROCEDURE [prcUser_GetPermission]
(
@userID		int,
@adminUserID 	int,
@permission  	char(1)=null output
)

AS

set nocount on

Declare @intUserOrganisationID int, @intUserUnitID int
declare @intAdminUserTypeID int, @intAdminUserOrganisationID int


select @intUserOrganisationID = OrganisationID,
@intUserUnitID = UnitID
from tblUser
where UserID=@userID

select @intAdminUserTypeID = UserTypeID,
@intAdminUserOrganisationID = OrganisationID
from tblUser
where userID = @adminUserID


set @permission=''''
--1. Salt Admin
if (@intAdminUserTypeID=1)
begin
select @permission = ''S''
end
--2. Org admin
else if (@intAdminUserTypeID=2)
begin
--If the admin user is in the same organisation as the user, it has Full permission
--otherwise no permission
if (@intUserOrganisationID = @intAdminUserOrganisationID)
select @permission = ''F''
else
select @permission = ''''
end
--3. Unit admin, User must be administrator of that unit
else if (@intAdminUserTypeID=3)
begin
if exists(
select 1
from tblUnitAdministrator
where UnitID =@intUserUnitID
and UserID =@adminUserID)
select @permission = ''F''
else
select @permission = ''''
end

if (@permission is null)
select @permission = ''''


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetQuizHistory]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Returns the quiz history for a given user for a given module
Parameters: @UserID integer, @ModuleID integer
Returns:

Recordset 1
Status,
QuizPassMark,
QuizScore,
DateCreated,
QuizStatusID,
QuizSessionID

Called By:
User.cs
Calls:


Remarks: Raises an error if the parameter is null

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

-- prcUser_GetQuizHistory 1,1
*/
CREATE Procedure [prcUser_GetQuizHistory]
@UserID 	Integer,		-- UserID of the user that we want the quiz history on
@ModuleID 	Integer,		-- Module ID from which we need the quiz history information
@OrgID int
As
Set NoCount On

--------------------------------------------------------------------
---- Declarations
--------------------------------------------------------------------

--------------------------------------------------------------------
---- Logic
----- Get the Users Quiz Details
--------------------------------------------------------------------

Select
Status,
QuizPassMark,
QuizScore,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @OrgID) as DateCreated,
tblUserQuizStatus.QuizStatusID,
QuizSessionID
From
tblUserQuizStatus, tblQuizStatus
Where
tblUserQuizStatus.QuizStatusID = tblQuizStatus.QuizStatusID
And
tblUserQuizStatus.UserID = @userID
And
tblUserQuizStatus.ModuleID = @moduleID

Order By
DateCreated desc
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetQuizSummary]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*
Summary: Returns the quiz history for a given user for a given module
Parameters: @QuizSessionID 	Varchar(50)
Returns:
QuizScore,
QuizPassMark,
DateTimeStarted,
DateTimeCompleted

Called By: User.cs
Calls: Nothing

Remarks: Raises an error if the parameter is null

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

-- prcUser_GetQuizSummary ''923F3547-94D2-4631-8DD4-FA8F8C8AC95A''
*/
CREATE    Procedure [prcUser_GetQuizSummary]
@QuizSessionID 	Varchar(50)	-- GUID Session ID of the quiz session that we want a summary
AS

Set NoCount On

--------------------------------
---- Validation
--------------------------------
If (@QuizSessionID is NULL or datalength(@QuizSessionID) = 0)
Begin
Raiserror (''Procedure prcUser_GetQuizSummary requires the Quiz Session ID'', 16, 1)
Return
End

--------------------------------
---- Logic
--------------------------------

Declare @Results table
(
Question 		nvarchar(4000),
CorrectAnswer	 	nvarchar(4000),
GivenAnswer		nvarchar(4000),
Correct			bit,
QuizQuestionID 		integer,
QuizAnswerID   		integer
)
Insert into
@Results

Select
tblQuizQuestion.Question,
tblQuizAnswer.Answer as ''CorrectAnswer'',
null,
null,
tblQuizQuestion.QuizQuestionID,
tblQuizAnswer.QuizAnswerID

From
tblQuizAnswer
INNER JOIN tblQuizQuestion
ON tblQuizQuestion.QuizQuestionID = tblQuizAnswer.QuizQuestionID
Inner Join tblQuizQuestionAudit
On tblQuizQuestionAudit.QuizQuestionID = tblQuizQuestion.QuizQuestionID
INNER JOIN tblQuizSession
ON tblQuizSession.QuizID = tblQuizQuestion.QuizID
INNER Join tblQuizAnswerAudit
on
tblQuizQuestion.QuizQuestionID  = tblQuizAnswerAudit.QuizQuestionID
and
tblQuizAnswerAudit.QuizSessionID = @QuizSessionID


Where
tblQuizSession.QuizSessionID = @QuizSessionID
and
tblQuizAnswer.Correct = 1
order by
tblQuizQuestion.QuizQuestionID,
tblQuizAnswer.QuizAnswerID

Insert into @Results

Select
null,null,answer as ''GivenAnswer'',correct,tblQuizAnswerAudit.QuizQuestionID,tblQuizAnswerAudit.QuizAnswerID
From
tblQuizAnswerAudit, tblQuizAnswer
Where
QuizSessionID = @QuizSessionID
And
tblQuizAnswerAudit.QuizAnswerID = tblQuizAnswer.QuizAnswerID
order by
tblQuizAnswerAudit.QuizQuestionID, tblQuizAnswerAudit.QuizAnswerID


SELECT
tblModule.Name as ''Module'',
tblUser.FirstName + '' '' +tblUser.LastName as ''FullName'',
tblQuizSession.QuizScore as ''QuizScore'',
tblQuizSession.QuizPassmark as ''QuizPassmark''
FROM
tblModule
Inner Join
tblQuiz on tblQuiz.ModuleID = tblModule.ModuleID
Inner Join
tblQuizSession on tblQuizSession.QuizID = tblQuiz.QuizID
Inner Join
tblUser on tblUser.UserID = tblQuizSession.UserID
where
tblQuizSession.QuizSessionID = @QuizSessionID

Select
distinct *
from
@Results

order by
QuizQuestionID,
Question desc,
CorrectAnswer,
GivenAnswer
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetSALTAdministrators]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'






/*Summary:
Gets a list of all SALT Administrators.  Restrict to those with
the specified Active status if specified.

Parameters:
@active Bit

Returns:
Nothing

Called By:
User.cs.

Calls:
Nothing

Remarks:

Author: Gavin Buddis
Date Created: 23rd March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE   Procedure [prcUser_GetSALTAdministrators]
(
@requestedByUserID Integer = Null, -- User ID of the currently logged in user
@OrgID int
)

As

Set NoCount On

Select
UserID,
Username,
FirstName,
case
When Active = 0 Then LastName + '' (I)''
Else LastName
End As LastName,
Email,
Active,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @OrgID),
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @OrgID)
From
tblUser
Where
(UserID <> @requestedByUserID)
And (UserTypeID = 1)



' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetTimeZoneBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


CREATE Procedure [prcUser_GetTimeZoneBySessionID]
(
@SessionID varchar(50) 		-- Session ID of the user we are looking for.
)

As

Set NoCount On

-- Declarations
Declare @userID Integer

-- Validation
If (@SessionID Is Null)
Begin
Raiserror(''The Parameter @SessionID was null.  @SessionID does not accept Null values.'', 16, 1)
Return
End

-- Logic
Set @userID= dbo.udfGetUserIDBySessionID(@SessionID)


Select
coalesce(USR.TimeZoneID,ORG.TimeZoneID) as TimeZone
From
tblOrganisation ORG
inner join tblUser USR on ORG.OrganisationID = USR.OrganisationID
inner join tblLessonSession LS on LS.UserID = USR.UserID
WHERE LessonSessionID = ltrim(rtrim(@sessionID))



Select
@UserID as ''UserID''


' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUnassigned]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Returns the users that are not currently assigned to a unit.
This function never returns users who are salt administrators

Parameters: @OrganisationID 	Integer
Returns:
UserID,
First Name,
Last Name,
DateUpdated
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By: User.cs
Calls: Nothing

Remarks: Raises an error if the parameter is null

Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
7. IntegrityConstraintException
10. BusinessServiceException (General)

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

-- prcUser_GetUnassigned 1
*/
CREATE Procedure [prcUser_GetUnassigned]
@OrganisationID 	Integer
AS

Set NoCount On

-- Declarations
Declare @strErrorMessage Varchar(200) 		-- Holds the error message
Declare @intErrorNumber Integer			-- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

-- Validation
If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure prcUser_GetUnassigned''
Goto Finalise
End

-- Logic
Select
UserID,
LastName,
FirstName,
UserName,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @OrganisationID) as DateUpdated
From
tblUser
Where
OrganisationID=@OrganisationID
And
UnitID is null
And
UserTypeID <> 1
order by
LastName,
FirstName
-- Set the error message to successfull
Set @strErrorMessage = ''User successfully selected.''

-- Finalise the procedure
Goto Finalise

Finalise:
If(@intErrorNumber > 0)
Begin
Select
@intErrorNumber 	As ''ErrorNumber'',
@strErrorMessage 	As ''ErrorMessage''
End
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUnitIDByUserID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcUser_GetUnitIDByUserID]
@UserID int
AS

SELECT
UnitID
FROM
tblUser
WHERE
UserID = @UserID
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUnitsTree]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get all units in the specified organisation
1. Preselect the unitID that the user belongs to
2. Expand the unit branch to the unitID that the user belongs to
3. Disable units that the admin user don''t have permission to admin


Returns:
Flat hierarchy table


Called By:
Calls:

Remarks:

Author:
Jack Liu
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcUser_GetUnitsTree 46, 5


**/

CREATE  PROC [prcUser_GetUnitsTree]
(
@userID int,
@adminUserID int
)

AS

set nocount on

declare @intOrganisationID int, @intUnitID int, @strHierarchy varchar(100)
declare @intAdminUserTypeID int

declare @strSelectedUnitIDs varchar(4000)
declare @strExpandedUnitIDs varchar(4000)
declare @strDisabledUnitIDs varchar(4000)

select 	@intOrganisationID = OrganisationID,
@intUnitID = UnitID
from tblUser
where userID = @userID


--1. Preselect the unitID that the user belongs to
set @strSelectedUnitIDs = cast(@intUnitID as varchar)

--2. Expand the unit branch to the unitID that the user belongs to
select @strHierarchy = Hierarchy
from tblUnit
where UnitID = @intUnitID

select 	@strExpandedUnitIDs= isNull(@strExpandedUnitIDs + '','','''')+  cast(tblUnit.unitID as varchar)
from 	tblUnit
where 	(tblUnit.organisationID=@intOrganisationID)
and charindex(tblUnit.hierarchy +'','', @strHierarchy)=1


--3. Disable units that the admin user don''t have permission to admin
select @intAdminUserTypeID = UserTypeID
from tblUser
where userID = @adminUserID

declare  @EnableUnit  table
(
UnitID int
)

--Salt Administrator, Organisation Administrator has permission to access all units
if (@intAdminUserTypeID=1 or @intAdminUserTypeID=2)
begin
insert 	into @EnableUnit(UnitID)
select 	u.UnitID
from 	tblUnit as u
where 	(u.organisationID=@intOrganisationID)
end
--A: Unit Administrator only has permission to those that he is administrator
else
begin
--Get a list of unit id that the user is  the administrator
insert into @EnableUnit(UnitID)
select 	u.UnitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @adminUserID)
where 	(u.organisationID=@intOrganisationID)

end

--Get a list of unit id that the user don''t have permission
select 	@strDisabledUnitIDs= isNull(@strDisabledUnitIDs + '','','''')+ cast(u.unitID as varchar)
from 	tblUnit as u
left join @EnableUnit as eu
on (u.unitID=eu.unitID)
where 	(u.organisationID=@intOrganisationID)
and eu.UnitID is null



exec prcUnit_GetUnitsByOrganisation @intOrganisationID, @strDisabledUnitIDs, @strSelectedUnitIDs,@strExpandedUnitIDs






' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUserForCC]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 18/11/2011
-- Description:	Get the user fields required forr CC list pop up for periodic reports
-- =============================================
CREATE PROCEDURE [prcUser_GetUserForCC] 
	-- Add the parameters for the stored procedure here
	@UserID int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT UserID, FirstName, LastName, UserName, Email
	FROM tblUser WHERE UserID = @UserID
END
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUserIDBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Given a SessionID
return the users  UserID

Parameters
SessionID	Varchar (mandatory)

Returns:
scalar - int - user''s id

Called By:
TooolBookListener.aspx

Calls:
udfGetUserIDBySessionID

Remarks:


Author:
Peter Kneale
Date Created: 9 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


**/


CREATE Procedure [prcUser_GetUserIDBySessionID]
(
@SessionID varchar(50) 		-- Session ID of the user we are looking for.
)

As

Set NoCount On

-- Declarations
Declare @userID Integer

-- Validation
If (@SessionID Is Null)
Begin
Raiserror(''The Parameter @SessionID was null.  @SessionID does not accept Null values.'', 16, 1)
Return
End

-- Logic
Set @userID= dbo.udfGetUserIDBySessionID(@SessionID)

Select
@UserID as ''UserID''
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUserType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Get user type

Role (UserType) Change

A Role change occurs when an administrator''s type changes.
This type of checking should occur at every user initiated event within the system
so that new permissions are enforced as soon as they are applied.
If a Role Change is detected, the administrator should be automatically logged out of the system
and redirected to the login page.

It is used by global.asax, all requests will be checked with data

Returns:  User type

Called By: User.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 18th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcUser_GetUserType]
(
@userID Integer, -- User ID
@userTypeID integer=null output -- User type
)

As
Set NoCount On


Select @userTypeID = UserTypeID
From	tblUser
Where	UserID = @userID


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Import]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Insert/Update the details of tblUser table
Parameters:
@userXML text The XML document containing the User data.
@ID Integer ID of either the Organisation or Unit
@hierachy VarChar(12) hierachy where the call to upload useres was made from. can only be Organisation or Unit.
@userID Integer = null -- ID of user inporting the xmlData
Returns:


Called By:
User.cs
Calls:

Author: Li Zhang
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date		Description

*/

CREATE    Procedure [dbo].[prcUser_Import]
(
@userName nvarchar(200),
@password nvarchar(100),
@firstName nvarchar(200),
@lastName nvarchar(200),
@email nvarchar(255),
@unitID int,
@classificationName nvarchar(100),
@classificationOption nvarchar(100),
@externalID	nvarchar(100),
@archival	int,
@isUpdate bit,
@uniqueField int,
@userID int,
@orgID int,
@NotifyUnitAdmin nvarchar(3),
@NotifyOrgAdmin nvarchar(3),
@ManagerNotification nvarchar(3),
@ManagerToNotify nvarchar(255)
)

As
begin

Set NoCount on

Set Xact_Abort On
Begin Transaction


--Declarations
Declare @uniqueField_Email int
Declare @uniuqeField_Username int

set @uniqueField_Email = 1
set @uniuqeField_Username = 2

declare @t int

--update
IF (@isUpdate = 1)
BEGIN

IF (@uniqueField = @uniqueField_Email)
BEGIN

--select ''debug update unique field email''
update tblUser
set UserName = case when @username =''''  then username else ISNULL(@userName,u.UserName)end,
FirstName = case when @firstname = '''' then FirstName else ISNULL(@firstName, u.FirstName)end,
LastName = case when @lastName =''''  then  lastname else ISNULL(@lastName, u.LastName)end,
Password = case when @password ='''' then Password else ISNULL(@password, u.password)end,
ExternalID = case when @externalid ='''' then externalid when @externalid =''^'' then null else ISNULL(@externalID, u.externalID)end,
UnitID = ISNULL(@unitID, u.UnitID),
Active = Case @archival when 1 then 0 -- archive user = true
when 0 then 1 -- archive user = false
else u.Active end,--remain unchanged
DateArchived = Case @archival when 1 then getutcdate()
when 0 then null
else u.DateArchived end,
NotifyUnitAdmin = case when @NotifyUnitAdmin is null then NotifyUnitAdmin when @NotifyUnitAdmin=''Yes'' then 1 when @NotifyUnitAdmin=''No'' then 0  else NotifyUnitAdmin end,
NotifyOrgAdmin = case when @NotifyOrgAdmin is null then notifyorgadmin  when @NotifyOrgAdmin = ''Yes'' then 1 when @NotifyOrgAdmin = ''No''then 0 else NotifyOrgAdmin end,
NotifyMgr = case when @ManagerNotification is null then NotifyMgr when @ManagerNotification = ''Yes'' then 1 when @ManagerNotification = ''No'' then 0 else NotifyMgr end,
DelinquencyManagerEmail = case when @ManagerToNotify='''' then DelinquencyManagerEmail when @ManagerToNotify = ''^'' then null else @ManagerToNotify end,
DateUpdated = getutcdate(),
UpdatedBy = @userID
FROM tblUser u
WHERE
u.Email = @email
and
u.OrganisationID = @orgID

-- get the userid from the email since it is the unique field
select @t = UserID from tblUser where Email = @email


--select ''debug update complete unique field email''
END

else IF (@uniqueField = @uniuqeField_Username)
BEGIN
--select ''debug update unique field username'' + @userName

update tblUser
set FirstName = case when @firstname = '''' then FirstName else ISNULL(@firstName, u.FirstName)end,
LastName = case when @lastName =''''  then  lastname else ISNULL(@lastName, u.LastName)end,
Password = case when @password ='''' then Password else ISNULL(@password, u.password)end,
ExternalID = case when @externalid ='''' then externalid when @externalid =''^'' then null else ISNULL(@externalID, u.externalID)end,
Email = case when @email ='''' then email else ISNULL(@Email, u.Email)end,
UnitID = ISNULL(@unitID, u.UnitID),
Active = Case @archival when 1 then 0
when 0 then 1
else u.Active end,
DateArchived = Case @archival when 1 then getutcdate()
when 0 then null
else u.DateArchived end,
DateUpdated = getutcdate(),
UpdatedBy = @userID,
NotifyUnitAdmin = case when @NotifyUnitAdmin is null then NotifyUnitAdmin when @NotifyUnitAdmin=''Yes'' then 1 when @NotifyUnitAdmin=''No'' then 0  else NotifyUnitAdmin end,
NotifyOrgAdmin = case when @NotifyOrgAdmin is null then notifyorgadmin  when @NotifyOrgAdmin = ''Yes'' then 1 when @NotifyOrgAdmin = ''No''then 0 else NotifyOrgAdmin end,
NotifyMgr = case when @ManagerNotification is null then NotifyMgr when @ManagerNotification = ''Yes'' then 1 when @ManagerNotification = ''No'' then 0 else NotifyMgr end,
DelinquencyManagerEmail = case when @ManagerToNotify='''' then DelinquencyManagerEmail when @ManagerToNotify = ''^'' then null else @ManagerToNotify end
FROM tblUser u
WHERE
u.Username = @username
and
u.OrganisationID = @orgID

-- get the user id from the user name since it is the key field
select @t = UserID from tblUser where Username = @username

--select ''debug update complete unique field username'' + @userName
END

--select @classificationName as a , @classificationOption as b

if (@classificationName!='''' and @classificationOption !='''')
begin
-- Delete existing userclassifications
--====================================

--select @uniqueField , @uniuqeField_Username

IF (@uniqueField = @uniuqeField_Username)
BEGIN

Delete
From
tblUserClassification
from tblUserClassification uc
join tblUser u on u.UserID = uc.UserID
Where
u.UserName = @userName

--select ''debug deleted classifications username''

-- only insert if its not delete ie is not ''^''
if (@classificationName != ''^'' and @classificationOption != ''^'')
begin
--select ''debug inserting classifications username''
-- insert the updated ones into the database
--===================================================
insert into tblUserClassification
(
UserID,
ClassificationID
)
select UserID, cl.ClassificationID
from
tblClassificationType ct
join tblClassification cl on cl.ClassificationTypeID = ct.ClassificationTypeID and ct.OrganisationID=@orgID
join tblUser on UserName = @userName
where
Value= @classificationOption
and ct.OrganisationID = @orgid
--select ''debug completed inserting classifications username''
end
END

IF (@uniqueField = @uniqueField_Email)
BEGIN
Delete
From
tblUserClassification
from tblUserClassification uc
join tblUser u on u.UserID = uc.UserID
Where
u.Email = @email

--select ''debug deleted classifications email ''

-- only insert if its not delete ie is not ''^''
if (@classificationName != ''^'' and @classificationOption != ''^'')
begin
--select ''debug inserting classifications email''
-- insert the updated ones into the database
--===================================================
insert into tblUserClassification
(
UserID,
ClassificationID
)
select userid, cl.ClassificationID
from
tblClassificationType ct
join tblClassification cl on cl.ClassificationTypeID = ct.ClassificationTypeID and ct.OrganisationID=@orgID
join tblUser on Email = @email
where
Value= @classificationOption
and ct.OrganisationID = @orgid
--select ''debug completed inserting classifications email''
end
END

END


--if @archival = 1 begin
--select ''insert into tblBulkInactiveUsers''
--insert into tblBulkInactiveUsers (UserID)values(@t)
--end
END

-- insert
IF @isUpdate = 0
BEGIN
insert into tblUser
(
Username,
Password,
Firstname,
Lastname,
Email,
ExternalID,
OrganisationID,
UnitID,
CreatedBy,
Active,
DateArchived,
NewStarter,
NotifyUnitAdmin,
NotifyOrgAdmin,
NotifyMgr,
DelinquencyManagerEmail

) values
(
@username,
@password,
@firstname,
@lastname,
@email,
@externalID,
@orgID,
@unitID,
@userID,
case @archival when 1 then 0 else 1 end,
case @archival when 1 then getutcdate() else null end,
1,
case when @NotifyUnitAdmin=''Yes'' then 1 else 0 end ,
case when @NotifyOrgAdmin = ''Yes'' then 1 else 0 end,
case when @ManagerNotification = ''Yes'' then 1 else 0 end,
case when @ManagerToNotify='''' then null else @ManagerToNotify end
)
select @t = UserID from tblUser where Username = @username and Email = @email

--Insert the classification data into the tblUserCalssification table.
Insert Into tblUserClassification
(
UserID,
ClassificationID
)
select
@t,
cls.ClassificationID
From
tblClassificationType As c, tblClassification As cls
where c.Name = @classificationName
And (c.OrganisationID = @orgID)
and cls.ClassificationTypeID = c.ClassificationTypeID
AND cls.Value = @classificationOption
And (cls.Active = 1)


--insert course licencing for the imported user
INSERT INTO tblCourseLicensingUser(CourseLicensingID, UserID)
SELECT 		DISTINCT
tblCourseLicensing.CourseLicensingID,
vwUserModuleAccess.UserID

FROM
tblCourseLicensing
INNER JOIN vwUserModuleAccess ON tblCourseLicensing.CourseID = vwUserModuleAccess.CourseID
AND tblCourseLicensing.OrganisationID = vwUserModuleAccess.OrganisationID
INNER JOIN tblUser ON vwUserModuleAccess.UserID = tblUser.UserID
LEFT OUTER JOIN	tblCourseLicensingUser ON tblUser.UserID = tblCourseLicensingUser.UserID
AND tblCourseLicensing.CourseLicensingID = tblCourseLicensingUser.CourseLicensingID
WHERE
tblCourseLicensing.DateStart <= GETUTCDATE()
AND tblCourseLicensing.DateEnd >= GETUTCDATE()
AND tblCourseLicensingUser.CourseLicensingID IS NULL
AND tblUser.userid = @t


-- Get ProfilePeriodIDs for Organisation
create table #ProfilePeriod
(
ProfilePeriodID int
)

insert into #ProfilePeriod
select ProfilePeriodID
from tblProfilePeriod  pp
join tblprofile p
on pp.profileid = p.profileid
where p.organisationid = @orgID


-- insert user into profileperiodaccess against all profileperiodids
-- for the organisation
insert into tblUserProfilePeriodAccess
select ProfilePeriodID, @t, 0 from #ProfilePeriod

drop table #ProfilePeriod

-- Get Policies for Organisation
create table #Policy
(
PolicyID int
)

insert into #Policy
select PolicyID
from tblPolicy
where OrganisationID = @orgID
and deleted = 0

-- insert user  policy access for all policies associated with organisation
insert into tbluserpolicyaccess (PolicyID, UserID,Granted)
select PolicyID, @t, 0 from #Policy

-- insert user policy acceptance for all policies for this org
insert into tblUserPolicyAccepted (PolicyID, UserID, Accepted)
select PolicyID, @t, 0 from #Policy

drop table #Policy

select @archival as archive

END

commit

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_ImportPreview]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/****** Object:  StoredProcedure [dbo].[prcUser_ImportPreview]    Script Date: 07/15/2008 12:42:55 ******/

/*
Summary: Uploads the details from an XML document to the tblUser table
Parameters:
@userXML text The XML document containing the User data.
@ID Integer ID of either the Organisation or Unit
@hierachy VarChar(12) hierachy where the call to upload useres was made from. can only be Organisation or Unit.
@userID Integer = null -- ID of user inporting the xmlData
Returns:
two Result sets

One: The first result set has the totals for the Upload
Total of Records in the XML File
Total of Successfully Inserted Records
Total of Already Existing Records
Total of  Records with error details

Two: The second result set holds the detail of the records that failed to insert.
RecordNumber
Username
Password
Firstname
Lastname
Email
ExternalID
ClassificationName
ClassificationOption

Called By:
User.cs
Calls:
sp_xml_preparedocument -- system stored procedure to ALTER  an internal representation of the XML document.
sp_xml_removedocument -- system stored procesure to remove the previously created representation of the XML document.

Remarks: The XML document must be well formed otherwise the process will fail.

Process
--1. Get the Organisation ID and unit ID
--2. Get a list of users that will be imported
--3. Data Validation
any other validation???
--4. Insert valid user data to user  and  user classification tables
--5. Get the summary report of the imported users
--6. Get all records with details of errors found in the data records

Author: Peter Vranich
Date Created: 10th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date		Description
#1	Peter Kneale	23/2/04		Changed name from prcImportUsers to prcUser_Import
#2	jack Liu	9/03/04		Reorganize the process and put comments
#3	Peter Kneale	2/12/2004	An empty Extenal ID is now treated as a null value.
#4	Jack Liu	14/09/2005	Validate UnitID, the unitID must be inside the specified organisation
UserName is unique per organisation
#5  Li Zhang	Jul	2008	added unique field for updating existing user data
#5  						the actual function of insert/update to the user data are not perform in this stored procedure
#5							it''s used to prepare preview user data record before importing user data records to tblUser

Test:
exec prcUser_Import @userXMLData = ''<BDWUserUpload><User Username="imported22" Firstname="Imported" Lastname="User1" Email="imported.user1@bdw.com" ExternalID="IU1">
<CustomClassifications><CustomClassification Name="State" Option="NSW"/></CustomClassifications>
</User>
<User Username="imported22" Firstname="Imported" Lastname="User2" Email="imported.user2@bdw.com" ExternalID="IU2">
<CustomClassifications><CustomClassification Name="State" Option="ACT"/></CustomClassifications>
</User></BDWUserUpload>'', @ID = 18, @hierachy = ''Organisation'', @userID = 1100
*/

CREATE    Procedure [prcUser_ImportPreview]
(
	@userXMLData nText = null, 	-- XML document
	@ID Integer = null,		-- ID
	@hierachy nVarChar(12) = null, 	-- hierachy where the call to upload useres was made from.
	--can only be Organisation or Unit.
	@userID Integer = null, 		-- ID of user importing the xmlData
	@uniqueField Integer = null
)

As
Begin

	Set NoCount On

	Set Xact_Abort On
	Begin Transaction


	--Declarations
	-- OrganisationID of the Unit that the Users are being imported too.
	Declare @intOrganisationID Integer
	Declare @intUnitID Integer

	Declare @hdoc Integer 			-- Is the document handle of the internal representation of an XML document.
	Declare @strRowPattern Varchar(19) 	-- The row pattern to be used with the OPENXML statement.
	Declare @intRecordCountTotal Integer 	-- Number of rows inserted
	-- Set the rowpattern for the Openxml statement.
	Set @strRowPattern = ''/BDWUserUpload/User''

	Declare @constant_EmailAddress int
	Declare @constant_UserName int

	set @constant_EmailAddress  = 1
	set @constant_UserName = 2

	--1. Get the Organisation ID and unit ID
	If(@hierachy = ''Unit'')
	Begin
		set @intUnitID = @ID
		-- Get the OrganisationID for this Unit.
		Select
		@intOrganisationID = OrganisationID
		From
		tblUnit
		Where
		UnitID = @ID
	end
	else
		begin
		set @intUnitID = null
		set @intOrganisationID = @ID
	end

	--2. Get a list of users that will be imported
	-- Create a temp table to hold the values from the XML document
	Create Table #xmlUserData
	(
		TempUserID				Integer Identity(1, 1),
		UnitID					int default(null),
		Username				nVarchar(50) COLLATE database_default Not Null,
		Password				nVarchar(50) COLLATE database_default Not Null,
		Firstname				nVarchar(50) COLLATE database_default,
		Lastname				nVarchar(50) COLLATE database_default,
		Email					nVarchar(50) COLLATE database_default  Not Null,
		ExternalID				nVarchar(50) COLLATE database_default,
		ClassificationName		nVarchar(50) COLLATE database_default,
		ClassificationOption	Varchar(50)  COLLATE database_default,
		Status					int  default(Null),-- ErrorFound:1, Updated:2, Added:3
		Reason					varchar(1000)  COLLATE database_default,
		ErrField				varchar(255) default(Null),
		Archive					varchar (1) default(''2''),
		NotifyUnitAdmin			nVarchar(3) COLLATE database_default default(''No''),
		NotifyOrgAdmin			nVarchar(3) COLLATE database_default default(''No''),
		ManagerNotification		nVarchar(3) COLLATE database_default default(''No''),
		ManagerToNotify			nVarchar(50) COLLATE database_default default(null),
		UpdField				varchar(255) default ('''')
	)


	Exec sp_xml_preparedocument @hdoc Output, @userXMLData

	-- Get the records from the XML file and insert them into the temp table.

	Insert Into #xmlUserData
	(
		UnitID,
		Username,
		Password,
		Firstname,
		Lastname,
		Email,
		ExternalID,
		Archive,
		ClassificationName,
		ClassificationOption,
		NotifyUnitAdmin,
		NotifyOrgAdmin,
		ManagerNotification,
		ManagerToNotify
	)
	Select
		*
	From
		OpenXml(@hdoc, @strRowPattern)
	With
	(
		UnitID					int		''@UnitID'',
		Username				nVarchar(50) ''@Username'',
		Password				nVarchar(50) ''@Password'',
		Firstname				nVarchar(50) ''@Firstname'',
		Lastname				nVarchar(50) ''@Lastname'',
		Email					nVarchar(50) ''@Email'',
		ExternalID				nVarchar(50) ''@ExternalID'',
		Archive					nVarchar (1)		''@Archive'',
		ClassificationName		Varchar(50) ''CustomClassifications/CustomClassification/@Name'',
		ClassificationOption	Varchar(50) ''CustomClassifications/CustomClassification/@Option'',
		NotifyUnitAdmin			nVarchar (3)		''@NotifyUnitAdmin'',
		NotifyOrgAdmin			nVarchar (3)		''@NotifyOrgAdmin'',
		ManagerNotification		nVarchar (3)		''@ManagerNotification'',
		ManagerToNotify			nVarchar (50)		''@ManagerToNotify''
	)


	-- Ensure that any values that should be null havent been cast to 0 instead of NULL
	Update
		#xmlUserData
	Set
		UnitID = null
	Where
		UnitID = 0

	Update
		#xmlUserData
	Set
		ErrField = ''''

	--======================================================--
	-- SECURITY												--
	--======================================================--
	Declare @UserType int	-- the type of the user

	-- Get user type
	Select @UserType = UserTypeID from tblUser Where UserID = @UserID

	-- Salt Administrator
	-----------------------------
	--IF (@UserType = 1)
	-- This user is allowed to perform any action


	-- Organisation Administrator
	-----------------------------
	IF (@UserType = 2)
	Begin
		-- See if any units in the temp table are not found in this organisation
		Update
			#xmlUserData
		Set
			Status = 1,
			Reason = ''Reason1'',
			ErrField = '';6''
		Where
			UnitID is not null
			and UnitID not in (select UnitID from tblUnit Where OrganisationID = @intOrganisationID)
	End

	-- Unit Administrator
	IF (@UserType = 3)
	Begin
		-- A table of units that this user can administer
		Create Table #AdministerableUnits
		(
			UnitID int
		)

		-- populate the list
		Insert into
			#AdministerableUnits
		select
			u.UnitID
		from
			tblUnit as u
			inner join tblUnitAdministrator as ua on (u.unitID=ua.unitID) and (ua.userID = @userID)

		-- update rows that arent present in the users list of administerbale units.
		Update
			#xmlUserData
		Set
			Status = 1,
			Reason = ''Reason2'',
			ErrField = #xmlUserData.ErrField + '';6''
		Where
			UnitID is not null
			and
			UnitID not in (select UnitID from #AdministerableUnits)
		
		--check that the unitadmin is not updating the org admin
		
		if @uniqueField= @constant_EmailAddress  
		begin
			-- join on the email address
			update 
				#xmlUserData
			set
				Status= 1,
				Reason = ''Reason2'',
				ErrField = #xmlUserData.ErrField +'';1''
			From
				#xmlUserData
				inner Join tblUser As usr
					On #xmlUserData.Email = usr.Email and usr.UserTypeID <3
		end
		else begin
			-- join on the username
			update 
				#xmlUserData
			set
				Status= 1,
				Reason = ''Reason2'',
				ErrField = #xmlUserData.ErrField +'';1''
			From
				#xmlUserData
				inner Join tblUser As usr
					On #xmlUserData.Username = usr.Username and usr.UserTypeID <3
		end
		
		
		Drop table #AdministerableUnits
	End

	-- Normal User
	if (@UserType = 4)
	Begin
		Select ''Status1'' as ''Status''
		Select *, 0 as ''RecordNumber'' from #xmlUserData
		Rollback
		return
	End
	--======================================================--
	-- SECURITY FINISHED									--
	--======================================================--


	-- Get the total number of records to be processed.
	Set @intRecordCountTotal = @@Rowcount
	if ((select count(1) from #xmlUserData) > 1000)
	Begin
		Select ''Status2'' as ''Status''
		Select *, 0 as ''RecordNumber'' from #xmlUserData
		Rollback
		return
	End
	-- remove the internal representation of the XML Document.
	Exec sp_xml_removedocument @hdoc

	--3. Data Validation

	-- Validate that specified units exist (not active or not in this organisation).
	-- and the unitID must be inside the specified organisation -#4
	Update
		#xmlUserData
	Set
		Status = 1,
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason3'',
		ErrField = '';6''
	Where	
		UnitID is not null
		And
		UnitID not in (select UnitID from tblUnit Where Active=1 and OrganisationID = @intOrganisationID)


	--fields that connot be deleted and have a ^ to be treated as NC

	update 
		#xmlUserData
	set
		--UnitID = case when UnitID=''^'' then '''' else unitid end,
		Username= case when Username = ''^''  or username is null then '''' else Username end,
		Password = case when Password = ''^'' then '''' else password end,
		Firstname= case when Firstname =  ''^'' then '''' else firstname end,
		Lastname = case when Lastname = ''^'' then '''' else lastname end,
		Email = case when Email = ''^'' OR Email IS NULL then '''' else email end,
		Archive = case when Archive = ''^'' then '''' else archive end,
		NotifyUnitAdmin = case when NotifyUnitAdmin = ''^'' then '''' else notifyunitadmin end,
		NotifyOrgAdmin = case when NotifyOrgAdmin  = ''^'' then '''' else NotifyOrgAdmin end,
		ManagerNotification = case when ManagerNotification = ''^'' then '''' else ManagerNotification end
		
	
	
	/*-- if the unique field is email address and its blank then error
	if @uniqueField = @constant_EmailAddress 
	begin
		update 
			#xmlUserData
		set
			Reason = ''Reason10'', -- change this to the correct reason
			Status = 1,
			ErrField  = '';5''
		where Email =''''
	end
	
	
	if @uniqueField = @constant_UserName
	begin 
		update 
			#xmlUserData
		set
			Reason = ''Reason10'', -- change this to the correct reason
			Status = 1,
			ErrField  = '';1''
		where Username =''''
	
	end */
	
	
	-- Get a list of users whose user names already exist
	-- when unique field is username, and username is found in database, update record
	Update
		#xmlUserData
	Set
		Status = CASE @uniqueField 
			WHEN @constant_UserName THEN
				ISNULL(#xmlUserData.Status,2)
			ELSE
				case when usr.email = #xmlUserData.Email then
					ISNULL(#xmlUserData.Status,2)
				else
					1
				end
			END,
		Reason = CASE @uniqueField 
			WHEN @constant_UserName	THEN
				#xmlUserData.Reason
			ELSE
				case when usr.email = #xmlUserData.Email then
					#xmlUserData.Reason
				else
					isNull(#xmlUserData.Reason+''; '','''')+ ''Reason4''
				end
			END,
		ErrField = CASE @uniqueField 
			WHEN @constant_UserName THEN
				#xmlUserData.ErrField
			ELSE
				case when usr.email = #xmlUserData.Email then
					#xmlUserData.ErrField
				else
					#xmlUserData.ErrField+'';1''
				end
			END
	From
		#xmlUserData
		inner Join tblUser As usr
			On #xmlUserData.Username = usr.Username and (usr.OrganisationID = @intOrganisationID or usr.OrganisationID is null)


	-- Get a list of users whose email addresses already exist
	-- Business logic changed:
	--when unique field is email address, and email address is exists, update record
	Update
		#xmlUserData
	Set
		Reason = CASE @uniqueField 
				WHEN @constant_EmailAddress THEN
					case when  (@intOrganisationID = usr.organisationid) then
						#xmlUserData.Reason
					else
						isNull(#xmlUserData.Reason+''; '','''')+ ''Reason5''
					end
				ELSE
					case when #xmlUserData.Email = usr.Email and @intOrganisationID = usr.organisationid then
						#xmlUserData.Reason
					else
						isNull(#xmlUserData.Reason+''; '','''')+ ''Reason5''
					end
				END,
		Status = CASE @uniqueField WHEN @constant_EmailAddress THEN
					case when  (@intOrganisationID = usr.organisationid) then
						ISNULL(#xmlUserData.Status,2)
					else
						1
					end
				ELSE
					case when #xmlUserData.Email = usr.Email and @intOrganisationID = usr.organisationid then
						ISNULL(#xmlUserData.Status,2)
					else
						1
					end
				END,
		ErrField = CASE @uniqueField WHEN @constant_EmailAddress THEN
						case when  (@intOrganisationID = usr.organisationid) then
							#xmlUserData.ErrField
						else
							#xmlUserData.ErrField + '';5''
						end
					ELSE
						case when #xmlUserData.Email = usr.Email and @intOrganisationID = usr.organisationid	then
							#xmlUserData.ErrField
						else
							#xmlUserData.ErrField + '';5''
						end
					END
	From
		#xmlUserData
		inner Join tblUser As usr On #xmlUserData.Email = usr.Email

	--Get a list of users whose user name are duplicated in this batch
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason6'',
		Status = 1,
		ErrField = #xmlUserData.ErrField + '';1''
	From
		#xmlUserData
		inner  join #xmlUserData u2 On #xmlUserData.Username = u2.Username and u2.TempUserID>#xmlUserData.TempUserID

	-- This adds the reason code to the other records with the duplicated user name
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason6'',
		Status = 1,
		ErrField = #xmlUserData.ErrField + '';1''
	From
		#xmlUserData
		inner  join #xmlUserData u2 On #xmlUserData.Username = u2.Username and u2.TempUserID<#xmlUserData.TempUserID 
			and #xmlUserData.TempUserID not in
				(	select u3.TempUserID 
					from #xmlUserData u3
						inner  join #xmlUserData u4 On u3.Username = u4.Username 
									and u4.TempUserID>u3.TempUserID
				)

	--Get a list of users whos username is the same as their password
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason7'',
		Status = 1,
		ErrField = #xmlUserData.ErrField + '';1;2''
	From
		#xmlUserData
	Where
		UserName = Password

	--Get a list of users whose email addresses are duplicated in this batch
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason8'',
		Status = 1,
		ErrField = #xmlUserData.ErrField + '';5''
	From
		#xmlUserData
		inner  join #xmlUserData u2 On #xmlUserData.Email = u2.Email 
					and u2.TempUserID>#xmlUserData.TempUserID
	where #xmlUserData.Email <>''''

	-- This adds the reason code to the other records with the duplicated emails
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason8'',
		Status = 1,
		ErrField = #xmlUserData.ErrField + '';5''
	From
		#xmlUserData
		inner  join #xmlUserData u2 on #xmlUserData.Email = u2.Email and u2.TempUserID<#xmlUserData.TempUserID
					and #xmlUserData.TempUserID not in
						(	select u3.TempUserID 
							from #xmlUserData u3
								inner  join #xmlUserData u4	On u3.Email = u4.Email
										and u4.TempUserID>u3.TempUserID
						)
	where #xmlUserData.Email <>''''


	-- Get a list of users who are missing a first or last name
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason9'',
		Status = 1,
		ErrField = #xmlUserData.ErrField +'';3''
	Where
		len(FirstName) = 0
		and Status <> 2 -- allow empty value with update user

	-- Get a list of users who are missing a first or last name
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason9'',
		Status = 1,
		ErrField = #xmlUserData.ErrField +'';4''
	Where
		len(LastName) = 0
		and Status <> 2 -- allow empty value with update user

	-- check that the archive bit has been set
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason11'',
		Status = 1,
		ErrField = #xmlUserData.ErrField +'';7'',
		Archive = null
	Where
		Archive = 2

	-- Change made for consistancy - see bug ID 269 for further info.
	-- Empty string values for External ID should be NULLs
	UPDATE 
		#xmlUserData
	SET
		[ExternalID]=NULL
	WHERE
		[ExternalID]=''''

	UPDATE 
		#xmlUserData
	SET
		Status = 3
		--Reason = ''Add User''
	WHERE
		Status is null 
		and	Reason is null
		
		
		
	-- flag the fields that have changed using email as unique field (ie email clearly is not being changed)
	if (@uniqueField = @constant_EmailAddress) begin
	

		-- username has changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Username != u.UserName and xd.Username != '''' then xd.UpdField +'';1'' else xd.UpdField end						
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		-- password has changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Password!=u.Password  and xd.password != '''' then xd.UpdField +'';2'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
			
		-- firstname change
		update
			#xmlUserData
		set 
			UpdField = case when xd.Firstname!=u.FirstName  and xd.firstname != '''' then xd.UpdField +'';3'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		-- last name changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Lastname!=u.LastName and xd.lastname != '''' then xd.UpdField +'';4'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		--external id changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.externalid!=u.externalID  and xd.externalid != '''' then xd.UpdField +'';6'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2	
		
		
		-- unit id changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.UnitID!=u.UnitID  and xd.unitid != '''' then xd.UpdField +'';7'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
			
		
		-- archive bit changed	
		update
			#xmlUserData
		set 
			UpdField = case when xd.Archive = u.Active and xd.archive != '''' then xd.UpdField +'';8'' else xd.UpdField end -- if archive 1 then active 0
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		-- user classification type or value has changed
		update
			#xmlUserData
		set 
			UpdField = case when (xd.ClassificationName !=ct.Name) or (xd.ClassificationOption != c.Value)  then xd.UpdField +'';9'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and xd.ErrField is null and xd.Status = 2
			join tblUserClassification uc on uc.UserID = u.UserID
			join tblClassification c on c.ClassificationID = uc.ClassificationID
			join tblClassificationType ct on ct.ClassificationTypeID = c.ClassificationTypeID
			
		
		-- unit admin notification flag has changed
		update
			#xmlUserData
		set 
			UpdField = case when (case when xd.NotifyUnitAdmin =''Yes'' then 1 when xd.NotifyUnitAdmin =''No'' then 0 else '''' end) != u.NotifyUnitAdmin and xd.NotifyUnitAdmin != '''' then xd.UpdField +'';10'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
		-- org admin notification flag has changed
		update
			#xmlUserData
		set 
			UpdField = case when (case when xd.NotifyOrgAdmin= ''Yes'' then 1 when xd.NotifyOrgAdmin =''No'' then 0 else '''' end )!= u.NotifyOrgAdmin and xd.NotifyOrgAdmin != '''' then xd.UpdField +'';11'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
		-- manager notification flag has changed
		update
			#xmlUserData
		set 
			UpdField = case when (case when xd.ManagerNotification = ''Yes'' then 1 when xd.ManagerNotification =''No'' then 0 else '''' end ) != u.NotifyMgr and xd.ManagerNotification != '''' then xd.UpdField +'';12'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
		-- notification managers email has changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.ManagerToNotify != u.DelinquencyManagerEmail and xd.ManagerToNotify != '''' then xd.UpdField +'';13'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
			
		
		
	end
	else if (@uniqueField = @constant_UserName) 
	begin
	
		-- password has changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Password!=u.Password  and xd.password  != '''' then xd.UpdField +'';2'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''') and xd.Status = 2
			
		-- firstname changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Firstname!=u.FirstName and xd.firstname != '''' then xd.UpdField +'';3'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		-- last name changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Lastname!=u.LastName and xd.lastname != ''''  then xd.UpdField +'';4'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		-- email changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Email!=u.Email and xd.email != '''' then xd.UpdField +'';5'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		--external id changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.externalid!=coalesce(u.externalID,'''')  and xd.externalid != '''' then xd.UpdField +'';6'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2	
			
		-- unit id changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.UnitID!=u.UnitID  and xd.unitid != '''' then xd.UpdField +'';7'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
			
		-- archive bit changed	
		update
			#xmlUserData
		set 
			UpdField = case when xd.Archive = u.Active and xd.archive  != '''' then xd.UpdField +'';8'' else xd.UpdField end -- if archive 1 then active 0
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2		
			
		-- user classification type or value has changed
		update
			#xmlUserData
		set 
			UpdField = case when (xd.ClassificationName !=ct.Name) or (xd.ClassificationOption != c.Value)  then xd.UpdField +'';9'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
			join tblUserClassification uc on uc.UserID = u.UserID
			join tblClassification c on c.ClassificationID = uc.ClassificationID
			join tblClassificationType ct on ct.ClassificationTypeID = c.ClassificationTypeID
			
		
		-- unit admin notification flag has changed
		update
			#xmlUserData
		set 
			UpdField = case when (case when xd.NotifyUnitAdmin = ''Yes'' then 1 when xd.NotifyUnitAdmin =''No'' then 0 else '''' end) != u.NotifyUnitAdmin and xd.NotifyUnitAdmin != '''' then xd.UpdField +'';10'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
		-- org admin notification flag has changed
		update
			#xmlUserData
		set 
			UpdField = case when (case when xd.NotifyOrgAdmin = ''Yes'' then 1 when xd.NotifyOrgAdmin =''No'' then 0 else '''' end ) != u.NotifyOrgAdmin and xd.NotifyOrgAdmin != '''' then xd.UpdField +'';11'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
		-- manager notification flag has changed
		update
			#xmlUserData
		set 
			UpdField = case when (case when xd.ManagerNotification = ''Yes'' then 1 when xd.ManagerNotification= ''No'' then 0 else '''' end ) != u.NotifyMgr and xd.ManagerNotification != '''' then xd.UpdField +'';12'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
		-- notification managers email has changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.ManagerToNotify != u.DelinquencyManagerEmail and xd.ManagerToNotify != '''' then xd.UpdField +'';13'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
	end
	
	
	Select
		''Status'' = ''Status5''
		
	Select
		tmp.TempUserID As ''RowNumber'',
		tmp.Username,
		tmp.Password,
		tmp.Firstname,
		tmp.Lastname,
		tmp.Email,
		UnitID,
		tmp.Status,
		tmp.Reason as Reason,
		tmp.ClassificationOption,
		tmp.ClassificationName,
		tmp.ExternalID,
		tmp.ErrField,
		tmp.UpdField,
		tmp.Archive,
		tmp.NotifyUnitAdmin,
		tmp.NotifyOrgAdmin,
		tmp.ManagerNotification,
		tmp.ManagerToNotify
	From
		#xmlUserData As tmp

	drop table #xmlUserData
	commit

	SET ANSI_NULLS ON
END' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Login]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Authenticate user
Password and user status will be checked in the application
Returns:
UserID, User Password, status, UserType, OrgID

Called By: Login.ascx
Calls:

Remarks:
User Password and status are used to authenticate used in the application
UserID, UserType, OrgID, OrgLogo are used as user context. these values will be saved in the form authentication ticket

Author:
Jack Liu
Date Created: 27 Jan 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Jack Liu	14/09/2005		Add domain Name to the organisation
The domain Name is unique to each organisation
if the user name can''t be found in that organisation, search if that user is a salt administrator
prcUser_Login ''Jack'', ''Organisation1.salt.devbdw.com''

prcUser_Login ''SaltAdmin'', ''Organisation1.salt.devbdw.com''


**/

CREATE  PROC [prcUser_Login]
(
@userName  nVARCHAR(50),
@domainName nvarchar(100)
)

AS

set nocount on
if exists (select 1
from tblUser u
inner join tblOrganisation o on u.OrganisationID = o.OrganisationID and o.domainName = @domainName
where (u.username=@userName)
)
begin
select top 1
u.UserID,
u.UserTypeID,
u.Password,
u.Active,
u.OrganisationID,
u.LoginFailCount,
o.Logo,
o.AdvancedReporting,
o.PasswordLockout
from tblUser u
inner join tblOrganisation o on u.OrganisationID = o.OrganisationID and o.domainName = @domainName
where (u.username=@userName)
end
else
begin
select top 1
u.UserID,
u.UserTypeID,
u.Password,
u.Active,
u.OrganisationID,
u.LoginFailCount,
o.Logo,
o.AdvancedReporting,
o.PasswordLockout
from tblUser u
left join tblOrganisation o on u.OrganisationID = o.OrganisationID
where (u.username=@userName) and (u.UserTypeID=1)
end

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_LogLogin]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Logs the fact that a user has successfully logged in.
Returns:
nothing

Called By: Login.ascx
Calls:

Remarks:

Author:
Peter Kneale
Date Created: 17 Jan 2005

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Jack Liu	14/09/2005		Change the UserName parameter to UserID, the user name is not unique after add domain name


prcUser_LogLogin ''Jack''
**/

CREATE  PROC [prcUser_LogLogin]
(
@userID  int
)

AS

set nocount on

Update
tblUser
Set
LastLogin = GETUTCDATE()
where
userID=@userID

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_SaveModuleAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Saves User module access settings

If the Unit Module Access profile is changed however
then the User Module Access profiles will be over-written with the new Unit Module Access profile.

Called By: User.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 17th of February 2004



Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUser_SaveModuleAccess 2, 1, ''1,2''

select * from tblModule


*/

CREATE  Procedure [prcUser_SaveModuleAccess]
(
@userID Int,
@courseID int,
@grantedModuleIDs varchar(500)
)

As

set nocount on

set xact_abort on
Begin Tran

-- Remove existing settings
Delete tblUserModuleAccess
from  tblUserModuleAccess uma
inner join tblModule m
on uma.ModuleID=m.ModuleID
where 	uma.UserID=@userID
and m.courseID = @courseID

--Insert new settings
insert into tblUserModuleAccess
(UserID,
ModuleID,
Granted
)
select @userID,
m.ModuleID,
case
when g.IntValue is null then 0
else 1
end as Granted
From tblModule m
left join dbo.udfCsvToInt(@grantedModuleIDs) as  g
on g.IntValue=m.moduleID
where CourseId= @courseID

--Update course status
Declare @intOldCourseStatus int
Declare @intNewCourseStatus int
Declare @ModuleID int

exec @intOldCourseStatus = prcUserCourseStatus_GetStatus @courseId, @userID
exec @intNewCourseStatus = prcUserCourseStatus_Calculate @courseID, @userID

IF (@intOldCourseStatus = -1) or (@intOldCourseStatus <> @intNewCourseStatus)
BEGIN
--Just need to get one of the modules of the course to pass into prcUserCourseStatus_Insert
set @moduleID = (select top 1 m.moduleId
From tblModule m
left join dbo.udfCsvToInt(@grantedModuleIDs) as  g
on g.IntValue=m.moduleID
where CourseId= @courseID and m.active=1)
EXEC prcUserCourseStatus_Insert @UserID, @ModuleID, @intNewCourseStatus
END

Commit tran

' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Search]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
The procedure will search within the selected Parent Units for those Users whose name contains the entered first and last names.
(If no Parent Units have been selected, the system will search across the whole organisation.)

Returns:
Unit Name
Full pathway

Called By:
Calls:

Remarks:
The searching units will include all children and grandchildren
Only return users that logged on user has permission to see


Author: Gavin Buddis
Date Created: 2 Mar 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Aaron		27/03/2007		@parentUnitIDs modified from Varchar(500)


**/

CREATE  Procedure  [dbo].[prcUser_Search]
(
@organisationID  Int,
@parentUnitIDs  Varchar(max),
@firstName	nVarchar(100),
@lastName	nVarchar(100),
@adminUserID		Int,
@includeInactiveUsers bit
)
As
Set Nocount On

Declare @intUserTypeID Int

Select @intUserTypeID = UserTypeID
From tblUser
Where userID = @adminUserID

--Check Data
If @parentUnitIDs is null
set @parentUnitIDs =''''

If @firstName is null
Set @firstName = ''''

Set @firstName =rtrim(@firstName)

If @lastName is null
Set @lastName = ''''

Set @lastName =rtrim(@lastName)



if (@includeInactiveUsers = 0)
Begin
Select
us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(us.LastLogin as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active

From tblUnit un, tblUser us

Where (un.OrganisationID = @organisationID)
and
(
us.Active=1
)
--0. Join Unit and User tables
and (
un.UnitID = us.UnitID
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
and (
un.UnitID in
(
Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
)
or (@parentUnitIDs='''')
)
--2. User firstname contains the entered text
and (
(firstname like ''%''+ @firstName + ''%'')
or (firstname ='''')
)
--3. User lastname contains the entered text
and (
(lastname like ''%''+ @lastName + ''%'')
or (lastname ='''')
)
--4. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
Order By Name
End
Else
Begin
Select 	us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(us.LastLogin as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active

From tblUnit un, tblUser us

Where (un.OrganisationID = @organisationID)
--0. Join Unit and User tables
and (
un.UnitID = us.UnitID
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
and (
un.UnitID in
(
Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
)
or (@parentUnitIDs='''')
)
--2. User firstname contains the entered text
and (
(firstname like ''%''+ @firstName + ''%'')
or (firstname ='''')
)
--3. User lastname contains the entered text
and (
(lastname like ''%''+ @lastName + ''%'')
or (lastname ='''')
)
--4. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
Order By Name
End
' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_SelectAdminUnitsTree]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE PROC [prcUser_SelectAdminUnitsTree]
(
@userID Integer
)

AS

set nocount on

declare @intOrganisationID int

declare @strSelectedUnitIDs varchar(4000)
declare @strExpandedUnitIDs varchar(4000)
declare @strDisabledUnitIDs varchar(4000)

select 	@intOrganisationID = OrganisationID
from tblUser
where userID = @userID



--1. Get a list of unit id that the user has permission
select 	@strSelectedUnitIDs= isNull(@strSelectedUnitIDs + '','','''')+ cast(u.unitID as varchar)
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@intOrganisationID)


--2. Expand the unit branch to the unitID that has admin permission
select 	@strExpandedUnitIDs= isNull(@strExpandedUnitIDs + '','','''')+  cast(tblUnit.unitID as varchar)
from 	tblUnit
where 	(tblUnit.organisationID=@intOrganisationID)
and exists (select U.UnitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@intOrganisationID)
and charindex(tblUnit.hierarchy +'','', u.hierarchy)=1
) --Get units whose child units can be administered

--select @strExpandedUnitIDs

--3. Disable the whole tree
select 	@strDisabledUnitIDs= isNull(@strDisabledUnitIDs + '','','''')+  cast(u.unitID as varchar)
from 	tblUnit as u
where 	(u.organisationID=@intOrganisationID)


exec prcUnit_GetUnitsByOrganisation @intOrganisationID, '''', @strSelectedUnitIDs,@strExpandedUnitIDs
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcUser_Update] 
(
	@userID Integer = Null,
	@unitID Integer = Null,
	@firstName nvarchar(50) = Null,
	@lastName nvarchar(50) = Null,
	@userName nvarchar(100) = Null,
	@email nvarchar(100) = null,
	@active bit = null,
	@userTypeID Integer = Null,
	@updatedByUserID Integer = Null,
	@dateUpdated datetime = Null,
	@password nvarchar(50) = Null,
	@oldPassword nvarchar(50) = Null,
	@externalID nvarchar(50) = Null,
	@TimeZoneID Integer = Null,
	@DelinquencyManagerEmail nvarchar(100) = Null,
	@NotifyUnitAdmin bit = null,
	@NotifyOrgAdmin bit = null,
@NotifyMgr bit = null,
@EbookNotification bit = 0
)

As BEGIN

	Set NoCount On
	Set Xact_Abort On

	Begin Transaction

	-- Declarations
	Declare @strErrorMessage Varchar(200) -- Holds the error message
	Declare @OrgTimeZone Integer -- Holds the ORG timezone
	Declare @intErrorNumber Integer -- Holds the error number
	Declare @UpdatedByUserTypeID Integer -- Holds the UserTypeID for the Updating user.
	Declare @blnChangePassword bit			-- Boolean value to indentify update of the password
	Declare @strCurrentPassword nvarchar(50) -- Holds the current password in the DB for this user
	Declare @strCurrentUserName nvarchar(100) -- Holds the current username in the DB for this user
	Declare @strCurrentEmail nvarchar(100) -- Holds the current email in the DB for this user
	Declare @organisationID Integer -- Used to set the OrgID to null when updating a SALT Administrator
	Declare @dteCurrentDateUpdated datetime -- Holds the current dateupdated in the DB for this user

	-- Initialise variables
	Set @strErrorMessage = ''''
	Set @intErrorNumber = 0
	Set @blnChangePassword = 0

	-- PARAMETER VALIDATION
	--==============================================================

	-- Verify @UnitID and OrgID
	Select
		@organisationID = OrganisationID
	From
		tblUser
	Where
		UserID = @userID

	--==================================================
	-- If 0 passed in (for a SALT Admin), insert nulls for
	-- Unit and Org IDs
	if (@UnitID = 0)
	begin
		Set @UnitID = null
		Set @OrganisationID = null
	end

	Select
		@OrgTimeZone = TimeZoneID
	From
		tblOrganisation
	Where
		OrganisationID = @OrganisationID

	if (@OrgTimeZone = @TimeZoneID)
	begin
		Set @TimeZoneID = null
	end

	--Missing or Null parameter {0} in stored procedure prcUser_Update
	--Validate Parameter @userID
	If(@userID Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcUser_Update''
		Goto Finalise
	End

	-- If user type is not SALT Administrator, validate parameter @UnitID
	If(@userTypeID <> 1)
	Begin
		If(@unitID Is Null)
		Begin
			Set @intErrorNumber = 5
			Set @strErrorMessage = ''Missing or Null parameter @unitID in stored procedure prcUser_Update''
			Goto Finalise
		End
	End

	--Validate Parameter @firstName
	If(@firstName Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @firstName in stored procedure prcUser_Update''
		Goto Finalise
	End

	--Validate Parameter @lastName
	If(@lastName Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @lastName in stored procedure prcUser_Update''
		Goto Finalise

	End

	--Validate Parameter @userName
	If(@userName Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @userName in stored procedure prcUser_Update''
		Goto Finalise
	End

	--Validate Parameter @email
	If(@email Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @email in stored procedure prcUser_Update''
		Goto Finalise
	End

	--Validate Parameter @active
	If(@active Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure prcUser_Update''
		Goto Finalise
	End

	--Validate Parameter @userTypeID
	If(@userTypeID Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @userTypeID in stored procedure prcUser_Update''
		Goto Finalise
	End

	--Validate Parameter @updatedByUserID
	If(@updatedByUserID Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @updatedByUserID in stored procedure prcUser_Update''
		Goto Finalise
	End

	--Validate Parameter @dateUpdated
	If(@dateUpdated Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @dateUpdated in stored procedure prcUser_Update''
		Goto Finalise
	End

	-- Validate User Exists
	--=========================================================
	If Not Exists(Select * From tblUser Where UserID = @userID)
	Begin
		Set @intErrorNumber = 1
		Set @strErrorMessage = ''This record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''
		Goto Finalise
	End

	-- If a unit was specified make sure it exists
	--=========================================================
	If (@unitID Is Not Null)
	Begin
		If Not Exists(Select * From tblUnit Where UnitID = @unitID)
		Begin
			Set @intErrorNumber = 11
			Set @strErrorMessage = ''The specified unit could be found or may not be active.''
			Goto Finalise
		End
	End

	-- Integrity Constraint
	--=========================================================
	Select
		@dteCurrentDateUpdated = DateUpdated
	from
		tblUser
	Where
		UserID = @userID


	/*If (DateDiff(s, @dteCurrentDateUpdated, @dateUpdated) <> 0)
	Begin
	Set @intErrorNumber = 7
	Set @strErrorMessage = ''This record has already been updated by another user, please refresh your screen. If the problem persists please contact your administrator.''
	Goto Finalise
	End */


	-- Validate Passwords
	--=======================

	-- get Updating User, UserTypeID
	Select
		@UpdatedByUserTypeID = UserTypeID
	from
		tblUser
	Where
		UserID = @updatedByUserID

	if(@UpdatedByUserTypeID = 4)
	Begin

		-- SALT User
		If (@password Is Not Null or @oldPassword Is Not Null)
		Begin
			If(@password Is Null)
			Begin
				Set @intErrorNumber = 5
				Set @strErrorMessage = ''Missing or Null parameter @password in stored procedure prcUser_Update''
				Goto Finalise
			End

			If(@oldPassword Is Null)
			Begin
				Set @intErrorNumber = 5
				Set @strErrorMessage = ''Missing or Null parameter @oldPassword in stored procedure prcUser_Update''
				Goto Finalise
			End

			-- Get the current password in the DB
			Select
				@strCurrentPassword = Password
			From
				tblUser
			Where
				UserID = @userID

			-- Ensure old password match current password otherwise error
			if(@oldPassword <> @strCurrentPassword)
			Begin
				Set @intErrorNumber = 4
				Set @strErrorMessage = ''Your old password was entered incorrectly so the user details have not been saved. ''
				Set @strErrorMessage = @strErrorMessage + ''Please try again and if the problem persists please contact your administrator.''
				Goto Finalise
			End

			Set @blnChangePassword = 1
		End
	End
	else
	Begin
		-- Administrator
		-- if there is a value in @oldPassword then admin is attempting to update their own password
		if(@oldPassword Is Not Null)
			Begin
			-- Get the current password in the DB
			Select
				@strCurrentPassword = Password
			From
				tblUser
			Where
				UserID = @userID

			-- Ensure old password match current password otherwise error
			if(@oldPassword <> @strCurrentPassword)
			Begin
				Set @intErrorNumber = 4
				Set @strErrorMessage = ''Your old password was entered incorrectly so the user details have not been saved. ''
				Set @strErrorMessage = @strErrorMessage + ''Please try again and if the problem persists please contact your administrator.''
				Goto Finalise
			End

			Set @blnChangePassword = 1
		End

		If(@password Is Not Null)
		Begin
			Set @blnChangePassword = 1
		End
	End

	-- Validate Permisions
	--========================================
	if(@UpdatedByUserTypeID = 4)
	Begin
	-- Salt User can only update themselves
	if(@UpdatedByUserID <> @UserID)
	Begin
	Set @intErrorNumber = 41
	Set @strErrorMessage = ''You do not have the permissions required to update this user.''
	Goto Finalise
	End
	End


	-- Validate Unique UserName
	--========================================
	Select
	@strCurrentUserName = UserName
	From
	tblUser
	Where
	UserID = @userID

	-- Check for uniqueness if the username is changing
	if(@strCurrentUserName <> @userName)
	Begin
	If(@userTypeID <> 1)
	begin
	if Exists(Select * from tblUser where UserName = @userName and (organisationID=@organisationID or organisationID is null))
	Begin
	Set @intErrorNumber = 42
	Set @strErrorMessage = @userName
	Goto Finalise
	End
	end
	else
	begin
	if Exists(Select * from tblUser where UserName = @userName)
	Begin
	Set @intErrorNumber = 42
	Set @strErrorMessage = @userName
	Goto Finalise
	End
	end
	End


	-- Validate Unique UserName
	--========================================
	Select
	@strCurrentEmail = Email
	From
	tblUser
	Where
	UserID = @userID

	-- Check for uniqueness if the email address is changing
	if(@strCurrentEmail <> @email)
	If Exists(Select * From tblUser Where Email = @email)
	Begin
	Set @intErrorNumber = 43
	Set @strErrorMessage = @email
	Goto Finalise
	End


	-- only update if the user is moved to a new unit (so new unit is diff from the current unit)
	if (select unitid from tblUser where userid=@userid) <> @unitid
	begin


	-- update the profile access of the user
	-- give the user access to profiles for the selected unit
	update tbluserprofileperiodaccess set granted = 1
	where	userid = @userid
	and profileperiodid in (
	select profileperiodid from tblunitprofileperiodaccess where
	unitid = @unitID and granted = 1)

	-- give the user access to the policies for the selected unit.
	/*update tbluserpolicyaccess set granted = 1
	where	userid = @userid
	and policyid in (
	select policyid from tblunitpolicyaccess where
	unitid = @unitID and granted = 1)*/

	update upa1
	set upa1.granted = upa2.granted
	from tbluserpolicyaccess upa1
	inner join tblunitpolicyaccess upa2
	on upa1.policyid=upa2.policyid
	inner join tblPolicy p
	on upa1.policyid=p.policyid
	where
	upa1.userid=@userid and upa2.unitid=@unitid
	and p.deleted=0

	end



	-- Execute Update
	--===============================================================
	-- Update the record in tblUser
	if(@blnChangePassword = 1)
	Begin
		-- Update with password change
		Update 
			tblUser
		Set
			FirstName = @firstName,
			LastName = @lastName,
			UserName = @userName,
			Password = @password,
			Email = @email,
			OrganisationID = @organisationID,
			UnitID = @unitID,
			UserTypeID = @userTypeID,
			Active = @active,
			UpdatedBy = @updatedByUserID,
			DateUpdated = getutcDate(),
			ExternalID = @externalID,
			TimeZoneID = @TimeZoneID,
			DelinquencyManagerEmail = @DelinquencyManagerEmail,
			NotifyMgr = @NotifyMgr,
			NotifyOrgAdmin = @NotifyOrgAdmin,
NotifyUnitAdmin =@NotifyUnitAdmin,
EbookNotification = @EbookNotification
		Where
			UserID = @userID
	End
	Else
	Begin
		Update 
			tblUser
		Set
			FirstName = @firstName,
			LastName = @lastName,
			UserName = @userName,
			Email = @email,
			UnitID = @unitID,
			UserTypeID = @userTypeID,
			Active = @active,
			UpdatedBy = @updatedByUserID,
			DateUpdated = getutcDate(),
			ExternalID = @externalID,
			TimeZoneID = @TimeZoneID,
			DelinquencyManagerEmail = @DelinquencyManagerEmail,
			NotifyMgr = @NotifyMgr,
			NotifyOrgAdmin = @NotifyOrgAdmin,
NotifyUnitAdmin =@NotifyUnitAdmin,
EbookNotification = @EbookNotification
		Where
			UserID = @userID
	End


	update tblUser set DateArchived = getutcdate() where Active = 0 and DateArchived IS NULL AND UserID = @userID
	update tblUser set DateArchived = null where Active = 1 and NOT(DateArchived IS NULL) AND UserID = @userID


	-- update the user current status
	/*declare courseIDCursor cursor
	for
	select
	grantedcourseid
	from
	tblOrganisationCourseAccess oca
	where
	organisationid = (select organisationid from tblUser where userid=@userid)


	-- update course status for users
	declare @intOldCourseStatus int
	declare @intNewCourseStatus int
	declare @courseID int
	declare @moduleID int


	open courseIDCursor

	fetch next from courseIDCursor into @courseid
	while (@@FETCH_STATUS <> -1)
	begin
	if (@@FETCH_STATUS <> -2)
	begin
	exec @intOldCourseStatus = prcUserCourseStatus_GetStatus @courseID, @userID
	exec @intNewCourseStatus = prcUserCourseStatus_Calculate @courseID, @userID

	--select * from tbluser where userid=@userid

	--select * from tblUsercoursestatus where userid=@userid and courseid=@courseid

	print ''CourseID: '' + convert(varchar(10), @courseid)
	print ''Old Course Status : '' + convert(varchar(10), @intOldCourseStatus)
	print ''New Course Status : '' + convert(varchar(10), @intNewCourseStatus)

	if (@intOldCourseStatus <> -1) and (@intOldCourseStatus <> @intNewCourseStatus)
	begin
	print ''Insert''

	set @moduleID = (select top 1 m.moduleId from tblModule m where CourseID = @courseID and  and m.active = 1)  --prcUserCourseStatus_Insert will not update if module is inactive
	--print ''ModuleID: '' + convert(varchar(10), @moduleid)  + ''\n''
	exec prcUserCourseStatus_Insert @userID, @ModuleID, @intNewCourseStatus
	end
	end

	fetch next from courseIDCursor into @courseid
	end

	close courseIDCursor deallocate courseIDCursor*/



	-- Set the error message to successfull
	Set @strErrorMessage = ''Successfully Updated''

	-- Finalise the procedure
	Goto Finalise


	Finalise:
	If(@intErrorNumber > 0)
	Begin
	Rollback Transaction
	Select
	@intErrorNumber As ''ErrorNumber'',
	@strErrorMessage As ''ErrorMessage''
	End
	Else
	Begin
	Commit Transaction
	Select
	@intErrorNumber As ''ErrorNumber'',
	@strErrorMessage As ''ErrorMessage''
	End
END

' 
END
GO


SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_UsernameSearch]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
The procedure will search within the selected Parent Units for those Users whose name contains the entered first and last names.
(If no Parent Units have been selected, the system will search across the whole organisation.)

Returns:
Unit Name
Full pathway

Called By:
Calls:

Remarks:
The searching units will include all children and grandchildren
Only return users that logged on user has permission to see


Author: Gavin Buddis
Date Created: 2 Mar 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Li Zhang	4/4/2006		Added search on username function
#2	VDL			26 Sep 2008		Add Search on email field / add boolean logic for include inactive users


**/

CREATE  Procedure  [prcUser_UsernameSearch]
(
@organisationID  Int,
@parentUnitIDs  Varchar(500),
@firstName	nVarchar(100),
@lastName	nVarchar(100),
@userName   nVarchar(200),
@userEmail	nvarchar(300),
@userID		int = 0,
@adminUserID		Int,
@includeInactiveUsers bit
)
As
Set Nocount On

Declare @intUserTypeID Int

Select @intUserTypeID = UserTypeID
From tblUser
Where userID = @adminUserID

--Check Data
If @parentUnitIDs is null
set @parentUnitIDs =''''

If @firstName is null
Set @firstName = ''''

Set @firstName =rtrim(@firstName)

If @lastName is null
Set @lastName = ''''

Set @lastName =rtrim(@lastName)

If @userName is null
Set @userName = ''''

Set @userName = rtrim(@userName)

if @userEmail is null
Set @userEmail =''''

Select
us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(dbo.udfUTCtoDaylightSavingTime(us.LastLogin,@OrganisationID) as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active

From tbluser us
join tblunit un on us.unitid = un.unitid

Where (us.OrganisationID = @organisationID)
and
(
us.Active= case when @includeInactiveUsers=0 then 1 else us.active end
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
and (
un.UnitID in
(
Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
)
or (@parentUnitIDs='''')
)
--2. User firstname contains the entered text
and (
(us.firstname like ''%''+ @firstName + ''%'')
or (us.firstname ='''')
)
--3. User lastname contains the entered text
and (
(us.lastname like ''%''+ @lastName + ''%'')
or (us.lastname ='''')
)
--4. User username contains the entered text
and (
(us.UserName like ''%'' + @userName + ''%'')
or (us.UserName ='''')
)
--4.5 User Email Address is the entered text
and (
(us.email like ''%'' + @userEmail + ''%'')
or (@useremail ='''')
)
--5. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
-- 6. User ID
and (
(@userid != 0 and us.userid = @userid ) or (@userid = 0 and us.userid > 0)
)


Order By Name' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcVersion_Get]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Get the current product version

Parameters:


Returns:
None

Called By:
Database Configuration

Calls:
None

Remarks:

Author: Jack Liu
Date Created: 8/March/2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


*/

CREATE procedure [prcVersion_Get]
as
set nocount on

select version from tblVersion


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcVersion_Set]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Set the product version with version ID

Parameters:


Returns:
None

Called By:
Database Configuration

Calls:
None

Remarks:

Author: Jack Liu
Date Created: 8/March/2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


*/

CREATE procedure [prcVersion_Set]
(
@version varchar(50)
)
as
set nocount on

update tblVersion
set version =@version


' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prc_ADMIN_LessonPageAuditPagesVisited]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'create proc [prc_ADMIN_LessonPageAuditPagesVisited]

@OrgID int

as

select
left(tblOrganisation.OrganisationName, 25) as [Org Name]
, left(tblUser.Firstname + '' '' + tblUser.LastName, 25) as [username]
, left(tblCourse.Name + ''/'' + tblModule.Name, 65) as [Course / Module]
, left(tblLessonPage.ToolbookPageID + ''/'' + tblLessonPage.Title, 50) [Page id / name]
, dbo.udfUTCtoDaylightSavingTime(tblLessonPageAudit.DateAccessed, @OrgID)
From
tblLessonPageAudit
inner join .tblLessonSession on tblLessonPageAudit.LessonSessionID = tblLessonSession.LessonSessionID
inner join tblUser on tblLessonSession.UserID = tblUser.userID
inner join tblOrganisation on tblOrganisation.OrganisationID = tblUser.OrganisationID
inner join tblLessonPage on tblLessonPage.LessonPageID = tblLessonPageAudit.LessonPageID
inner join tblLesson on tblLesson.LessonID = .tblLessonPage.LessonID
inner join tblModule on tblModule.moduleid = tblLesson.moduleID
inner join tblCourse on tblModule.courseid = tblCourse.courseid
where
tblLessonSession.dATEtIMECompleted > ''2004-11-23''
and tblOrganisation.OrganisationID <> 8
order by tblOrganisation.OrganisationName, tblUser.LastName, tblLessonSession.LessonSessionID desc

' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prc_cpu_percent]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prc_cpu_percent]


AS
BEGIN

DECLARE @CPU_percent int

DECLARE @CPU_BUSY int, @IDLE int
SELECT @CPU_BUSY = @@CPU_BUSY, @IDLE = @@IDLE WAITFOR DELAY ''000:00:01''
SET @CPU_percent = (@@CPU_BUSY - @CPU_BUSY)/((@@IDLE - @IDLE + @@CPU_BUSY - @CPU_BUSY) *1.00) *100

SELECT @CPU_percent
RETURN @CPU_percent

END
' 
END
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[ReassignReportInactive]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 14/12/2011
-- Description:	Reassigns owner or cc for the periodic report
-- =============================================
CREATE PROCEDURE [ReassignReportInactive] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int = 0, 
	@FromUser int = 0,
	@ToUser int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF EXISTS (SELECT * FROM tblReportSchedule 
		WHERE ScheduleID = @ScheduleId AND UserID = @FromUser)
	BEGIN
		UPDATE tblReportSchedule SET UserID = @ToUser
			WHERE ScheduleID = @ScheduleId
	END
	
	IF EXISTS (SELECT * FROM tblCCList
		WHERE ScheduleId = @ScheduleId AND UserID = @FromUser)
	BEGIN
		UPDATE tblCCList SET UserID = @ToUser
			WHERE ScheduleID = @ScheduleId
	END
	
END
' 
END
GO



