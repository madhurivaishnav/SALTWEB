IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID('DF_tblOrganisation_DelinquencyPeriod') AND type = 'D')
BEGIN
ALTER TABLE dbo.tblOrganisation
	DROP CONSTRAINT DF_tblOrganisation_DelinquencyReminderPeriod
END
GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID('DF_tblOrganisation_DelinquencyPeriod') AND type = 'D')
BEGIN
ALTER TABLE dbo.tblOrganisation
	DROP CONSTRAINT DF_tblOrganisation_DelinquencyPeriod
END
GO


IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID('DF_tblOrganisation_NumberOfReminders') AND type = 'D')
BEGIN
ALTER TABLE dbo.tblOrganisation
	DROP CONSTRAINT DF_tblOrganisation_NumberOfReminders
END
GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID('DF_tblOrganisation_DaysWarningBeforeExpiry') AND type = 'D')
BEGIN
ALTER TABLE dbo.tblOrganisation
	DROP CONSTRAINT DF_tblOrganisation_DaysWarningBeforeExpiry
END
GO


IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID('DF__tblOrgani__WarnM__2DE868C6') AND type = 'D')
BEGIN
ALTER TABLE dbo.tblOrganisation
	DROP CONSTRAINT DF__tblOrgani__WarnM__2DE868C6
END
GO


IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID('DF__tblOrgani__WarnU__2EDC8CFF') AND type = 'D')
BEGIN
ALTER TABLE dbo.tblOrganisation
	DROP CONSTRAINT DF__tblOrgani__WarnU__2EDC8CFF
END
GO


IF EXISTS( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'tblOrganisation' 
		AND  COLUMN_NAME = 'DelinquencyPeriod')
BEGIN
ALTER TABLE dbo.tblOrganisation
	DROP COLUMN DelinquencyPeriod
END
GO

IF EXISTS( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'tblOrganisation' 
		AND  COLUMN_NAME = 'DelinquencyReminderPeriod')
BEGIN
ALTER TABLE dbo.tblOrganisation
	DROP COLUMN  DelinquencyReminderPeriod
END
GO
IF EXISTS( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'tblOrganisation' 
		AND  COLUMN_NAME = 'NumberOfReminders')
BEGIN
ALTER TABLE dbo.tblOrganisation
	DROP COLUMN  NumberOfReminders
END
GO
IF EXISTS( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'tblOrganisation' 
		AND  COLUMN_NAME = 'DaysWarningBeforeExpiry')
BEGIN
ALTER TABLE dbo.tblOrganisation
	DROP COLUMN  DaysWarningBeforeExpiry
END
GO

SET QUOTED_IDENTIFIER ON
GO
IF EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUpdateOrgDeliquency]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra
-- Create date: 17/06/2011
-- Description:	Update Delinquency settings for Organisation
-- =============================================
ALTER PROCEDURE [prcUpdateOrgDeliquency]

@OrgID int,
@WarnMgrsofDeliquentUsers bit,
@WarnUsersofDelinquency bit,
@NumberOfReminders int,
@DelinquencyPeriod int,
@DelinquencyReminderPeriod int,
@DaysWarningBeforeExpiry int,
@IncludeLogo bit,
@QuizDueDate datetime

AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

UPDATE tblOrganisation SET --WarnMgrsofDeliquentUsers = @WarnMgrsofDeliquentUsers,
--WarnUsersofDelinquency = @WarnUsersofDelinquency,
--NumberOfReminders = @NumberOfReminders,
--DelinquencyPeriod = @DelinquencyPeriod,
--DelinquencyReminderPeriod = @DelinquencyReminderPeriod,
--DaysWarningBeforeExpiry = @DaysWarningBeforeExpiry,
IncludeLogoOnCorrespondence = @IncludeLogo,
QuizDueDate = @QuizDueDate
WHERE OrganisationID = @OrgID
END
' 
END
GO

DECLARE @OrgConstraint nvarchar(100)
SELECT @OrgConstraint = name FROM dbo.sysobjects WHERE name like 'DF__tblOrgani__WarnM%' and type = 'D'
IF (@OrgConstraint != '')
BEGIN
SET @OrgConstraint = 'ALTER TABLE dbo.tblOrganisation DROP CONSTRAINT ' +@OrgConstraint
EXEC dbo.sp_executesql @statement =  @OrgConstraint

END
GO

DECLARE @OrgConstraint nvarchar(100)
SELECT @OrgConstraint = name FROM dbo.sysobjects WHERE name like 'DF__tblOrgani__WarnU%' and type = 'D'
IF (@OrgConstraint != '')
BEGIN
SET @OrgConstraint = 'ALTER TABLE dbo.tblOrganisation DROP CONSTRAINT ' +@OrgConstraint
EXEC dbo.sp_executesql @statement =  @OrgConstraint

END
GO


IF EXISTS( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'tblOrganisation' 
		AND  COLUMN_NAME = 'WarnMgrsofDeliquentUsers')
BEGIN
ALTER TABLE dbo.tblOrganisation
	DROP COLUMN  WarnMgrsofDeliquentUsers
END
GO

IF EXISTS( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'tblOrganisation' 
		AND  COLUMN_NAME = 'WarnUsersofDelinquency')
BEGIN
ALTER TABLE dbo.tblOrganisation
	DROP COLUMN  WarnUsersofDelinquency
END
GO



DELETE FROM tblOrganisationConfig WHERE [Name] = 'Course_Completion_Certificate'
GO

INSERT INTO tblOrganisationConfig
           ([OrganisationID]
           ,[Name]
           ,[Description]
           ,[Value])
     VALUES
           (null
           ,'Course_Completion_Certificate'
           ,'Course Completion Certificate'
           ,'Congratulations %FirstName% %LastName% on passing the %APP_NAME%  %COURSE% , your completion certificate is attached or may be reprinted from the website at %URL%.')
GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_ReportStartDate]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] DROP CONSTRAINT [DF_tblReportSchedule_ReportStartDate]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_ReportTitle]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] DROP CONSTRAINT [DF_tblReportSchedule_ReportTitle]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_ParamLangCode]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] DROP CONSTRAINT [DF_tblReportSchedule_ParamLangCode]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF__tblReport__Param__082CD432]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] DROP CONSTRAINT [DF__tblReport__Param__082CD432]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_ParamProfilePeriodID]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] DROP CONSTRAINT [DF_tblReportSchedule_ParamProfilePeriodID]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_IsPeriodic]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] DROP CONSTRAINT [DF_tblReportSchedule_IsPeriodic]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_LastUpdatedBy]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] DROP CONSTRAINT [DF_tblReportSchedule_LastUpdatedBy]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_LastUpdated]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] DROP CONSTRAINT [DF_tblReportSchedule_LastUpdated]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_NumberDelivered]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] DROP CONSTRAINT [DF_tblReportSchedule_NumberDelivered]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_TerminatedNormally]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] DROP CONSTRAINT [DF_tblReportSchedule_TerminatedNormally]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_DateCreated]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] DROP CONSTRAINT [DF_tblReportSchedule_DateCreated]
END

GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[tblReportSchedule]') AND type in (N'U'))
DROP TABLE [tblReportSchedule]
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[tblReportSchedule]') AND type in (N'U'))
BEGIN
CREATE TABLE [tblReportSchedule](
	[ScheduleID] [int] IDENTITY(1,1) NOT NULL,
	[UserID] [int] NOT NULL,
	[ReportID] [int] NOT NULL,
	[LastRun] [datetime] NULL,
	[NextRun] [datetime] NULL,
	[ReportDuration] [int] NULL,
	[ReportDurationPeriod] [char](1) NULL,
	[ReportStartDate] [datetime] NOT NULL,
	[ReportEndDate] [datetime] NULL,
	[NumberOfReports] [int] NULL,
	[ReportFrequency] [int] NULL,
	[ReportFrequencyPeriod] [char](1) NULL,
	[DocumentType] [char](1) NOT NULL,
	[ReportTitle] [nvarchar](100) NOT NULL,
	[ParamOrganisationID] [int] NOT NULL,
	[ParamCompleted] [char](1) NULL,
	[ParamStatus] [char](1) NULL,
	[ParamFailCount] [int] NULL,
	[ParamCourseIDs] [nvarchar](800) NULL,
	[ParamHistoricCourseIDs] [nvarchar](800) NULL,
	[ParamAllUnits] [char](1) NULL,
	[ParamTimeExpired] [int] NULL,
	[ParamTimeExpiredPeriod] [char](1) NULL,
	[ParamQuizStatus] [char](1) NULL,
	[ParamGroupBy] [char](1) NULL,
	[ParamGroupingOption] [int] NULL,
	[ParamFirstName] [nvarchar](200) NULL,
	[ParamLastName] [nvarchar](200) NULL,
	[ParamUserName] [nvarchar](200) NULL,
	[ParamEmail] [nvarchar](200) NULL,
	[ParamIncludeInactive] [char](1) NULL,
	[ParamSubject] [nvarchar](200) NULL,
	[ParamBody] [nvarchar](200) NULL,
	[ParamProfileID] [int] NULL,
	[ParamOnlyUsersWithShortfall] [char](1) NULL,
	[ParamEffectiveDate] [datetime] NULL,
	[ParamSortBy] [char](1) NULL,
	[ParamClassificationID] [int] NULL,
	[ParamUnitIDs] [nvarchar](max) NULL,
	[ParamLangCode] [nvarchar](10) NULL,
	[ParamDateTo] [datetime] NULL,
	[ParamDateFrom] [datetime] NULL,
	[ParamLicensingPeriod] [varchar](8000) NULL,
	[ParamProfilePeriodID] [int] NOT NULL,
	[ReportPeriodType] [int] NULL,
	[ReportFromDate] [datetime] NULL,
	[IsPeriodic] [char](1) NOT NULL,
	[LastUpdatedBy] [int] NULL,
	[LastUpdated] [datetime] NULL,
	[NumberDelivered] [int] NOT NULL,
	[TerminatedNormally] [bit] NULL,
	[ParamPolicyIDs] [nvarchar](4000) NULL,
	[ParamAcceptance] [varchar](20) NULL,
	[DateCreated] [datetime] NOT NULL,
 CONSTRAINT [PK_tblReportSchedule] PRIMARY KEY CLUSTERED 
(
	[ScheduleID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
END
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[TRGReportScheduleAuditDelete]'))
EXEC dbo.sp_executesql @statement = N'CREATE TRIGGER [TRGReportScheduleAuditDelete]
   ON  [tblReportSchedule] 
   AFTER  DELETE
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
INSERT INTO tblReportScheduleAudit
           ([ScheduleID]
		   ,[UserID]
           ,[ReportID]
           ,[LastRun]
           ,[NextRun]
           ,[ReportDuration]
           ,[ReportDurationPeriod]
           ,[ReportStartDate]
           ,[ReportEndDate]
           ,[NumberOfReports]
           ,[ReportFrequency]
           ,[ReportFrequencyPeriod]
           ,[DocumentType]
           ,[ReportTitle]
           ,[ParamOrganisationID]
           ,[ParamCompleted]
           ,[ParamStatus]
           ,[ParamFailCount]
           ,[ParamCourseIDs]
           ,[ParamHistoricCourseIDs]
           ,[ParamAllUnits]
           ,[ParamTimeExpired]
           ,[ParamTimeExpiredPeriod]
           ,[ParamQuizStatus]
           ,[ParamGroupBy]
           ,[ParamGroupingOption]
           ,[ParamFirstName]
           ,[ParamLastName]
           ,[ParamUserName]
           ,[ParamEmail]
           ,[ParamIncludeInactive]
           ,[ParamSubject]
           ,[ParamBody]
           ,[ParamProfileID]
           ,[ParamOnlyUsersWithShortfall]
           ,[ParamEffectiveDate]
           ,[ParamSortBy]
           ,[ParamClassificationID]
           ,[ParamUnitIDs]
           ,[ParamLangCode]
           ,[ParamDateTo]
           ,[ParamDateFrom]
           ,[ParamLicensingPeriod]
           ,[ParamProfilePeriodID]
           ,[ReportPeriodType]
           ,[ReportFromDate]
           ,[IsPeriodic]
           ,[LastUpdatedBy]
           ,[LastUpdated]
           ,[NumberDelivered]
           ,[TerminatedNormally]
           ,[LastUpdAction]
         ,DateCreated  )
SELECT [ScheduleID]
      ,[UserID]
      ,[ReportID]
      ,[LastRun]
      ,[NextRun]
      ,[ReportDuration]
      ,[ReportDurationPeriod]
      ,[ReportStartDate]
      ,[ReportEndDate]
      ,[NumberOfReports]
      ,[ReportFrequency]
      ,[ReportFrequencyPeriod]
      ,[DocumentType]
      ,[ReportTitle]
      ,[ParamOrganisationID]
      ,[ParamCompleted]
      ,[ParamStatus]
      ,[ParamFailCount]
      ,[ParamCourseIDs]
      ,[ParamHistoricCourseIDs]
      ,[ParamAllUnits]
      ,[ParamTimeExpired]
      ,[ParamTimeExpiredPeriod]
      ,[ParamQuizStatus]
      ,[ParamGroupBy]
      ,[ParamGroupingOption]
      ,[ParamFirstName]
      ,[ParamLastName]
      ,[ParamUserName]
      ,[ParamEmail]
      ,[ParamIncludeInactive]
      ,[ParamSubject]
      ,[ParamBody]
      ,[ParamProfileID]
      ,[ParamOnlyUsersWithShortfall]
      ,[ParamEffectiveDate]
      ,[ParamSortBy]
      ,[ParamClassificationID]
      ,[ParamUnitIDs]
      ,[ParamLangCode]
      ,[ParamDateTo]
      ,[ParamDateFrom]
      ,[ParamLicensingPeriod]
      ,[ParamProfilePeriodID]
      ,[ReportPeriodType]
      ,[ReportFromDate]
      ,[IsPeriodic]
      ,[LastUpdatedBy]
      ,[LastUpdated]
      ,[NumberDelivered]
      ,[TerminatedNormally]
      ,''D''
     ,DateCreated 
  FROM  deleted

END
' 
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[TRGReportScheduleAuditInsert]'))
EXEC dbo.sp_executesql @statement = N'CREATE TRIGGER [TRGReportScheduleAuditInsert]
   ON  [tblReportSchedule] 
   AFTER  INSERT
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
INSERT INTO tblReportScheduleAudit
           ([ScheduleID]
		   ,[UserID]
           ,[ReportID]
           ,[LastRun]
           ,[NextRun]
           ,[ReportDuration]
           ,[ReportDurationPeriod]
           ,[ReportStartDate]
           ,[ReportEndDate]
           ,[NumberOfReports]
           ,[ReportFrequency]
           ,[ReportFrequencyPeriod]
           ,[DocumentType]
           ,[ReportTitle]
           ,[ParamOrganisationID]
           ,[ParamCompleted]
           ,[ParamStatus]
           ,[ParamFailCount]
           ,[ParamCourseIDs]
           ,[ParamHistoricCourseIDs]
           ,[ParamAllUnits]
           ,[ParamTimeExpired]
           ,[ParamTimeExpiredPeriod]
           ,[ParamQuizStatus]
           ,[ParamGroupBy]
           ,[ParamGroupingOption]
           ,[ParamFirstName]
           ,[ParamLastName]
           ,[ParamUserName]
           ,[ParamEmail]
           ,[ParamIncludeInactive]
           ,[ParamSubject]
           ,[ParamBody]
           ,[ParamProfileID]
           ,[ParamOnlyUsersWithShortfall]
           ,[ParamEffectiveDate]
           ,[ParamSortBy]
           ,[ParamClassificationID]
           ,[ParamUnitIDs]
           ,[ParamLangCode]
           ,[ParamDateTo]
           ,[ParamDateFrom]
           ,[ParamLicensingPeriod]
           ,[ParamProfilePeriodID]
           ,[ReportPeriodType]
           ,[ReportFromDate]
           ,[IsPeriodic]
           ,[LastUpdatedBy]
           ,[LastUpdated]
           ,[NumberDelivered]
           ,[TerminatedNormally]
           ,[LastUpdAction]
         ,DateCreated  )
SELECT [ScheduleID]
      ,[UserID]
      ,[ReportID]
      ,[LastRun]
      ,[NextRun]
      ,[ReportDuration]
      ,[ReportDurationPeriod]
      ,[ReportStartDate]
      ,[ReportEndDate]
      ,[NumberOfReports]
      ,[ReportFrequency]
      ,[ReportFrequencyPeriod]
      ,[DocumentType]
      ,[ReportTitle]
      ,[ParamOrganisationID]
      ,[ParamCompleted]
      ,[ParamStatus]
      ,[ParamFailCount]
      ,[ParamCourseIDs]
      ,[ParamHistoricCourseIDs]
      ,[ParamAllUnits]
      ,[ParamTimeExpired]
      ,[ParamTimeExpiredPeriod]
      ,[ParamQuizStatus]
      ,[ParamGroupBy]
      ,[ParamGroupingOption]
      ,[ParamFirstName]
      ,[ParamLastName]
      ,[ParamUserName]
      ,[ParamEmail]
      ,[ParamIncludeInactive]
      ,[ParamSubject]
      ,[ParamBody]
      ,[ParamProfileID]
      ,[ParamOnlyUsersWithShortfall]
      ,[ParamEffectiveDate]
      ,[ParamSortBy]
      ,[ParamClassificationID]
      ,[ParamUnitIDs]
      ,[ParamLangCode]
      ,[ParamDateTo]
      ,[ParamDateFrom]
      ,[ParamLicensingPeriod]
      ,[ParamProfilePeriodID]
      ,[ReportPeriodType]
      ,[ReportFromDate]
      ,[IsPeriodic]
      ,[LastUpdatedBy]
      ,[LastUpdated]
      ,[NumberDelivered]
      ,[TerminatedNormally]
      ,''I''
     ,DateCreated 
  FROM  inserted
WHERE   IsPeriodic = ''N''

END
' 
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[TRGReportScheduleAuditUpdate]'))
EXEC dbo.sp_executesql @statement = N'CREATE TRIGGER [TRGReportScheduleAuditUpdate]
   ON  [tblReportSchedule] 
   AFTER  UPDATE
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
INSERT INTO tblReportScheduleAudit
           ([ScheduleID]
		   ,[UserID]
           ,[ReportID]
           ,[LastRun]
           ,[NextRun]
           ,[ReportDuration]
           ,[ReportDurationPeriod]
           ,[ReportStartDate]
           ,[ReportEndDate]
           ,[NumberOfReports]
           ,[ReportFrequency]
           ,[ReportFrequencyPeriod]
           ,[DocumentType]
           ,[ReportTitle]
           ,[ParamOrganisationID]
           ,[ParamCompleted]
           ,[ParamStatus]
           ,[ParamFailCount]
           ,[ParamCourseIDs]
           ,[ParamHistoricCourseIDs]
           ,[ParamAllUnits]
           ,[ParamTimeExpired]
           ,[ParamTimeExpiredPeriod]
           ,[ParamQuizStatus]
           ,[ParamGroupBy]
           ,[ParamGroupingOption]
           ,[ParamFirstName]
           ,[ParamLastName]
           ,[ParamUserName]
           ,[ParamEmail]
           ,[ParamIncludeInactive]
           ,[ParamSubject]
           ,[ParamBody]
           ,[ParamProfileID]
           ,[ParamOnlyUsersWithShortfall]
           ,[ParamEffectiveDate]
           ,[ParamSortBy]
           ,[ParamClassificationID]
           ,[ParamUnitIDs]
           ,[ParamLangCode]
           ,[ParamDateTo]
           ,[ParamDateFrom]
           ,[ParamLicensingPeriod]
           ,[ParamProfilePeriodID]
           ,[ReportPeriodType]
           ,[ReportFromDate]
           ,[IsPeriodic]
           ,[LastUpdatedBy]
           ,[LastUpdated]
           ,[NumberDelivered]
           ,[TerminatedNormally]
           ,[LastUpdAction]
         ,DateCreated  )
SELECT [ScheduleID]
      ,[UserID]
      ,[ReportID]
      ,[LastRun]
      ,[NextRun]
      ,[ReportDuration]
      ,[ReportDurationPeriod]
      ,[ReportStartDate]
      ,[ReportEndDate]
      ,[NumberOfReports]
      ,[ReportFrequency]
      ,[ReportFrequencyPeriod]
      ,[DocumentType]
      ,[ReportTitle]
      ,[ParamOrganisationID]
      ,[ParamCompleted]
      ,[ParamStatus]
      ,[ParamFailCount]
      ,[ParamCourseIDs]
      ,[ParamHistoricCourseIDs]
      ,[ParamAllUnits]
      ,[ParamTimeExpired]
      ,[ParamTimeExpiredPeriod]
      ,[ParamQuizStatus]
      ,[ParamGroupBy]
      ,[ParamGroupingOption]
      ,[ParamFirstName]
      ,[ParamLastName]
      ,[ParamUserName]
      ,[ParamEmail]
      ,[ParamIncludeInactive]
      ,[ParamSubject]
      ,[ParamBody]
      ,[ParamProfileID]
      ,[ParamOnlyUsersWithShortfall]
      ,[ParamEffectiveDate]
      ,[ParamSortBy]
      ,[ParamClassificationID]
      ,[ParamUnitIDs]
      ,[ParamLangCode]
      ,[ParamDateTo]
      ,[ParamDateFrom]
      ,[ParamLicensingPeriod]
      ,[ParamProfilePeriodID]
      ,[ReportPeriodType]
      ,[ReportFromDate]
      ,[IsPeriodic]
      ,[LastUpdatedBy]
      ,[LastUpdated]
      ,[NumberDelivered]
      ,[TerminatedNormally]
      ,''U''
     ,DateCreated 
  FROM  inserted

END
' 
GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_ReportStartDate]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] ADD  CONSTRAINT [DF_tblReportSchedule_ReportStartDate]  DEFAULT (getutcdate()) FOR [ReportStartDate]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_ReportTitle]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] ADD  CONSTRAINT [DF_tblReportSchedule_ReportTitle]  DEFAULT ('?') FOR [ReportTitle]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_ParamLangCode]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] ADD  CONSTRAINT [DF_tblReportSchedule_ParamLangCode]  DEFAULT (N'en-AU') FOR [ParamLangCode]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF__tblReport__Param__082CD432]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] ADD  CONSTRAINT [DF__tblReport__Param__082CD432]  DEFAULT ((0)) FOR [ParamLicensingPeriod]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_ParamProfilePeriodID]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] ADD  CONSTRAINT [DF_tblReportSchedule_ParamProfilePeriodID]  DEFAULT ((1)) FOR [ParamProfilePeriodID]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_IsPeriodic]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] ADD  CONSTRAINT [DF_tblReportSchedule_IsPeriodic]  DEFAULT ('M') FOR [IsPeriodic]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_LastUpdatedBy]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] ADD  CONSTRAINT [DF_tblReportSchedule_LastUpdatedBy]  DEFAULT ((1)) FOR [LastUpdatedBy]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_LastUpdated]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] ADD  CONSTRAINT [DF_tblReportSchedule_LastUpdated]  DEFAULT (getutcdate()) FOR [LastUpdated]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_NumberDelivered]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] ADD  CONSTRAINT [DF_tblReportSchedule_NumberDelivered]  DEFAULT ((0)) FOR [NumberDelivered]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_TerminatedNormally]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] ADD  CONSTRAINT [DF_tblReportSchedule_TerminatedNormally]  DEFAULT ((0)) FOR [TerminatedNormally]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReportSchedule_DateCreated]') AND type = 'D')
BEGIN
ALTER TABLE [tblReportSchedule] ADD  CONSTRAINT [DF_tblReportSchedule_DateCreated]  DEFAULT (getutcdate()) FOR [DateCreated]
END

GO



IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblUser_NotifyMgr]') AND type = 'D')
BEGIN
ALTER TABLE dbo.tblUser ADD
	NotifyMgr bit NOT NULL CONSTRAINT DF_tblUser_NotifyMgr DEFAULT 0
END
GO


IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblUser_NotifyUnitAdmin]') AND type = 'D')
BEGIN
ALTER TABLE dbo.tblUser ADD
	NotifyUnitAdmin bit NOT NULL CONSTRAINT DF_tblUser_NotifyUnitAdmin DEFAULT 0
END
GO


IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblUser_NotifyOrgAdmin]') AND type = 'D')
BEGIN
ALTER TABLE dbo.tblUser ADD
	NotifyOrgAdmin bit NOT NULL CONSTRAINT DF_tblUser_NotifyOrgAdmin DEFAULT 0
END
GO



IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID('DF_tblUser_NotifyOfPendingDelinquencies') AND type = 'D')
BEGIN
ALTER TABLE dbo.tblUser
	DROP CONSTRAINT DF_tblUser_NotifyOfPendingDelinquencies
END
GO

IF EXISTS( SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'tblUser' 
		AND  COLUMN_NAME = 'NotifyOfPendingDelinquencies')
BEGIN
ALTER TABLE dbo.tblUser
	DROP COLUMN NotifyOfPendingDelinquencies, EmailInOrgDomain
END
GO




IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[tblReportScheduleAudit]') AND type in (N'U'))
DROP TABLE [tblReportScheduleAudit]
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[tblReportScheduleAudit]') AND type in (N'U'))
BEGIN
CREATE TABLE [tblReportScheduleAudit](
	[AuditID] [int] IDENTITY(1,1) NOT NULL,
	[ScheduleID] [int]  NULL,
	[UserID] [int]  NULL,
	[ReportID] [int]  NULL,
	[LastRun] [datetime] NULL,
	[NextRun] [datetime] NULL,
	[ReportDuration] [int]  NULL,
	[ReportDurationPeriod] [char](1)  NULL,
	[ReportStartDate] [datetime]  NULL,
	[ReportEndDate] [datetime] NULL,
	[NumberOfReports] [int] NULL,
	[ReportFrequency] [int]  NULL,
	[ReportFrequencyPeriod] [char](1)  NULL,
	[DocumentType] [char](1)  NULL,
	[OnceOnly] [bit]  NULL,
	[Now] [bit]  NULL,
	[ReportTitle] [nvarchar](100) NULL,
	[ParamOrganisationID] [int]  NULL,
	[ParamCompleted] [char](1) NULL,
	[ParamStatus] [char](1) NULL,
	[ParamFailCount] [int] NULL,
	[ParamCourseIDs] [nvarchar](800) NULL,
	[ParamHistoricCourseIDs] [nvarchar](800) NULL,
	[ParamAllUnits] [char](1) NULL,
	[ParamTimeExpired] [int] NULL,
	[ParamTimeExpiredPeriod] [char](1) NULL,
	[ParamQuizStatus] [char](1) NULL,
	[ParamGroupBy] [char](1) NULL,
	[ParamGroupingOption] [int] NULL,
	[ParamFirstName] [nvarchar](200) NULL,
	[ParamLastName] [nvarchar](200) NULL,
	[ParamUserName] [nvarchar](200) NULL,
	[ParamEmail] [nvarchar](200) NULL,
	[ParamIncludeInactive] [char](1) NULL,
	[ParamSubject] [nvarchar](200) NULL,
	[ParamBody] [nvarchar](200) NULL,
	[ParamProfileID] [int] NULL,
	[ParamOnlyUsersWithShortfall] [char](1) NULL,
	[ParamEffectiveDate] [datetime] NULL,
	[ParamSortBy] [char](1) NULL,
	[ParamClassificationID] [int] NULL,
	[ParamUnitIDs] [nvarchar](max) NULL,
	[ParamLangCode] [nvarchar](10) NULL,
	[ParamDateTo] [datetime] NULL,
	[ParamDateFrom] [datetime] NULL,
	[ParamLicensingPeriod] [varchar](8000) NULL,
	[ParamProfilePeriodID] [int]  NULL,
	[ReportPeriodType] [int] NULL,
	[ReportFromDate] [datetime] NULL,
	[IsPeriodic] [char](1)  NULL,
	[LastUpdatedBy] [int]  NULL,
	[LastUpdated] [datetime]  NULL,
	[LastUpdAction] [char](1)  NULL,
	[NumberDelivered] [int]  NULL,
	TerminatedNormally bit  NULL,
	DateCreated datetime NULL 

 CONSTRAINT [PK_tblReportScheduleAudit] PRIMARY KEY CLUSTERED 
(
	[AuditID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
END
GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_DaysToCompleteCourse]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] DROP CONSTRAINT [DF_tblReminderEscalation_DaysToCompleteCourse]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_RemindUsers]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] DROP CONSTRAINT [DF_tblReminderEscalation_RemindUsers]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_NumOfRemNotfy]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] DROP CONSTRAINT [DF_tblReminderEscalation_NumOfRemNotfy]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_RepeatRem]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] DROP CONSTRAINT [DF_tblReminderEscalation_RepeatRem]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_NotifyMgr]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] DROP CONSTRAINT [DF_tblReminderEscalation_NotifyMgr]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_IsCumulative]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] DROP CONSTRAINT [DF_tblReminderEscalation_IsCumulative]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_QuizExpiryWarn]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] DROP CONSTRAINT [DF_tblReminderEscalation_QuizExpiryWarn]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_DaysQuizExpiry]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] DROP CONSTRAINT [DF_tblReminderEscalation_DaysQuizExpiry]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_LastNotified]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] DROP CONSTRAINT [DF_tblReminderEscalation_LastNotified]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_NotifyMgrDays]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] DROP CONSTRAINT [DF_tblReminderEscalation_NotifyMgrDays]
END

GO

IF  EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_IndividualNotification]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] DROP CONSTRAINT [DF_tblReminderEscalation_IndividualNotification]
END

GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[tblReminderEscalation]') AND type in (N'U'))
DROP TABLE [tblReminderEscalation]
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[tblReminderEscalation]') AND type in (N'U'))
BEGIN
CREATE TABLE [tblReminderEscalation](
	[RemEscId] [int] IDENTITY(1,1) NOT NULL,
	[OrgId] [int] NOT NULL,
	[CourseId] [int] NOT NULL,
	[DaysToCompleteCourse] [int] NOT NULL,
	[RemindUsers] [bit] NOT NULL,
	[NumOfRemNotfy] [int] NOT NULL,
	[RepeatRem] [int] NOT NULL,
	[NotifyMgr] [bit] NOT NULL,
	[IsCumulative] [bit] NOT NULL,
	[QuizExpiryWarn] [bit] NOT NULL,
	[DaysQuizExpiry] [int] NOT NULL,
	[LastNotified] [datetime] NOT NULL,
	[NotifyMgrDays] [int] NOT NULL,
	[IndividualNotification] [bit] NOT NULL
) ON [PRIMARY]
END
GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_DaysToCompleteCourse]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] ADD  CONSTRAINT [DF_tblReminderEscalation_DaysToCompleteCourse]  DEFAULT ((365)) FOR [DaysToCompleteCourse]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_RemindUsers]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] ADD  CONSTRAINT [DF_tblReminderEscalation_RemindUsers]  DEFAULT ((0)) FOR [RemindUsers]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_NumOfRemNotfy]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] ADD  CONSTRAINT [DF_tblReminderEscalation_NumOfRemNotfy]  DEFAULT ((0)) FOR [NumOfRemNotfy]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_RepeatRem]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] ADD  CONSTRAINT [DF_tblReminderEscalation_RepeatRem]  DEFAULT ((365)) FOR [RepeatRem]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_NotifyMgr]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] ADD  CONSTRAINT [DF_tblReminderEscalation_NotifyMgr]  DEFAULT ((0)) FOR [NotifyMgr]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_IsCumulative]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] ADD  CONSTRAINT [DF_tblReminderEscalation_IsCumulative]  DEFAULT ((0)) FOR [IsCumulative]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_QuizExpiryWarn]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] ADD  CONSTRAINT [DF_tblReminderEscalation_QuizExpiryWarn]  DEFAULT ((0)) FOR [QuizExpiryWarn]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_DaysQuizExpiry]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] ADD  CONSTRAINT [DF_tblReminderEscalation_DaysQuizExpiry]  DEFAULT ((0)) FOR [DaysQuizExpiry]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_LastNotified]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] ADD  CONSTRAINT [DF_tblReminderEscalation_LastNotified]  DEFAULT ('1 jan 2001') FOR [LastNotified]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_NotifyMgrDays]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] ADD  CONSTRAINT [DF_tblReminderEscalation_NotifyMgrDays]  DEFAULT ((1)) FOR [NotifyMgrDays]
END

GO

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblReminderEscalation_IndividualNotification]') AND type = 'D')
BEGIN
ALTER TABLE [tblReminderEscalation] ADD  CONSTRAINT [DF_tblReminderEscalation_IndividualNotification]  DEFAULT ((0)) FOR [IndividualNotification]
END

GO








IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[tblEmailPurged]') AND type in (N'U'))
DROP TABLE [tblEmailPurged]
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[tblEmailPurged]') AND type in (N'U'))
BEGIN
CREATE TABLE [tblEmailPurged](
	[EmailId] [int] IDENTITY(1,1) NOT NULL,
	[ToEmail] [nvarchar](1000) NOT NULL,
	[ToName] [nvarchar](128) NULL,
	[FromEmail] [nvarchar](128) NOT NULL,
	[FromName] [nvarchar](128) NULL,
	[CC] [nvarchar](1000) NULL,
	[BCC] [nvarchar](1000) NULL,
	[Subject] [nvarchar](256) NOT NULL,
	[Body] [ntext] NULL,
	[DateCreated] [smalldatetime] NOT NULL,
	[OrganisationID] [int] NOT NULL,
 CONSTRAINT [PK_tblEmailPurged] PRIMARY KEY CLUSTERED 
(
	[EmailId] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
END
GO


IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[tblCCList]') AND type in (N'U'))
DROP TABLE [tblCCList]
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[tblCCList]') AND type in (N'U'))
BEGIN
CREATE TABLE [tblCCList](
	[CCId] [int] NOT NULL,
	[UserID] [int] NOT NULL,
	[ScheduleId] [int] NOT NULL,
 CONSTRAINT [PK_tblCCList] PRIMARY KEY CLUSTERED 
(
	[CCId] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
END
GO


IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[tblCCList]') AND name = N'IX_tblCCList')
CREATE NONCLUSTERED INDEX [IX_tblCCList] ON [tblCCList] 
(
	[ScheduleId] ASC,
	[UserID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO





IF  NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblOrganisation_StopEmails]') AND type = 'D')
BEGIN
ALTER TABLE dbo.tblOrganisation ADD
	StopEmails bit NOT NULL CONSTRAINT DF_tblOrganisation_StopEmails DEFAULT 0
END
GO

IF  NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[DF_tblOrganisation_ShowLastPassed]') AND type = 'D')
BEGIN
ALTER TABLE dbo.tblOrganisation ADD
	ShowLastPassed bit NOT NULL CONSTRAINT DF_tblOrganisation_ShowLastPassed DEFAULT 1
END
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_GetNext]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcEmail_GetNext]
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[prcEmail_GetNext]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [dbo].[prcEmail_GetNext]
AS
BEGIN

  select
  tblEmailQueue.EmailQueueID
  into
  #tblEmailsToPurge
  FROM tblEmailQueue
  inner join tblOrganisation on tblOrganisation.OrganisationID = tblEmailQueue.organisationID  
  join tblAppConfig on name  = ''SEND_AUTO_EMAILS'' 
  where (tblOrganisation.StopEmails = 1 or upper(Value) = ''NO'')

  INSERT INTO tblEmailPurged
           ([ToEmail]
           ,[ToName]
           ,[FromEmail]
           ,[FromName]
           ,[CC]
           ,[BCC]
           ,[Subject]
           ,[Body]
           ,[DateCreated]
           ,[OrganisationID])
     
  SELECT  case when ((CHARINDEX (''>'',AddressTo) > 0) and (CHARINDEX (''<'',AddressTo) > 0)) then SUBSTRING(AddressTo,CHARINDEX (''<'',AddressTo)+1,CHARINDEX (''>'',AddressTo)-CHARINDEX (''<'',AddressTo)-1) else AddressTo end

      ,case when ((CHARINDEX (''>'',AddressTo) > 0) and (CHARINDEX (''<'',AddressTo) > 0)) then SUBSTRING(AddressTo,1,CHARINDEX (''<'',AddressTo)-1) else AddressTo end
	  ,case when ((CHARINDEX (''>'',AddressFrom) > 0) and (CHARINDEX (''<'',AddressFrom) > 0)) then SUBSTRING(AddressFrom,CHARINDEX (''<'',AddressFrom)+1,CHARINDEX (''>'',AddressFrom)-CHARINDEX (''<'',AddressFrom)-1) else AddressFrom end
      ,case when ((CHARINDEX (''>'',AddressFrom) > 0) and (CHARINDEX (''<'',AddressFrom) > 0)) then SUBSTRING(AddressFrom,1,CHARINDEX (''<'',AddressFrom)-1) else AddressFrom end
      ,''''
      ,AddressBccs
      ,Subject
      ,Body
      ,QueuedTime
      ,tblEmailQueue.organisationID
  FROM tblEmailQueue inner join
  #tblEmailsToPurge ON tblEmailQueue.EmailQueueID = #tblEmailsToPurge.EmailQueueID
  DELETE FROM tblEmailQueue WHERE EmailQueueID in (SELECT EmailQueueID FROM #tblEmailsToPurge) 

  DECLARE  @EmailQueueID INT
  SELECT @EmailQueueID = MIN (EmailQueueID)
  FROM tblEmailQueue
  WHERE ((SendStarted is NULL) OR (DATEADD(DAY,1,SendStarted) < GETUTCDATE()))
-- A SINGLE INSTANCE  WILL BE UPDATING THE TABLE SO DO NO MULTIUSER CODE
  SELECT TOP (1) EmailQueueID,OrganisationID,AddressTo,AddressBCCs,[Subject],body,AddressSender,AddressFrom,IsHTML,CASE WHEN DATEDIFF(d,QueuedTime,GETUTCDATE()) > 1 THEN 1 ELSE 0 END AS Retry
  FROM tblEmailQueue  WHERE @EmailQueueID =  EmailQueueID
  UPDATE tblEmailQueue SET SendStarted = GETUTCDATE()  WHERE @EmailQueueID =  EmailQueueID

END
' 
END
GO

INSERT [tblOrganisationConfig] ([OrganisationID], [Name], [Description], [Value]) VALUES (NULL, N'Overdue_Summary_Header_Individual', N'Overdue Summary Header - Individual Emails', N'Hi %FirstName%, The Following student is now Overdue for their %APP_NAME% course/s:')
GO

UPDATE tblOrganisationConfig
SET       Value = REPLACE(Value, 'Hi,', 'Hi %FirstName%,')
WHERE (OrganisationID IS NULL)
GO


If  exists (select * from tblLangValue where LangID = 2 and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = '/Reporting/PeriodicReport.aspx') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = 'lblFrequency')) 
begin update tblLangValue set LangEntryValue = 'Every' where LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = '/Reporting/PeriodicReport.aspx')
and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = 'lblFrequency')  and LangID = 2 end
GO


UPDATE tblReportInterface
   SET 
     RequiresParamLicensingPeriod = 1
 WHERE ReportID = 30
GO

UPDATE tblReportInterface
   SET 
     RequiresParamLicensingPeriod = 1
 WHERE ReportID = 20
GO

UPDATE tblReportInterface
   SET 
     RequiresParamCourseID = 0
 WHERE ReportID = 20
GO

DELETE FROM tblReportType
      WHERE TYPE = 'X'
GO

IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[tblEmailQueue]') AND name = N'PK_tblEmailQueue')
ALTER TABLE [tblEmailQueue] DROP CONSTRAINT [PK_tblEmailQueue]
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[tblEmailQueue]') AND name = N'PK_tblEmailQueue')
ALTER TABLE [tblEmailQueue] ADD  CONSTRAINT [PK_tblEmailQueue] PRIMARY KEY CLUSTERED 
(
	[EmailQueueID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO


IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[tblEmailQueue]') AND name = N'IX_tblEmailQueue')
DROP INDEX [IX_tblEmailQueue] ON [tblEmailQueue] WITH ( ONLINE = OFF )
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[tblEmailQueue]') AND name = N'IX_tblEmailQueue')
CREATE NONCLUSTERED INDEX [IX_tblEmailQueue] ON [tblEmailQueue] 
(
	[SendStarted] ASC,
	[EmailQueueID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO




IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[tblReminderEscalation]') AND name = N'PK_tblReminderEscalation_1')
ALTER TABLE [tblReminderEscalation] DROP CONSTRAINT [PK_tblReminderEscalation_1]
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[tblReminderEscalation]') AND name = N'PK_tblReminderEscalation_1')
ALTER TABLE [tblReminderEscalation] ADD  CONSTRAINT [PK_tblReminderEscalation_1] PRIMARY KEY CLUSTERED 
(
	[RemEscId] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO




IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[tblReminderEscalation]') AND name = N'IX_tblReminderEscalation')
DROP INDEX [IX_tblReminderEscalation] ON [tblReminderEscalation] WITH ( ONLINE = OFF )
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[tblReminderEscalation]') AND name = N'IX_tblReminderEscalation')
CREATE NONCLUSTERED INDEX [IX_tblReminderEscalation] ON [tblReminderEscalation] 
(
	[OrgId] ASC,
	[CourseId] ASC,
	[IndividualNotification] ASC,
	[NotifyMgr] ASC,
	[DaysToCompleteCourse] ASC,
	[NotifyMgrDays] ASC,
	[RepeatRem] ASC,
	[NumOfRemNotfy] ASC,
	[LastNotified] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO


IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[tblEmailQueueLinkedResource]') AND name = N'PK_tblEmailQueueLinkedResource')
ALTER TABLE [tblEmailQueueLinkedResource] DROP CONSTRAINT [PK_tblEmailQueueLinkedResource]
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[tblEmailQueueLinkedResource]') AND name = N'PK_tblEmailQueueLinkedResource')
ALTER TABLE [tblEmailQueueLinkedResource] ADD  CONSTRAINT [PK_tblEmailQueueLinkedResource] PRIMARY KEY CLUSTERED 
(
	[EmailQueueID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO




IF  EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[tblReportInterface]') AND name = N'PK_tblReportInterface')
ALTER TABLE [tblReportInterface] DROP CONSTRAINT [PK_tblReportInterface]
GO

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID(N'[tblReportInterface]') AND name = N'PK_tblReportInterface')
ALTER TABLE [tblReportInterface] ADD  CONSTRAINT [PK_tblReportInterface] PRIMARY KEY CLUSTERED 
(
	[ReportID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO


 
if not exists (select * from tblAppConfig where Name ='Email_OnBehalfOf') begin
	insert into tblAppConfig (Name, Value) values('Email_OnBehalfOf','ENTER_ON_BEHALF_OF_EMAIL@ADDRESS.HERE')
end
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[prc_tblUserLessonCurrentStatus_Update]'))
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE TRIGGER [prc_tblUserLessonCurrentStatus_Update]
ON [tblUserLessonStatus]
AFTER  INSERT,UPDATE
AS
BEGIN
SET NOCOUNT ON;
--###################################################################
--  I N S E R T S     A N D     U P D A T E S
--###################################################################
delete from tblUserCurrentLessonStatus  where UserLessonStatusID in
(select C.UserLessonStatusID from tblUserCurrentLessonStatus C inner join inserted I on I.UserID = C.UserID and I.ModuleID = C.ModuleID)
INSERT INTO tblUserCurrentLessonStatus
([UserLessonStatusID],
[UserID]
,[ModuleID]
,[LessonStatusID]
,[LessonFrequency]
,[DateCreated]
,[LessonCompletionDate]
,[Excluded])
SELECT [UserLessonStatusID]
,[UserID]
,[ModuleID]
,[LessonStatusID]
,[LessonFrequency]
,[DateCreated]
,[LessonCompletionDate]
,[Excluded]
FROM [dbo].[tblUserLessonStatus]
WHERE UserLessonStatusID IN(



SELECT MAX(LS.UserLessonStatusID) AS UserLessonStatusID
FROM   dbo.tblUserLessonStatus LS inner join
inserted I on I.ModuleID = LS.ModuleID and i.UserID = LS.UserID
group by LS.UserID, LS.ModuleID)

--###################################################################
--                         D E L E T E S
--###################################################################

delete from tblUserCurrentLessonStatus  where UserLessonStatusID in
(select C.UserLessonStatusID from tblUserCurrentLessonStatus C inner join deleted d on d.UserID = C.UserID and d.ModuleID = C.ModuleID)
INSERT INTO tblUserCurrentLessonStatus
([UserLessonStatusID],
[UserID]
,[ModuleID]
,[LessonStatusID]
,[LessonFrequency]
,[DateCreated]
,[LessonCompletionDate]
,[Excluded])
SELECT [UserLessonStatusID]
,[UserID]
,[ModuleID]
,[LessonStatusID]
,[LessonFrequency]
,[DateCreated]
,[LessonCompletionDate]
,[Excluded]
FROM [dbo].[tblUserLessonStatus]
WHERE UserLessonStatusID IN(



SELECT MAX(LS.UserLessonStatusID) AS UserLessonStatusID
FROM   dbo.tblUserLessonStatus LS inner join
deleted d on d.ModuleID = LS.ModuleID and d.UserID = LS.UserID
group by LS.UserID, LS.ModuleID)

END
' 
GO




DELETE FROM tblReportType
WHERE (Name LIKE '%html%')
GO

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcToolbook_Import]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcToolbook_Import]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_CreateQuizAnswerAudit]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuizSession_CreateQuizAnswerAudit]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetQuizAnswerIDByToolbookAnswerID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetQuizAnswerIDByToolbookAnswerID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_CreateQuizAudit]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuizSession_CreateQuizAudit]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetQuizQuestionIDByToolbookPageID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetQuizQuestionIDByToolbookPageID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonPageAudit_InsertPageVisited]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLessonPageAudit_InsertPageVisited]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonSession_EndLesson]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLessonSession_EndLesson]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetLessonPageIDByToolbookPageID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetLessonPageIDByToolbookPageID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcToolbook_Preview]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcToolbook_Preview]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetToolbookPageIDByLessonPageID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetToolbookPageIDByLessonPageID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_GetModulePointsByCourse]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfile_GetModulePointsByCourse]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_GetPolicyPoints]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfile_GetPolicyPoints]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfilePeriod_RollOver]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfilePeriod_RollOver]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfilePoints_Add]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfilePoints_Add]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfilePoints_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfilePoints_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetScore]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuiz_GetScore]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetQuizSummary]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetQuizSummary]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPD_CurrentPoints]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCPD_CurrentPoints]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPD_Report]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCPD_Report]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDEmail_Report]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCPDEmail_Report]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDModuleHistory_Report]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCPDModuleHistory_Report]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDPoints_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCPDPoints_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDPoints_UpdateUser]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCPDPoints_UpdateUser]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDProfileHistory_Report]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCPDProfileHistory_Report]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_GetDetailsForHomePage]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcModule_GetDetailsForHomePage]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_Add]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_Add]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prc_ADMIN_LessonPageAuditPagesVisited]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prc_ADMIN_LessonPageAuditPagesVisited]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcBookMark_GetBookMarkBySessionID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcBookMark_GetBookMarkBySessionID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonPageAudit_GetPagesVisited]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLessonPageAudit_GetPagesVisited]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonPageAudit_GetPagesVisitedBySessionID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLessonPageAudit_GetPagesVisitedBySessionID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetListByModule]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuiz_GetListByModule]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_SetUserAccessByUser]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfile_SetUserAccessByUser]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfile_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_GetQuizIDByToolbookID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuizSession_GetQuizIDByToolbookID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetModuleIDByToolbookID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuiz_GetModuleIDByToolbookID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_Add]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfile_Add]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_ResetUnitAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfile_ResetUnitAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_ResetUserAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfile_ResetUserAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_SetUnitAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfile_SetUnitAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetProfiles]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetProfiles]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLesson_GetListByModule]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLesson_GetListByModule]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetModuleIDByLessonID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetModuleIDByLessonID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetModuleIDBySessionID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuiz_GetModuleIDBySessionID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetModuleIDByQuizID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetModuleIDByQuizID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetCourseList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetCourseList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetLessonIDByToolbookID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetLessonIDByToolbookID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetLessonIDByToolbookIDAndModuleID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetLessonIDByToolbookIDAndModuleID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetQuizIDByToolbookID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetQuizIDByToolbookID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetQuizIDByToolbookIDAndModuleID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetQuizIDByToolbookIDAndModuleID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetActiveQuizIDByModuleID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetActiveQuizIDByModuleID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_Get]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfile_Get]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_AddType]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcClassification_AddType]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_GetType]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcClassification_GetType]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_UpdateType]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcClassification_UpdateType]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCourse_GetList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetListByOrganisation]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCourse_GetListByOrganisation]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetOne]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCourse_GetOne]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_GetOne]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcErrorLog_GetOne]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_GetReport]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcErrorLog_GetReport]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcErrorLog_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEscalationConfigForCourse_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcEscalationConfigForCourse_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisationConfig_Delete]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisationConfig_Delete]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisationConfig_GetList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisationConfig_GetList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisationConfig_GetOne]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisationConfig_GetOne]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisationConfig_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisationConfig_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_UpdateCPDPolicyAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_UpdateCPDPolicyAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_CheckFileName]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_CheckFileName]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_CheckPolicyName]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_CheckPolicyName]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_Get]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_Get]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_Search]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcEmail_Search]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_Create]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcErrorLog_Create]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetCourseAccessList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetCourseAccessList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetCPDAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetCPDAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetCPDPolicyAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetCPDPolicyAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetOne]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetOne]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetPolicies]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetPolicies]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_UsersToNotify]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcAutomatedEmails_UsersToNotify]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetSaltOrgDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetSaltOrgDate]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModuleStatusUpdateHistory_GetLastRun]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcModuleStatusUpdateHistory_GetLastRun]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZoneRule_add]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcTimeZoneRule_add]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZoneRule_update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcTimeZoneRule_update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_New StartersToNotify]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcAutomatedEmails_New StartersToNotify]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfUser_GetAdministratorsOnBehalfOfEmailAddress]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfUser_GetAdministratorsOnBehalfOfEmailAddress]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetOneBySessionID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCourse_GetOneBySessionID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_BeforeStartQuiz]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuizSession_BeforeStartQuiz]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_EndQuiz]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuizSession_EndQuiz]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_GetEndQuizInfo]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuizSession_GetEndQuizInfo]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Warning]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_Warning]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_WarningGrandTotal]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_WarningGrandTotal]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_FIX]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserQuizStatus_FIX]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_GetListByCourse]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcModule_GetListByCourse]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_GetOne]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcModule_GetOne]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcModule_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_UpdateSequence]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcModule_UpdateSequence]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetPolicyAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetPolicyAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetPolicyList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetPolicyList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetPolicyUsedSpace]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetPolicyUsedSpace]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetSaltOrgDate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetSaltOrgDate]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetMailThroughputPagedandSorted]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetMailThroughputPagedandSorted]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicFields]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetPeriodicFields]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetSelected]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCourse_GetSelected]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcDatabaseMail_Setup]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcDatabaseMail_Setup]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcDeleteReport]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcDeleteReport]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetEmailThroughput]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetEmailThroughput]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLink_Add]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLink_Add]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLink_Delete]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLink_Delete]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLink_GetListByOrganisation]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLink_GetListByOrganisation]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLink_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLink_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_Create]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcModule_Create]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_SaveCourseAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_SaveCourseAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_CheckProfileName]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfile_CheckProfileName]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetListByOrganisation]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_GetListByOrganisation]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReassignReport]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReassignReport]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_DeleteReportInactive]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_DeleteReportInactive]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetSaltOrgDateStr]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetSaltOrgDateStr]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_ManagersToNotifyIndividually]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcAutomatedEmails_ManagersToNotifyIndividually]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_ManagersToNotifyList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcAutomatedEmails_ManagersToNotifyList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetNextOnceOnlyReport]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_GetNextOnceOnlyReport]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetNextReport]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_GetNextReport]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetNextUrgentReport]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_GetNextUrgentReport]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetSaltOrgMidnight]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetSaltOrgMidnight]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetSaltOrgTomorrow]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetSaltOrgTomorrow]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[ReassignReportInactive]') AND type in (N'P', N'PC'))
DROP PROCEDURE [ReassignReportInactive]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetTypeFromScheduleId]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_GetTypeFromScheduleId]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_ReassignReportInactive]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_ReassignReportInactive]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSetPeriodicFields]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcSetPeriodicFields]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_add]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcTimeZone_add]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReportSchedule_CalcNextRunDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReportSchedule_CalcNextRunDate]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonSession_BeforeStartLesson]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLessonSession_BeforeStartLesson]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_IndividualDetailsExtended]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_IndividualDetailsExtended]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_SetUserAccessByUnit]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfile_SetUserAccessByUnit]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_Create]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_Create]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Create]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_Create]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Import]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_Import]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetAllocatedDiskSpace]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetAllocatedDiskSpace]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_AdminMashup]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCourse_AdminMashup]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetPoliciesInUnit]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_GetPoliciesInUnit]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetUserAndPoliciesForAdmins]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_GetUserAndPoliciesForAdmins]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_UpdateEndQuizInfo]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuizSession_UpdateEndQuizInfo]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_ActiveInactive]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_ActiveInactive]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_AtRisk]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_AtRisk]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_AtRiskGrandTotal]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_AtRiskGrandTotal]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CompletedUsersDetails]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_CompletedUsersDetails]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CourseStatusGrandTotal]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_CourseStatusGrandTotal]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CourseStatusSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_CourseStatusSearch]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_EmailReportDistinctUsers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_EmailReportDistinctUsers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_EmailReportToAdministrators]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_EmailReportToAdministrators]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_EmailReportUserSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_EmailReportUserSearch]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetAdminList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetAdminList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetUsers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetUsers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_SetAdmin]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_SetAdmin]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_UserSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfile_UserSearch]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CompletedUsers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_CompletedUsers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_HistoricAdminSummary]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_HistoricAdminSummary]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_HistoricUserLessonStatus]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_HistoricUserLessonStatus]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_HistoricUserQuizStatus]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_HistoricUserQuizStatus]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_Add]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_Add]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetPeriodicReportList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportListOnInactivateBulkUsers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetPeriodicReportListOnInactivateBulkUsers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportListOnInactivateEmail]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetPeriodicReportListOnInactivateEmail]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportListOnInactivateUser]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetPeriodicReportListOnInactivateUser]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportListUser]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetPeriodicReportListUser]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetEmailsinDay]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetEmailsinDay]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetEmailsinHour]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetEmailsinHour]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetEmailOnBehalfOf]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetEmailOnBehalfOf]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetFLBNamefromTZID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcTimeZone_GetFLBNamefromTZID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcTimeZone_GetList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetTimeZoneFLBName]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcTimeZone_GetTimeZoneFLBName]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetTimeZoneID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcTimeZone_GetTimeZoneID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetTimeZoneWrittenName]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcTimeZone_GetTimeZoneWrittenName]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetTZIDfromFLBName]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcTimeZone_GetTZIDfromFLBName]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetReportRequiredParameters]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_GetReportRequiredParameters]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetTypeFromID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_GetTypeFromID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcRequiresDateFromDateTo]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcRequiresDateFromDateTo]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcRequiresEffectiveDate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcRequiresEffectiveDate]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_SaveCCUser]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_SaveCCUser]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUpdateOrgDeliquency]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUpdateOrgDeliquency]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTotalNumberofMails]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcTotalNumberofMails]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetListByUser]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCourse_GetListByUser]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetCPDReportName]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_GetCPDReportName]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetUnitAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_GetUnitAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_ResetUnitAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_ResetUnitAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_SetUnitAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_SetUnitAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_SetUserAccessByUser]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_SetUserAccessByUser]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_GetUnitAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcProfile_GetUnitAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLocalisationGet]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLocalisationGet]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetTimeZone]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetTimeZone]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetTimeZoneStandardName]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetTimeZoneStandardName]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetTimeZoneWrittenName]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetTimeZoneWrittenName]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcgetEscalationConfigForCourse ]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcgetEscalationConfigForCourse ]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_OrganisationsToNotify]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcAutomatedEmails_OrganisationsToNotify]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcDeleteTimezoneDaylightSavingRule]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcDeleteTimezoneDaylightSavingRule]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_MailServerURL]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcAutomatedEmails_MailServerURL]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCourse_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAppConfig_GetList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcAppConfig_GetList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAppConfig_GetMailServices]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcAppConfig_GetMailServices]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAppConfig_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcAppConfig_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetReminderEscalations]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetReminderEscalations]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLanguage_ReportLabels]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLanguage_ReportLabels]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetSet_MailFlag]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetSet_MailFlag]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetTimezoneDaylightRules]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetTimezoneDaylightRules]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGridExport_Headers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGridExport_Headers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGridExport_PeriodicCSV]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGridExport_PeriodicCSV]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGridExport_PeriodicPDF]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGridExport_PeriodicPDF]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGridExport_PeriodicRS]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGridExport_PeriodicRS]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[ToUTC]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [ToUTC]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_AdminSummaryReport]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_AdminSummaryReport]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_HistoricAdminSummaryOptimised]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_HistoricAdminSummaryOptimised]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_UnitAdministrators]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_UnitAdministrators]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_UserDetails]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_UserDetails]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_ImportPreview]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_ImportPreview]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetPercentExpectedEmails]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetPercentExpectedEmails]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcVersion_Get]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcVersion_Get]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcVersion_Set]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcVersion_Set]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_AdminMashup]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_AdminMashup]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetAcceptedUsers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_GetAcceptedUsers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetPoliciesAssignedToUsers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_GetPoliciesAssignedToUsers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetUsersByPolicyAndUnit]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_GetUsersByPolicyAndUnit]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Policies]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_Policies]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_PoliciesGrandTotal]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_PoliciesGrandTotal]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_PoliciesTotals]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_PoliciesTotals]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_RemoveAdmin]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_RemoveAdmin]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_RemoveAdministrator]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_RemoveAdministrator]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_SetAdministrator]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_SetAdministrator]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetAdminsInOrgPendingPolicy]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_GetAdminsInOrgPendingPolicy]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Licensing]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_Licensing]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Progress]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_Progress]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetModuleRule]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_GetModuleRule]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetOne]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_GetOne]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetArchiveUsers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetArchiveUsers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetDetailsByEmail]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetDetailsByEmail]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetDetailsByEmailAndDomain]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetDetailsByEmailAndDomain]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetOne]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetOne]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetOneWithOwnTime]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetOneWithOwnTime]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetQuizHistory]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetQuizHistory]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetSALTAdministrators]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetSALTAdministrators]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Trend]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_Trend]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_UnitCompliance]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_UnitCompliance]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetModuleAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_GetModuleAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SaveModuleAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_SaveModuleAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SaveModuleAccess1]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_SaveModuleAccess1]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SaveModuleRuleToAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_SaveModuleRuleToAll]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetModuleAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetModuleAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_SaveModuleAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_SaveModuleAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_Calc]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserCourseStatus_Calc]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_EnabledLastPassed]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_EnabledLastPassed]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetByUser]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCourse_GetByUser]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_ErrorLevelList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcErrorLog_ErrorLevelList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_ErrorStatusList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcErrorLog_ErrorStatusList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_UpdateDomainName]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_UpdateDomainName]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUnassigned]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetUnassigned]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourse_GetCompletionDate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserCourse_GetCompletionDate]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_GetOne]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserCourseStatus_GetOne]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserQuizStatus_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_Update_Quick]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserQuizStatus_Update_Quick]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_UpdateCourseStatus]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserQuizStatus_UpdateCourseStatus]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_insert]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserCourseStatus_insert]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_Calculate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserCourseStatus_Calculate]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcDatabaseMail_SetupProfile]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcDatabaseMail_SetupProfile]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_EnableQueuedMessage]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcEmail_EnableQueuedMessage]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_GetAttachments]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcEmail_GetAttachments]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_GetNext]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcEmail_GetNext]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_LogSentEmail]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcEmail_LogSentEmail]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_Purge]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcEmail_Purge]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_QueuedMessageAttachments]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcEmail_QueuedMessageAttachments]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_QueueMessage]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcEmail_QueueMessage]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_RemoveMessage]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcEmail_RemoveMessage]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOvernightJobPreprocessOneOrg]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOvernightJobPreprocessOneOrg]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOvernightJobGetNextPreprocessingOrg]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOvernightJobGetNextPreprocessingOrg]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Summary]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_Summary]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_CompleteUsersLogic]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_CompleteUsersLogic]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SaveModuleRule]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_SaveModuleRule]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetNotes]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCourse_GetNotes]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_Create]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCourse_Create]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_GetList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcClassification_GetList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_GetListAll]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcClassification_GetListAll]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_AddClassification]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcClassification_AddClassification]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Individual]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_Individual]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_IndividualDetails]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_IndividualDetails]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_InitialisePolicyAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_InitialisePolicyAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_InitialiseProfilePeriodAccess]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_InitialiseProfilePeriodAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_UserSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_UserSearch]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_ProgressGrandTotal]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_ProgressGrandTotal]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_UnitPath]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_UnitPath]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_Search]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_Search]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUSER_ArchiveUsers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUSER_ArchiveUsers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_ClassificationUpdate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_ClassificationUpdate]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetEmailAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetEmailAddress]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Search]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_Search]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_UsernameSearch]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_UsernameSearch]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_AssignUnit]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_AssignUnit]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetTimeZoneBySessionID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetTimeZoneBySessionID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Login]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_Login]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserLessonStatus_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_Quick]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserLessonStatus_Update_Quick]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_NO_TRIGGER]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserLessonStatus_Update_NO_TRIGGER]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_NO_TRIGGER_Quick]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserLessonStatus_Update_NO_TRIGGER_Quick]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_NO_TRIGGER_CurrentStatus]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserLessonStatus_Update_NO_TRIGGER_CurrentStatus]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_NO_TRIGGER_CurrentStatus_Quick]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserLessonStatus_Update_NO_TRIGGER_CurrentStatus_Quick]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_old_Quick]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserLessonStatus_Update_old_Quick]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_SetUserAccessByUnit]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_SetUserAccessByUnit]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetNotesByUser]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_GetNotesByUser]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetCCList]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetCCList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetCCListMain]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcGetCCListMain]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetCCList]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetCCList]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_UpdateClassification]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcClassification_UpdateClassification]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfIsGUID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfIsGUID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfUserUTCtoDaylightSavingTime]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfUserUTCtoDaylightSavingTime]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSearchAdminUsers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcSearchAdminUsers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSearchUsers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcSearchUsers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_IncompleteUsersLogic]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_IncompleteUsersLogic]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_HistoricUserCourseStatus]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_HistoricUserCourseStatus]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udf_GridExportHeaders]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udf_GridExportHeaders]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_UserMashup]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcCourse_UserMashup]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_Users]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcEmail_Users]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcJobGetAgentStatus]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcJobGetAgentStatus]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prc_cpu_percent]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prc_cpu_percent]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcApplication_GetDatabaseVersion]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcApplication_GetDatabaseVersion]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[GetSaltDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [GetSaltDate]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetSaltDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetSaltDate]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcPolicy_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSalt_GrantPermission]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcSalt_GrantPermission]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSqlAgentRunningStatus_Get]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcSqlAgentRunningStatus_Get]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetEmailReplyTo]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetEmailReplyTo]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReportSchedule_IncrementNextRunDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReportSchedule_IncrementNextRunDate]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udf_GetAdminEmailsForORG]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udf_GetAdminEmailsForORG]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udf_GetUnitHierarchiesForORG]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udf_GetUnitHierarchiesForORG]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLogUsage_Daily]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLogUsage_Daily]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLogUsage_Hourly]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLogUsage_Hourly]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonSession_StartLesson]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLessonSession_StartLesson]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetLessonIDBySessionID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetLessonIDBySessionID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonQuizSession_CheckSessionUnique]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLessonQuizSession_CheckSessionUnique]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfUnit_GetAdministratorsEmailAddress]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfUnit_GetAdministratorsEmailAddress]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetAdministratorsEmailAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetAdministratorsEmailAddress]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfUser_GetAdministratorsEmailAddress]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfUser_GetAdministratorsEmailAddress]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetQuizStatus]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetQuizStatus]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetUserQuizDetails]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetUserQuizDetails]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetUnitIDPathway]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetUnitIDPathway]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUnitIDByUserID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetUnitIDByUserID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUnitsTree]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetUnitsTree]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUserForCC]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetUserForCC]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUserType]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetUserType]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_LogLogin]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_LogLogin]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_SelectAdminUnitsTree]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_SelectAdminUnitsTree]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetAdminUnitsTree]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetAdminUnitsTree]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetPermission]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetPermission]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetIdFromEmail]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetIdFromEmail]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetIdFromUsername]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetIdFromUsername]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetNameBySessionID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetNameBySessionID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetClassification]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetClassification]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUserIDBySessionID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUser_GetUserIDBySessionID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_GetStatus]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserCourseStatus_GetStatus]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_AddAdministrator]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_AddAdministrator]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_RemoveAdministrator]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_RemoveAdministrator]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetAdministrableUnitsByUserID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_GetAdministrableUnitsByUserID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetAdministrators]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_GetAdministrators]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SearchUsers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_SearchUsers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLendLeaseUnitRestructure]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLendLeaseUnitRestructure]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_Update]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_Update]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetLastCompletedDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetLastCompletedDate]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUnitNames]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_GetUnitNames]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CourseStatusReport]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcReport_CourseStatusReport]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_CompleteCourseLogic]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_CompleteCourseLogic]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfUTCtoDaylightSavingTime]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfUTCtoDaylightSavingTime]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_IncompleteCourseLogic]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_IncompleteCourseLogic]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_HistoricUserCourseStatusWithinRange]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_HistoricUserCourseStatusWithinRange]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfCsvToInt]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfCsvToInt]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfDaylightSavingTimeToUTC]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfDaylightSavingTimeToUTC]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetPassMark]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuiz_GetPassMark]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfQuiz_GetPassMark]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfQuiz_GetPassMark]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_GetQuizIDBySessionID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuizSession_GetQuizIDBySessionID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_StartQuiz]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcQuizSession_StartQuiz]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcJobMaintainUnitHierarchies]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcJobMaintainUnitHierarchies]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonQuizSession_GetUserIDBySession]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcLessonQuizSession_GetUserIDBySession]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetUserIDBySessionID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetUserIDBySessionID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetAdministratorsEmailAddress]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_GetAdministratorsEmailAddress]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetPermission]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_GetPermission]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUnitsTreeByUserIDAndSelect]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_GetUnitsTreeByUserIDAndSelect]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUnitsByOrganisation]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_GetUnitsByOrganisation]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUnitsTreeByUserID]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_GetUnitsTreeByUserID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUsers]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_GetUsers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_Move]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_Move]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_CheckUserRole]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_CheckUserRole]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_MoveToTopLevel]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUnit_MoveToTopLevel]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetLessonStatus]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetLessonStatus]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_IncompleteUsers]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_IncompleteUsers]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfUserCourseComplete]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfUserCourseComplete]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_REMOVEDUPLICATESTATUS]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserCourseStatus_REMOVEDUPLICATESTATUS]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserModuleAccess_Validate]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcUserModuleAccess_Validate]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_GetEarliestLessonStatus]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfReport_GetEarliestLessonStatus]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_CheckUnitTree]') AND type in (N'P', N'PC'))
DROP PROCEDURE [prcOrganisation_CheckUnitTree]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetQuizIDBySessionID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetQuizIDBySessionID]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetUserModuleAccess]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetUserModuleAccess]
GO
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetUnitPathway]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
DROP FUNCTION [udfGetUnitPathway]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetUnitPathway]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetUnitPathway    Script Date: 20/04/2004 8:25:57 AM ******/

/*
Summary:
user Defined Function that returns pathway of a specified unit
Returns:
">" delimited pathway of a unit
e.g. "Unit 1 > Unit 2 > Unit 5 > Unit 7"

Called By:

Calls:

Remarks:


Author: Jack Liu
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


select  dbo.udfGetUnitPathway(9)

select dbo.udfGetUnitPathway(UnitID)
from tblUnit

**/
CREATE  FUNCTION [udfGetUnitPathway]
(
@UnitID int
)
RETURNS nvarchar(4000)
Begin

declare @strPathway nvarchar(4000)
declare @strHierarchy nvarchar(500)

select @strHierarchy='',''+hierarchy+'',''
from tblUnit
where UnitID = @UnitID

--Convert unit ID hierarchy ''''1,2,5,7'''' to pathway ''''Unit 1 > Unit 2 > Unit 5 > Unit 7''''

select @strPathway=IsNull(@strPathway+'' > '','''')+Name
from tblUnit
where charindex('',''+cast(UnitID as varchar)+'','', @strHierarchy)>0
order by [Level]

--select @strPathway

RETURN @strPathway
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetUserModuleAccess]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/*
Summary:
user Defined Function that returnsthe ModulesID''s as a comma seperated string
Returns:


Remarks:


Author: Jack Liu
Date Created: 6 09 2005

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


select  dbo.udfGetUserModuleAccess(2,333)



**/
CREATE  FUNCTION [udfGetUserModuleAccess]
(
@UserID int,
@CourseID int
)
RETURNS varchar(4000)
Begin

declare @strModuleIDs varchar(8000)

set @strModuleIDs = '''' -- string to hold moduelids
select
@strModuleIDs = cast(ModuleID as varchar) + '','' + @strModuleIDs
from
vwUserModuleAccess
where
CourseID = @CourseID
and  UserID = @UserID

RETURN @strModuleIDs
End
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetQuizIDBySessionID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetQuizIDBySessionID    Script Date: 20/04/2004 8:25:57 AM ******/

/*
Summary:
user Defined Function that returns a Quiz id given a Session id
Returns:
integer

Called By:
ToolbookListener.aspx

Calls:

Remarks:


Author:	Peter Kneale
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	GB		9/2/04			Coding standards

**/

CREATE  Function [udfGetQuizIDBySessionID]
(
@sessionID Varchar(50) --Session ID used to determine the Quiz ID
)
Returns Integer

Begin
-- Declarations
Declare @retVal Integer --Quiz ID to be returned

-- Get Quiz ID from Session
Set @retVal =
(
Select Top 1
QuizID
From
tblQuizSession
Where
QuizSessionID = ltrim(rtrim(@sessionID))
)

Return @retVal

End
' 
END
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[prcOrganisation_CheckUnitTree]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Check and rebuild unit tree hierarchy for a specified organisation,


Returns:
none


Called By:
Calls:

Remarks:
The unit hierarchy data are redundent and may be inconsistent with the actual tree structure

This procedure will guarantee the tree hierarchy are correct.


Author: Jack Liu
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcOrganisation_CheckUnitTree 3
prcOrganisation_CheckUnitTree


**/

CREATE  PROCEDURE [dbo].[prcOrganisation_CheckUnitTree]
(
@organisationID  int=null
)
as
set nocount on

declare @intLevel int
declare @intRecordCount int

SET XACT_ABORT On

begin tran
--Initialize
Update tblUnit
set 	[level]=null,
Hierarchy=null
where 	(organisationID = @organisationID)
or (@organisationID is null)

--Build top level
set @intLevel=0

Update tblUnit
set 	[level]=@intLevel+1,
Hierarchy=cast(UnitID as varchar)
where 	((organisationID = @organisationID)
or (@organisationID is null))
and (parentUnitID is null)

set @intRecordCount=@@ROWCOUNT
set @intLevel=@intLevel+1

-- build middle level
while @intRecordCount>0
begin

Update 	tblUnit
set 	[Level]=@intLevel+1,
Hierarchy=parent.Hierarchy + '','' + cast(tblUnit.UnitID as varchar)
from 	tblUnit
inner join tblUnit parent
on tblUnit.ParentUnitID = parent.UnitID
and parent.[Level] = @intLevel
where (tblUnit.organisationID = @organisationID)
or (@organisationID is null)

set @intRecordCount=@@ROWCOUNT
set @intLevel=@intLevel+1
end

COMMIT TRAN
' 
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_GetEarliestLessonStatus]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [udfReport_GetEarliestLessonStatus]
(
@UserID int,
@ModuleID int
)
RETURNS INT
AS
BEGIN
DECLARE @strStatus INT

SELECT  TOP 1 @strStatus = LessonStatusID
FROM tblUserLessonStatus uls
ORDER BY uls.DateCreated ASC
RETURN @strStatus
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[prcUserModuleAccess_Validate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Validates that a user has Access to a lesson / quiz
Given User ID
Returns:
int
0 - (false) - indicates user does NOT have access
1 - (true)  - indicates user does have access

Called By: TooolBooLlistner.aspx
Calls:

Remarks:
Given the Module ID and UserID this proc returns true or false
Both paramaters are manditory
Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Jack Liu	23/02/2004		Get module access from view


prcUserModuleAccess_Validate @UserID = 11, @ModuleID = 1

**/

CREATE    PROC [dbo].[prcUserModuleAccess_Validate]
(
@UserID int, -- the user ID
@ModuleID int-- the Module ID
)

AS
set nocount on

declare @Ret_Value int
if exists(select ModuleID
from vwUserModuleAccess
where UserID=@UserID
and ModuleID = @ModuleID)
Begin
set @Ret_Value = 1
end
else
Begin
set @Ret_Value = 0
End


Select @Ret_Value
Return




' 
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[prcUserCourseStatus_REMOVEDUPLICATESTATUS]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE procedure [dbo].[prcUserCourseStatus_REMOVEDUPLICATESTATUS]
AS
-- prcUserCourseStatus_REMOVEDUPLICATESTATUS
--Remove duplicated unassigned status records due to a bug inside the tblUserQuizStatus trigger

select UserID, courseID,min(UserCourseStatusID) as minID, max(UserCourseStatusID) as maxID
into #Duplicated
from tblUserCourseStatus
where  CourseStatusID=0
group by UserID, courseID
having min(UserCourseStatusID)<>max(UserCourseStatusID)
order by UserID, courseID


--Don''t delete the following records if there are any other status between unassigned status
select d.*
into #DuplicatedError
from #Duplicated d
inner join tblUserCourseStatus s on s.UserID=d.UserID and s.CourseID=d.CourseID and s.UserCourseStatusID>=d.minID and s.UserCourseStatusID<=d.MaxID
where s.CourseStatusID<>0

delete #Duplicated
from #Duplicated d
inner join tblUserCourseStatus s on s.UserID=d.UserID and s.CourseID=d.CourseID and s.UserCourseStatusID>=d.minID and s.UserCourseStatusID<=d.MaxID
where s.CourseStatusID<>0


--Removed duplicated records, leave the first record
delete tblUserCourseStatus
from tblUserCourseStatus s
inner join #Duplicated d on s.UserID=d.UserID and s.CourseID=d.CourseID and s.UserCourseStatusID>d.minID and s.UserCourseStatusID<=d.MaxID
where s.CourseStatusID=0

select cast(@@rowCount as varchar) + '' duplicated status have been removed''

if (select count(*) from #DuplicatedError)>0
begin
select ''The following user course status need to be manually removed''
select * from #DuplicatedError
end

drop table #Duplicated
drop table #DuplicatedError




' 
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfUserCourseComplete]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfUserCourseComplete   Script Date: 08/12/2009 8:25:58 AM ******/

/*
Summary:	Returns 1 if the given user has a current course status of complete (2) for the given course

Called By:	dbo.prcReport_Warning.PRC
dbo.prcReport_WarningGrandTotal.PRC

Author:		Mark Donald
Created:	8 Dec 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

*/

CREATE FUNCTION [udfUserCourseComplete]
(
@userID int,
@courseID int
)
RETURNS bit AS
BEGIN
DECLARE @course_status int
SELECT
TOP 1 @course_status = CourseStatusID
FROM
tblUserCourseStatus
WHERE
CourseID = @CourseID
AND UserID = @UserID
ORDER BY
DateCreated DESC
RETURN CASE WHEN isnull(@course_status, 0) = 2 THEN 1 ELSE 0 END
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_IncompleteUsers]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/*Summary:
List of users that have not completed there training requirements

Returns:
Table (userID int)

Called By:
BusinessServices.GetCompletedUsersReport
Calls:
vwUserQuizStatus
vwUserModuleAccess
dbo.udfReport_IncompletUsers_logic
Remarks:
This function abstracts dbo.udfReport_IncompletUsers_logic and
filters for the required rows

Author:
Stephen Kennedy-Clark
Date Created: 18 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


--------------------
-- SELECT * FROM dbo.udfReport_incompleteUsers(null)

**/

CREATE    function [udfReport_IncompleteUsers]()
Returns table
as
Return
SELECT DISTINCT
vUMA.UserID
, vUMA.CourseID
FROM
vwUserModuleAccess vUMA
left outer join vwUserQuizStatus vUQS
on vUQS.UserID = vUMA.UserID
and vUQS.ModuleID = vUMA.ModuleID
and vUQS.QuizStatusID = 2
where
vUQS.QuizStatusID is null -- (is null = incomplete)
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetLessonStatus]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetLessonStatus    Script Date: 20/04/2004 8:25:57 AM ******/



/*
Summary:
user Defined Function that returns a sessionID given a module id and a userID
only the users Latest Status ID is returned
Returns:
integer

Called By: prcModule_GetDetailsForHomePage

Calls:

Remarks:


Author:	Stephen Kennedy Clark
Date Created: Fiday 13 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	GB		9/2/04			Coding standards

print dbo.udfGetLessonStatus(4,41)
select * from tblUserLessonStatus

Order by DateCreated desc
**/

CREATE   Function [udfGetLessonStatus]
(
@moduleID Integer -- the module to get the users status for
, @userID Integer -- the user id to get the status for
)
Returns Integer --< Lesson Status >-

Begin

Declare @intReturnValue Integer -- User Status

Set @intReturnValue =
(
Select Top 1
LessonstatusID
From
tblUserLessonStatus
Where
UserID = @userID
and ModuleID = @moduleID
Order by DateCreated desc
)

Return @intReturnValue

End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[prcUnit_MoveToTopLevel]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Move a unit to top level.
Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:


Exception:
0: Succeed
1.RecordNotFound
2.FK constraint
3.PKViolationException
4.UniqueViolationException
10.BusinessServiceException (General)


Author: Jack Liu
Date Created: 11 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE PROCEDURE [dbo].[prcUnit_MoveToTopLevel]
(
@fromUnitID	int,
@adminUserID 	int
)

AS

set nocount on

set xact_abort on
Begin Tran
declare @strErrorMessage varchar(500)
declare @intErrorNumber int

declare @intUserTypeID int

declare @intFromOrganisationID int
declare @strFromHierarchy nvarchar(500)
declare @intFromParentUnitID int

select @intUserTypeID = UserTypeID
from tblUser
where userID = @adminUserID

select @intFromOrganisationID = OrganisationID,
@strFromHierarchy = Hierarchy,
@intFromParentUnitID = parentUnitID
from tblUnit
where unitID=@fromUnitID


set @strErrorMessage=''''

-------------- 1. Permission Checking ----------------
--Only Salt Administrator (1), Organisation Administrator (2) can move a unit to top level
If (@intUserTypeID>2)
begin
set @strErrorMessage = ''You do not have permission to move a unit to the top level.''
set @intErrorNumber = 1
end

-----------------2. Validation -----------------------------
if (@strErrorMessage='''')
begin
--	2.1. "From" unit is in top level
if (@intFromParentUnitID is null)
begin
set @strErrorMessage = ''The ''''From'''' unit already exists at the top level.''
set @intErrorNumber = 11
end
end

if (@strErrorMessage='''')
begin
--1. Update hierarchy and rebuild the unit tree
Update tblUnit
set parentUnitID=null,
UpdatedBy = @adminUserID,
DateUpdated = getutcdate()
where unitID=@fromUnitID

--rebuild the unit tree
exec prcOrganisation_CheckUnitTree @intFromOrganisationID

--2. Keep the exsiting administrators
select 0 as Error, '''' as ErrorMessage
end
else
begin
select @intErrorNumber as Error,  @strErrorMessage as ErrorMessage
end

commit TRAN
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[prcOrganisation_CheckUserRole]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Check user role for one organisation,


Returns:
none


Called By:
Calls:

Remarks:
The user role may be changed due to permission changes, it may be inconsistent with the other data

This procedure will check the permission and guarantee the roles are correct.


Author: Jack Liu
Date Created: 12 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcOrganisation_CheckUserRole 3



**/

CREATE  PROCEDURE [dbo].[prcOrganisation_CheckUserRole]
(
@organisationID  int=null
)
as
set nocount on

--1. Salt Admin(1) or Org Admin (2)
-- Remove Unit Administrator permission because these two roles have full permission to all units
delete tblUnitAdministrator
from tblUnitAdministrator ua
inner join tblUser u on ua.userID=u.UserID
where ((u.organisationID = @organisationID)
or (@organisationID is null))
and u.UserTypeID in (1,2) --Salt Admin or Org Admin

--2. Unit Administrator(3)
--Change User role to Unit Administrator(3) if a Salt User(4) manage some units
Update tblUser
set UserTypeID=3
from tblUser u
inner join tblUnitAdministrator ua on ua.userID=u.UserID
where ((u.organisationID = @organisationID)
or (@organisationID is null))
and u.UserTypeID=4 --Salt user


--3. Salt User (4)
--Change User role to Salt User(4) if a Unit Administrator(3) no longer manages any units
Update tblUser
set UserTypeID=4
from tblUser u
left join tblUnitAdministrator ua on ua.userID=u.UserID
where ((u.organisationID = @organisationID)
or (@organisationID is null))
and u.UserTypeID=3 --Unit Administrator
and ua.unitID is null



' 
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_Move]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Move a  unit to a new parent
Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:
1. Permission Checking:
1.1. "From" unit permision: Administrator of this unit and all sub-units
1.2. "To" unit permision: "Propagate" administrator of this unit

2. Validation:
2.1. "From" unit is not the same as "To" unit
2.2. "From" and "To" unit are in the same organisation
2.3. "From" unit is not the parent of "To" unit
2.4  "To" unit is the direct parent of "From" unit


Moving permissions:
When a Unit is moved into to another Unit, all of its current administrators will be removed,
and it will inherit its new administrators from its new place in the hierarchy,
according to the "Administer Sub-units" rights of the existing administrators.



Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
10.BusinessServiceException (General)


Author: Jack Liu
Date Created: 11 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE PROCEDURE [prcUnit_Move]
(
@fromUnitID	int,
@toUnitID	int,
@adminUserID 	int
)

AS

set nocount on

set xact_abort on
Begin Tran
declare @strErrorMessage varchar(500)
declare @intErrorNumber int

declare @intUserTypeID int

declare @intFromOrganisationID int, @intToOrganisationID int
declare @strFromHierarchy nvarchar(500),@strToHierarchy nvarchar(500)
declare @intFromParentUnitID int

select @intUserTypeID = UserTypeID
from tblUser
where userID = @adminUserID

select @intFromOrganisationID = OrganisationID,
@strFromHierarchy = Hierarchy,
@intFromParentUnitID = parentUnitID
from tblUnit
where unitID=@fromUnitID

select @intToOrganisationID = OrganisationID,
@strToHierarchy = Hierarchy
from tblUnit
where unitID=@toUnitID


set @strErrorMessage=''''

-------------- 1. Permission Checking ----------------

--Salt Administrator (1), Organisation Administrator (2): full permission to access all units
--Salt User (4): No permission
if (@intUserTypeID=4)
begin
set @strErrorMessage = ''You are not the administrator of the system''
set @intErrorNumber = 1
end
--Unit Administrator (3): limited permission
else if (@intUserTypeID=3)
begin
--	1.1. "From" unit permision: Administrator of this unit and all sub-units
if 	exists(select su.unitid
from tblUnit su --sub-units
left join tblUnitAdministrator ua
on su.unitID=ua.unitID
and ua.userID = @adminUserID
where su.hierarchy+'','' like @strFromHierarchy+'',%'' --"From" Unit and all its sub-units
and ua.unitID is null)	--Not administrator
begin
set @strErrorMessage = ''You are not administrator of the "From" unit and all its sub-units''
set @intErrorNumber = 11
end
--	1.2. "To" unit permision: "Propagate" administrator of this unit
else 	if not exists(select unitid from tblUnitAdministrator where unitID=@toUnitID and userID = @adminUserID and propagate=1)
begin
set @strErrorMessage = ''You don''''t have permission to administer sub-units of the "To" unit''
set @intErrorNumber = 12
end
end

-----------------2. Validation -----------------------------
if (@strErrorMessage='''')
begin
--	2.1. "From" unit is not the same as "To" unit
if (@fromUnitID=@toUnitID)
begin
set @strErrorMessage = ''The "From" unit can''''t be the same as the "To" unit''
set @intErrorNumber = 13
end
--	2.2. "From" and "To" unit are in the same organisation
else if (@intFromOrganisationID<>@intToOrganisationID)
begin
set @strErrorMessage = ''The "From" and the "To" unit should be in the same organisation''
set @intErrorNumber = 14
end
--	2.3. "From" unit is not the parent of "To" unit
else if (charindex( @strFromHierarchy+'','', @strToHierarchy)=1)
begin
set @strErrorMessage = ''The "From" unit can''''t be the parent of the "To" unit''
set @intErrorNumber = 15
end
--	2.4  "To" unit is the direct parent of "From" unit
else if (@intFromParentUnitID=@toUnitID)
begin
set @strErrorMessage = ''The "To" unit can''''t be the direct parent of the "From" unit''
set @intErrorNumber = 16
end
end

if (@strErrorMessage='''')
begin
--1. Update hierarchy and rebuild the unit tree
Update tblUnit
set parentUnitID=@toUnitID,
UpdatedBy = @adminUserID,
DateUpdated = getutcdate()
where unitID=@fromUnitID

exec prcOrganisation_CheckUnitTree @intToOrganisationID

--2. Moving permissions
--2.1 Get the new hierarchy
select 	@strFromHierarchy = Hierarchy
from tblUnit
where unitID=@fromUnitID
--2.2 Remove all current administrators from the unit and  its sub-units
Delete
from tblUnitAdministrator
where unitID in (select unitID
from tblUnit
where hierarchy+'','' like @strFromHierarchy+'',%'') --Current Unit and its sub-units


--2.3 Propagate all unit admininstrators from parent (with propagate flag)
insert into tblUnitAdministrator(UnitID, UserID, Propagate, createdBy)
select 	u.UnitID, ua.UserID, 1 , @adminUserID
from 	tblUnitAdministrator ua
cross join  tblUnit u
where 	ua.unitID = @toUnitID
and ua.Propagate=1
and u.hierarchy+'','' like @strFromHierarchy+'',%''

--2.4 Check and Update user role
exec prcOrganisation_CheckUserRole @intToOrganisationID

select 0 as Error, '''' as ErrorMessage
end
else
begin
select @intErrorNumber as Error,  @strErrorMessage as ErrorMessage
end

commit TRAN
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Gets a list of users from a specific Unit

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcUnit_GetUsers]
(
@unitID Integer = null,
@includeInactiveUsers bit = 0
)

As

If @unitID Is Null
Begin
Raiserror(''The Parameter @unitID was null.  @unitID does not accept Null values.'', 16, 1)
Return
End
if (@includeInactiveUsers = 0)
Begin
Select 	UserID,
UserName,
FirstName,
LastName,
Email,
Active
From tblUser
Where UnitID = @unitID
And
Active = 1
order by LastName
End
Else
Begin
Select 	UserID,
UserName,
FirstName,
LastName,
Email,
Active
From tblUser
Where UnitID = @unitID

order by LastName
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUnitsTreeByUserID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Get all units in the specified organisation and can be selected by the specified user

Returns:
Flat hierarchy table


Called By:
Calls:

Remarks:

@permission:
A: [A]dministrator
P: Administrator with [P]ropagating right
S: Administrator of the Unit and all of its [S]ub-units
Empty or null: All units, no permission needed

Author:
Jack Liu
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcUnit_GetUnitsTreeByUserID 3, 5,''S''


**/

CREATE   PROC [prcUnit_GetUnitsTreeByUserID]
(
@organisationID  int,
@userID int,
@permission char(1)=''A'',
@includingInactiveUnits bit = 0
)

AS

set nocount on

declare @intUserTypeID int
declare @strDisabledUnitIDs varchar(4000)

if @permission is null
set @permission=''''

select @intUserTypeID = UserTypeID
from tblUser
where userID = @userID

declare @EnableUnit table
(
UnitID int
)

--Salt Administrator, Organisation Administrator has permission to access all units
if (@intUserTypeID=1 or @intUserTypeID=2 or @permission='''')
begin
insert 	into @EnableUnit(UnitID)
select 	u.UnitID
from 	tblUnit as u
where 	(u.organisationID=@organisationID)
end
--A: Unit Administrator only has permission to those that he is administrator
else if @permission=''A''
begin
--Get a list of unit id that the user is  the administrator
insert into @EnableUnit(UnitID)
select 	u.UnitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@organisationID)

end
--P: Administrator with [P]ropagating right
else if @permission=''P''
begin
--Get a list of unit id that the user has [P]ropagating right
insert into @EnableUnit(UnitID)
select 	u.UnitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
and (ua.propagate=1)
where 	(u.organisationID=@organisationID)
end
--S: Administrator of the Unit and all of its [S]ub-units
else if @permission=''S''
begin

insert into @EnableUnit(UnitID)
select 	u.UnitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@organisationID)
and not exists(
select su.unitid
from tblUnit su --sub-units
left join tblUnitAdministrator ua
on su.unitID=ua.unitID
and ua.userID = @userID
where su.hierarchy+'','' like u.hierarchy+'',%'' --Current Unit and all sub-units
and ua.unitID is null	--Not administrator
)--Administrator of all sub-units
end

--Get a list of unit id that the user dn''t have permission
select 	@strDisabledUnitIDs= isNull(@strDisabledUnitIDs + '','','''')+ cast(u.unitID as varchar)
from 	tblUnit as u
left join @EnableUnit as eu
on (u.unitID=eu.unitID)
where 	(u.organisationID=@organisationID)
and eu.UnitID is null

-- If @includingInactiveUnits = 1 then return all units even those that are inactive
-- By default only return those that are active
if @includingInactiveUnits = 1
select 
un.unitid ''UnitID'',
un.parentunitid ''ParentUnitID'',
un.name ''Name'',
case when eu.unitid is null then 1 else 0 end ''Disabled'',
0 ''Selected'',
0 ''Expanded''
from tblUnit un
left join @EnableUnit as eu
on (un.unitID=eu.unitID)
where 	(un.organisationID=@organisationID)
order by un.hierarchy

else

select 
un.unitid ''UnitID'',
un.parentunitid ''ParentUnitID'',
un.name ''Name'',
case when eu.unitid is null then 1 else 0 end ''Disabled'',
0 ''Selected'',
0 ''Expanded''
from tblUnit un
left join @EnableUnit as eu
on (un.unitID=eu.unitID)
where 	(un.organisationID=@organisationID)
and un.active=1
order by un.hierarchy









' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUnitsByOrganisation]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get all units in the specified organisation

Returns:
Flat  hierarchy table


Called By:
Calls:

Remarks:
This procedure will be used by many other procedures to get unit tree for special purpose.
The @disabledUnitIDs, @selectedUnitIDs, @expandedUnitIDs parameters are comma delimited string, such as ''1,34,67''
These strings will be different according different criteria.
For example: For unit administrators, they only have permission to manage the units  that the administrator  has administration rights

if  @parentUnitID is not null, it will show all sub units of this unit

The returned flat  hierarchy table will be used by UnitTreeConvert.xslt to convert to hierarchy tree document.
The standard tree document can be used by TreeView  Control

Author:
Jack Liu
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcUnit_GetUnitsByOrganisation 3,'''','''','''',1
prcUnit_GetUnitsByOrganisation 3, ''1,4,5''

**/

CREATE  PROC [prcUnit_GetUnitsByOrganisation]
(
@organisationID  int,
@disabledUnitIDs varchar(4000)=null,
@selectedUnitIDs varchar(4000)=null,
@expandedUnitIDs varchar(4000)=null,
@parentUnitID	int =null,
@includingInactiveUnits bit = 0
)

AS


set nocount on
declare @strParentHierarchy varchar(500)

set @disabledUnitIDs = '','' + @disabledUnitIDs  + '',''
set @selectedUnitIDs = '','' + @selectedUnitIDs + '',''
set @expandedUnitIDs= '','' + @expandedUnitIDs + '',''

if (@includingInactiveUnits = 1)
begin
-- Return Only Units that are currently active
if (@parentUnitID>0)
select @strParentHierarchy = Hierarchy +'',%''
from tblUnit
where UnitID=@parentUnitID
else
set @strParentHierarchy=''%'';

SELECT 	UnitID,
case
when ParentUnitID = @parentUnitID then null
else ParentUnitID
end as ParentUnitID,

case
when Active=0 then [Name] +'' (I)''
else [Name]
end as Name,

case
when charindex('','' + cast(UnitID as varchar)+'','', @disabledUnitIDs)>0 then 1
else 0
end as Disabled,
case
when charindex('','' + cast(UnitID as varchar)+'','', @selectedUnitIDs)>0 then 1
else 0
end as Selected,
case
when charindex('','' + cast(UnitID as varchar)+'','', @expandedUnitIDs)>0 then 1
else 0
end as Expanded
from tblUnit as Unit
where OrganisationID =@organisationID
and Hierarchy like @strParentHierarchy
order by Hierarchy
end
else
begin
if (@parentUnitID>0)
select @strParentHierarchy = Hierarchy +'',%''
from tblUnit
where UnitID=@parentUnitID
else
set @strParentHierarchy=''%'';

SELECT 	UnitID,
case
when ParentUnitID = @parentUnitID then null
else ParentUnitID
end as ParentUnitID,

[Name],

case
when charindex('','' + cast(UnitID as varchar)+'','', @disabledUnitIDs)>0 then 1
else 0
end as Disabled,
case
when charindex('','' + cast(UnitID as varchar)+'','', @selectedUnitIDs)>0 then 1
else 0
end as Selected,
case
when charindex('','' + cast(UnitID as varchar)+'','', @expandedUnitIDs)>0 then 1
else 0
end as Expanded
from tblUnit as Unit
where OrganisationID =@organisationID
and Hierarchy like @strParentHierarchy
and Active = 1
order by Hierarchy
end
' 
END
GO

SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUnitsTreeByUserIDAndSelect]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get all units in the specified organisation and can be selected by the specified user.
The default selected unit is passed in via the @selectedUnitID parameter.
All parents of the selected unit back up the the root of the tree will be expanded.

Returns:
Flat hierarchy table


Called By:
User.cls
Calls:
prcUnit_GetUnitsByOrganisation
Remarks:

@permission:
A: [A]dministrator
P: Administrator with [P]ropagating right
S: Administrator of the Unit and all of its [S]ub-units
Empty or null: All units, no permission needed

Author:
Peter Kneale
Date Created: 2 Mar 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcUnit_GetUnitsTreeByUserID 3, 5,''S''


**/

CREATE Procedure [prcUnit_GetUnitsTreeByUserIDAndSelect]
(
@organisationID  	Integer,		-- Organisation ID of the calling user
@userID 		Integer, 		-- User ID of the calling user
@permission 		Char(1)=''A'',	-- Permission as described above
@selectedUnitID 	Integer		-- Unit ID of the unit that is to be selected initially
)

AS

set nocount on

-- Declarations

Declare @intUserTypeID	 	Integer		-- User Type of the calling user
Declare @strDisabledUnitIDs 	Varchar(4000)	-- CSV List of disabled units
Declare @strExpandedUnitID 	Varchar(4000)	-- CSV List of expanded Units

Declare @EnableUnit Table
(
UnitID Integer
)
-- Replace null permission with empty string
If @permission is null
Begin
Set @permission=''''
End

-- Get user type
Select
@intUserTypeID = UserTypeID
from
tblUser
where
userID = @userID



--Salt Administrator, Organisation Administrator has permission to access all units
If (@intUserTypeID=1 or @intUserTypeID=2 or @permission='''')
Begin
Insert 	Into
@EnableUnit(UnitID)
Select
u.UnitID
From
tblUnit as u
Where
(u.organisationID=@organisationID)
End

--A: Unit Administrator only has permission to those that he is administrator
Else If @permission=''A''
Begin
--Get a list of unit id that the user is  the administrator
Insert Into
@EnableUnit(UnitID)
Select 	u.UnitID
From 	tblUnit as u
Inner join tblUnitAdministrator as ua
On (u.unitID=ua.unitID)
and (ua.userID = @userID)
Where 	(u.organisationID=@organisationID)

End

--P: Administrator with [P]ropagating right
Else If @permission=''P''
Begin
--Get a list of unit id that the user has [P]ropagating right
Insert Into @EnableUnit(UnitID)
Select 	u.UnitID
From 	tblUnit as u
Inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
and (ua.propagate=1)
Where 	(u.organisationID=@organisationID)
End
--S: Administrator of the Unit and all of its [S]ub-units
Else If @permission=''S''
Begin
Insert Into @EnableUnit(UnitID)
Select
u.UnitID
From 	tblUnit as u
Inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
Where 	(u.organisationID=@organisationID)
and not exists(
select su.unitid
from tblUnit su --sub-units
left join tblUnitAdministrator ua
on su.unitID=ua.unitID
and ua.userID = @userID
where su.hierarchy+'','' like u.hierarchy+'',%'' --Current Unit and all sub-units
and ua.unitID is null	--Not administrator
)--Administrator of all sub-units
end

--Get a list of unit id that the user dn''t have permission
Select
@strDisabledUnitIDs= isNull(@strDisabledUnitIDs + '','','''')+ cast(u.unitID as varchar)
From
tblUnit as u
left join @EnableUnit as eu
on (u.unitID=eu.unitID)
Where
(u.organisationID=@organisationID)
and eu.UnitID is null

-- Get the hierarchy in CSV format down to this unit so that they can be expanded and make the
-- selected unit visible
Select
@strExpandedUnitID = Hierarchy
From
tblUnit
Where
UnitID = @selectedUnitID

-- Get the Tree
Exec prcUnit_GetUnitsByOrganisation @organisationID, @strDisabledUnitIDs,@selectedUnitID, @strExpandedUnitID
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetPermission]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get unit administering permission
Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:



Author: Jack Liu
Date Created: 18 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE PROCEDURE [prcUnit_GetPermission]
(
@unitID		int,
@adminUserID 	int,
@permission  	char(1)=null output
)

AS

set nocount on

Declare @intUnitOrganisationID int
declare @intUserTypeID int, @intUserOrganisationID int


select @intUnitOrganisationID = OrganisationID
from tblUnit
where UnitID=@unitID

select @intUserTypeID = UserTypeID,
@intUserOrganisationID = OrganisationID
from tblUser
where userID = @adminUserID


if (@intUnitOrganisationID is not null)
begin
--1. Salt Admin
if (@intUserTypeID=1)
begin
select @permission = ''F''
end
--2. Org admin
else if (@intUserTypeID=2)
begin
--If the admin user is in the same organisation as the unit, it has Full permission
--otherwise no permission
if (@intUnitOrganisationID = @intUserOrganisationID)
select @permission = ''F''
else
select @permission = ''''
end
--3. Unit admin, User must be administrator of that unit
else if (@intUserTypeID=3)
begin
select @permission =
case
when Propagate = 0 then ''A''
when Propagate =1 then ''P''
else ''''
end
from tblUnitAdministrator
where UnitID =@unitID
and UserID =@adminUserID
end
end

if (@permission is null)
select @permission = ''''
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetAdministratorsEmailAddress]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'




CREATE PROCEDURE [prcUnit_GetAdministratorsEmailAddress]
(
@unitID	int
)

AS

select coalesce(
-- try to get the closest unit admin then search further afield
(Select top 1	u.Email
from tblUnitAdministrator ua
inner join tblUser u on ua.userID = u.UserID
where ua.unitID=@unitID
and u.usertypeID=3 --Unit administrator(3)
and u.unitID=@unitID
and u.Email is not null),


(Select top 1	u.Email
from tblUnitAdministrator ua
inner join tblUser u on ua.userID = u.UserID
where ua.unitID=@unitID
and u.usertypeID=3 --Unit administrator(3)
and u.Email is not null),

(Select top 1	u.Email
from tblUser u inner join tblUnit un on un.OrganisationID = u.OrganisationID
where un.unitID=@unitID
and UserTypeID = 2
and Email is not null),


(Select top 1	u.Email
from tblUser u inner join tblUnit un on un.OrganisationID = u.OrganisationID
where un.unitID=@unitID
and UserTypeID = 1
and Email is not null),

--all else failed so get the salt admin
(Select top 1	u.Email
from tblUser u
where UserTypeID = 1
and Email is not null))




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetUserIDBySessionID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetUserIDBySessionID    Script Date: 20/04/2004 8:25:57 AM ******/


/*Summary:
user Defined Function that return a user id given a session id
Works for both the lesson and quiz
Returns:
UserID int

Called By:
dbo.prcBookMark_GetBookMark
dbo.prcBookMark_GetBookMarkBySessionID
dbo.prcLessonPageAudit_GetPagesVisited
dbo.prcLessonPageAudit_GetPagesVisitedBySessionID
dbo.prcLessonQuizSession_GetUserIDBySession
dbo.prcLessonSession_EndLesson
dbo.prcQuizSession_EndQuiz
dbo.prcUser_GetNameBySessionID
dbo.prcUser_GetUserIDBySessionID
Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


print dbo.udfGetUserIDBySessionID(''52FC3930-B1B6-474D-B041-28771E9964AD'')
-- select * from tblQuizSession
-- select * from tblLessonSession
**/
CREATE  FUNCTION [udfGetUserIDBySessionID]
(
@sessionID varchar(50) -- Session ID a GUID
)
RETURNS INT --< UserID >--
Begin
------------------------------------------
-- get user id for this session
------------------------------------------

DECLARE @retVal int
set @retVal =
(
Select Top 1
UserID
From
(
--< tblQuizSession >--
Select
userID
From
tblQuizSession
where
QuizSessionID = @SessionID
UNION

--< tblLessonSession >--
Select
userID
From
tblLessonSession
Where
LessonSessionID =  @SessionID
) t1 --< Dummy Table name to stop SQL complaining >--
)
RETURN @retVal
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonQuizSession_GetUserIDBySession]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Starts a Lesson and Returns a  sessionID
Returns:
UserID int

Called By: TooolBooLlistner.aspx
prcUserModuleAccess_Validate
Calls:
udfGetUserIDBySessionID
Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


declare @val int
execute @val =prcLessonQuizSession_GetUserIDBySession @SessionID=''EDB764D3-5099-4E94-B870-DEE8C56243EA''
print @val

print dbo.udfGetUserIDBySessionID(''EDB764D3-5099-4E94-B870-DEE8C56243EA'')
-- select * from tblQuizSession
-- select * from tblLessonSession
**/

CREATE Proc [prcLessonQuizSession_GetUserIDBySession]
(
@SessionID varchar(50)
)

As

Set NoCount On


------------------------------------------
-- Declerations
------------------------------------------
Declare @intRetVal int

------------------------------------------
-- get user id for this session
------------------------------------------
set @intRetVal = dbo.udfGetUserIDBySessionID(@SessionID)

------------------------------------------
-- return
------------------------------------------
select @intRetVal as ''SessionName'';
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcJobMaintainUnitHierarchies]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcJobMaintainUnitHierarchies] AS

if (select count(*) from sysobjects where [name] = ''tblUnitHierarchy'') = 0
BEGIN

CREATE TABLE [dbo].[tblUnitHierarchy] (
[UnitID] [int] NOT NULL ,
[Hierarchy] [nvarchar] (500) COLLATE Latin1_General_CI_AS NULL ,
[HierarchyName] [nvarchar] (2000) COLLATE Latin1_General_CI_AS NULL
) ON [PRIMARY]


CREATE  INDEX [IX_tblUnitHierarchy] ON [dbo].[tblUnitHierarchy]([Hierarchy]) ON [PRIMARY]
END


if (select count(*) from sysobjects where [name] = ''utg_UpdateUnitHierarchy'') = 0
BEGIN

EXEC(''CREATE TRIGGER utg_UpdateUnitHierarchy ON tblUnit AFTER INSERT, UPDATE AS '' +
--Update Existing hierarchies
''UPDATE '' +
''tblUnitHierarchy '' +
''SET '' +
''Hierarchy = B.Hierarchy, '' +
''HierarchyName = dbo.udfGetUnitPathway(B.UnitID) '' +
''FROM '' +
''tblUnitHierarchy A, tblUnit B '' +
''WHERE '' +
''A.UnitID = B.UnitID AND '' +
''B.UnitID IN (Select A.UnitID FROM tblUnit A, INSERTED B WHERE A.Hierarchy LIKE ''''%'''' + CAST(B.UnitID AS VARCHAR(10)) + ''''%'''') '' +
''INSERT INTO '' +
''tblUnitHierarchy '' +
''SELECT '' +
''A.UnitID, A.Hierarchy, dbo.udfGetUnitPathway(A.UnitID) '' +
''FROM '' +
''INSERTED A '' +
''WHERE '' +
''A.UnitID NOT IN (SELECT B.UnitID FROM tblUnitHierarchy B WHERE B.UnitID = A.UnitID)'')
END



if (select count(*) from sysobjects where [name] = ''utg_DeleteUnitHierarchy'') = 0
BEGIN

EXEC(''CREATE TRIGGER utg_DeleteUnitHierarchy ON tblUnit AFTER DELETE AS '' +
''DELETE FROM tblUnitHierarchy '' +
''WHERE UnitID IN (SELECT UnitID FROM Deleted) '')

END

--Dummy to fill tblUnitHierarchy table
UPDATE tblUnit SET Hierarchy = Hierarchy
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_StartQuiz]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
-- Check that the quiz has not already been started
-- if it has - return false
-- if it has not, start it and return true
Returns:
boolean (bit) OKToStart true = 1, false = 0

Called By:
ToolbookListener.cs
Calls:

Remarks:

Author:
Peter Kneale
Date Created: 10 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


-----------
prcQuizSession_StartQuiz @QuizSessionID = ''4986F67F-FF29-4979-9A97-D7846839E0DB''


**/

CREATE Procedure  [prcQuizSession_StartQuiz]
(
@QuizSessionID varchar(50)
)

As

Set NoCount On
Set Xact_Abort On
Begin Tran


------------------------------------------
-- Declerations
------------------------------------------
Declare @RetVal bit 		-- Return value holding bit indicating success condition as described above

------------------------------------------
-- Check that the quiz has not already been started
-- if it has - return false
-- if it has not, start it and return true
-- Start the quiz ( insert a start date )
------------------------------------------
If Exists
(
Select
QuizSessionID
From
tblQuizSession
Where
QuizSessionID = @QuizSessionID
And
DateTimeStarted is Null
)

Begin
-- it is ok to start, record start and return true
--< do update >--
Update
tblQuizSession
Set
DateTimeStarted =	GETUTCDATE()
Where
QuizSessionID = @QuizSessionID
--< set return value >--
Set @RetVal = 1
End

Else

Begin  -- it is NOT ok to start, return false
--< set return value >--
Set @RetVal = 0
End

Commit Tran

------------------------------------------
-- select SessionID
------------------------------------------

Select @RetVal as ''OKToStart''
Return
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_GetQuizIDBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:

Parameters: @strSessionID varchar(50)

Returns: integer

Called By: ToolbookListener.aspx

Calls: udfGetQuizIDBySessionID

Remarks: Raises an error any input parameter is null

Author: Peter Kneale
Date Created: 4th of February 2004

Modification History
-----------------------------------------------------------
v#	Author	Date		Description
#1	GB	9/2/04		Coding standards
#2	GB	3/3/04		Changed to retrieve QuizID by SessionID rather than ToolbookID
*/

CREATE  Procedure [prcQuizSession_GetQuizIDBySessionID]
(
@strSessionID varchar(50)
)
As
-- Declarations
Declare @intRetVal Int

-- Validation
If @strSessionID Is Null
Begin
Raiserror(''The Parameter @strSessionID was null.  @strSessionID does not accept Null values.'', 16, 1)
Return
End

-- Logic
Set @intRetVal = dbo.udfGetQuizIDBySessionID(@strSessionID)
If @intRetVal Is Null
Begin
Raiserror(''The QuizID could not be determined using udfGetQuizIDBySessionID .'', 16, 1)
Return
End

Select @intRetVal As ''QuizID''
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfQuiz_GetPassMark]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfQuiz_GetPassMark    Script Date: 20/04/2004 8:25:57 AM ******/

/*
Summary:
user Defined Function that returns the pass mark for the given module for the given unit
Parameters: @UnitID integer, @ModuleID integer
Returns: integer
Returns:
scaler - Passmark - integer

Called By:
prcQuiz_GetPassMark
Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 11 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Jack Liu        18/02/2003	 	Get quizPassMark from tblUnitRule, if it is null
Get the organisation default quiz pass mark

print dbo.udfQuiz_GetPassMark(1,2)

**/
CREATE   Function [udfQuiz_GetPassMark]
(
@UnitID 	int	-- Unit ID
, @ModuleID 	int	-- Unit ID
)
RETURNS INT --< Passmark >--
Begin

DECLARE @retVal int
--Get quizPassMark from tblUnitRule, if it is null
--Get the organisation default quiz pass mark
Select 	@retVal =isNull(ur.QuizPassMark, o.DefaultQuizPassMark)
From  tblUnit u
inner join tblOrganisation o
on  o.OrganisationID = u.OrganisationID
left join tblUnitRule ur
on ur.ModuleID = @ModuleID
and ur.UnitID=@unitID
where u.UnitID=@unitID


RETURN @retVal
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetPassMark]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Returns the pass mark for the given module for the given unit
Parameters: @UnitID integer, @ModuleID integer
Returns: integer

Called By: ToolbookListener.aspx
Calls: udfQuiz_GetPassMark

Remarks: Raises an error if the parameter is null

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	GB		9/2/04			Coding standards
#2	SKC		11/2/04		Moved functionality into a udf so that it is accessable to other stored proc''s

-- prcQuiz_GetPassMark 1,1
*/

CREATE  Procedure [prcQuiz_GetPassMark]
(
@UnitID int = null,
@ModuleID int = null
)

As

If @UnitID Is Null
Begin
Raiserror(''The Parameter @UnitID was null.  @UnitID does not accept Null values.'', 16, 1)
Return
End

If @ModuleID Is Null
Begin
Raiserror(''The Parameter @ModuleID was null.  @ModuleID does not accept Null values.'', 16, 1)
Return
End

Select
dbo.udfQuiz_GetPassMark(@UnitID, @ModuleID) As ''PassMark''
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfDaylightSavingTimeToUTC]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [udfDaylightSavingTimeToUTC]
(
@LocalTime DateTime,
@OrgID int
)
RETURNS DateTime
AS
BEGIN
-- trap error condition
IF (@LocalTime is null) RETURN null

DECLARE @OrgLocalTime datetime
DECLARE @UTC_Offset int
DECLARE @Timezone datetime
DECLARE @offset_mins int, @hours_start int, @day_start int, @week_start int, @month_start int, @hours_end int, @day_end int, @week_end int, @month_end int, @year_end int , @year_start int


SELECT @UTC_Offset = TZ.OffsetUTC , @Timezone = TZ.TimezoneID
FROM tblTimeZone TZ
INNER JOIN tblOrganisation Org ON TZ.TimeZoneID = Org.TimeZoneID
WHERE Org.OrganisationID = @OrgID
IF (@UTC_Offset IS NULL)
BEGIN
Set @OrgLocalTime = ''1 Jan 1900'' 	-- create an "error" that will be apparent in Report (The timezone does not exist so create an error that will draw attention to the problem)
END
ELSE
BEGIN
-- get the daylight saving rules of the (at most) 1 definition that may cover the datetime
--overlapping definitions are removed by the GUI so a maximum of 1 result can be returned
Set @OrgLocalTime = DATEADD(minute,-@UTC_Offset,@LocalTime )
SELECT  @offset_mins = offset_mins,
@hours_start = hours_start,
@day_start = day_start,
@week_start = week_start,
@month_start = month_start,
@hours_end = hours_end,
@day_end = day_end,
@week_end = week_end,
@month_end = month_end
FROM tblTimeZoneDaylightSavingRules
WHERE  TimezoneID = @Timezone
AND @LocalTime >= first_start_date
AND @LocalTime <= last_end_date

-- the first_start_date and last_end_date may cover a period of decades so we now have to decide if the rule is applied at the datetime given
-- so calculate the exact start and end dates and times for the relevant daylight saving period (in the year being considered)


-- start with a period (@Period_start datetime, @period_end datetime) that just has the correct year digits
DECLARE @Period_start datetime, @period_end datetime
Set @year_start = year(@LocalTime)
set @year_end = year(@LocalTime)

if (month(@LocalTime) <= @month_end) and (@month_start > @month_end) set @year_start = @year_start - 1   -- rule spans december 31 so adjust

IF(@month_start > @month_end) and (month(@LocalTime) >= @month_start) set @year_end = @year_start + 1  -- rule spans december 31 so adjust


set @Period_start = ''1 jan 2000''
set @year_start = @year_start - 2000
Set @Period_start = DATEADD(year,@year_start,@Period_start)
-- ok year digit ok (for @Period_start) so move on



-- Then set the month digit correctly
Set @Period_start = DATEADD(month,@month_start-1,@Period_start)


-- Then move to the correct week (let week 5 slide to the next month for now)
Set @Period_start = DATEADD(week,@week_start-1,@Period_start)

-- Now move FORWARD to the correct day (say) the 5th sunday of february
Declare @day_offset int
if (@day_start >=  DatePart(weekday,@Period_start) ) set @day_offset = @day_start -  DatePart(weekday,@Period_start) else  set @day_offset = @day_start -  DatePart(weekday,@Period_start) + 7
Set @Period_start = DATEADD(day,@day_offset,@Period_start)

-- now fix up the week = 5 rule - week=5 means "last week in the month" not "add 5 weeks"
-- (We may have jumped to the next month if week = 5 so step back a week if necessary)
if (DatePart(month,@Period_start) > @month_start) set @Period_start = DATEADD(week,-1,@Period_start)


-- now add the hours part of the rule - i.e. rule starts at 02:00
Set @Period_start = DATEADD(minute,@hours_start,@Period_start)  ---TODO check if offset applied OK for 1 hour either side of daylight saving start and end




-- we have calculated the start of the Daylight saving rule (to the hour) for the year in question
-- no do exactly the same for the end time of the daylight saving rule for the year in question:
set @Period_end = ''1 jan 2000''
set @year_end = @year_end - 2000
Set @Period_end = DATEADD(year,@year_end,@Period_end)
Set @Period_end = DATEADD(month,@month_end-1,@Period_end)
Set @Period_end = DATEADD(week,@week_end-1,@Period_end)
if (@day_end >=  DatePart(weekday,@Period_end) ) set @day_offset = @day_end -  DatePart(weekday,@Period_end) else  set @day_offset = @day_end -  DatePart(weekday,@Period_end) + 7
Set @Period_end = DATEADD(day,@day_offset,@Period_end)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_end) > @month_end)
BEGIN
set @Period_end = DATEADD(week,-1,@Period_end)
END
Set @Period_end = DATEADD(minute,@hours_end,@Period_end)  ---TODO check if offset applied OK for 1 hour either side of daylight saving start and end
--Set @Period_end = DATEADD(minute,-@offset_mins,@Period_end) -- end time is quoted with daylight savings included

-- now all we have to do is check if the rule applied to the timestamp in question
IF (@LocalTime >= @Period_start)
AND (@LocalTime < @Period_end)
BEGIN
-- it did so apply the daylight saving offset
set @OrgLocalTime = DATEADD(minute,-@offset_mins,@OrgLocalTime)
END

END
RETURN @OrgLocalTime
--RETURN @PERIOD_END

END
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfCsvToInt]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfCsvToInt    Script Date: 20/04/2004 8:25:57 AM ******/


/*
Summary:
user Defined Function converts a comma seperated string into a table
Returns:
table
Called By:
dbo.prcOrganisation_SaveCourseAccess
dbo.prcReport_CurrentAdminSummary
dbo.prcReport_EmailReportToAdministrators
dbo.prcReport_EmailReportUserSearch
dbo.prcReport_HistoricPointAdminSummaryReport
dbo.prcReport_HistoricRangeAdminLessonSummaryReport
dbo.prcReport_HistoricRangeAdminQuizSummaryReport
dbo.prcReport_Trend
dbo.prcUnit_Search
dbo.prcUser_ClassificationUpdate
dbo.prcUser_GetEmailAddress
dbo.prcUser_SaveModuleAccess
dbo.prcUser_Search
dbo.udfReport_CompletUsers_logic
dbo.udfReport_HistoricAdminSummary
dbo.udfReport_IncompletUsers_logic
Calls:
null
Remarks:
bassed on several examples found at http://www.sqlteam.com/

Author:
Stephen Kennedy Clark
Date Created:
Monday 16 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

use:

select * from dbo.udfCsvToInt('''')
select * from dbo.udfCsvToInt('',,,,,1'')
select * from dbo.udfCsvToInt(''1,,,,,,'')
select * from dbo.udfCsvToInt(''1,,3,,34534534,,'')

**/

CREATE   Function [udfCsvToInt]
(
@commaSepperatedList varchar(MAX) = '''' -- Input string, comma seperated list of integers to be returned as a table
)
returns @tblIntTable table
(IntValue int)
AS
begin
if @commaSepperatedList <> ''''
begin
-- get rid of spaces
while CHARINDEX('' '' , @commaSepperatedList) <> 0
begin
set @commaSepperatedList = replace(@commaSepperatedList,'' '','''')
end

-- get rid of "null" values
while CHARINDEX('',,'' , @commaSepperatedList) <> 0
begin
set @commaSepperatedList = replace(@commaSepperatedList,'',,'','','')
end

set @commaSepperatedList = replace(@commaSepperatedList,'',,'','','')

-- get rid of leading and trailing commas
if @commaSepperatedList like('',%'')
begin
set @commaSepperatedList = right(@commaSepperatedList,len(@commaSepperatedList)-1)
end
if @commaSepperatedList like(''%,'')
begin
set @commaSepperatedList = left(@commaSepperatedList,len(@commaSepperatedList)-1)
end

declare @sep char(1)
set @sep = '',''

declare @intPos int
declare @strTemp varchar(500)

set @commaSepperatedList = @commaSepperatedList + '',''

while patindex(''%,%'' , @commaSepperatedList) <> 0
begin

select @intPos =  patindex(''%,%'' , @commaSepperatedList)
select @strTemp = left(@commaSepperatedList, @intPos - 1)

Insert @tblIntTable
Values (Cast(@strTemp as int))

select @commaSepperatedList = stuff(@commaSepperatedList, 1, @intPos, '''')
end
end
return
end
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_HistoricUserCourseStatusWithinRange]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/*Summary:
gets the last historic course results for each user within a date range

Returns:
Table

Called By:
Calls:

Remarks:


Author:
Stephen Clark
Date Created: 28 September 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


--------------------
select * from udfReport_HistoricUserCourseStatusWithinRange(''September 1 2004'', ''September 30 2004'')

**/

Create function [udfReport_HistoricUserCourseStatusWithinRange]
(
@effectiveStartDate      datetime = null ,
@effectiveEndDate    datetime = null
)

Returns table
as
-----------------------------------------------------------

return select
--< Historic User Course Status Clause >---
tUCS.UserCourseStatusID
, tUCS.UserID
, tUCS.CourseID
, tUCS.CourseStatusID
, tUCS.ModulesAssigned
, tUCS.DateCreated
From
tblUserCourseStatus tUCS
--< only get data on active courses >--
inner join tblCourse tC
on tC.CourseID = tUCS.CourseID
and tC.Active = 1
--< only get the latest result for each user - prior to the efective date >--
inner join(
select
max(UserCourseStatusID) UserCourseStatusID --UserQuizStatusID is identity
from
tblUserCourseStatus
where
--< only get data in the date range specified >--
tblUserCourseStatus.DateCreated BETWEEN @effectiveStartDate and DATEADD(DD, 1, @effectiveEndDate)
group by
UserID,CourseID
) currentStatus
on tUCS.UserCourseStatusID = currentStatus.UserCourseStatusID
--< / Historic User Course Status Clause >---
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_IncompleteCourseLogic]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfReport_IncompleteCourseLogic ******/
/*Summary:
Selects Users that have not Completed their training

Parameters:
@organisationID	int		(optional)
@unitIDs	string		(optional)
@courseID	int		(Mandatory)
@effectiveFromDate	datetime	(optional)
@effectiveToDate	datetime	(optional)
Returns:
Table

Called By:
dbo.prcReport_CourseStatusReport

Calls:
fn dbo.udfGetUnitPathway( UnitID )
fn udfCsvToInt( csv )
fn udfReport_HistoricUserCourseStatusWithinRange
Remarks:


Author:
Date Created: 16 March 2006

Execution:


Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	j hedlefs		09/06/2011		Timezone
**/

CREATE                function [udfReport_IncompleteCourseLogic]
(
@organisationID		Integer=null,		-- Organisation ID to search if the unit is empty
@unitIDs 		varchar(8000) = null,	-- string of unit id''s
@courseIDs		varchar(8000) = null,		-- course ID to restrict search to
@effectiveFromDateOrg 	datetime = null,	-- effective date of report From
@effectiveToDateOrg	datetime = null		-- effective date of report To
)

-------------------------------------------------------------------
Returns @tblReturn table
(
UserID		Int,
UnitID		Int,
FirstName		nvarchar(255),
LastName 	nvarchar(255),
UnitPathway 	nvarchar(4000),
Username		nvarchar(100),
Email		nvarchar(100),
ExternalID		nvarchar(50),
CourseName	nvarchar(200)
)

as
Begin --1
DECLARE @effectiveFromDate DateTime
SET @effectiveFromDate = dbo.udfDaylightSavingTimeToUTC(@effectiveFromDateOrg,@OrganisationID)
DECLARE @effectiveToDate DateTime
SET @effectiveToDate = dbo.udfDaylightSavingTimeToUTC(@effectiveToDateOrg,@OrganisationID)

if (@effectiveFromDate is null)
Begin
----------------------------------------------------
--- Report on the current date
----------------------------------------------------
if (@unitIDs is null)
begin --2
----------------------------------------------------
--- Report on the current date on all units
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
, tC.Name as ''CourseName''
FROM
tblUser tU1
inner join tblUnit on
tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join vwUserCourseStatus vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 1 --< want users that are incomplete >--
inner join dbo.udfCsvToInt(@courseIDs) tR
on tR.IntValue = vUCS.CourseID
inner join dbo.tblCourse as tC
on tR.IntValue = tC.CourseID
end --/2
else
begin --3
----------------------------------------------------
--- Report on the current date on a specific unit
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
, tC.Name as ''CourseName''
FROM
tblUser tU1
inner join tblUnit on
tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join vwUserCourseStatus vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 1 --< want users that are incomplete >--
--and vUCS.CourseID = @courseID--
inner join dbo.udfCsvToInt(@courseIDs) tR
on tR.IntValue = vUCS.CourseID
inner join dbo.udfCsvToInt(@unitIDs) tU
on tU.IntValue = tblUnit.UnitID
inner join dbo.tblCourse as tC
on tR.IntValue = tC.CourseID --< restrict units to thoes in the list >--

end --/3
End

Else

Begin
----------------------------------------------------
--- Report on the historic date range provided
----------------------------------------------------
if (@unitIDs is null)
begin --2
----------------------------------------------------
--- Report on the historic date range provided for all units
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
, tC.Name as ''CourseName''
FROM
tblUser tU1
inner join tblUnit on
tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join  dbo.udfReport_HistoricUserCourseStatusWithinRange(@effectiveFromDate, @effectiveToDate) vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 1 --< want users that are incomplete >--
--and vUCS.CourseID = @courseID--
inner join dbo.udfCsvToInt(@courseIDs) tR
on tR.IntValue = vUCS.CourseID
inner join dbo.tblCourse as tC
on tR.IntValue = tC.CourseID

end --/2
else
begin --3
----------------------------------------------------------------
--- Report on the historic date range provided for the specified units
----------------------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
, tC.Name as ''CourseName''
FROM
tblUser tU1
inner join tblUnit on
tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join  dbo.udfReport_HistoricUserCourseStatusWithRange(@effectiveFromDate, @effectiveToDate) vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 1 --< want users that are incomplete >--
--and vUCS.CourseID = @courseID--
inner join dbo.udfCsvToInt(@courseIDs) tR
on tR.IntValue = vUCS.CourseID
inner join dbo.tblCourse as tC
on tR.IntValue = tC.CourseID
inner join dbo.udfCsvToInt(@unitIDs) tU
on tU.IntValue = tblUnit.UnitID --< restrict units to thoes in the list >--

end --/3
End
return
end -- /1
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfUTCtoDaylightSavingTime]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [udfUTCtoDaylightSavingTime]
(
@UTC DateTime,
@OrgID int
)
RETURNS DateTime
AS
BEGIN

IF (@UTC is null) RETURN null
DECLARE @OrgLocalTime datetime
DECLARE @UTC_Offset int
DECLARE @Timezone datetime
DECLARE @offset_mins int, @hours_start int, @day_start int, @week_start int, @month_start int, @hours_end int, @day_end int, @week_end int, @month_end int, @year_end int , @year_start int
SELECT @UTC_Offset = TZ.OffsetUTC , @Timezone = TZ.TimezoneID
FROM tblTimeZone TZ
INNER JOIN tblOrganisation Org ON TZ.TimeZoneID = Org.TimeZoneID
WHERE Org.OrganisationID = @OrgID
IF (@UTC_Offset IS NULL)
BEGIN
Set @OrgLocalTime = ''1 Jan 1900'' -- all results are displayed by Reporting Services so create an "error" that will be apparent in Reporting Services
END
ELSE
BEGIN
Set @OrgLocalTime = DATEADD(minute,@UTC_Offset,@UTC )
SELECT  @offset_mins = offset_mins, --get definition of the (at most) 1 definition that may cover the datetime
@hours_start = hours_start, --overlapping definitions removed by GUI so only 1 result returned
@day_start = day_start,
@week_start = week_start,
@month_start = month_start,
@hours_end = hours_end,
@day_end = day_end,
@week_end = week_end,
@month_end = month_end
FROM tblTimeZoneDaylightSavingRules
WHERE  TimezoneID = @Timezone
AND @OrgLocalTime >= first_start_date
AND @OrgLocalTime <= last_end_date

-- start with a period (@Period_start datetime, @period_end datetime) that just has the correct year digits
DECLARE @Period_start datetime, @period_end datetime
Set @year_start = year(@OrgLocalTime)
set @year_end = year(@OrgLocalTime)

if (month(@OrgLocalTime) <= @month_end) and (@month_start > @month_end) set @year_start = @year_start - 1   -- rule spans december 31 so adjust

IF(@month_start > @month_end) and (month(@OrgLocalTime) >= @month_start) set @year_end = @year_start + 1  -- rule spans december 31 so adjust


--Set @year_start = year(@OrgLocalTime) --now calculate the exact start and end dates and times for the year under consideration
--IF(@month_start > @month_end) set @year_end = @year_start+1 else set @year_end = @year_start
--DECLARE @Period_start datetime, @period_end datetime

set @Period_start = ''1 jan 2000'' -- start with a known datetime
set @year_start = @year_start - 2000
Set @Period_start = DATEADD(year,@year_start,@Period_start) -- then set the year correctly
-- Then move to the correct month
Set @Period_start = DATEADD(month,@month_start-1,@Period_start)
-- Then move to the correct week (let week 5 slide to the next month for now)
Set @Period_start = DATEADD(week,@week_start-1,@Period_start)
-- Now move FORWARD to the correct day (say) the 5th sunday of february
Declare @day_offset int
if (@day_start >=  DatePart(weekday,@Period_start) ) set @day_offset = @day_start -  DatePart(weekday,@Period_start) else  set @day_offset = @day_start -  DatePart(weekday,@Period_start) + 7
Set @Period_start = DATEADD(day,@day_offset,@Period_start)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_start) > @month_start) set @Period_start = DATEADD(week,-1,@Period_start)
Set @Period_start = DATEADD(minute,@hours_start,@Period_start)  ---TODO check if offset applied OK for 1 hour either side of daylight saving start and end

set @Period_end = ''1 jan 2000'' -- start with a known datetime
set @year_end = @year_end - 2000
Set @Period_end = DATEADD(year,@year_end,@Period_end) -- then adjust it to match the definition
Set @Period_end = DATEADD(month,@month_end-1,@Period_end)
Set @Period_end = DATEADD(week,@week_end-1,@Period_end)
if (@day_end >=  DatePart(weekday,@Period_end) ) set @day_offset = @day_end -  DatePart(weekday,@Period_end) else  set @day_offset = @day_end -  DatePart(weekday,@Period_end) + 7
Set @Period_end = DATEADD(day,@day_offset,@Period_end)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_end) > @month_end) set @Period_end = DATEADD(week,-1,@Period_end)
Set @Period_end = DATEADD(minute,@hours_end,@Period_end)  ---TODO check if offset applied OK for 1 hour either side of daylight saving start and end
Set @Period_end = DATEADD(minute,-@offset_mins,@Period_end) -- end time is quoted with daylight savings included


IF (@OrgLocalTime >= @Period_start)
AND (@OrgLocalTime < @Period_end) set @OrgLocalTime = DATEADD(minute,@offset_mins,@OrgLocalTime)
END
RETURN @OrgLocalTime
END
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_CompleteCourseLogic]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfReport_CompleteCourseLogic    Script Date: 16/03/2006******/

/*Summary:
Selects User details for users that have Completed their training

Parameters:
@organisationID Integer,
@unitIDs	string		(Mandatory)
@courseIDs	string		(Mandatory)
@effectiveFromDate	datetime	(optional)
@effectiveToDate	datetime	(optional)
Returns:


Called By:
prcReport_CourseStatusReport

Calls:
fn dbo.udfGetUnitPathway( UnitID )
fn udfReport_completeUsers()
fn udfCsvToInt( csv )


Remarks:


Author:

Execution:


Modification History
-----------------------------------------------------------
v#	Author		Date			Description
**/
CREATE function [udfReport_CompleteCourseLogic]
(
@organisationID Integer,	-- Organisation of the user running the report
@unitIDs Varchar(8000),		-- string of unit id''s
@courseIDs varchar(8000), 			-- course IDs to restrict search to
@effectiveFromDateOrg datetime = null,	-- effective date of report From
@effectiveToDateOrg datetime = null	-- effective date of report To
)

-------------------------------------------------------------------
Returns @tblReturn Table
(
UserID		Int,
UnitID		Int,
FirstName		nVarchar(255),
LastName 	nVarchar(255),
UnitPathway 	nVarchar(3000),
[Date]		Datetime,
Username		nvarchar(100),
Email		nvarchar(100),
ExternalID		nvarchar(50),
CourseName	nvarchar(200)
)

as
Begin --1
DECLARE @effectiveFromDate 		datetime
DECLARE @effectiveToDate 		datetime
SET @effectiveFromDate = dbo.udfDaylightSavingTimeToUTC(@effectiveFromDateOrg,@OrganisationID)
SET @effectiveToDate = dbo.udfDaylightSavingTimeToUTC(@effectiveToDateOrg,@OrganisationID)

if (@unitIDs is null)
begin --2
----------------------------------------------------
--- Report on all units
----------------------------------------------------
if (@effectiveFromDate is null)
begin --4
----------------------------------------------------
--- Report on the current date
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, dbo.udfUTCtoDaylightSavingTime(vUCS.DateCreated,@OrganisationID) as ''Date''
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
, tC.Name as ''CourseName''
FROM
tblUser tU1
inner join tblUnit
on tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join vwUserCourseStatus vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 2 --< only want completed users >--
--and vUCS.CourseID in (SELECT * FROM dbo.udfCsvToInt(@courseIDs))--
inner join dbo.udfCsvToInt(@courseIDs)tR
on tR.IntValue = vUCS.CourseID
inner join dbo.tblCourse tC
on tR.IntValue = tC.CourseID
end --/4
else
begin --5

----------------------------------------------------
--- Report on the historic date
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, dbo.udfUTCtoDaylightSavingTime(vUCS.DateCreated,@OrganisationID) as ''Date''
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
, tC.Name as ''CourseName''
FROM
tblUser tU1
inner join tblUnit
on tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join  dbo.udfReport_HistoricUserCourseStatusWithinRange(@effectiveFromDate, @effectiveToDate) vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 2 --< only want completed users >--
--and vUCS.CourseID in (SELECT * FROM dbo.udfCsvToInt(@courseIDs))--
inner join dbo.udfCsvToInt(@courseIDs)tR
on tR.IntValue = vUCS.CourseID
inner join dbo.tblCourse tC
on tR.IntValue = tC.CourseID
end  --/5
end --/2
else
begin --3
----------------------------------------------------
--- Report on specified units
----------------------------------------------------
if (@effectiveFromDate is null)
Begin --6
----------------------------------------------------
--- Report on the current date
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, dbo.udfUTCtoDaylightSavingTime(vUCS.DateCreated,@OrganisationID) as ''Date''
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
, tC.Name as ''CourseName''
FROM
tblUser tU1
inner join tblUnit on
tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join vwUserCourseStatus vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 2 --< only want completed users >--
--and vUCS.CourseID in (SELECT * FROM dbo.udfCsvToInt(@courseIDs))--
inner join dbo.udfCsvToInt(@courseIDs)tR
on tR.IntValue = vUCS.CourseID
inner join dbo.tblCourse as tC
on tR.IntValue = tC.CourseID
inner join dbo.udfCsvToInt(@unitIDs) tU
on tU.IntValue = tblUnit.UnitID --< restrict units to thoes in the list >--
end  --/6
else
Begin  --7
----------------------------------------------------
--- Report on the historic date
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, dbo.udfUTCtoDaylightSavingTime(vUCS.DateCreated,@OrganisationID) as ''Date''
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
, tC.Name as ''CourseName''
FROM
tblUser tU1
inner join tblUnit
on tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join  dbo.udfReport_HistoricUserCourseStatusWithinRange(@effectiveFromDate, @effectiveToDate) vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 2 --< only want completed users >--
--and vUCS.CourseID = @courseID--
inner join dbo.udfCsvToInt(@courseIDs) tR
on tR.IntValue = vUCS.CourseID
inner join dbo.tblCourse as tC
on tR.IntValue = tC.CourseID
inner join dbo.udfCsvToInt(@unitIDs) tU
on tU.IntValue = tblUnit.UnitID --< restrict units to thoes in the list >--
End  --/7
end --/3
return
end -- /1
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CourseStatusReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Given a user id returns the list of courses / modules and the latest results for that user
If the User id is ommited it returns results for all users
Returns:
Course ID

Called By:
Home.aspx via Businessservices.Report.GetCourseStatusReport
Calls:
udfReport_CompletUsers_logic
udfReport_IncompletUsers_logic
Remarks:


Author:

Date Created: 16 March 2006

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

--------------------

**/

CREATE          Proc [prcReport_CourseStatusReport]

(
@organisationID Integer,		-- Organisation of the current user
@unitIDs varchar(max) = '''',	-- string of unit id''s
@courseIDs varchar(8000),			-- course IDs to restrict search to
@effectiveFromDate datetime = Null,	-- Effective date as at when to run the report
@effectiveToDate datetime = Null,	-- Effective date as at when to run the report
@completed bit = 0 		-- Completed or incompleted flag
-- 1 = True = completed users
-- 0 = false (default) = not comleted or INcompleted users
)

AS
------------------------------------------
Set Nocount On
If @completed = 1
Begin
Select
userID
, unitID
, FirstName
, LastName
, UnitPathway
,Date
,Username
,Email
,ExternalID
,CourseName
From
dbo.udfReport_CompleteCourseLogic(@organisationID, @unitIDs, @courseIDs,@effectiveFromDate,@effectiveToDate)
Order By
CourseName,UnitPathway,LastName, FirstName
End
Else
Begin
Select
userID
, unitID
, FirstName
, LastName
, UnitPathway
, Username
, Email
, ExternalID
, CourseName
From
dbo.udfReport_IncompleteCourseLogic(@organisationID, @unitIDs, @courseIDs,@effectiveFromDate,@effectiveToDate)
Order By
CourseName,UnitPathway,LastName,FirstName
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetUnitNames]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary:
Convert unit IDs  array such as  ''''1,2,5,7'''' to Unit names array  ''''Unit 1, Unit 1 > Unit 2 > Unit 5 > Unit 7, Unit 1 > Unit 2 > Unit 5 > Unit 7''''

Called By:

Calls:

Remarks:


Author: Jack Liu
Date Created: 1 Apr 2005

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

exec prcUnit_GetUnitNames ''''19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,84''''

**/
CREATE  Procedure [prcUnit_GetUnitNames]
(
@unitIDs varchar(4000)
)
as
declare	@unitNames varchar(8000)

select @UnitIDs='',''+@UnitIDs+'',''

--Convert unit IDs  ''''1,2,5,7'''' to Unit names ''''Unit 1, Unit 1 > Unit 2 > Unit 5 > Unit 7, Unit 1 > Unit 2 > Unit 5 > Unit 7''''


--dbo.udfGetUnitPathway(u.UnitID) as Pathway,

--char(13)+char(10)
select @unitNames=IsNull(@unitNames+'' , '','''')+dbo.udfGetUnitPathway(tblUnit.UnitID)
from tblUnit
where charindex(@UnitIDs, '',''+cast(UnitID as varchar)+'','')>0
order by Hierarchy

select @unitNames as UnitNames
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetLastCompletedDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetLastCompletedDate    Script Date: 24/07/2009 4:47 PM ******/


/*
Summary:		Calculates the date when the user last
completed the course, or ''Never'' (if status
is not incomplete or they have never
completed the course.

Returns:		varchar

Called By:		vwUserCourseStatus,
udfReport_HistoricViewCourseStatus

Author:			Mark Donald
Create date:	24/07/2009

Modification History
-----------------------------------------------------------
Author		Date			Description

*/

CREATE FUNCTION [udfGetLastCompletedDate]
(
@userCourseStatusID int,
@userID int,
@courseID int,
@courseStatusID int
)
RETURNS varchar(10)
AS
BEGIN

RETURN (SELECT
coalesce(convert(varchar(10), max(DateCreated), 103), ''Never'')
FROM
tblUserCourseStatus
WHERE
@courseStatusID = 1 --incompleted users only
AND UserID = @userID
AND CourseID = @courseID
AND CourseStatusID = 2
AND UserCourseStatusID < @userCourseStatusID)

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Updates a unit details.
Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:
Validation:
1. Integrity Violation
The Unit''s details have been updated by another user (since the data are retrieved)

2. Deactivate a Unit
.There are no users in this unit
.There are no active sub-units in this units

3. Activate a Unit
.Parent unit must be active

Exception:
0. Succeed
1. RecordNotFound
4. UniqueViolationException
5. MissingParameterException
6. PermissionDeniedException
7. IntegrityViolationException
10. BusinessServiceException (General)


Author: Jack Liu
Date Created: 10 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE PROCEDURE [prcUnit_Update]
(
@unitID	int,
@name 	nvarchar(100),
@active	bit,
@updatedByUserID int,
@originalDateUpdated DateTime,
@OrgID int
)
AS

set nocount on

set xact_abort on
Begin Tran

--Validation
Declare @intErrorNumber Integer -- Holds the error number
Declare @strErrorMessage Varchar(200) -- Holds the error message

declare @blnExistingStatus bit
declare @strHierarchy nvarchar(500)
declare @intParentUnitID int
declare @dteDateUpdated datetime


select @blnExistingStatus = active,
@strHierarchy=  Hierarchy +'',%'',
@intParentUnitID = ParentUnitID,
@dteDateUpdated = dbo.udfUTCtoDaylightSavingTime(DateUpdated, @OrgID)
from tblUnit
where UnitID = @unitID

set @intErrorNumber=0
set @strErrorMessage=''''

--1. Integrity Violation
--The Unit''s details have been updated by another user (since the data are retrieved)

if (@dteDateUpdated>@originalDateUpdated)
Begin
Set @intErrorNumber = 7
Set @strErrorMessage = ''The unit''''s details have been updated by another user, you will need to refresh the unit''''s details and re-enter your changes.  <a href="[Url]">Click here</a> to refresh.''
Goto Finalise
End

--2. Deactivate unit
--.There are no users in this unit
--.There are no active sub-units in this units
if (@blnExistingStatus=1 and @active=0)
Begin
if exists(select UserID from tblUser where UnitID=@unitID)
BEGIN
Set @intErrorNumber = 10
set @strErrorMessage = ''You can not deactivate a unit which contains users.  Please move the users to another unit.''
Goto Finalise
end

if exists(select UnitID from tblUnit where hierarchy like @strHierarchy  and active=1)
BEGIN
Set @intErrorNumber = 101
set @strErrorMessage = ''You can not deactivate a unit which contains active sub-units.''
Goto Finalise
end
end

--3. Activate a Unit
--.Parent unit must be active
else if (@blnExistingStatus=0 and @active=1)
Begin
if exists(select UnitID from tblUnit where unitID=@intParentUnitID  and active=0)
BEGIN
Set @intErrorNumber = 102
set @strErrorMessage = ''You cannot activate a unit whose parent unit is inactive.''
Goto Finalise
end
end


if (@intErrorNumber=0)
begin
UPDATE 	tblUnit
SET 	Name		= 	@name,
Active		= 	@active,
UpdatedBy	= 	@updatedByUserID,
DateUpdated	= 	GETUTCDATE()
WHERE 	UnitID = @unitID
end


Finalise:
If(@intErrorNumber > 0)
Begin
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
Rollback Transaction
End
Else
Begin
Select
0 As ''ErrorNumber'',
''Successfully Updated'' As ''ErrorMessage''
Commit Transaction
End


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLendLeaseUnitRestructure]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [prcLendLeaseUnitRestructure]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    declare @organisationid int


	set @organisationid = 29

	select
	un.UnitID, un.Name
	into #tblParentUnit
	from
	tblUnit un
	where
	un.OrganisationID=@organisationid
	and ParentUnitID is null
	and un.Active=1


	declare unitCursor cursor
	for 
	select
	pu.UnitID, pu.Name, un2.UnitID, un2.name, un.UnitID, un.name
	from #tblParentUnit pu,
	tblUnit un inner join tblUnit un2
	on un.ParentUnitID=un2.unitid
	where
	un.hierarchy like (convert(varchar(10), pu.unitid) + ''%'') 
	and un.unitid not in
	(
		select distinct parentunitid from tblUnit where organisationid=@organisationid and parentunitid is not null and active=1
	)
	and un.organisationid=@organisationid
	and un.active = 1
	and un.name like ''[A-Z][A-Z][A-Z][0-9][0-9][0-9]''
	--and pu.unitid = 767 -- BLL
	and pu.unitid in
	(1319, 1325, 1357, 1494, 1569)
	
	open unitCursor

	declare @main_unitid int
	declare @main_unitname varchar(200)
	declare @parent_unitid int
	declare @parent_unitname varchar(200)
	declare @child_unitid int
	declare @child_unitname varchar(200)
	declare @default_date datetime


	set @default_date = GETDATE()

	fetch next from unitCursor into 
	@main_unitid,
	@main_unitname,
	@parent_unitid,
	@parent_unitname,
	@child_unitid,
	@child_unitname

	while @@FETCH_STATUS <> -1
	begin
		if @@FETCH_STATUS <> -2
		begin

		declare @new_unitname varchar(200)
		set @new_unitname= @parent_unitname + '' '' + @child_unitname

		print ''Renaming '' + @child_unitname + '' to '' + @new_unitname	
		exec prcUnit_Update @unitid=@child_unitid, @name=@new_unitname, @active = 1, @updatedByUserID=1, @originalDateUpdated = @default_date

		print ''Moving '' + @new_unitname + '' as child unit of '' + @main_unitname
		exec prcUnit_Move @fromUnitID = @child_unitid, @toUnitID = @main_unitid, @adminuserid=1

		print ''Set '' + @parent_unitname + '' to inactive''
		exec prcUnit_Update @unitid=@parent_unitid, @name=@parent_unitname, @active = 0, @updatedByUserID=1, @originalDateUpdated = @default_date

		end
		
		fetch next from unitCursor into 
		@main_unitid,
		@main_unitname,
		@parent_unitid,
		@parent_unitname,
		@child_unitid,
		@child_unitname
	end

	close unitcursor
	deallocate unitcursor

	drop table #tblParentUnit
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SearchUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Gets a list of users from a specific Unit which conform to the criteria
and who have a User Role which is lower than or equal to the specified user type id or the logged-in administrator''s user role.

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcUnit_SearchUsers]
(
@unitID Int,
@firstName nvarchar(50),
@lastName nvarchar(50),
@userTypeID int =null,
@adminUserID int,
@includeInactiveUsers bit = 0
)

As

set nocount off

--Check data
if (@userTypeID is null or @userTypeID<=0)
begin
select @userTypeID = UserTypeID
from tblUser
where userID = @adminUserID
end

if @firstName is null
set @firstName=''''
if @lastName is null
set @lastName=''''

if (@includeInactiveUsers=0)
Begin
Select 	UserID,
UserName,
FirstName,
LastName,
Email,
Active
From tblUser
Where UnitID = @unitID
and firstName like ''%''+ @firstName +''%''
and lastName like ''%'' + @lastName +''%''
and UserTypeID >=@userTypeID
and Active = 1
order by LastName
End
Else
Begin
Select 	UserID,
UserName,
FirstName,
LastName,
Email,
Active
From tblUser
Where UnitID = @unitID
and firstName like ''%''+ @firstName +''%''
and lastName like ''%'' + @lastName +''%''
and UserTypeID >=@userTypeID
order by LastName
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetAdministrators]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get a list of existing unit administrators for a unit.
Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:
1. Permission Checking:

Exception:


Author: Jack Liu
Date Created: 12 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcUnit_GetAdministrators 1

**/
CREATE PROCEDURE [prcUnit_GetAdministrators]
(
@unitID	int
)

AS

set nocount on

Select 	u.UserID,
u.UserName,
u.FirstName,
u.LastName,
u.Email,
u.Active
from tblUnitAdministrator ua
inner join tblUser u on ua.userID = u.UserID
where ua.unitID=@unitID
and u.usertypeID=3 --Unit administrator(3)
order by u.LastName




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetAdministrableUnitsByUserID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Get all units administrable by any administrator by the userID

Returns:
Table of unitID''s


Called By:
Calls:

Remarks:

UserTypeID  Type
----------- --------------------------------------------------
1           Salt Administrator
2           Organisation Administrator
3           Unit Administrator
4           User

Author:
Stephen Kennedy-Clark
Date Created: 26 Aug 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


-- prcUnit_GetAdministrableUnitsByUserID 14, 3
-- prcUnit_GetAdministrableUnitsByUserID 1, 3

select * from tblUser

-- select * from tblUnitAdministrator
**/


Create procedure [prcUnit_GetAdministrableUnitsByUserID]
(
@userID int,                      -- Users ID
@organisationID int = null    -- Organisation ID
)

as
set nocount on

Declare @intUserTypeID int -- Users (Administrator) Type




-- Get the Users (Administrator) Type
select
@intUserTypeID = UserTypeID
From
tblUser
where
UserID = @userID

-------------------------------------------------------------------------
-- If the user is a normal user then they dont have access to anythign
-------------------------------------------------------------------------
if @intUserTypeID = 4 -- user
begin
declare @NullTable table
(
UnitID int
)
select UnitID from @NullTable

return 0 -- exit proceadure with sucess
end


-------------------------------------------------------------------------
-- If the user is a salt administrator then they have access to everything
-------------------------------------------------------------------------
if @intUserTypeID = 1 -- Salt Administrator
begin
select UnitID from tblUnit where Organisationid = isnull(@organisationID, organisationid)

return 0  -- exit proceadure with sucess
end


-------------------------------------------------------------------------
-- If the user is an organisation administrator then they have access to
-- all units in their org
-------------------------------------------------------------------------
if @intUserTypeID = 2 -- Organisation Administrator
begin
select
tblUnit.UnitID
from
tblUnit
--< as an xtra security check ensure that the Org admin is in the organisation >--
inner join tblUser
on tblUnit.OrganisationID = tblUser.OrganisationID
and tblUser.UserID = @userID
and tblUser.OrganisationID = @organisationID

return 0  -- exit proceadure with sucess
end

-------------------------------------------------------------------------
-- If the user is an Unit administrator then they have access to units
-- defined in tblUnitAdministrator
-------------------------------------------------------------------------
if @intUserTypeID = 3 -- Unit Administrator
begin
select
u.UnitID
from
tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
--< as an xtra security check ensure that the administrator is in the organisation >--
inner join tblUser usr
on u.OrganisationID = usr.OrganisationID
and usr.UserID = @userID
and usr.OrganisationID = @organisationID

return 0  -- exit proceadure with sucess
end


-- code should never get here
declare @strErrorMessage varchar(200)
set @strErrorMessage = ''Procedure prcUnit_GetAdministrableUnitsByUserID encountered the userType ('' + cast(@intUserTypeID as varchar(5)) + '') that should not exist''
RAISERROR (@strErrorMessage, 16, 1)
return 1 -- exit proceadure with error

--<end>--




SET QUOTED_IDENTIFIER ON
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_RemoveAdministrator]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Remove a unit administrator from a unit.

They will also be removed from any sub-units that they had administrator rights to
by virtue of any Administer sub-units functions.

Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:
1. Permission Checking:
1.1. "From" unit permision: Administrator of this unit and all sub-units


Their user role will also change back to that of SALT User, if they no longer manage any Units.

Exception:
0: Succeed
1.RecordNotFound
2.FK constraint
3.PKViolationException
4.UniqueViolationException
10.BusinessServiceException (General)


Author: Jack Liu
Date Created: 11 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_RemoveAdministrator 14, 46, 46
**/
CREATE PROCEDURE [prcUnit_RemoveAdministrator]
(
@unitID	int,
@removedUserID	int,
@adminUserID 	int
)

AS

set nocount on

set xact_abort on
Begin Tran
declare @strErrorMessage varchar(500)

declare @intUserTypeID int

select @intUserTypeID = UserTypeID
from tblUser
where userID = @adminUserID

set @strErrorMessage=''''

-------------- 1. Permission Checking ----------------
--Salt Administrator (1), Organisation Administrator (2): full permission to access all units
--Salt User (4): No permission
if (@intUserTypeID=4)
begin
set @strErrorMessage = ''You are not the administrator of the system''
end
--Unit Administrator (3): limited permission
--else if (@intUserTypeID=3)
--begin
--	 --Unit Administrator (3): limited permission
--
--end

if @strErrorMessage=''''
begin

declare @blnPropagate bit, @strHierarchy varchar(100), @intLevel int, @intOrganisationID int

select @blnPropagate =ua.propagate,
@strHierarchy =u.Hierarchy,
@intLevel = u.[Level],
@intOrganisationID = u.OrganisationID
from tblUnit u
inner join tblUnitAdministrator ua
on u.UnitID=ua.UnitID and ua.userID=@removedUserID
where u.unitID = @unitID
--1. Remove this administrator from the specified Unit
--1.1 Can''t administer sub-units, just remove from this unit
if (@blnPropagate=0)
begin
Delete
from tblUnitAdministrator
where unitID = 	@unitID
and	UserID = @removedUserID
end
--1.2 Can administer sub-units, remove from all sub-units
else if (@blnPropagate=1)
begin
/*
They will also be removed from any sub-units that they had administrator rights to
by virtue of any "Administer sub-units" functions.
*/
delete tblUnitAdministrator
from tblUnitAdministrator cua --child unit administrator
inner join tblUnit cu --child unit
on cu.UnitID=cua.UnitID and cua.userID=@removedUserID and cua.propagate=1
where 	charindex(@strHierarchy+'','', cu.hierarchy+'','')=1
--Administrator(propagate flag) of all parent units(up to current unit) of a child unit
and not exists(
select pua.*
from tblUnit pu --parent unit
left join tblUnitAdministrator pua --Parent Unit Administrator
on pu.UnitID=pua.UnitID and pua.userID=@removedUserID and pua.propagate=1
where charindex(pu.hierarchy+'','',  cu.hierarchy+'','')=1 --parent unit of a child unit
and pu.level>=@intLevel --Up to the current unit
and pua.UnitID is null) -- Administrator
end


/*
Their user role will also change back to that of SALT User, if they no longer manage any Units.
*/

--2. Check and Update user role
exec prcOrganisation_CheckUserRole @intOrganisationID

select 0 as Error,  '''' as ErrorMessage
end
else
begin
select 10 as Error,  @strErrorMessage as ErrorMessage
end

commit TRAN
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_AddAdministrator]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Add a user as administrator of a unit
and all sub units (if the "administer sub-units" is flaged)

Called By: Unit.cs
Calls: None

Remarks:
"Administer Sub-units" checkbox
When this is flagged for a Unit Administrator, it means they will automatically also become a Unit Administrator privileges to all Sub-Units (and sub-sub-units etc) within this Unit.

Changing User Statuses
When a SALT User is selected as an Administrator of a Unit, their User Role is updated to Unit Administrator.



Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_AddAdministrator 1, 46,1,46

*/

CREATE  Procedure [prcUnit_AddAdministrator]
(
@unitID Int,
@userID int,
@adminSubUnit bit,
@adminUserID int
)

As

set nocount on


set xact_abort on
Begin Tran

declare @strHierarchy varchar(100), @intLevel int, @intOrganisationID int

declare @strErrorMessage varchar(500)

declare @intUserTypeID int

select @intUserTypeID = UserTypeID
from tblUser
where userID = @adminUserID

set @strErrorMessage=''''

-------------- 1. Permission Checking ----------------
--Salt Administrator (1), Organisation Administrator (2): full permission to access all units
--Salt User (4): No permission
if (@intUserTypeID=4)
begin
set @strErrorMessage = ''You are not the administrator of the system''
end


if @strErrorMessage=''''
begin
select 	@strHierarchy =u.Hierarchy,
@intLevel = u.[Level],
@intOrganisationID = u.OrganisationID
from tblUnit u
where u.unitID = @unitID


--Remove existing permissions for this user
--1. If the new permission is administer sub-units, remove existing permissions from all sub-units
if (@adminSubUnit=1)
begin
delete tblUnitAdministrator
from tblUnitAdministrator ua
inner join tblUnit u
on ua.UnitID=u.UnitID
where ua.UserID=@userID
and charindex(@strHierarchy+'','', u.hierarchy+'','')=1

insert into tblUnitAdministrator(UnitID, UserID,propagate, CreatedBy)
select unitID, @userID, 1, @adminUserID
from tblUnit u
where charindex(@strHierarchy+'','', u.hierarchy+'','')=1
end
--2. If the new permission is only applied to this units(Not administer sub-units), remove existing permissions from all sub-units only it is flaged to "Propagate"
else
begin
exec prcUnit_RemoveAdministrator @unitID, @userID, @adminUserID
insert into tblUnitAdministrator(UnitID, UserID,propagate, CreatedBy)
values( @unitID, @userID,0, @adminUserID)
end

--Changing User Statuses
--When a SALT User is selected as an Administrator of a Unit, their User Role is updated to "Unit Administrator".
--2. Check and Update user role
exec prcOrganisation_CheckUserRole @intOrganisationID

select 0 as Error,  '''' as ErrorMessage
end
else
begin
select 10 as Error,  @strErrorMessage as ErrorMessage
end

commit TRAN

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_GetStatus]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/****** Object:  Stored Procedure dbo.prcUserCourseStatus_GetStatus    Script Date: 31/03/2004 2:11:11 PM ******/


/*Summary:
gets the latest status for a user for a course

Returns:
table - single row, single column - integer or null

Called By:
trgUserQuizStatus
Calls:

Remarks:




Author: Stepehn Clark
Date Created: 24 March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

exec prcUserCourseStatus @UserID = @intUserID, @ModuleID = @intModuleID, @StatusID = @intNewCourseStatus

prcUserCourseStatus_GetStatus @CourseID = 19, @UserID = 113
QuizStatusID Status
------------ --------------------------------------------------
0            Unassigned
1            Not Started
2            Passed
3            Failed
4            Expired (Time Elapsed)
5            Expired (New Content)
**/
CREATE    procedure [prcUserCourseStatus_GetStatus]
(
@CourseID int -- the Course ID
, @UserID   int -- The User ID

)
As
------------------------
declare @intCourseStatus int -- the course status id to be returned
set @intCourseStatus =
(
select top 1
CourseStatusID -- could be null?
from
tblUserCourseStatus
where
CourseID = @CourseID
and UserID = @UserID

order by DateCreated desc
)
if @intCourseStatus is null
begin
set @intCourseStatus = -1
end
return  @intCourseStatus




' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUserIDBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Given a SessionID
return the users  UserID

Parameters
SessionID	Varchar (mandatory)

Returns:
scalar - int - user''s id

Called By:
TooolBookListener.aspx

Calls:
udfGetUserIDBySessionID

Remarks:


Author:
Peter Kneale
Date Created: 9 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


**/


CREATE Procedure [prcUser_GetUserIDBySessionID]
(
@SessionID varchar(50) 		-- Session ID of the user we are looking for.
)

As

Set NoCount On

-- Declarations
Declare @userID Integer

-- Validation
If (@SessionID Is Null)
Begin
Raiserror(''The Parameter @SessionID was null.  @SessionID does not accept Null values.'', 16, 1)
Return
End

-- Logic
Set @userID= dbo.udfGetUserIDBySessionID(@SessionID)

Select
@UserID as ''UserID''
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetClassification]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*
Summary: Gets a list of Classification Types for an Organisation
Parameters: OrganisationID
Returns: ClassificationID, ClassificationTypeID, Value, Active

Called By: Classification.cs
Calls: None

Remarks: None

Author: John Crawford
Date Created: 17th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcUser_GetClassification]
(
@userID Integer = Null -- ID of the Classification Type that you wish to get the Classification List For.
)

As

Select
UserID,
ClassificationID
From
tblUserClassification
Where
UserID = @UserID



' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetNameBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'





/*Summary:
Given a SessionID
returns the users name (Firstname + " " + LastName) as Name
Returns:
scalar - string - user''s name

Called By:
TooolBooLlistner.aspx via Businessservices.Toolbook.GetUser
Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 4 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


--------------------


**/


CREATE   PROC [prcUser_GetNameBySessionID]
(
@SessionID varchar(50) -- Toolbook session ID - A GUID
)

AS

SET NOCOUNT ON

------------------------------------------
-- Declerations
------------------------------------------
Declare @userID int

------------------------------------------
-- get @userID from @lessonSessionID
------------------------------------------
SET @userID= dbo.udfGetUserIDBySessionID(@SessionID)

------------------------------------------
-- Return Scalar
------------------------------------------

SELECT top 1
[FirstName] + '' '' + [LastName] as ''Name''
FROM
tblUser
WHERE
UserID = @userID

return




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetIdFromUsername]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 14/11/2011
-- Description:	Gets UserId from Username
-- =============================================
CREATE PROCEDURE [prcUser_GetIdFromUsername] 
	-- Add the parameters for the stored procedure here
	@Username nvarchar(100)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT UserID FROM tblUser WHERE  UserName = @Username
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetIdFromEmail]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 
-- Description:	
-- =============================================
CREATE PROCEDURE [prcUser_GetIdFromEmail] 
	-- Add the parameters for the stored procedure here
	@Email nvarchar(100) = null
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT UserID FROM tblUser WHERE Email = @Email
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetPermission]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get user administering permission
Returns:
Nothing.

Called By:
User Class.

Calls:
Nothing
Remarks:



Author: Jack Liu
Date Created: 09 Mar 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE PROCEDURE [prcUser_GetPermission]
(
@userID		int,
@adminUserID 	int,
@permission  	char(1)=null output
)

AS

set nocount on

Declare @intUserOrganisationID int, @intUserUnitID int
declare @intAdminUserTypeID int, @intAdminUserOrganisationID int


select @intUserOrganisationID = OrganisationID,
@intUserUnitID = UnitID
from tblUser
where UserID=@userID

select @intAdminUserTypeID = UserTypeID,
@intAdminUserOrganisationID = OrganisationID
from tblUser
where userID = @adminUserID


set @permission=''''
--1. Salt Admin
if (@intAdminUserTypeID=1)
begin
select @permission = ''S''
end
--2. Org admin
else if (@intAdminUserTypeID=2)
begin
--If the admin user is in the same organisation as the user, it has Full permission
--otherwise no permission
if (@intUserOrganisationID = @intAdminUserOrganisationID)
select @permission = ''F''
else
select @permission = ''''
end
--3. Unit admin, User must be administrator of that unit
else if (@intAdminUserTypeID=3)
begin
if exists(
select 1
from tblUnitAdministrator
where UnitID =@intUserUnitID
and UserID =@adminUserID)
select @permission = ''F''
else
select @permission = ''''
end

if (@permission is null)
select @permission = ''''


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetAdminUnitsTree]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
This is a hierarchical list of the Units that this user has Unit Administrator rights to.
It is for display-only.


Returns:
Flat hierarchy table


Called By:
Calls:

Remarks:

Author:
Jack Liu
Date Created: 17 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcUser_GetAdminUnitsTree 143


**/

CREATE PROC [prcUser_GetAdminUnitsTree]
(
@userID int
)

AS

set nocount on

declare @intOrganisationID int
/*
declare @strSelectedUnitIDs varchar(4000)
declare @strExpandedUnitIDs varchar(4000)
declare @strDisabledUnitIDs varchar(4000)
*/
select 	@intOrganisationID = OrganisationID
from tblUser
where userID = @userID


/*
--1. Get a list of unit id that the user has permission
select 	@strSelectedUnitIDs= isNull(@strSelectedUnitIDs + '','','''')+ cast(u.unitID as varchar)
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@intOrganisationID)


--2. Expand the unit branch to the unitID that has admin permission
select 	@strExpandedUnitIDs= isNull(@strExpandedUnitIDs + '','','''')+  cast(tblUnit.unitID as varchar)
from 	tblUnit
where 	(tblUnit.organisationID=@intOrganisationID)
and exists (select U.UnitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@intOrganisationID)
and charindex(tblUnit.hierarchy +'','', u.hierarchy)=1
) --Get units whose child units can be administered

--select @strExpandedUnitIDs

--3. Disable the whole tree
select 	@strDisabledUnitIDs= isNull(@strDisabledUnitIDs + '','','''')+  cast(u.unitID as varchar)
from 	tblUnit as u
where 	(u.organisationID=@intOrganisationID)


exec prcUnit_GetUnitsByOrganisation @intOrganisationID, @strDisabledUnitIDs, @strSelectedUnitIDs,@strExpandedUnitIDs
*/

select
un.unitid ''UnitID'',
un.parentunitid ''ParentUnitID'',
un.name ''Name'',
case when ua.unitid is null then 1 else 0 end ''Disabled'',
case when ua.unitid is null then 0 else 1 end ''Selected'',
case when un2.unitid is null then 0 else 1 end ''Expanded''
from tblUnit un
left join tblUnitAdministrator ua
on un.unitid=ua.unitid and ua.userid=@userid
left join
(
select un.* from tblUnit un
inner join tblUnitAdministrator ua
on un.unitid=ua.unitid
where
ua.userid=@userid
) un2
on charindex(un2.hierarchy +'','', un.hierarchy)=1
where un.organisationid=@intOrganisationID
and un.active=1
order by un.hierarchy' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_SelectAdminUnitsTree]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE PROC [prcUser_SelectAdminUnitsTree]
(
@userID Integer
)

AS

set nocount on

declare @intOrganisationID int

declare @strSelectedUnitIDs varchar(4000)
declare @strExpandedUnitIDs varchar(4000)
declare @strDisabledUnitIDs varchar(4000)

select 	@intOrganisationID = OrganisationID
from tblUser
where userID = @userID



--1. Get a list of unit id that the user has permission
select 	@strSelectedUnitIDs= isNull(@strSelectedUnitIDs + '','','''')+ cast(u.unitID as varchar)
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@intOrganisationID)


--2. Expand the unit branch to the unitID that has admin permission
select 	@strExpandedUnitIDs= isNull(@strExpandedUnitIDs + '','','''')+  cast(tblUnit.unitID as varchar)
from 	tblUnit
where 	(tblUnit.organisationID=@intOrganisationID)
and exists (select U.UnitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@intOrganisationID)
and charindex(tblUnit.hierarchy +'','', u.hierarchy)=1
) --Get units whose child units can be administered

--select @strExpandedUnitIDs

--3. Disable the whole tree
select 	@strDisabledUnitIDs= isNull(@strDisabledUnitIDs + '','','''')+  cast(u.unitID as varchar)
from 	tblUnit as u
where 	(u.organisationID=@intOrganisationID)


exec prcUnit_GetUnitsByOrganisation @intOrganisationID, '''', @strSelectedUnitIDs,@strExpandedUnitIDs
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_LogLogin]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Logs the fact that a user has successfully logged in.
Returns:
nothing

Called By: Login.ascx
Calls:

Remarks:

Author:
Peter Kneale
Date Created: 17 Jan 2005

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Jack Liu	14/09/2005		Change the UserName parameter to UserID, the user name is not unique after add domain name


prcUser_LogLogin ''Jack''
**/

CREATE  PROC [prcUser_LogLogin]
(
@userID  int
)

AS

set nocount on

Update
tblUser
Set
LastLogin = GETUTCDATE()
where
userID=@userID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUserType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Get user type

Role (UserType) Change

A Role change occurs when an administrator''s type changes.
This type of checking should occur at every user initiated event within the system
so that new permissions are enforced as soon as they are applied.
If a Role Change is detected, the administrator should be automatically logged out of the system
and redirected to the login page.

It is used by global.asax, all requests will be checked with data

Returns:  User type

Called By: User.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 18th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcUser_GetUserType]
(
@userID Integer, -- User ID
@userTypeID integer=null output -- User type
)

As
Set NoCount On


Select @userTypeID = UserTypeID
From	tblUser
Where	UserID = @userID


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUserForCC]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 18/11/2011
-- Description:	Get the user fields required forr CC list pop up for periodic reports
-- =============================================
CREATE PROCEDURE [prcUser_GetUserForCC] 
	-- Add the parameters for the stored procedure here
	@UserID int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT UserID, FirstName, LastName, UserName, Email
	FROM tblUser WHERE UserID = @UserID
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUnitsTree]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get all units in the specified organisation
1. Preselect the unitID that the user belongs to
2. Expand the unit branch to the unitID that the user belongs to
3. Disable units that the admin user don''t have permission to admin


Returns:
Flat hierarchy table


Called By:
Calls:

Remarks:

Author:
Jack Liu
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcUser_GetUnitsTree 46, 5


**/

CREATE  PROC [prcUser_GetUnitsTree]
(
@userID int,
@adminUserID int
)

AS

set nocount on

declare @intOrganisationID int, @intUnitID int, @strHierarchy varchar(100)
declare @intAdminUserTypeID int

declare @strSelectedUnitIDs varchar(4000)
declare @strExpandedUnitIDs varchar(4000)
declare @strDisabledUnitIDs varchar(4000)

select 	@intOrganisationID = OrganisationID,
@intUnitID = UnitID
from tblUser
where userID = @userID


--1. Preselect the unitID that the user belongs to
set @strSelectedUnitIDs = cast(@intUnitID as varchar)

--2. Expand the unit branch to the unitID that the user belongs to
select @strHierarchy = Hierarchy
from tblUnit
where UnitID = @intUnitID

select 	@strExpandedUnitIDs= isNull(@strExpandedUnitIDs + '','','''')+  cast(tblUnit.unitID as varchar)
from 	tblUnit
where 	(tblUnit.organisationID=@intOrganisationID)
and charindex(tblUnit.hierarchy +'','', @strHierarchy)=1


--3. Disable units that the admin user don''t have permission to admin
select @intAdminUserTypeID = UserTypeID
from tblUser
where userID = @adminUserID

declare  @EnableUnit  table
(
UnitID int
)

--Salt Administrator, Organisation Administrator has permission to access all units
if (@intAdminUserTypeID=1 or @intAdminUserTypeID=2)
begin
insert 	into @EnableUnit(UnitID)
select 	u.UnitID
from 	tblUnit as u
where 	(u.organisationID=@intOrganisationID)
end
--A: Unit Administrator only has permission to those that he is administrator
else
begin
--Get a list of unit id that the user is  the administrator
insert into @EnableUnit(UnitID)
select 	u.UnitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @adminUserID)
where 	(u.organisationID=@intOrganisationID)

end

--Get a list of unit id that the user don''t have permission
select 	@strDisabledUnitIDs= isNull(@strDisabledUnitIDs + '','','''')+ cast(u.unitID as varchar)
from 	tblUnit as u
left join @EnableUnit as eu
on (u.unitID=eu.unitID)
where 	(u.organisationID=@intOrganisationID)
and eu.UnitID is null



exec prcUnit_GetUnitsByOrganisation @intOrganisationID, @strDisabledUnitIDs, @strSelectedUnitIDs,@strExpandedUnitIDs






' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUnitIDByUserID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcUser_GetUnitIDByUserID]
@UserID int
AS

SELECT
UnitID
FROM
tblUser
WHERE
UserID = @UserID
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetUnitIDPathway]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetUnitPathway    Script Date: 20/04/2004 8:25:57 AM ******/

/*
Summary:
user Defined Function that returns pathway of a specified unit
Returns:
">" delimited pathway of a unit
e.g. "Unit 1 > Unit 2 > Unit 5 > Unit 7"

Called By:

Calls:

Remarks:


Author: Jack Liu
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


select  dbo.udfGetUnitIDPathway(9)

select dbo.udfGetUnitIDPathway(UnitID)
from tblUnit

**/
CREATE  FUNCTION [udfGetUnitIDPathway]
(
@UnitID int
)
RETURNS nvarchar(4000)
Begin

declare @strPathway nvarchar(4000)
declare @strHierarchy nvarchar(500)

select @strHierarchy='',''+hierarchy+'',''
from tblUnit
where UnitID = @UnitID

--Convert unit ID hierarchy ''1,2,5,7'' to pathway ''Unit 1 > Unit 2 > Unit 5 > Unit 7''

select @strPathway=IsNull(@strPathway+'' > '','''')+cast(UnitID as varchar)
from tblUnit
where charindex('',''+cast(UnitID as varchar)+'','', @strHierarchy)>0
order by [Level]

--select @strPathway

RETURN @strPathway
End
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetUserQuizDetails]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetUserQuizDetails    Script Date: 20/04/2004 8:25:57 AM ******/



/*
Summary:
user Defined Function that returns a table containing *
for the last quiz sat by a user
Returns:
table

Called By: prcModule_GetDetailsForHomePage

Calls:

Remarks:


Author:	Stephen Kennedy Clark
Date Created: Fiday 17 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

select * from  dbo.udfGetUserQuizDetails(11)
**/

CREATE  Function [udfGetUserQuizDetails]
(
@userID int -- the user id to get the status for
)
Returns table
as
Return
select 	UserID
, ModuleID
, QuizStatusID
, QuizFrequency
, QuizPassMark
, QuizScore
, DateCreated
from
tblUserQuizStatus tUQS_Outer
Where not exists
(
Select
UserID
From
tblUserQuizStatus tUQS_Inner
Where
tUQS_Inner.UserID = tUQS_Outer.UserID
and tUQS_Inner.ModuleID = tUQS_Outer.ModuleID
and tUQS_Inner.DateCreated < tUQS_Outer.DateCreated
)
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetQuizStatus]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetQuizStatus    Script Date: 20/04/2004 8:25:57 AM ******/




/*
Summary:
user Defined Function that returns a status id for quizes given a module id and a userID
only the users Latest Status ID is returned
Returns:
integer

Called By: prcModule_GetDetailsForHomePage

Calls:

Remarks:


Author:	Stephen Kennedy Clark
Date Created: Fiday 13 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

print dbo.udfGetQuizStatus(3, 11)
**/

CREATE    Function [udfGetQuizStatus]
(
@moduleID int -- the module to get the users status for
, @userID int -- the user id to get the status for
)
Returns Integer

Begin

Declare @retVal Integer -- User Status

Set @retVal =
(
Select Top 1
QuizStatusID
From
tblUserQuizStatus
Where
UserID = @userID
and ModuleID = @moduleID
Order by DateCreated desc
)

Return @retVal

End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfUser_GetAdministratorsEmailAddress]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'create function [udfUser_GetAdministratorsEmailAddress]
(
@UserID	int
)
Returns varchar(100)
AS
BEGIN
DECLARE @UnitID int
SELECT @UnitID = UnitID FROM tblUser WHERE UserID = @UserID

DECLARE @Email VARCHAR(100)
SELECT @Email = coalesce(
-- try to get the closest unit admin then search further afield
(Select top 1	u.Email
from tblUnitAdministrator ua
inner join tblUser u on ua.userID = u.UserID
where ua.unitID=@unitID
and u.usertypeID=3 --Unit administrator(3)
and u.unitID=@unitID
and u.Email is not null),


(Select top 1	u.Email
from tblUnitAdministrator ua
inner join tblUser u on ua.userID = u.UserID
where ua.unitID=@unitID
and u.usertypeID=3 --Unit administrator(3)
and u.Email is not null),

(Select top 1	u.Email
from tblUser u inner join tblUnit un on un.OrganisationID = u.OrganisationID
where un.unitID=@unitID
and UserTypeID = 2
and Email is not null),


(Select top 1	u.Email
from tblUser u inner join tblUnit un on un.OrganisationID = u.OrganisationID
where un.unitID=@unitID
and UserTypeID = 1
and Email is not null),

--all else failed so get the salt admin
(Select top 1	u.Email
from tblUser u
where UserTypeID = 1
and Email is not null))



return @Email
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetAdministratorsEmailAddress]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 01/07/2011
-- Description:	Gets nearest admin for user
-- =============================================
CREATE PROCEDURE [prcUser_GetAdministratorsEmailAddress]
@UserId int
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

-- Insert statements for procedure here
SELECT dbo.udfUser_GetAdministratorsEmailAddress(@UserId)
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfUnit_GetAdministratorsEmailAddress]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'create function [udfUnit_GetAdministratorsEmailAddress]
(
@unitID	int
)
Returns varchar(100)
AS
BEGIN
DECLARE @Email VARCHAR(100)
SELECT @Email = coalesce(
-- try to get the closest unit admin then search further afield
(Select top 1	u.Email
from tblUnitAdministrator ua
inner join tblUser u on ua.userID = u.UserID
where ua.unitID=@unitID
and u.usertypeID=3 --Unit administrator(3)
and u.unitID=@unitID
and u.Email is not null),


(Select top 1	u.Email
from tblUnitAdministrator ua
inner join tblUser u on ua.userID = u.UserID
where ua.unitID=@unitID
and u.usertypeID=3 --Unit administrator(3)
and u.Email is not null),

(Select top 1	u.Email
from tblUser u inner join tblUnit un on un.OrganisationID = u.OrganisationID
where un.unitID=@unitID
and UserTypeID = 2
and Email is not null),


(Select top 1	u.Email
from tblUser u inner join tblUnit un on un.OrganisationID = u.OrganisationID
where un.unitID=@unitID
and UserTypeID = 1
and Email is not null),

--all else failed so get the salt admin
(Select top 1	u.Email
from tblUser u
where UserTypeID = 1
and Email is not null))



return @Email
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonQuizSession_CheckSessionUnique]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
Given SessionID (lesson or quiz) guid
returns true if the session is unique else returns false
Returns:
scaler bit 0 = false,  1 = true

Called By: TooolBooLlistner.aspx via Businessservices.Toolbook.SessionIsUnique
Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



--------------------

**/


CREATE   Proc [prcLessonQuizSession_CheckSessionUnique]
(
@sessionID varchar(50) -- The session ID
)

AS

Set NoCount On

------------------------------------------
-- Declerations
------------------------------------------
Declare @intReurnValue int
set @intReurnValue = 1

------------------------------------------
-- Check to see if lesson or session already exists
------------------------------------------
if exists
(
(select LessonSessionID from tblLessonSession where LessonSessionID = @sessionID)
union
(select QuizSessionID from tblQuizSession where QuizSessionID = @sessionID)
)
Begin
set @intReurnValue = 0
End

Select @intReurnValue
Return

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetLessonIDBySessionID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetLessonIDBySessionID    Script Date: 20/04/2004 8:25:57 AM ******/





/*
Summary:
user Defined Function that returns a lesson id given a Session id
only Works for a lesson
Returns:
scaler - lesson id - int

Called By:
dbo.prcBookMark_GetBookMarkBySessionID
dbo.prcLessonPageAudit_GetPagesVisited
dbo.prcLessonPageAudit_GetPagesVisitedBySessionID
dbo.prcLessonSession_EndLesson
dbo.prcLessonPageAudit_InsertPageVisited

Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


print dbo.udfGetLessonIDByToolbookID(''toolBookID-1'')
-- select * from tblLesson

**/
CREATE    FUNCTION [udfGetLessonIDBySessionID]
(
@sessionID varchar(50) -- The session ID - GUID
)
RETURNS INT --< UserID >--
Begin
------------------------------------------
-- get Lesson id for this Session
------------------------------------------

DECLARE @retVal int
set @retVal =
(
(
SELECT TOP 1
LessonID
FROM
tblLessonSession
WHERE
LessonSessionID = ltrim(rtrim(@sessionID))
)
)
RETURN @retVal
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonSession_StartLesson]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
-- Check that the lesson has not already been started
-- if it has - return false
-- if it has not, start it and return true
Returns:
boolean (bit) OKToStart true = 1, false = 0

Called By:
Businessservices.Toolbook.StartLesson
Calls:

Remarks:

Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
#2 Removed unnecessary transactions

-----------
prcLessonSession_StartLesson @LessonSessionID = ''4986F67F-FF29-4979-9A97-D7846839E0DB''


**/

CREATE     Procedure [prcLessonSession_StartLesson]
(
@lessonSessionID varchar(50) -- ToolBook Session ID - GUID
)

As
Set NoCount On
Set Xact_Abort On



------------------------------------------
-- Declerations
------------------------------------------
Declare @bitReturnValue bit -- Return Value

------------------------------------------
-- Check that the lesson has not already been started
-- if it has - return false
-- if it has not, start it and return true
-- Start the lesson ( insert a start date )
------------------------------------------
if exists (select LessonSessionID from tblLessonSession where LessonSessionID=@LessonSessionID and DateTimeStarted is null)
Begin -- it is ok to start, record start and return true
--< do update >--
Update
tblLessonSession
Set
[DateTimeStarted] = GETUTCDATE()
Where
[LessonSessionID] = @LessonSessionID
--< set return value >--
Set @bitReturnValue = 1
End
Else
Begin  -- it is NOT ok to start, return false
--< set return value >--
Set @bitReturnValue = 0
End


------------------------------------------
-- select SessionID
------------------------------------------

Select @bitReturnValue as ''OKToStart''
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLogUsage_Hourly]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcLogUsage_Hourly] AS

Insert Into
tblLogHourly ([OrganisationID]
,[TimePeriod1]
,[TimePeriod2]
,[TimePeriod3]
,[TimePeriod4]
,[TimePeriod5]
,[TimePeriod6]
,[DateCreated] )


SELECT  MAX(tblOrganisation.OrganisationID),
COUNT(Minute.UserMinute) AS ''Last Minute'',
COUNT(Hour.UserHour) AS ''Last Hour'',
COUNT(Days.UserDay) AS ''Last Day'',
COUNT(Weeks.userWeek) AS ''Last Week'',
COUNT(Months.UserMonth) AS ''Last Month'',
COUNT(Years.UserYear) AS ''Last Year'',
GetUTCDate()
FROM         tblUser INNER JOIN
tblOrganisation ON tblUser.OrganisationID = tblOrganisation.OrganisationID LEFT OUTER JOIN
(SELECT     UserID AS UserYear
FROM          tblUser
WHERE      DATEDIFF(Year, LastLogin, getutcdate()) <= 1) AS Years ON UserID = UserYear LEFT OUTER JOIN
(SELECT     UserID AS UserMonth
FROM          tblUser
WHERE      DATEDIFF(Month, LastLogin, getutcdate()) <= 1) AS Months ON UserID = UserMonth LEFT OUTER JOIN
(SELECT     UserID AS UserWeek
FROM          tblUser
WHERE      DATEDIFF(Week, LastLogin, getutcdate()) <= 1) AS Weeks ON UserID = UserWeek LEFT OUTER JOIN
(SELECT     UserID AS UserDay
FROM          tblUser
WHERE      DATEDIFF(Day, LastLogin, getutcdate()) <= 1) AS Days ON UserID = UserDay LEFT OUTER JOIN
(SELECT     UserID AS UserHour
FROM          tblUser
WHERE      DATEDIFF(Hour, LastLogin, getutcdate()) <= 1) AS Hour ON UserID = UserHour LEFT OUTER JOIN
(SELECT     UserID AS UserMinute
FROM          tblUser
WHERE      DATEDIFF(Minute, LastLogin, getutcdate()) <= 1) AS Minute ON UserID = UserMinute
GROUP BY tblUser.OrganisationID
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLogUsage_Daily]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcLogUsage_Daily]
as
Insert
into
tblLogDaily ([OrganisationID]
,[TimePeriod1]
,[TimePeriod2]
,[TimePeriod3]
,[TimePeriod4]
,[TimePeriod5]
,[TimePeriod6]
,[TimePeriod7]
,[TimePeriod8]
,[DateCreated])

SELECT  MAX(tblOrganisation.[OrganisationID]) ,
COUNT(User_A.User_A) AS ''12am - 7am '',
COUNT(User_B.User_B) AS '' 7am - 9am '',
COUNT(User_C.User_C) AS '' 9am - 11am'',
COUNT(User_D.User_D) AS ''11am - 1pm '',
COUNT(User_E.User_E) AS ''1pm  - 3pm'',
COUNT(User_F.User_F) AS '' 3pm - 5pm '',
COUNT(User_G.User_G) AS '' 5pm - 7pm'',
COUNT(User_H.User_H) AS '' 7pm - 12pm '',
GetUTCDate()
FROM         tblUser INNER JOIN
tblOrganisation ON tblUser.OrganisationID = tblOrganisation.OrganisationID LEFT OUTER JOIN
(SELECT     UserID AS User_A
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 0 AND DATEPART(hh, LastLogin) < 7) AS User_A ON UserID = User_A LEFT OUTER JOIN
(SELECT     UserID AS User_B
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 7 AND DATEPART(hh, LastLogin) < 9) AS User_B ON UserID = User_B LEFT OUTER JOIN
(SELECT     UserID AS User_C
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 9 AND DATEPART(hh, LastLogin) < 11) AS User_C ON UserID = User_C LEFT OUTER JOIN
(SELECT     UserID AS User_D
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 11 AND DATEPART(hh, LastLogin) < 13) AS User_D ON UserID = User_D LEFT OUTER JOIN
(SELECT     UserID AS User_E
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 13 AND DATEPART(hh, LastLogin) < 15) AS User_E ON UserID = User_E LEFT OUTER JOIN
(SELECT     UserID AS User_F
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 15 AND DATEPART(hh, LastLogin) < 17) AS User_F ON UserID = User_F LEFT OUTER JOIN
(SELECT     UserID AS User_G
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 17 AND DATEPART(hh, LastLogin) < 19) AS User_G ON UserID = User_G LEFT OUTER JOIN
(SELECT     UserID AS User_H
FROM          tblUser
WHERE      DATEPART(hh, LastLogin) >= 19 AND DATEPART(hh, LastLogin) < 24) AS User_H ON UserID = User_H
GROUP BY tblUser.OrganisationID
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udf_GetUnitHierarchiesForORG]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE  FUNCTION [udf_GetUnitHierarchiesForORG](@Org INT)
RETURNS @Result TABLE(UnitID INT, Hierarchy nVARCHAR(500), HierarchyName nVARCHAR(2000))
AS
BEGIN
INSERT INTO @Result
SELECT
A.UnitID, A.Hierarchy, A.HierarchyName
FROM
tblUnitHierarchy A, tblUnit B
WHERE
A.UnitID = B.UnitID AND B.OrganisationID = @ORG

RETURN
END
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udf_GetAdminEmailsForORG]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE  FUNCTION [udf_GetAdminEmailsForORG](@Org INT)
--RETURNS @Result TABLE(UserID INT, UnitID INT, Hierarchy nVARCHAR(500), HierarchyName nVARCHAR(2000))
RETURNS TABLE
AS
RETURN

SELECT
unt.UnitID, uadm.UserID, hier.Hierarchy, hier.HierarchyName
FROM
tblUnitAdministrator uadm
INNER JOIN tblUnit unt ON uadm.UnitID = unt.UnitID AND unt.OrganisationID = @ORG
INNER JOIN tblUnitHierarchy hier ON hier.UnitID = unt.UnitID

--For units with no Unit Admin inform the Organisation Administrator instead
UNION
SELECT
unt.UnitID, ORGadm.UserID, hier.Hierarchy, hier.HierarchyName
FROM
tblUser ORGadm
INNER JOIN tblUnit unt ON ORGadm.OrganisationID = unt.OrganisationID AND ORGadm.OrganisationID = @ORG AND ORGadm.UserTypeID = 2
INNER JOIN tblUnitHierarchy hier ON hier.UnitID = unt.UnitID
WHERE NOT EXISTS
(
SELECT * FROM tblUnitAdministrator uadm WHERE uadm.UnitID = unt.UnitID
)
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReportSchedule_IncrementNextRunDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [udfReportSchedule_IncrementNextRunDate]
(
	@RunDate datetime, 
	@ReportStartDate datetime, 
	@ReportFrequencyPeriod char(1), 
	@ReportFrequency int, 
	@OrgID int	
)
RETURNS  datetime
AS
BEGIN
	if (@ReportFrequency = 0)
	begin
	   set @ReportFrequency = 1
	 end
	-- NextRun is saved in the ORGs timezone so that when an ORG goes into daylight saving the Report is run at the correct time.
	-- ALL other times are saved in the ORGs timezone to reduce load on the GUI when the ORGs timezone is changed

	DECLARE @NumReportPeriodsToNextRun bigint
	SELECT @NumReportPeriodsToNextRun = 
	1 + CASE 
		WHEN (@ReportFrequencyPeriod=''Y'') THEN DATEDIFF(YEAR,@ReportStartDate,@RunDate)/ @ReportFrequency
		WHEN (@ReportFrequencyPeriod=''M'') THEN DATEDIFF(MONTH,@ReportStartDate,@RunDate)/ @ReportFrequency
		WHEN (@ReportFrequencyPeriod=''W'') THEN DATEDIFF(WEEK,@ReportStartDate,@RunDate)/ @ReportFrequency
		WHEN (@ReportFrequencyPeriod=''D'') THEN DATEDIFF(DAY,@ReportStartDate,@RunDate)/ @ReportFrequency
		WHEN (@ReportFrequencyPeriod=''H'') THEN DATEDIFF(HOUR,@ReportStartDate,@RunDate)/ @ReportFrequency
	END	
	

	DECLARE @NextNextRun DateTime
	SELECT @NextNextRun = 
	CASE 
		WHEN (@ReportFrequencyPeriod=''Y'') THEN DATEADD(YEAR,@NumReportPeriodsToNextRun*@ReportFrequency,@ReportStartDate)
		WHEN (@ReportFrequencyPeriod=''M'') THEN DATEADD(MONTH,@NumReportPeriodsToNextRun*@ReportFrequency,@ReportStartDate)
		WHEN (@ReportFrequencyPeriod=''W'') THEN DATEADD(WEEK,@NumReportPeriodsToNextRun*@ReportFrequency,@ReportStartDate)
		WHEN (@ReportFrequencyPeriod=''D'') THEN DATEADD(DAY,@NumReportPeriodsToNextRun*@ReportFrequency,@ReportStartDate)
		WHEN (@ReportFrequencyPeriod=''H'') THEN DATEADD(HOUR,@NumReportPeriodsToNextRun*@ReportFrequency,@ReportStartDate)
	END	


	-- Return the result of the function
	RETURN @NextNextRun

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetEmailReplyTo]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [udfGetEmailReplyTo]
(
@OrgID int,
@Sender nvarchar(255)
)
RETURNS nvarchar(255)
AS
BEGIN
	DECLARE @OnBehalfOf nvarchar(255)
	SELECT @OnBehalfOf = ''''
RETURN @OnBehalfOf
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSqlAgentRunningStatus_Get]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
return teh running state of the SQLServerAgent
Returns:
sclaer

Called By:
Bdw.Application.Salt.BusinessServices.Application.GetSqlAgentRunningStatus
Calls:
master..xp_servicecontrol
Remarks:
- May not work if permissions are insuficient

Author:
Stephen Kennedy-Clark
Date Created: 10 May 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



--------------------
prcSqlAgentRunningStatus_Get

**/
CREATE Procedure [prcSqlAgentRunningStatus_Get]

AS


EXEC master..xp_servicecontrol ''QUERYSTATE'', ''SQLServerAgent''

' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSalt_GrantPermission]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Grant all required permission to the website user
User don''t need to be an dbowner
Required Permission
1. Execute permission to all procedures
2. Select permission to all tables and views that are used in dynamic query
That permission is not required, all dynamic query need to be reviewed before set this permission

Parameters:
Returns:

Called By:
Calls:

Remarks:

Author: Jack Liu
Date Created: 25th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcSalt_GrantPermission ''Salt_user''


select * from sysobjects
where xtype=''p''
order by name

prcSalt_GrantPermission
*/


CREATE   procedure [prcSalt_GrantPermission]
(
@login sysname
)
as
declare @userName sysname

declare @name varchar(100), @sql varchar(1000)

set nocount on

--1. Check whether the login has been granted access permission to this database
--If not, grant access permission
select @userName = u.name
from sysusers u
inner join master.dbo.syslogins  l
on u.sid = l.sid
where u.uid < 16382
and l.name=@login

if @userName is null
begin
-- If the db user name is used by other login, drop it
If exists(select 1 from sysusers where name=@login)
begin
EXEC sp_revokedbaccess @login
end

EXEC sp_grantdbaccess @login, @userName output
end


--2. Grant minimum permission
DECLARE Proc_Cursor CURSOR FOR
select name from sysobjects where xtype=''p'' and Category=0
OPEN Proc_Cursor
FETCH NEXT FROM Proc_Cursor
into @name
WHILE @@FETCH_STATUS = 0
BEGIN
set @sql=''GRANT execute ON [''+ @name + ''] TO ''+  @userName
exec(@sql)
FETCH NEXT FROM Proc_Cursor
into @name
END
CLOSE Proc_Cursor
DEALLOCATE Proc_Cursor

EXEC sp_droprolemember ''db_owner'', @userName




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Updates a Policy.

Parameters:
@PolicyID int,
@OrganisationID int,
@PolicyName nvarchar(255),
@Active bit,
@Deleted bit,
@PolicyFileName nvarchar(255),
@PolicyFileSize bigint,
@UploadDate datetime


Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

CREATE procedure [prcPolicy_Update]
(
@PolicyID int,
@OrganisationID int,
@PolicyName nvarchar(255),
@Active bit,
@Deleted bit,
@PolicyFileName nvarchar(255),
@PolicyFileSize bigint,
@UploadDate datetime,
@ConfirmationMessage nvarchar(500)
)
as

declare @SQL nvarchar(1000)
declare @SQLL nvarchar(1000)
declare @SQLR nvarchar(1000)
declare @Index int

set @PolicyName = replace(@PolicyName, '''''''', '''''''''''')
set @ConfirmationMessage = replace(@ConfirmationMessage, '''''''', '''''''''''')

set @SQL = ''update tblPolicy''
set @SQL = @SQL + '' set''
if @OrganisationID is not null
begin
set @SQL = @SQL + '' OrganisationID = '' + cast(@OrganisationID as nvarchar) + '',''
end
if @PolicyName is not null
begin
set @SQL = @SQL + '' PolicyName = '''''' + @PolicyName + '''''',''
end
if @Active is not null
begin
set @SQL = @SQL + '' Active = '' + cast(@Active as char(1)) + '', ''
end
if @Deleted is not null
begin
set @SQL = @SQL + '' Deleted = '' + cast(@Deleted as char(1)) + '', ''
end
if @PolicyFileName is not null
begin
set @SQL = @SQL + '' PolicyFileName = '''''' + @PolicyFileName + '''''',''
end
if @PolicyFileSize is not null
begin
set @SQL = @SQL + '' PolicyFileSize = '' + cast(@PolicyFileSize as nvarchar) + '',''
end
if @UploadDate is not null
begin
set @SQL = @SQL + '' UploadDate = getUTCDate() ,''
end
if @ConfirmationMessage is not null
begin
set @SQL = @SQL + '' ConfirmationMessage = '''''' + @ConfirmationMessage + '''''',''
end
set @SQL = @SQL + '' where PolicyID ='' + cast(@PolicyID as nvarchar)

-- this removes last '','' character from @SQL
set @SQL = reverse(@SQL)
set @index = charindex('','', @SQL)
if @index > 0
begin
set @SQLL = left(@SQL, @index-1)
set @SQLR = right(@SQL, len(@SQL) - (@index))
set @SQL = @SQLL + @SQLR
end
set @SQL = reverse(@SQL)

exec (@SQL)
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetSaltDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [udfGetSaltDate]
(

)
-- This function should be called by all Stored Procedures in SALT that use getdate() or getUTCdate()
-- By directing all calls through this function it is easy to perform testing on date related business rules - for
-- example by changing the function call (below) to	SELECT @UTCDate = DATEADD(YEAR,1,dbo.getUTCdate()) it is possible to enter test data through the WebSite that is 1 year old

RETURNS DateTime
AS
BEGIN

DECLARE @UTCDate datetime

SELECT @UTCDate = dbo.getUTCdate()


RETURN @UTCDate

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[GetSaltDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [GetSaltDate]
(

)
RETURNS DateTime
AS
BEGIN

DECLARE @UTCDate datetime

SELECT @UTCDate = dbo.getUTCdate()


RETURN @UTCDate

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcApplication_GetDatabaseVersion]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Gets SQL Server version

Called By: Dependency
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 23/02/2004

prcApplication_GetDatabaseVersion

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcApplication_GetDatabaseVersion]
as
set nocount on
select @@version
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prc_cpu_percent]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prc_cpu_percent]


AS
BEGIN

DECLARE @CPU_percent int

DECLARE @CPU_BUSY int, @IDLE int
SELECT @CPU_BUSY = @@CPU_BUSY, @IDLE = @@IDLE WAITFOR DELAY ''000:00:01''
SET @CPU_percent = (@@CPU_BUSY - @CPU_BUSY)/((@@IDLE - @IDLE + @@CPU_BUSY - @CPU_BUSY) *1.00) *100

SELECT @CPU_percent
RETURN @CPU_percent

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcJobGetAgentStatus]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


CREATE Procedure [prcJobGetAgentStatus]
@Status Varchar(50) OUTPUT
AS

/******************************************************************************
**		File:
**		Name: prcJobGetAgentStatus
**		Desc:
**
**		This template can be customized:
**
**		Return values:
**
**		Called by:
**
**		Parameters:
**		Input							Output
**     ----------							-----------
**
**		Auth:
**		Date:
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		--------		--------				-------------------------------------------
**
*******************************************************************************/


EXEC @Status= master..xp_servicecontrol ''QUERYSTATE'', ''SQLServerAgent''
RETURN



' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_Users]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Returns: result set (active users in the csv list of units)

Author: Mark Donald
Date Created: 04 Aug 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

exec dbo.prcEmail_Users 109, ''4463''
**/

CREATE PROC [prcEmail_Users]
(
@organisationID		int,
@unitIDs 			varchar(MAX)
)
AS
SET NOCOUNT ON

BEGIN
SELECT DISTINCT
u.userid, firstname, lastname, email
FROM
tblUser u, tblunit t
WHERE
u.unitid = t.unitid
AND u.organisationid = @organisationID
AND t.unitid IN (SELECT * FROM dbo.udfCsvToInt(@unitIDs))
AND u.Active = 1
AND t.Active = 1
END

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_UserMashup]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:		Compiles a %COURSE_NAMES% block and returns it with a bunch of user info for sending email to that user
Parameters:		Comma separated list of userID:courseID
Returns:		table (lastname nvarchar(50), firstname nvarchar(50), userid int, email nvarchar(100), course_names varchar(8000))

Called By:		BusinessServices.Course.GetUserMashup in Course.cs
Calls:			None

Remarks:		None

Author:			Mark Donald
Date Created:	13 Nov 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcCourse_UserMashup]
@input_csv varchar(8000),
@user_ids varchar(8000)
AS
BEGIN
SET NOCOUNT ON;

DECLARE @mashup TABLE (userid int, courseid int)
DECLARE @selected_users TABLE (userid int)
DECLARE @result TABLE (firstname nvarchar(50), lastname nvarchar(50), userid int, email nvarchar(100), course_names varchar(8000))
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50),
@userid int,
@course_names varchar(8000)

-- rip the user selection
INSERT INTO @selected_users
SELECT
*
FROM
dbo.udfCsvToInt(@user_ids)

-- clean up the input so it resembles ''userid:courseid,userid:courseid,''
SELECT @input_csv = replace(rtrim(ltrim(replace(replace(replace(@input_csv,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''

-- rip the csv into a table
WHILE patindex(''%,%'', @input_csv) <> 0
BEGIN
SELECT @pos = patindex(''%,%'', @input_csv)
SELECT @temp = left(@input_csv, @pos - 1)
SELECT @colon_pos = patindex(''%:%'', @input_csv)
INSERT @mashup VALUES (
cast(substring(@temp, 1, @colon_pos - 1) AS int),
cast(substring(@temp, @colon_pos + 1, len(@temp)) AS int)
)
SELECT @input_csv = substring(@input_csv, @pos + 1, len(@input_csv))
END

-- Note to self: if the reporting server environment is ever upgraded
-- to SQL Server 2005+ we can improve performace by dicing the cursor
-- and @result table in favour of a UDA function... (UDAs are not
-- available in SS2000)
SELECT @course_names = ''<BR>&nbsp;''
DECLARE concatenator CURSOR READ_ONLY FOR
SELECT
userid
FROM
@selected_users
OPEN concatenator
FETCH NEXT FROM concatenator INTO @userid
WHILE @@FETCH_STATUS = 0
BEGIN
SELECT
@course_names = @course_names + [name] + ''<BR>&nbsp;''
FROM
tblcourse c, @mashup m
WHERE
c.courseid = m.courseid
AND userid = @userid
INSERT INTO
@result
SELECT
lastname, firstname, userid, email, @course_names
FROM
tbluser
WHERE
userid = @userid
SELECT @course_names = ''<BR>&nbsp;''
FETCH NEXT FROM concatenator INTO @userid
END
CLOSE concatenator
DEALLOCATE concatenator

SELECT * FROM @result
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udf_GridExportHeaders]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'create  FUNCTION [udf_GridExportHeaders](@LangCode varchar(10) = ''en-AU'',
@LangInterfaceName varchar(200) = ''/Reporting/PeriodicReport.aspx'')
--RETURNS @Result TABLE( C1 nVARCHAR(500),C2 nVARCHAR(500), C3 nVARCHAR(500), C4 nVARCHAR(500),C5 nVARCHAR(500),C6 nVARCHAR(500),C7 nVARCHAR(500),C8 nVARCHAR(500),C9 nVARCHAR(500),C10 nVARCHAR(500),C11 nVARCHAR(500))
RETURNS TABLE
AS
RETURN

SELECT 1 AS C1
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_HistoricUserCourseStatus]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/*Summary:
gets the last historic course results for each user prior to the effective date

Returns:
Table

Called By:
Calls:

Remarks:


Author:
Stephen Clark
Date Created: 21 September 2004

Modification History
-----------------------------------------------------------
Author		Date			Description

Mark DOnald	24/07/2009		Added LastCompleted column to select

--------------------
select * from udfReport_HistoricUserCourseStatus(''September 5 2004'')

**/

CREATE  function [udfReport_HistoricUserCourseStatus]
(
@effectiveDate datetime
)
Returns table
as
-----------------------------------------------------------

return select
--< Historic User Course Status Clause >---
tUCS.UserCourseStatusID
, tUCS.UserID
, tUCS.CourseID
, tUCS.CourseStatusID
, tUCS.ModulesAssigned
, tUCS.DateCreated
, (SELECT
max(DateCreated)
FROM
tblUserCourseStatus
WHERE
tUCS.CourseStatusID = 1 --incompleted users only
AND UserID =tUCS.UserID
AND CourseID =tUCS.CourseID
AND CourseStatusID = 2
AND UserCourseStatusID < tUCS.UserCourseStatusID) as  LastCompleted
From
tblUserCourseStatus tUCS
--< only get data on active courses >--
inner join tblCourse tC
on tC.CourseID = tUCS.CourseID
and tC.Active = 1
--< only get the latest result for each user - prior to the efective date >--
inner join(
select
max(UserCourseStatusID) UserCourseStatusID --UserQuizStatusID is identity
from
tblUserCourseStatus
where
tblUserCourseStatus.DateCreated < DATEADD(DD, 1, @effectiveDate)
group by
UserID,CourseID
) currentStatus
on tUCS.UserCourseStatusID = currentStatus.UserCourseStatusID
--< / Historic User Course Status Clause >---
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_IncompleteUsersLogic]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE                  function [udfReport_IncompleteUsersLogic]
(
@organisationID		Integer=null,		-- Organisation ID to search if the unit is empty
@unitIDs 		varchar(MAX) = null,	-- string of unit id''s
@courseID		Integer = null,		-- course ID to restrict search to
@effectiveDate 		datetime = null		-- effective date of report

)

-------------------------------------------------------------------
Returns @tblReturn table
(
UserID		Int,
UnitID		Int,
FirstName		nvarchar(255),
LastName 	nvarchar(255),
UnitPathway 	nvarchar(4000),
LastCompleted	varchar(23),
Username		nvarchar(100),
Email		nvarchar(100),
ExternalID		nvarchar(50)
)

as
Begin --1
if (@effectiveDate is null)
Begin
----------------------------------------------------
--- Report on the current date
----------------------------------------------------
if (@unitIDs is null)
begin --2
----------------------------------------------------
--- Report on the current date on all units
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
--, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, tUH.HierarchyName as ''UnitPathway''
, LastCompleted
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
FROM
tblUser tU1
inner join tblUnit on
tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join vwUserCourseStatus vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 1 --< want users that are incomplete >--
and vUCS.CourseID = @courseID
inner join tblUnitHierarchy tUH
on tU1.UnitID = tUH.UnitID
end --/2
else
begin --3
----------------------------------------------------
--- Report on the current date on a specific unit
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
--, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, tUH.HierarchyName as ''UnitPathway''
, LastCompleted
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
FROM
tblUser tU1
inner join tblUnit on
tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join vwUserCourseStatus vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 1 --< want users that are incomplete >--
and vUCS.CourseID = @courseID
inner join dbo.udfCsvToInt(@unitIDs) tU
on tU.IntValue = tblUnit.UnitID --< restrict units to thoes in the list >--
inner join tblUnitHierarchy tUH
on tU1.UnitID = tUH.UnitID
end --/3
End

Else

Begin
----------------------------------------------------
--- Report on the historic date provided
----------------------------------------------------
if (@unitIDs is null)
begin --2
----------------------------------------------------
--- Report on the historic date provided for all units
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
--, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, tUH.HierarchyName as ''UnitPathway''
, LastCompleted
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
FROM
tblUser tU1
inner join tblUnit on
tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join  dbo.udfReport_HistoricUserCourseStatus(@effectiveDate) vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 1 --< want users that are incomplete >--
and vUCS.CourseID = @courseID
inner join tblUnitHierarchy tUH
on tU1.UnitID = tUH.UnitID

end --/2
else
begin --3
----------------------------------------------------------------
--- Report on the historic date provided for the specified units
----------------------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
--, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, coalesce(tUH.HierarchyName,'''')  as ''UnitPathway''
, LastCompleted
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
FROM
tblUser tU1
inner join tblUnit on
tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join  dbo.udfReport_HistoricUserCourseStatus(@effectiveDate) vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 1 --< want users that are incomplete >--
and vUCS.CourseID = @courseID
inner join dbo.udfCsvToInt(@unitIDs) tU
on tU.IntValue = tblUnit.UnitID --< restrict units to thoes in the list >--
inner join tblUnitHierarchy tUH
on tU1.UnitID = tUH.UnitID

end --/3
End

return
end -- /1
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSearchUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 27/10/2011
-- Description:	Searches the Users with First name and last name
-- =============================================
CREATE PROCEDURE [prcSearchUsers] 
(
	-- Add the parameters for the stored procedure here
	@OrgID int,
	@Firstname varchar(100), 
	@LastName varchar(100),
	@ScheduleId int
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

If @Firstname is null
Set @Firstname = ''''

Set @Firstname =rtrim(@firstName)

If @LastName is null
Set @LastName = ''''

Set @LastName =rtrim(@lastName)

	SELECT UserID, 
		CASE u.Active WHEN 1 THEN FirstName WHEN 0 THEN FirstName + ''(I)'' END AS FirstName, 
		LastName, UserName, Email
		FROM tblUser u JOIN tblUserType ut ON u.UserTypeID = ut.UserTypeID
		WHERE FirstName like @Firstname + ''%'' 
		AND LastName like @LastName +''%'' AND OrganisationID=@OrgID
--		AND u.UserTypeID <> 4 
--		AND u.UserID NOT IN (SELECT UserID FROM tblCCList WHERE ScheduleId = @ScheduleId)
END' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSearchAdminUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 27/10/2011
-- Description:	Searches the Unit and Org Admins with First name and last name
-- =============================================
CREATE PROCEDURE [prcSearchAdminUsers] 
(
	-- Add the parameters for the stored procedure here
	@OrgID int,
	@Firstname varchar(100), 
	@LastName varchar(100)
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

If @Firstname is null
Set @Firstname = ''''

Set @Firstname =rtrim(@firstName)

If @LastName is null
Set @LastName = ''''

Set @LastName =rtrim(@lastName)

	SELECT UserID, FirstName, LastName, UserName, Email, ut.Type
		FROM tblUser u JOIN tblUserType ut ON u.UserTypeID = ut.UserTypeID
		WHERE FirstName like @Firstname + ''%'' 
		AND LastName like @LastName +''%'' AND OrganisationID=@OrgID
		AND u.UserTypeID <> 4 
END' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfUserUTCtoDaylightSavingTime]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 30/06/2011
-- Description:	changes time from utc to user local time while displaying
-- =============================================
CREATE FUNCTION [udfUserUTCtoDaylightSavingTime]
(
@UTC DateTime,
@UserID int
)
RETURNS DateTime
AS
BEGIN

IF (@UTC is null) RETURN null
DECLARE @UserLocalTime datetime
DECLARE @UTC_Offset int
DECLARE @Timezone datetime
DECLARE @offset_mins int, @hours_start int, @day_start int, @week_start int, @month_start int, @hours_end int, @day_end int, @week_end int, @month_end int, @year_end int , @year_start int

DECLARE @TimezoneID int
SELECT @TimezoneID = TimeZoneID FROM tblUser WHERE UserID=@UserID

IF (@TimezoneID is NULL)
BEGIN
SELECT @UTC_Offset = TZ.OffsetUTC , @Timezone = TZ.TimezoneID
FROM tblTimeZone TZ
INNER JOIN tblOrganisation Org ON TZ.TimeZoneID = Org.TimeZoneID
INNER JOIN tblUser Usr ON Usr.OrganisationID = Org.OrganisationID
WHERE Usr.UserID = @UserID
END
ELSE
BEGIN
SELECT @UTC_Offset = TZ.OffsetUTC , @Timezone = TZ.TimezoneID
FROM tblTimeZone TZ
INNER JOIN tblUser Usr ON TZ.TimeZoneID = Usr.TimeZoneID
WHERE Usr.UserID = @UserID
END

IF (@UTC_Offset IS NULL)
BEGIN
Set @UserLocalTime = ''1 Jan 1900'' -- all results are displayed by Reporting Services so create an "error" that will be apparent in Reporting Services
END
ELSE
BEGIN
Set @UserLocalTime = DATEADD(minute,@UTC_Offset,@UTC )
SELECT  @offset_mins = offset_mins, --get definition of the (at most) 1 definition that may cover the datetime
@hours_start = hours_start, --overlapping definitions removed by GUI so only 1 result returned
@day_start = day_start,
@week_start = week_start,
@month_start = month_start,
@hours_end = hours_end,
@day_end = day_end,
@week_end = week_end,
@month_end = month_end
FROM tblTimeZoneDaylightSavingRules
WHERE  TimezoneID = @Timezone
AND @UserLocalTime >= first_start_date
AND @UserLocalTime <= last_end_date

-- start with a period (@Period_start datetime, @period_end datetime) that just has the correct year digits
DECLARE @Period_start datetime, @period_end datetime
Set @year_start = year(@UserLocalTime)
set @year_end = year(@UserLocalTime)

if (month(@UserLocalTime) <= @month_end) and (@month_start > @month_end) set @year_start = @year_start - 1   -- rule spans december 31 so adjust

IF(@month_start > @month_end) and (month(@UserLocalTime) >= @month_start) set @year_end = @year_start + 1  -- rule spans december 31 so adjust


--Set @year_start = year(@UserLocalTime) --now calculate the exact start and end dates and times for the year under consideration
--IF(@month_start > @month_end) set @year_end = @year_start+1 else set @year_end = @year_start
--DECLARE @Period_start datetime, @period_end datetime

set @Period_start = ''1 jan 2000'' -- start with a known datetime
set @year_start = @year_start - 2000
Set @Period_start = DATEADD(year,@year_start,@Period_start) -- then set the year correctly
-- Then move to the correct month
Set @Period_start = DATEADD(month,@month_start-1,@Period_start)
-- Then move to the correct week (let week 5 slide to the next month for now)
Set @Period_start = DATEADD(week,@week_start-1,@Period_start)
-- Now move FORWARD to the correct day (say) the 5th sunday of february
Declare @day_offset int
if (@day_start >=  DatePart(weekday,@Period_start) ) set @day_offset = @day_start -  DatePart(weekday,@Period_start) else  set @day_offset = @day_start -  DatePart(weekday,@Period_start) + 7
Set @Period_start = DATEADD(day,@day_offset,@Period_start)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_start) > @month_start) set @Period_start = DATEADD(week,-1,@Period_start)
Set @Period_start = DATEADD(minute,@hours_start,@Period_start)  ---TODO check if offset applied OK for 1 hour either side of daylight saving start and end

set @Period_end = ''1 jan 2000'' -- start with a known datetime
set @year_end = @year_end - 2000
Set @Period_end = DATEADD(year,@year_end,@Period_end) -- then adjust it to match the definition
Set @Period_end = DATEADD(month,@month_end-1,@Period_end)
Set @Period_end = DATEADD(week,@week_end-1,@Period_end)
if (@day_end >=  DatePart(weekday,@Period_end) ) set @day_offset = @day_end -  DatePart(weekday,@Period_end) else  set @day_offset = @day_end -  DatePart(weekday,@Period_end) + 7
Set @Period_end = DATEADD(day,@day_offset,@Period_end)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_end) > @month_end) set @Period_end = DATEADD(week,-1,@Period_end)
Set @Period_end = DATEADD(minute,@hours_end,@Period_end)  ---TODO check if offset applied OK for 1 hour either side of daylight saving start and end
Set @Period_end = DATEADD(minute,-@offset_mins,@Period_end) -- end time is quoted with daylight savings included


IF (@UserLocalTime >= @Period_start)
AND (@UserLocalTime < @Period_end) set @UserLocalTime = DATEADD(minute,@offset_mins,@UserLocalTime)
END
RETURN @UserLocalTime
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfIsGUID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfIsGUID    Script Date: 20/04/2004 8:25:57 AM ******/

/*
Summary:
user Defined Function that returns 1 (true) if the value supplied was a GUID
else it returns 0 (false)
Returns:
scaler - bit  0 = false, 1 = true

Called By:
prcCourse_GetOneBySessionID
Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



print dbo.udfIsGUID(newID())
**/
CREATE    FUNCTION [udfIsGUID]
(
@testString varchar(50) -- presumably this is a - GUID
)
RETURNS bit --< boolean >--
Begin
------------------------------------------
-- Declerations
------------------------------------------
DECLARE @returnValue int

set @returnValue = 0
------------------------------------------
-- Try and cast
------------------------------------------
if @testString like replicate(''[0-9a-fA-F]'', 8) + ''-'' +
replicate(''[0-9a-fA-F]'', 4) + ''-'' +
replicate(''[0-9a-fA-F]'', 4) + ''-'' +
replicate(''[0-9a-fA-F]'', 4) + ''-'' +
replicate(''[0-9a-fA-F]'', 12)
Begin
set @returnValue = 1
End
------------------------------------------
RETURN @returnValue



End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_UpdateClassification]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*
Summary:
Updates a Classification.

Parameters:
@name nVarChar(50)
@active Bit
@classificationID Integer

Returns:
None

Called By:
Classification.cs

Calls:
None

Remarks:
Exception:
0. Succeed
1. RecordNotFoundException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 19th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/
CREATE  Procedure [prcClassification_UpdateClassification]
(
@name nVarChar(50) = Null, -- Name of the Classification
@active Bit = 1, -- Status of the classification
@classificationID Integer = Null, -- The ID of the classification that you wish to update.
@classificationTypeID Integer = Null -- The ID of the classification type that this classification belongs to.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage VarChar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @intErrorNumber = 0
Set @strErrorMessage = ''''

-- Validation Routines
If(@classificationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @classificationID in stored procedure  prcClassification_UpdateClassification''
Goto Finalise
End

If(@classificationTypeID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @classificationTypeID in stored procedure  prcClassification_UpdateClassification''
Goto Finalise
End

If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure  prcClassification_UpdateClassification''
Goto Finalise
End

If Exists(Select * From tblClassification Where Value = @name And ClassificationID != @classificationID And ClassificationTypeID = @classificationTypeID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Classification Value '' + @name + '' already exists for this ClassificationType please choose another value for your ClassificationType.''
Goto Finalise
End

If(@active Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure  prcClassification_UpdateClassification''
Goto Finalise
End

If Exists(Select * From tblClassification Where ClassificationID = @classificationID)
Begin

Update tblClassification
Set
Value = @name,
Active = @active
Where
ClassificationID = @classificationID
DELETE FROM
tblUserClassification
WHERE
ClassificationID = @classificationID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetCCList]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE  FUNCTION [udfGetCCList]
(
@ScheduleID int
)
RETURNS nvarchar(4000)
Begin

declare @CCList nvarchar(4000)
set @CCList = ''''

select @CCList=   @CCList  + CASE WHEN @CCList = '''' THEN '''' ELSE '','' END + tblUser.FirstName + '' '' + tblUser.LastName + '' <'' + tblUser.Email + ''>''
FROM tblCCList
INNER JOIN tblUser ON tblUser.UserID = tblCCList.UserID 
WHERE tblUser.Active = 1 
AND tblCCList.ScheduleID = @ScheduleID 


RETURN @CCList
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetCCListMain]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 4/11/2011
-- Description:	Get the CC List on the Periodic report main page
-- =============================================
CREATE PROCEDURE [prcGetCCListMain] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    SELECT u.UserID, FirstName, LastName, Email FROM tblCCList cc 
    JOIN tblUser u ON u.UserID = cc.UserID
    WHERE cc.ScheduleId = @ScheduleId
END' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetCCList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 26/10/2011
-- Description:	Gets the list of cc users for a periodic report
-- =============================================
CREATE PROCEDURE [prcGetCCList] 
(
	@ScheduleId int
)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT u.UserID, u.Username FROM tblCCList cc
		JOIN tblUser u ON cc.UserId = u.UserID
		WHERE cc.ScheduleId = @ScheduleId
END' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetNotesByUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
Given a Course id return the Course notes
Returns:
Course Notes

Called By: Home.aspx via Businessservices.Organisation.GetOrganisationNotes
Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

--------------------
prcOrganisation_GetNotesByUser   @organisationID=3

**/

CREATE   Proc [prcOrganisation_GetNotesByUser]
(
@LangCode varchar(10),
@organisationID Int = Null, 	-- organisation id 	- not required
@userID 	Int = Null		 	-- user id 		- not required
)
AS
------------------------------------------
Set Nocount On

------------------------------------------
-- Validate Requird Paramaters were supplied
------------------------------------------
If @organisationID Is Null And @userID Is Null
Begin
Raiserror (''Procedure prcOrganisation_GetNotesByUser expects at least one  the following pramaters: @userID or @organisationID'', 16, 1)
Return
End

------------------------------------------
-- Get OrganisationID if it was not Supplied
------------------------------------------
If @organisationID Is Null
Begin
Set @organisationID = (Select Top 1 organisationID From tblUser Where UserID = @userID)
End

------------------------------------------
-- Return select
------------------------------------------

--Select
--	Notes
--From
--	tblOrganisation
--Where
--	OrganisationID = @organisationID

select
Notes
from dbo.tblOrganisationNotes orgN
left Join dbo.tblLang l
on orgN.[LanguageID] = l.[LangID]
where orgN.[OrganisationID] = @OrganisationID
and l.[LangCode] = @LangCode




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_SetUserAccessByUnit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/**Summary:
Set''s a users that have access to a profile

Parameters:
@ProfileID integer
@UnitID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: Feb 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcPolicy_SetUserAccessByUnit]
(
@PolicyID int,
@UnitID int
)
as
set nocount on

update tblUserPolicyAccess
set Granted = 1
where PolicyID = @PolicyID
and UserID in
(select UserID from tblUser where UnitID = @UnitID and active=1)

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_old_Quick]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/* Summary:
Update lesson status for each user
This schedule task only updates three status:
Unassigned Modules (0)
New Assigned Modules (Not Started(1))
Expired Modules (Time Elapsed)(4)

Returns:

Called By:

Calls:
Nothing

Remarks:
This is a schedule job running every night to check there are any changes in the user lesson status based on current compliance rules.
If they are the same as the current status, ignore it, otherwise a new status will be created.

If a module is assigned to a user, and there is no activity for this module, the status will be  ''Not started''.
If a module is unassigned from a user, the status will be ''unassinged"(There are records in status table, but the module is not assigned to this user now)
If a module is set to inactive, the status will be ''unassinged''

------------ Decision Processes -------------

1. Get CurrentAssignedModules and PreviousAssignedModules
1.1  CurrentAssignedModules
Get all modules that are currently assigned to each users
and compliance rules

1.2  PreviousAssignedModules
Get a list of modules that is in the lesson status table that the last statuses are not Unassigned (0)

2. Add New lesson status
2.1. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)

2.2. New Assigned Modules (Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)

2.3. Expired Modules (Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson date/frequency, the new status is Expired (Time Expired)(4)



------------ Data need to be recorded -------------

LessonFrequency
0  Unassigned:  		-
1  Not Started: 		Y
4  Expired (Time Elapsed): 	Y


Author: Jack Liu
Date Created: 21 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		1/5/2007		Added LessonCompletionDate

prcUserLessonStatus_Update

**/
CREATE Procedure [prcUserLessonStatus_Update_old_Quick]
(
@OrgID int	-- comma separated organisationID
)
AS
Set Nocount On

/*

1. Get CurrentAssignedModules and PreviousAssignedModules
1.1  CurrentAssignedModules
Get all modules that are currently assigned to each users
and compliance rules
*/

-- mikev(1): added lessonCompletionDate
select 	um.UserID,
um.ModuleID,
umr.LessonFrequency,
umr.LessonCompletionDate
into #tblCurrentAssignedModules
from vwUserModuleAccess um
inner join vwUnitModuleRule umr
on umr.ModuleID  = um.ModuleID
and umr.UnitID = um.UnitID
where um.UnitID in (select UnitID from tblUnit where OrganisationID = @OrgID)
and um.UserID IN (select UserID from tblUser where OrganisationID = @OrgID)


-- select * from #tblCurrentAssignedModules
/*
1.2  PreviousAssignedModules
Get a list of modules that is in the lesson status table that the last statuses are not Unassigned (0)

*/

select 	uls.UserID,
uls.ModuleID
into #PreviousAssignedModules
from vwUserLessonStatus uls
where 	uls.LessonStatusID<>0 --not Unassigned (0)
and uls.UserID IN (select UserID from tblUser where OrganisationID = @OrgID)

/*
2. Add New lesson status
2.1. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)
*/

insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID
)
select pam.UserID,
pam.ModuleID,
0  as QuizStatusID --Unassigned (0)
from #PreviousAssignedModules pam
left join #tblCurrentAssignedModules cam
on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where cam.moduleID is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)


/*
2.2. New Assigned Modules (Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)
*/

-- mikev(1): Added LessonCompletionDate
insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency,
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
1  as LessonStatusID,--Not Started(1)
cam.LessonFrequency, cam.LessonCompletionDate
from #tblCurrentAssignedModules cam
left join #PreviousAssignedModules pam
on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where pam.moduleID is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)

/*
2.3. Expired Modules (Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson frequency, the new status is Expired (Time Expired)(4)
*/

select 	max(LastStarted.UserLessonStatusID) LastStartedStatusID
into #tblLastStartedStatus
from tblUserLessonStatus LastStarted
inner join vwUserLessonStatus CurrentStatus
on  LastStarted.UserID = CurrentStatus.UserID
and  LastStarted.ModuleID = CurrentStatus.ModuleID
and CurrentStatus.LessonStatusID in (2,3)
where LastStarted.LessonStatusID = 2
and LastStarted.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
group by LastStarted.UserID, LastStarted.moduleID

-- mikev(1): added LessonCompletionDate
insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency,
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
4  as LessonStatusID, --(Time Elapsed)(4)
cam.LessonFrequency, cam.LessonCompletionDate
from #tblLastStartedStatus lss
inner join tblUserLessonStatus uls
on uls.UserLessonStatusID = lss.LastStartedStatusID
inner join #tblCurrentAssignedModules cam
on cam.UserID = uls.UserID
and cam.ModuleID = uls.ModuleID
where
(
cam.LessonCompletionDate is null
and DateDiff(day,GETUTCDATE(), dateadd(month, cam.LessonFrequency, uls.DateCreated)) <= 0
)
or
(
isnull(DateDiff(day, GETUTCDATE(), cam.LessonCompletionDate), 1) <= 0
)
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
--Expired

drop table #tblCurrentAssignedModules

drop table #PreviousAssignedModules

drop table #tblLastStartedStatus

-- Extend completion dates
update tblOrganisation
set DefaultLessonCompletionDate = dateadd(year, 1, [DefaultLessonCompletionDate])
where DefaultLessonCompletionDate < GETUTCDATE() and OrganisationID = @OrgID

update tblUnitRule
set LessonCompletionDate = dateadd(year, 1, [LessonCompletionDate])
where LessonCompletionDate < GETUTCDATE() and UnitID IN (select UnitID from tblUnit where OrganisationID = @OrgID)
-- /Extend completion dates


SET QUOTED_IDENTIFIER ON
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update_Quick]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/* Summary:
Update lesson status for each user
This schedule task only updates three status:
Unassigned Modules (0)
New Assigned Modules (Not Started(1))
Expired Modules (Time Elapsed)(4)

Returns:

Called By:

Calls:
Nothing

Remarks:
This is a schedule job running every night to check there are any changes in the user lesson status based on current compliance rules.
If they are the same as the current status, ignore it, otherwise a new status will be created.

If a module is assigned to a user, and there is no activity for this module, the status will be  ''''Not started''''.
If a module is unassigned from a user, the status will be ''''unassinged"(There are records in status table, but the module is not assigned to this user now)
If a module is set to inactive, the status will be ''''unassinged''''

------------ Decision Processes -------------

1. Get CurrentAssignedModules and PreviousAssignedModules
1.1  CurrentAssignedModules
Get all modules that are currently assigned to each users
and compliance rules

1.2  PreviousAssignedModules
Get a list of modules that is in the lesson status table that the last statuses are not Unassigned (0)

2. Add New lesson status
2.1. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)

2.2. New Assigned Modules (Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)

2.3. Expired Modules (Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson date/frequency, the new status is Expired (Time Expired)(4)



------------ Data need to be recorded -------------

LessonFrequency
0  Unassigned:  		-
1  Not Started: 		Y
4  Expired (Time Elapsed): 	Y


Author: Jack Liu
Date Created: 21 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		1/5/2007		Added LessonCompletionDate

prcUserLessonStatus_Update

**/
CREATE Procedure [prcUserLessonStatus_Update_Quick]
(
@OrgID int	-- comma separated organisationID
)
AS
Set Nocount On



--##################################################################################################################
/*
2. Add New lesson status

2.1.     N O T      A S S I G N E D      M O D U L E S
(0) (PreviousAssignedModules - CurrentAssignedModules)
Add record of 0 (unassigned) to tblUserLessonStatus for each User-Module that has been started but now has no Course access or is specifically excluded at unit/user level
*/
--##################################################################################################################
insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID
)
select pam.UserID,
pam.ModuleID,
0  as QuizStatusID --Unassigned (0)
from

(
SELECT LessonStatus.UserID, LessonStatus.ModuleID
FROM  dbo.tblUserCurrentLessonStatus as LessonStatus
inner join tblUser on tblUser.UserID = LessonStatus.UserID and tblUser.OrganisationID = @OrgID
WHERE  (LessonStatus.Excluded = 0) OR (LessonStatus.Excluded IS NULL)
AND (LessonStatus.UserLessonStatusID <> 0)
and 	LessonStatus.LessonStatusID<>0 --not Unassigned (0)
)  pam


left join (SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL)
THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND
ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL))
THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
FROM  dbo.tblUser AS tU INNER JOIN
tblUnit on tU.UnitID = tblUnit.UnitID and tblUnit.OrganisationID = @OrgID INNER JOIN
dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
(tUsrMA.Granted = 1)) cam -- Current Assigned Modules

on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where cam.moduleID is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)



--##################################################################################################################
/*
2.2.      N E W     A S S I G N E D     M O D U L E S
(Not Started(1)) (CurrentAssignedModules- PreviousAssignedModules)
*/
--##################################################################################################################


insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency,
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
1  as LessonStatusID,--Not Started(1)
cam.LessonFrequency,
cam.LessonCompletionDate
from
(
SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL)
THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND
ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL))
THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
FROM  dbo.tblUser AS tU INNER JOIN
tblUnit on tU.UnitID = tblUnit.UnitID and tblUnit.OrganisationID = @OrgID INNER JOIN
dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
(tUsrMA.Granted = 1)
) cam
left join
(
SELECT LessonStatus.UserID, LessonStatus.ModuleID
FROM  dbo.tblUserCurrentLessonStatus as LessonStatus
inner join tblUser on tblUser.UserID = LessonStatus.UserID and tblUser.OrganisationID = @OrgID
WHERE  (LessonStatus.Excluded = 0) OR (LessonStatus.Excluded IS NULL)
AND (LessonStatus.UserLessonStatusID <> 0)
and 	LessonStatus.LessonStatusID<>0 --not Unassigned (0)
)  pam
on cam.UserID = pam.UserID
and cam.ModuleID = pam.ModuleID
where pam.moduleID is null



--##################################################################################################################
/*
2.3.       E X P I R E D    M O D U L E S
(Time Elapsed)(4): Expired a lesson if the cycle started date is past the lesson frequency
a)Get the last cycle started date which current lesson status is In Progress (2), or Completed(3)
b)If the cycle started date is past the current lesson frequency, the new status is Expired (Time Expired)(4)
*/
--##################################################################################################################




insert into tblUserLessonStatus
(
UserID,
ModuleID,
LessonStatusID,
LessonFrequency,
LessonCompletionDate
)
select cam.UserID,
cam.ModuleID,
4  as LessonStatusID, --(Time Elapsed)(4)
cam.LessonFrequency, cam.LessonCompletionDate
from (
select 	max(LastStarted.UserLessonStatusID) LastStartedStatusID
from tblUserLessonStatus LastStarted
inner join
(
SELECT LessonStatus.UserLessonStatusID, LessonStatus.UserID, LessonStatus.ModuleID, m.CourseID, LessonStatus.LessonStatusID, LessonStatus.LessonFrequency,
LessonStatus.DateCreated
FROM  dbo.tblUserCurrentLessonStatus as LessonStatus
inner join tblUser on tblUser.UserID = LessonStatus.UserID and tblUser.OrganisationID = @OrgID
inner join tblModule m on m.ModuleID = LessonStatus.ModuleID

WHERE  (LessonStatus.Excluded = 0) OR (LessonStatus.Excluded IS NULL)
) CurrentStatus
on  LastStarted.UserID = CurrentStatus.UserID
and  LastStarted.ModuleID = CurrentStatus.ModuleID
and CurrentStatus.LessonStatusID in (2,3)
where LastStarted.LessonStatusID = 2
and LastStarted.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
group by LastStarted.UserID, LastStarted.moduleID
) lss
inner join tblUserLessonStatus uls
on uls.UserLessonStatusID = lss.LastStartedStatusID
inner join (SELECT tU.UserID, tM.ModuleID, CASE WHEN (ur.LessonFrequency IS NULL AND ur.LessonCompletionDate IS NULL AND o.DefaultLessonCompletionDate IS NULL)
THEN o.DefaultLessonFrequency ELSE ur.LessonFrequency END AS LessonFrequency, CASE WHEN (ur.LessonFrequency IS NULL AND
ur.LessonCompletionDate IS NULL AND NOT (o.DefaultLessonCompletionDate IS NULL))
THEN o.DefaultLessonCompletionDate ELSE ur.LessonCompletionDate END AS LessonCompletionDate
FROM  dbo.tblUser AS tU INNER JOIN
dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID AND tOCA.OrganisationID = @OrgID INNER JOIN
dbo.tblOrganisation AS o ON o.OrganisationID = tOCA.OrganisationID INNER JOIN
dbo.tblUnit AS u ON u.OrganisationID = tU.OrganisationID and u.UnitID = tU.UnitID INNER JOIN
dbo.tblModule AS tM ON tM.Active = 1 AND tOCA.GrantedCourseID = tM.CourseID LEFT OUTER JOIN
dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitRule AS ur ON ur.ModuleID = tM.ModuleID AND ur.UnitID = tU.UnitID
WHERE (tU.Active = 1) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
(tUsrMA.Granted = 1)) cam
on cam.UserID = uls.UserID
and cam.ModuleID = uls.ModuleID
where
(
cam.LessonCompletionDate is null
and DateDiff(day,getutcdate(), dateadd(month, cam.LessonFrequency, uls.DateCreated)) <= 0
)
or
(
isnull(DateDiff(day, getutcdate(), cam.LessonCompletionDate), 1) <= 0
)
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
--Expired





--##################################################################################################################
-- Extend completion dates
update tblOrganisation
set DefaultLessonCompletionDate = dateadd(year, 1, [DefaultLessonCompletionDate])
where DefaultLessonCompletionDate < getutcdate() and OrganisationID = @OrgID

--##################################################################################################################
update tblUnitRule
set LessonCompletionDate = dateadd(year, 1, [LessonCompletionDate])
where LessonCompletionDate < getutcdate() and UnitID IN (select UnitID from tblUnit where OrganisationID = @OrgID)
-- /Extend completion dates
--##################################################################################################################




SET QUOTED_IDENTIFIER ON
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserLessonStatus_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE Procedure [prcUserLessonStatus_Update]
AS
Set Nocount On


declare @cursor_OrgID	    int

DECLARE OrgList CURSOR
FOR
SELECT OrganisationID from tblOrganisation order by OrganisationID desc

Open OrgList

FETCH NEXT FROM OrgList
Into
@cursor_OrgID

WHILE @@FETCH_STATUS = 0
BEGIN

exec prcUserLessonStatus_Update_Quick @cursor_OrgID

FETCH NEXT FROM OrgList Into @cursor_OrgID
END

CLOSE OrgList
DEALLOCATE OrgList


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Login]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Authenticate user
Password and user status will be checked in the application
Returns:
UserID, User Password, status, UserType, OrgID

Called By: Login.ascx
Calls:

Remarks:
User Password and status are used to authenticate used in the application
UserID, UserType, OrgID, OrgLogo are used as user context. these values will be saved in the form authentication ticket

Author:
Jack Liu
Date Created: 27 Jan 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Jack Liu	14/09/2005		Add domain Name to the organisation
The domain Name is unique to each organisation
if the user name can''t be found in that organisation, search if that user is a salt administrator
prcUser_Login ''Jack'', ''Organisation1.salt.devbdw.com''

prcUser_Login ''SaltAdmin'', ''Organisation1.salt.devbdw.com''


**/

CREATE  PROC [prcUser_Login]
(
@userName  nVARCHAR(50),
@domainName nvarchar(100)
)

AS

set nocount on
if exists (select 1
from tblUser u
inner join tblOrganisation o on u.OrganisationID = o.OrganisationID and o.domainName = @domainName
where (u.username=@userName)
)
begin
select top 1
u.UserID,
u.UserTypeID,
u.Password,
u.Active,
u.OrganisationID,
u.LoginFailCount,
o.Logo,
o.AdvancedReporting,
o.PasswordLockout
from tblUser u
inner join tblOrganisation o on u.OrganisationID = o.OrganisationID and o.domainName = @domainName
where (u.username=@userName)
end
else
begin
select top 1
u.UserID,
u.UserTypeID,
u.Password,
u.Active,
u.OrganisationID,
u.LoginFailCount,
o.Logo,
o.AdvancedReporting,
o.PasswordLockout
from tblUser u
left join tblOrganisation o on u.OrganisationID = o.OrganisationID
where (u.username=@userName) and (u.UserTypeID=1)
end

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetTimeZoneBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


CREATE Procedure [prcUser_GetTimeZoneBySessionID]
(
@SessionID varchar(50) 		-- Session ID of the user we are looking for.
)

As

Set NoCount On

-- Declarations
Declare @userID Integer

-- Validation
If (@SessionID Is Null)
Begin
Raiserror(''The Parameter @SessionID was null.  @SessionID does not accept Null values.'', 16, 1)
Return
End

-- Logic
Set @userID= dbo.udfGetUserIDBySessionID(@SessionID)


Select
coalesce(USR.TimeZoneID,ORG.TimeZoneID) as TimeZone
From
tblOrganisation ORG
inner join tblUser USR on ORG.OrganisationID = USR.OrganisationID
inner join tblLessonSession LS on LS.UserID = USR.UserID
WHERE LessonSessionID = ltrim(rtrim(@sessionID))



Select
@UserID as ''UserID''


' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_AssignUnit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Updates a Users Unit, if no user is specified then it updates all unassigned users
to be members of the specified unit. This function does not ever update Salt Admin Type users

Parameters:
@userID		(Optional)
@unitID 		(Mandatory)
@updatedByUserID	(Mandatory)
@organisationID		(Mandatory)

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
User.cs.

Calls:
Nothing

Assumptions:
None

Logic:
Updates the user and includes them in the appropriate unit


Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
7. IntegrityConstraintException
10. BusinessServiceException (General)


Author: Peter Kneale
Date Created: 23 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Peter Kneale	27/2			Added Organisation ID parameter

**/
CREATE  Procedure [prcUser_AssignUnit]
(
@userID 		Integer = Null,		-- User ID that should be assigned to the unit
@unitID 		Integer = Null,		-- Unit ID that the user should be assigned to
@updatedByUserID 	Integer = Null,		-- UserID of the user performing the update
@organisationID		Integer = Null		-- Organisation ID that the user is to be assigned to.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) 		-- Holds the error message
Declare @intErrorNumber Integer 		-- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0


-- PARAMETER VALIDATION
--==============================================================

--Validate Parameter @unitID
If(@unitID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @unitID in stored procedure prcUser_UpdateUnit''
Goto Finalise
End

--Validate Parameter @updatedByUserID
If(@updatedByUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @updatedByUserID in stored procedure prcUser_UpdateUnit''
Goto Finalise
End

--Validate Parameter @organisationID
If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure prcUser_UpdateUnit''
Goto Finalise
End

-- Validate User Exists
--=========================================================
If Not (@userID is null)
Begin
If Not Exists(Select * From tblUser Where UserID = @userID)
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This user record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''
Goto Finalise
End
End
-- Validate Updated By User ID Exists
--=========================================================
If Not Exists(Select * From tblUser Where UserID = @updatedByUserID)
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This user record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''
Goto Finalise
End

-- Validate Organisation ID Exists
--=========================================================
If Not Exists(Select * From tblOrganisation Where OrganisationID = @organisationID)
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This user record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''
Goto Finalise
End

-- Validate Unit Exists
--=========================================================
If Not Exists(Select * From tblUnit Where UnitID = @unitID and Active=1)
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This unit record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''
Goto Finalise
End

If (@userID is null)
Begin
-- Update All Unassigned Active Users
--=======================
Update
tblUser
Set
UnitID = @unitID,
DateUpdated=getutcDate(),
UpdatedBy=@updatedByUserID
Where
UnitID = null
And Active = 1
And UserTypeID <> 1
And OrganisationID = @organisationID
End
Else
Begin
-- Update  a Single User
--=======================
Update
tblUser
Set
UnitID = @unitID,
DateUpdated=getutcDate(),
UpdatedBy=@updatedByUserID
Where
UserID = @userID
And OrganisationID = @organisationID
End




-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Updated''

-- Finalise the procedure
Goto Finalise


Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_UsernameSearch]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
The procedure will search within the selected Parent Units for those Users whose name contains the entered first and last names.
(If no Parent Units have been selected, the system will search across the whole organisation.)

Returns:
Unit Name
Full pathway

Called By:
Calls:

Remarks:
The searching units will include all children and grandchildren
Only return users that logged on user has permission to see


Author: Gavin Buddis
Date Created: 2 Mar 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Li Zhang	4/4/2006		Added search on username function
#2	VDL			26 Sep 2008		Add Search on email field / add boolean logic for include inactive users


**/

CREATE  Procedure  [prcUser_UsernameSearch]
(
@organisationID  Int,
@parentUnitIDs  Varchar(500),
@firstName	nVarchar(100),
@lastName	nVarchar(100),
@userName   nVarchar(200),
@userEmail	nvarchar(300),
@adminUserID		Int,
@includeInactiveUsers bit
)
As
Set Nocount On

Declare @intUserTypeID Int

Select @intUserTypeID = UserTypeID
From tblUser
Where userID = @adminUserID

--Check Data
If @parentUnitIDs is null
set @parentUnitIDs =''''

If @firstName is null
Set @firstName = ''''

Set @firstName =rtrim(@firstName)

If @lastName is null
Set @lastName = ''''

Set @lastName =rtrim(@lastName)

If @userName is null
Set @userName = ''''

Set @userName = rtrim(@userName)

if @userEmail is null
Set @userEmail =''''

Select
us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(us.LastLogin as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active

From tbluser us
join tblunit un on us.unitid = un.unitid

Where (us.OrganisationID = @organisationID)
and
(
us.Active= case when @includeInactiveUsers=0 then 1 else us.active end
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
and (
un.UnitID in
(
Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
)
or (@parentUnitIDs='''')
)
--2. User firstname contains the entered text
and (
(us.firstname like ''%''+ @firstName + ''%'')
or (us.firstname ='''')
)
--3. User lastname contains the entered text
and (
(us.lastname like ''%''+ @lastName + ''%'')
or (us.lastname ='''')
)
--4. User username contains the entered text
and (
(us.UserName like ''%'' + @userName + ''%'')
or (us.UserName ='''')
)
--4.5 User Email Address is the entered text
and (
(us.email like ''%'' + @userEmail + ''%'')
or (@useremail ='''')
)
--5. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
Order By Name

' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Search]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
The procedure will search within the selected Parent Units for those Users whose name contains the entered first and last names.
(If no Parent Units have been selected, the system will search across the whole organisation.)

Returns:
Unit Name
Full pathway

Called By:
Calls:

Remarks:
The searching units will include all children and grandchildren
Only return users that logged on user has permission to see


Author: Gavin Buddis
Date Created: 2 Mar 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Aaron		27/03/2007		@parentUnitIDs modified from Varchar(500)


**/

CREATE  Procedure  [prcUser_Search]
(
@organisationID  Int,
@parentUnitIDs  Varchar(8000),
@firstName	nVarchar(100),
@lastName	nVarchar(100),
@adminUserID		Int,
@includeInactiveUsers bit
)
As
Set Nocount On

Declare @intUserTypeID Int

Select @intUserTypeID = UserTypeID
From tblUser
Where userID = @adminUserID

--Check Data
If @parentUnitIDs is null
set @parentUnitIDs =''''

If @firstName is null
Set @firstName = ''''

Set @firstName =rtrim(@firstName)

If @lastName is null
Set @lastName = ''''

Set @lastName =rtrim(@lastName)



if (@includeInactiveUsers = 0)
Begin
Select
us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(us.LastLogin as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active

From tblUnit un, tblUser us

Where (un.OrganisationID = @organisationID)
and
(
us.Active=1
)
--0. Join Unit and User tables
and (
un.UnitID = us.UnitID
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
and (
un.UnitID in
(
Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
)
or (@parentUnitIDs='''')
)
--2. User firstname contains the entered text
and (
(firstname like ''%''+ @firstName + ''%'')
or (firstname ='''')
)
--3. User lastname contains the entered text
and (
(lastname like ''%''+ @lastName + ''%'')
or (lastname ='''')
)
--4. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
Order By Name
End
Else
Begin
Select 	us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(us.LastLogin as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active

From tblUnit un, tblUser us

Where (un.OrganisationID = @organisationID)
--0. Join Unit and User tables
and (
un.UnitID = us.UnitID
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
and (
un.UnitID in
(
Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
)
or (@parentUnitIDs='''')
)
--2. User firstname contains the entered text
and (
(firstname like ''%''+ @firstName + ''%'')
or (firstname ='''')
)
--3. User lastname contains the entered text
and (
(lastname like ''%''+ @lastName + ''%'')
or (lastname ='''')
)
--4. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
Order By Name
End
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetEmailAddress]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Gets a list of email addresses when passed a csv list of userid''s

Parameters:
@userIDs (mandatory)

Returns:
1, James@home.com
23, Bob@home.com.au
97, Harry@home.com

order by userID, Email

Called By:
Report.cs

Calls:
udfCsvToInt

Remarks:



Author:Peter Kneale
Date Created: 27 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



--------------------

**/


CREATE Proc [prcUser_GetEmailAddress]
(
@userIDs varchar(8000)		-- CSV list of user IDs that email addresses of are needed
)

As

Select
FirstName,
LastName,
UserID,
Email
From
tblUser
Where
userID in
(
Select
*
From
udfCsvToInt (@userIDs) 	-- Convert csv list of user id''s into rows
)
and active = 1
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_ClassificationUpdate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'




/*Summary:
Updates a Users Classification details

Parameters:
@userID				(Mandatory)
@values				(Mandatory)

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
User.cs.

Calls:
Nothing


Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
7. IntegrityConstraintException
10. BusinessServiceException (General)

Assumptions:
Requires function udfCsvToInt

Author: John Crawford
Date Created: 18 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	John C		26-Feb-2004		Converted to user udfCsvToInt

**/
CREATE   Procedure [prcUser_ClassificationUpdate]
(
@userID Integer = Null,
@values nvarchar(4000) = Null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number


-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

-- PARAMETER VALIDATION
--==============================================================

--Validate Parameter @userID
If(@userID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcUser_Update''
Goto Finalise
End

-- Validate User Exists
--=========================================================
If Not Exists(Select * From tblUser Where UserID = @userID)
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''
Goto Finalise
End


-- Delete existing userclassifications
--====================================
Delete
From
tblUserClassification
Where
UserID = @userID


-- insert into the database
--===================================================
insert into tblUserClassification
(UserID,
ClassificationID
)
select @UserID,
c.ClassificationID
From tblClassification c
left join dbo.udfCsvToInt(@values) as  csv
on csv.IntValue=c.ClassificationID
where c.ClassificationID = csv.IntValue
and c.Active = 1


-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Updated''

-- Finalise the procedure
Goto Finalise


Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End





' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUSER_ArchiveUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		File:
**		Name: Stored_Procedure_Name
**		Desc: Uses user defined function to return full unit path
**
**		This template can be customized:
**
**		Return values:
**
**		Called by:
**
**		Parameters:
**		Input							Output
**     ----------							-----------
**
**		Auth: Li Zhang
**		Date: July 2008
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		--------		--------				-------------------------------------------
**
*******************************************************************************/
CREATE PROCEDURE [prcUSER_ArchiveUsers]
(@userIDs varchar(1000),
@updatedBy int)
AS

UPDATE tblUser set Active = ''False'', DateArchived = getutcdate(), updatedBy = @updatedBy,
DateUpdated = getutcdate() WHERE UserID in ( SELECT * FROM dbo.udfCsvToInt(@userIDs))
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_Search]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
The procedure will search within the selected Parent Units for those Units whose name contains the entered text.
(If not Parent Units have been selected, the system will search across the whole organisation.)

Returns:
Unit Name
Full pathway


Called By:
Calls:

Remarks:
The searching units will include all children and grandchildren
Only return units that user has permission to see


Author: Jack Liu
Date Created: 9 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Aaron		27/03/2007		@parentUnitIDs type modified from Varchar(500)



prcUnit_Search 3,'''',''unit'''' '',4

**/

CREATE  PROCEDURE [prcUnit_Search]
(

@organisationID  int,
@parentUnitIDs  varchar(8000),
@unitName	nvarchar(100),
@userID		int,
@includingInactiveUnits bit = 0
)
as
set nocount on

declare @intUserTypeID int

select @intUserTypeID = UserTypeID
from tblUser
where userID = @userID

--Check Data
if @parentUnitIDs is null
set @parentUnitIDs =''''

if @unitName is null
set @unitName = ''''

set @unitName =rtrim(@unitName)

-- Return all units even those that are inactive
if (@includingInactiveUnits = 1)
Begin

select 	u.UnitID,
case
when u.Active=1 then u.Name
else u.Name + ''(I)''
end as Name,
dbo.udfGetUnitPathway(u.UnitID) as Pathway
from tblUnit u
left join dbo.udfCsvToInt(@parentUnitIDs) as pu on u.UnitID=pu.intValue
where (u.OrganisationID = @organisationID)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
and (
pu.intValue is not null
or (@parentUnitIDs='''')
)
--2. Unit name contains the entered text
and (
(name like ''%''+ @unitName + ''%'')
or (name ='''')
)
--3. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (u.UnitID in (select UnitID from tblUnitAdministrator where UserID=@userID))
)
order by name
End
Else
Begin
-- Return only active units
select 	u.UnitID,
u.Name,
dbo.udfGetUnitPathway(u.UnitID) as Pathway
from tblUnit u
left join dbo.udfCsvToInt(@parentUnitIDs) as pu on u.UnitID=pu.intValue
where (u.OrganisationID = @organisationID)
-- Active Units Only
and
(u.Active = 1)
and (
pu.intValue is not null
or (@parentUnitIDs='''')
)
--2. Unit name contains the entered text
and (
(name like ''%''+ @unitName + ''%'')
or (name ='''')
)
--3. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (u.UnitID in (select UnitID from tblUnitAdministrator where UserID=@userID))
)
order by name
End



' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_UnitPath]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE Procedure [prcReport_UnitPath]
(
@OrganisationID int,
@IncludeInactiveUnits int,
@UnitIDs varchar(8000)
)
AS
begin
if @IncludeInactiveUnits = 1
BEGIN
select

UnitID ,
dbo.udfGetUnitPathway(tblUnit.UnitID) as ''UnitPathway'',
dbo.udfGetUnitIDPathway(tblUnit.UnitID) as ''UnitIDPathway'',

CASE
WHEN Active = 0  THEN [Name] + '' (I)''
ELSE [Name]
END as [Name]



from

tblUnit

where

tblUnit.OrganisationID = @OrganisationID
and tblUnit.UnitID in (SELECT * FROM dbo.udfCsvToInt(@unitIDs) tU)


order by

dbo.udfGetUnitPathway(tblUnit.UnitID)
END
else
BEGIN
select

UnitID,

dbo.udfGetUnitPathway(tblUnit.UnitID) as ''UnitPathway'',

dbo.udfGetUnitIDPathway(tblUnit.UnitID) as ''UnitIDPathway'',

Name



from

tblUnit

where

tblUnit.OrganisationID = @OrganisationID
and tblUnit.UnitID in (SELECT * FROM dbo.udfCsvToInt(@unitIDs) tU)
and tblUnit.Active = 1

order by

dbo.udfGetUnitPathway(tblUnit.UnitID)
END
end
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_ProgressGrandTotal]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		Name: prcReport_ProgressGrandTotal
**		Desc: a cut down copy of prcreport_Progress, with select statements
**				altered to return a total, instead of a list of data.
**
**		Return values: Grand Total distinct users in Progress report
**
**		Auth: Mark Donald
**		Date: 11 Jan 2010
**
*******************************************************************************/

CREATE       Procedure [prcReport_ProgressGrandTotal]
(
@organisationID		int,
@unitIDs 		varchar(8000),
@courseIDs 		varchar(8000),
@includeInactive int,
@classificationID int
)
AS
SET NOCOUNT ON;
BEGIN
SELECT
count(DISTINCT u.userid) TotalDistinctUsers
FROM
tblusercoursestatus s
INNER JOIN tblcourse c ON
c.courseid = s.courseid
AND c.courseid IN (SELECT IntValue FROM dbo.udfCsvToInt(@courseIDs))
INNER JOIN tbluser u ON
u.userid = s.userid
AND u.unitid IN (SELECT IntValue FROM dbo.udfCsvToInt(@unitIDs))
LEFT JOIN tbluserclassification g ON
g.userid = u.userid
WHERE
u.organisationid = @organisationID
AND (@includeInactive = 1 OR u.active = 1)
AND (@classificationID = 0 OR classificationID = @classificationID)
END

' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_UserSearch]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Returns results of search for users on Assign Users tab of CPDdetail.aspx

Returns:

Called By:

Calls:

Remarks:
The searching units will include all children and grandchildren
Only return users that logged on user has permission to see


Author: Aaron Cripps
Date Created: Feb 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

CREATE  Procedure  [prcPolicy_UserSearch]
(
@organisationID  Int,
@PolicyID int,
@parentUnitIDs  Varchar(8000),
@firstName	nVarchar(50),
@lastName	nVarchar(50),
@userName	nVarChar(100),
@Email		nVarChar(100),
@ExternalID nVarChar(50),
@adminUserID		Int,
@Type nvarchar(50)
)
As
Set Nocount On

Declare @intUserTypeID Int

Select @intUserTypeID = UserTypeID
From tblUser
Where userID = @adminUserID



--Check Data
If @parentUnitIDs is null
set @parentUnitIDs =''''

If @firstName is null
Set @firstName = ''''

Set @firstName =rtrim(@firstName)

If @lastName is null
Set @lastName = ''''

Set @lastName =rtrim(@lastName)

If @userName is null
Set @userName = ''''

set @userName = rtrim(@userName)

if @Email is null
set @Email = ''''

set @Email = rtrim(@Email)

if @ExternalID is null
set @ExternalID = ''''

set @ExternalID = rtrim(@ExternalID)

if @Type = ''search''
Begin
Select
us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(us.LastLogin as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active,
upa.Granted

From tblUnit un, tblUser us, tblUserPolicyAccess upa

Where (un.OrganisationID = @organisationID)
and
(
us.Active=1
)
--0. Join Unit and User tables
and (
un.UnitID = us.UnitID
)
-- Join User and UserProfilePeriodAccess tables
and (
us.UserID = upa.UserID
)
and (
upa.PolicyID = @PolicyID
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
and (
un.UnitID in
(
Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
)
or (@parentUnitIDs='''')
)
--2. User firstname contains the entered text
and (
(firstname like ''%''+ @firstName + ''%'')
or (firstname ='''')
)
--3. User lastname contains the entered text
and (
(lastname like ''%''+ @lastName + ''%'')
or (lastname ='''')
)
-- User username contains the entered text
and (
(username like ''%'' + @userName + ''%'')
or (userName='''')
)
-- User email contains the entered text
and (
(email like ''%'' + @Email + ''%'')
or (email='''') or (email = null)
)
-- User externalid contains the entered text
and (
(externalID like ''%'' + @ExternalID + ''%'')
or (externalID = '''') or (externalid = null)
)
--4. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
Order By Name
End
else if @Type = ''view''
Begin
Select
us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(us.LastLogin as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active,
upa.Granted

From tblUnit un, tblUser us, tblUserPolicyAccess upa

Where (un.OrganisationID = @organisationID)
and
(
us.Active=1
)
--0. Join Unit and User tables
and (
un.UnitID = us.UnitID
)
-- Join User and UserProfilePeriodAccess tables
and (
us.UserID = upa.UserID
)
and (
upa.PolicyID = @PolicyID
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
--and (
--un.UnitID in
--	(
--		Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
--	)
--	or (@parentUnitIDs='''')
--	)
--2. User firstname contains the entered text
--and (
--	(firstname like ''%''+ @firstName + ''%'')
--	or (firstname ='''')
--    )
--3. User lastname contains the entered text
--and (
--	(lastname like ''%''+ @lastName + ''%'')
--	or (lastname ='''')
--    )
-- User username contains the entered text
--and (
--	(username like ''%'' + @userName + ''%'')
--	or (userName='''')
--	)
-- User email contains the entered text
--and (
--	(email like ''%'' + @Email + ''%'')
--	or (email='''') or (email = null)
--	)
-- User externalid contains the entered text
--and (
--	(externalID like ''%'' + @ExternalID + ''%'' )
--	or (externalID = '''') or (externalid = null)
--	)
--4. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
and upa.Granted=1
Order By Name
End

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_InitialiseProfilePeriodAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s Granted value in tblUnitProfilePeriod and tblUserProfilePeriod when
the Profile is intitially created

Parameters:
@organisationID Integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE    Procedure [prcOrganisation_InitialiseProfilePeriodAccess]
(
@organisationID Integer,
@ProfileID Integer,
@ProfilePeriodID Integer
)

As

Set NoCount On

-- Get all units for this organisation
create table #OrgUnits
(
UnitID int
)

insert into #OrgUnits
select
unitid
from
tblUnit
where
OrganisationID = @OrganisationID
and active = 1
-- Insert all unitid''s into tblUnitProfilePeriodAccess with
-- initial granted value of 0 (not granted)

Insert into tblUnitProfilePeriodAccess
select @ProfilePeriodID, UnitID, 0 from #OrgUnits


drop table #OrgUnits

-- Get all users for this organisation
create table #OrgUsers
(
UserID int
)

insert into #OrgUsers
Select
UserID
From
tblUser
Where
OrganisationID = @organisationID
--	And UnitID Is Not Null
--	And Active = 1

-- Insert all userid''s into tblUserProfilePeriodAccess with
-- initial granted value of 0 (not granted)
Insert into tblUserProfilePeriodAccess
select @ProfilePeriodID, UserID, 0 from #OrgUsers

drop table #OrgUsers

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_InitialisePolicyAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s Granted value in tblUnitPolicyAccess and tblUserPolicyAccess when
the Policy is intitially created

Parameters:
@organisationID Integer	,
@PolicyID Integer

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: Feb 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE    Procedure [prcOrganisation_InitialisePolicyAccess]
(
@organisationID Integer,
@PolicyID Integer,
@granted bit
)

As

Set NoCount On

-- Get all units for this organisation
create table #OrgUnits
(
UnitID int
)

insert into #OrgUnits
select
unitid
from
tblUnit
where
OrganisationID = @OrganisationID
and active = 1
-- Insert all unitid''s into tblUnitProfilePeriodAccess with
-- initial granted value of 0 (not granted)

Insert into tblUnitPolicyAccess
select @PolicyID, UnitID, @granted from #OrgUnits
where unitid not in
(select unitid from tblUnitPolicyAccess where Unitid in
(select unitid from tblUnit where organisationid = @organisationid)
and policyid = @policyid)


drop table #OrgUnits

-- Get all users for this organisation
create table #OrgUsers
(
UserID int
)

insert into #OrgUsers
Select
UserID
From
tblUser
Where
OrganisationID = @organisationID



-- Insert all userid''s not already added into tblUserProfilePeriodAccess
Insert into tblUserPolicyAccess
select @PolicyID, UserID, @granted from #OrgUsers
where userid not in
(select userid from tblUserPolicyAccess where userid in
(select userid from tblUser where organisationid = @organisationid)
and policyid = @policyid)


-- update any users that were already existing
update tblUserPolicyAccess
set granted = @granted
where policyid = @policyid
and userid in (select userid from tbluser where organisationid = @organisationid)

drop table #OrgUsers

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_IndividualDetails]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfReport_IndividualDetails    Script Date: 20/04/2004 8:25:58 AM ******/



/*Summary:
Given a users ID this udfReport_IndividualDetails Gets Details for home page and individual report
Returns:
ordered table of distinct PageID''s

Called By:
dbo.prcReport_Individual
dbo.prcModule_GetDetailsForHomePage
Calls:
dbo.vwUserQuizStatus
dbo.udfGetLessonStatus
dbo.vwUserModuleAccess
Remarks:
1. This udf required that the schema of the underlying views does not change

Author:
Stephen Kennedy-Clark
Date Created: 17 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#3.0.25 Aaron Cripps	08/05/2007		Replace vwUserCourseStatus with a select statement that filters on UserID parameter passed into the function to reduce the number of rows returned (and the time taken to retrieve rows)


--------------------


**/
CREATE function [udfReport_IndividualDetails]
(
@userID  int = null     -- ID of this User
)
------------------------------------------
Returns table
as

Return
select
vUMA.UserID		as ''UserID''
, vUMA.CourseID		as ''CourseID''
, vUMA.CourseName 	as ''CourseName''
, vUMA.ModuleID		as ''ModuleID''
, vUMA.[Name] 		as ''ModuleName''
, tL.LessonID	  	as ''LessonID''
, isNull(dbo.udfGetLessonStatus(vUMA.ModuleID,vUMA.UserID), 1) as ''LessonStatus''  -- n^2 complexety :-(
, isNull(vUQS.QuizStatusID, 1)   as ''QuizStatus''
, vUQS.QuizScore	as ''QuizScore''
, vUQS.QuizPassMark	as ''QuizPassMark''
, replace(replace( tL.ToolbookLocation,''ie4/index.html'',''qfs.html''),''default.aspx'',''QFS.html'') as ''QFSPath''
--, SUBSTRING(  tL.ToolbookLocation,0,(len(tL.ToolbookLocation)-12)  ) + ''/'' + ''QFS.html'' as ''QFSPath''
, vUMA.Sequence		as ''Sequence''
from
--< get the module access details for this user >--
vwUserModuleAccess vUMA
--< get the module access details for this user >--
left outer join tblLesson tL
on tL.ModuleID = vUMA.ModuleID
and tL.Active = 1
--< get the details of the latest quiz  >--
left outer join 
--< below replaces vwUserQuizStatus >--
(
SELECT      QuizStatus.UserID, QuizStatus.ModuleID, m.CourseID, QuizStatus.QuizStatusID, QuizStatus.QuizPassMark, QuizStatus.QuizScore
FROM         dbo.tblUserQuizStatus AS QuizStatus INNER JOIN
                      dbo.tblModule AS m ON m.ModuleID = QuizStatus.ModuleID INNER JOIN
                          (SELECT     MAX(UserQuizStatusID) AS UserQuizStatusID
                            FROM          dbo.tblUserQuizStatus where UserID = @UserID
                            GROUP BY UserID, ModuleID ) AS currentStatus ON QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
WHERE     (m.Active = 1)
)
--vwUserQuizStatus 
vUQS -- n^2 complexety :-(
on vUQS.UserID = vUMA.UserID
and vUQS.ModuleID = vUMA.ModuleID
Where
-- vUMA.CourseID = isnull(@courseID, vUMA.CourseID ) and
vUMA.UserID = isnull(@userID, vUMA.UserID)
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Individual]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Given a user id returns the list of courses / modules and the latest results for that user
If the User id is ommited it returns results for all users
Returns:
Course ID

Called By:
Home.aspx via Businessservices.Report.GetIndividualReport
Calls:
udfReport_IndividualDetails
Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Peter Kneale	8/3/04			Modified, removed two level tier report format



--------------------

**/

CREATE       Proc [prcReport_Individual]
(
@userID int = null -- the user ID
)
AS
------------------------------------------
Set Nocount On

Select

UserID
, CourseID
, CourseName
, ModuleID
, ModuleName
, LessonID
, tLS.Status as ''LessonStatus''
, tQS.Status as ''QuizStatus''
, QuizScore
, QuizPassMark
, [Sequence]

From
udfReport_IndividualDetails(@userID) tID
--< inner join onto lesson status to get the name of the status>--
inner join tblLessonStatus tLS
on tLS.LessonStatusID = tID.LessonStatus
inner join tblQuizStatus tQS
on tQS.QuizStatusID =  tID.QuizStatus

Order by userid, CourseID, [Sequence]
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_AddClassification]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary:
Adds a Classification for a Classification Type.

Parameters:
@name nVarChar(50)
@active Bit
@classificationTypeID Integer

Returns:
None

Called By:
Classification.cs

Calls:
None

Remarks:
Exception:
0. Succeed
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 19th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/
CREATE   Procedure [prcClassification_AddClassification]
(
@name nVarChar(50) = Null, -- Name of the Classification
@active Bit = 1, -- Status of the classification
@classificationTypeID Integer = Null -- ID of the Classification Type that you wish to get the Classification List For.
)

As

Set NoCount On

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage VarChar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @intErrorNumber = 0
Set @strErrorMessage = ''''

-- Validation Routines
If(@classificationTypeID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @classificationTypeID in stored procedure  prcClassification_AddClassification''
Goto Finalise
End

If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure  prcClassification_AddClassification''
Goto Finalise
End

If Exists(Select * From tblClassification Where Value = @name And ClassificationTypeID = @classificationTypeID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Classification Value '' + @name + '' already exists for this ClassificationType please choose another value for your ClassificationType.''
Goto Finalise
End

If(@active Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure  prcClassification_AddClassification''
Goto Finalise
End

Insert Into tblClassification
(
Value,
Active,
ClassificationTypeID
)
Values
(
@name,
@active,
@classificationTypeID
)

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End



' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_GetListAll]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Gets a list of all classifications for the specified classification type.

Parameters:
@classificationTypeID Integer

Returns:
ClassificationID
ClassificationTypeID
Value
Active

Called By:
Classification.cs

Calls:
None

Remarks:
None

Author: Peter Vranich
Date Created: 19th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcClassification_GetListAll]
(
@classificationTypeID Integer = Null -- ID of the Classification Type that you wish to get the Classification List For.
)

As

Set NoCount On

Select
ClassificationID,
ClassificationTypeID,
Value,
Active
From
tblClassification
Where
(ClassificationTypeID = @classificationTypeID)


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_GetList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*
Summary:
Gets a list of Classifications for the specified classification type.

Parameters:
OrganisationID

Returns:
ClassificationID
ClassificationTypeID
Value
Active

Called By:
Classification.cs

Calls:
None

Remarks:
None

Author: John Crawford
Date Created: 17th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE     Procedure [prcClassification_GetList]
(
@classificationTypeID Integer = Null -- ID of the classification type that you wish to get the classification list for.
)

As

Set NoCount On

Select
ClassificationID,
ClassificationTypeID,
Value,
Active
From
tblClassification
Where
((ClassificationTypeID = @classificationTypeID)
And (Active = 1))
Order By
Value Asc




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_Create]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Created a new Course.

Parameters:
@intCourseID
@name
@notes
@active
@userID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Course.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeeded
4. UniqueViolationException
5. ParameterException
10. BusinessServiceException (General)


Author: Gavin Buddis
Date Created: 17th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE   Procedure [prcCourse_Create]
(
@intCourseID Integer OutPut, -- The ID of the newly created course.
@name nVarchar(100) = Null,
@notes nVarchar(1000) = Null,
@active Bit = 1,
@userID Integer = Null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @name
If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure prcCourse_Create''
Goto Finalise
End

--Validate Parameter @showDisclaimer
If(@active Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure prcCourse_Create''
Goto Finalise
End

--Validate Parameter @userID
If(@userID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcCourse_Create''
Goto Finalise
End

If Not Exists(Select * From tblCourse Where Name = @name)
Begin
-- Insert the new record
Insert Into tblCourse
(
[Name],
Notes,
Active,
CreatedBy,
DateCreated,
UpdatedBy,
DateUpdated
)
Values
(
@name,
@notes,
@active,
@userID,
GetUTCDate(),
@userID,
GetUTCDate()
)

-- Set the error message to successfull
Set @intErrorNumber = 0
Select @intCourseID = @@Identity

-- Finalise the procedure
Goto Finalise
End
Else
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Course Name '' + @name + '' already exists please choose another Course Name.''

Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetNotes]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Given a Course id return the Course notes
Returns:
Course Notes

Called By: Home.aspx via BusinessServices.Course.GetNotes
Calls: null

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

--------------------
prcCourse_GetNotes @courseID=11

**/

CREATE  Proc [prcCourse_GetNotes]
(
@courseID int -- Course ID
)
AS
------------------------------------------
Set Nocount On
Select
Notes
From
tblCourse
Where
CourseID = @courseID





' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SaveModuleRule]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Populate the compliance rules to an individual module

Called By: Unit.cs
Calls: None

Remarks:

Author: Jack Liu
Date Created: 18th of February 2004


Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_SaveModuleRule 1, 1

*/

CREATE  Procedure [prcUnit_SaveModuleRule]
(
@unitID Int,
@moduleID int,
@usingDefault bit,
@lessonFrequency int,
@quizFrequency int,
@quizPassMark int,
@lessonCompletionDate datetime,
@quizCompletionDate datetime,
@adminUserID int,
@OrgID int
)

As

set nocount on

set @lessonCompletionDate = dbo.udfDaylightSavingTimeToUTC(@lessonCompletionDate, @OrgID)
set @quizCompletionDate = dbo.udfDaylightSavingTimeToUTC(@quizCompletionDate, @OrgID)

--1. If the module uses default rules, delete the existing individual rule
if (@usingDefault=1)
begin
Delete
from tblUnitRule
where UnitID=@unitID
and moduleID= @moduleID
end
--2. If the module contains individual rule, update the existing individual rule
else if exists(select ModuleID
from tblUnitRule
where UnitID=@unitID
and moduleID= @moduleID)
begin
Update tblUnitRule
set 	LessonFrequency = @LessonFrequency,
QuizFrequency = @QuizFrequency,
QuizPassMark = @QuizPassMark,
LessonCompletionDate = @lessonCompletionDate,
QuizCompletionDate = @quizCompletionDate,
UpdatedBy = @adminUserID,
DateUpdated =  GETUTCDATE()
where UnitID=@unitID
and moduleID= @moduleID

end
--3. If the module doesn''t contain any individual rule, add the new rule
else
begin
insert into tblUnitRule
(
UnitID,
ModuleID,
LessonFrequency,
QuizFrequency,
QuizPassMark,
LessonCompletionDate,
QuizCompletionDate,
CreatedBy,
DateCreated
)
values (
@unitID,
@moduleID,
@lessonFrequency,
@quizFrequency,
@quizPassMark,
@lessonCompletionDate,
@quizCompletionDate,
@adminUserID,
GETUTCDATE()
)

end





' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_CompleteUsersLogic]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfReport_CompleteUsersLogic    Script Date: 20/04/2004 8:25:58 AM ******/

/*Summary:
Selects User details for users that have not Completed their training

Parameters:
@organisationID Integer,
@unitIDs	string		(Mandatory)
@courseID	int		(Mandatory)
@effectiveDateOrg	datetime	(optional) (in Organisations Timezone)
Returns:


Called By:
prcReport_CompletedUsers

Calls:
fn dbo.udfGetUnitPathway( UnitID )
fn udfReport_incompleteUsers()
fn udfCsvToInt( csv )


Remarks:


Author: Stephen Kennedy-Clark
Date Created: 18 February 2004

Execution:


Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Jack Liu	27/02/2004 		Change the "in" criteria to left join, this will improve performance
Fix the unit id bug
#2	Stephen Clark	1/4/2004		change the function to use the underlying table
#3	Peter Kneale	7/4/2004		Added function for effective date style reports
#4	Liz Dionisio(UW)	8/11/2005		Added Username, Email and ExternalID to returned recordset
#5	Yoppy Suwanto	22/08/2007		Replace the udfGetUnitPathway function with the tblUnitHierarchy usage.  This will improve perfomance
#5	j hedlefs		09/06/2011		Timezone
**/
CREATE   function [udfReport_CompleteUsersLogic]
(
@organisationID Integer,	-- Organisation of the user running the report
@unitIDs Varchar(MAX),		-- string of unit id''s
@courseID Int, 			-- course ID to restrict search to
@effectiveDateOrg datetime = null	-- effective date of report in Org timezone
)

-------------------------------------------------------------------
Returns @tblReturn Table
(
UserID		Int,
UnitID		Int,
FirstName		nVarchar(255),
LastName 	nVarchar(255),
UnitPathway 	nVarchar(4000),
[Date]		Datetime,
Username	nvarchar(100),
Email		nvarchar(100),
ExternalID	nvarchar(50)
)

as
Begin --1
DECLARE @effectiveDate DateTime
SET @effectiveDate = dbo.udfDaylightSavingTimeToUTC(@effectiveDateOrg,@OrganisationID)

if (@unitIDs is null)
begin --2
----------------------------------------------------
--- Report on all units
----------------------------------------------------
if (@effectiveDate is null)
begin --4
----------------------------------------------------
--- Report on the current date
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
--, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, tUH.HierarchyName as ''UnitPathway''
, dbo.udfUTCtoDaylightSavingTime(vUCS.DateCreated,@OrganisationID) as ''Date''
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
FROM
tblUser tU1
inner join tblUnit
on tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join vwUserCourseStatus vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 2 --< only want completed users >--
and vUCS.CourseID = @courseID
inner join tblUnitHierarchy tUH
on tU1.UnitID = tUH.UnitID
end --/4
else
begin --5

----------------------------------------------------
--- Report on the historic date
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
--, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, tUH.HierarchyName as ''UnitPathway''
, dbo.udfUTCtoDaylightSavingTime(vUCS.DateCreated,@OrganisationID) as ''Date''
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
FROM
tblUser tU1
inner join tblUnit
on tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join  dbo.udfReport_HistoricUserCourseStatus(@effectiveDate) vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 2 --< only want completed users >--
and vUCS.CourseID = @courseID
inner join tblUnitHierarchy tUH
on tU1.UnitID = tUH.UnitID
end  --/5
end --/2
else
begin --3
----------------------------------------------------
--- Report on specified units
----------------------------------------------------
if (@effectiveDate is null)
Begin --6
----------------------------------------------------
--- Report on the current date
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
--, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, tUH.HierarchyName as ''UnitPathway''
, dbo.udfUTCtoDaylightSavingTime(vUCS.DateCreated,@OrganisationID) as ''Date''
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
FROM
tblUser tU1
inner join tblUnit on
tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join vwUserCourseStatus vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 2 --< only want completed users >--
and vUCS.CourseID = @courseID
inner join dbo.udfCsvToInt(@unitIDs) tU
on tU.IntValue = tblUnit.UnitID --< restrict units to thoes in the list >--
inner join tblUnitHierarchy tUH
on tU1.UnitID = tUH.UnitID
end  --/6
else
Begin  --7
----------------------------------------------------
--- Report on the historic date
----------------------------------------------------
Insert into
@tblReturn
SELECT
tU1.userID
, tU1.UnitID
, tU1.FirstName
, tU1.LastName
--, dbo.udfGetUnitPathway(tU1.UnitID) as ''UnitPathway''
, tUH.HierarchyName as ''UnitPathway''
, dbo.udfUTCtoDaylightSavingTime(vUCS.DateCreated,@OrganisationID) as ''Date''
, tU1.Username as ''Username''
, tU1.Email as ''Email''
, tU1.ExternalID as ''ExternalID''
FROM
tblUser tU1
inner join tblUnit
on tU1.UnitID = tblUnit.UnitID
and tblUnit.organisationID = @organisationID
and tU1.Active = 1 --< only want active users >--
and tu1.userTypeID <> 1 --< not interested in saltadmins >--
inner join  dbo.udfReport_HistoricUserCourseStatus(@effectiveDate) vUCS
on vUCS.UserID = tU1.userID
and vUCS.CourseStatusID = 2 --< only want completed users >--
and vUCS.CourseID = @courseID
inner join dbo.udfCsvToInt(@unitIDs) tU
on tU.IntValue = tblUnit.UnitID --< restrict units to thoes in the list >--
inner join tblUnitHierarchy tUH
on tU1.UnitID = tUH.UnitID
End  --/7
end --/3
return
end -- /1
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Summary]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
This Report provides a high level summary information.
It shows how many users in each unit are complete or incomplete in each course.
The results can be views as a bar graph

Called By:
SummaryReport in Reporting Services

Calls:
udfReport_CompletUsers_logic
udfReport_IncompletUsers_logic
Remarks:


Author:
Jack Liu
Date Created: 31 March 2005

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
Mark Donald	23/07/2009		Add @classificationID parameter and use it
to filter insert into #result table

prcReport_Summary 8, ''19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,84'' ,7, null

prcReport_Summary 8, ''19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,84'' ,7, ''20041130''

--------------------

**/

CREATE  Proc [prcReport_Summary]
(
@organisationID Integer,	-- Organisation of the current user
@unitIDs varchar(8000) = '''',	-- string of unit id''s
@courseID int,			-- course ID to restrict search to
@effectiveDateOrg datetime = Null,	-- Effective date as at when to run the report
@classificationID int
)

AS
------------------------------------------
Set Nocount On
DECLARE @effectiveDate 		datetime
SET @effectiveDate = dbo.udfDaylightSavingTimeToUTC(@effectiveDateOrg,@OrganisationID)
CREATE TABLE #result
(
UnitID		Int,
UnitPathway 	nVarchar(4000),
Complete	int,
Incomplete	int
)
declare @rowCount as integer

insert into #result
select
UnitID,
min(UnitPathway) as UnitPathway,
sum(Complete) as Complete,
sum(Incomplete) as Incomplete
from (Select
UnitID,
UnitPathWay,
1 as Complete,
0 as Incomplete,
UserID
From	dbo.udfReport_CompleteUsersLogic(@organisationID, @unitIDs, @courseID,@effectiveDate)
Union all
Select
UnitID,
UnitPathWay,
0 as Complete,
1 as Incomplete,
UserID
from  dbo.udfReport_IncompleteUsersLogic(@organisationID, @unitIDs, @courseID,@effectiveDate)
) as Users
LEFT JOIN tblUserClassification c ON c.UserID  = Users.UserID
WHERE
((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification
group by UnitID
Order By UnitPathway

set @rowCount=@@rowcount

if (@rowCount>1)
begin
insert into #result
select 0,
''Total'',
Sum(Complete),
Sum(Incomplete)
from #result

set @rowCount = @rowCount+1
end

select *,
@rowCount  as Count
from #result

drop table #result










' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOvernightJobGetNextPreprocessingOrg]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcOvernightJobGetNextPreprocessingOrg]

AS
BEGIN
IF (0 = (SELECT COUNT(*) FROM tblCounters))
begin
DECLARE @Org INT
SELECT @Org = OrganisationID  FROM tblOrganisation order by OrganisationID
INSERT tblCounters (OvernightJobCurrentOrg) VALUES (@Org )
end
DECLARE @MaxOrg INT
SELECT @MaxOrg = OrganisationID  FROM tblOrganisation order by OrganisationID
DECLARE @LastOrg INT
SELECT @LastOrg = COALESCE(OvernightJobCurrentOrg,1) FROM tblCounters
IF (@LastOrg = @MaxOrg)
BEGIN
SELECT @Org = OrganisationID  FROM tblOrganisation order by OrganisationID DESC
UPDATE tblCounters SET OvernightJobCurrentOrg = @Org
END
ELSE
BEGIN
SELECT @Org = OrganisationID  FROM tblOrganisation WHERE OrganisationID > @LastOrg order by OrganisationID DESC
UPDATE tblCounters SET OvernightJobCurrentOrg = @Org
END

SELECT @Org = COALESCE(OvernightJobCurrentOrg,1) FROM tblCounters
SELECT @org
RETURN @org
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOvernightJobPreprocessOneOrg]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE Procedure [prcOvernightJobPreprocessOneOrg]
AS
BEGIN


declare @cursor_OrgID	    int
-- get the next OrgID (prcOvernightJobGetNextPreprocessingOrg remembers the last OrgID to be preprocessed)
exec @cursor_OrgID = dbo.prcOvernightJobGetNextPreprocessingOrg

-- update the UserLessonStatus for this org (handles the administrative changes to modules assigned to students)
--(originally this appears to have been done by triggers but it appears that the triggers slowed the ASP.NET WebPage too much and were replaced by the overnight job)
exec prcUserLessonStatus_Update_NO_TRIGGER_CurrentStatus_Quick @cursor_OrgID



END' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_RemoveMessage]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcEmail_RemoveMessage]

@EmailQueueID int

AS
BEGIN

DELETE FROM tblEmailQueue WHERE EmailQueueID = @EmailQueueID
DELETE FROM tblEmailQueueLinkedResource WHERE EmailQueueID = @EmailQueueID
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_QueueMessage]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcEmail_QueueMessage]
-- Add the parameters for the stored procedure here
@organisationID int,
@AddressTo nvarchar(255),
@Subject nvarchar(255),
@Body nvarchar(max),
@AddressSender nvarchar(255),
@AddressFrom nvarchar(255),
@IsHTML bit,
@AddressBccs nvarchar(max)
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

DECLARE @TEMP datetime
DECLARE @QueuedTime datetime
SET @TEMP = DATEADD(YEAR,1,GETUTCDATE())
SET @QueuedTime = GETUTCDATE()
INSERT INTO tblEmailQueue
([organisationID]
,[AddressTo]
,[Subject]
,[Body]
,[QueuedTime]
,[SendStarted]
,[AddressSender]
,[AddressFrom]
,[IsHTML]
,[AddressBccs])
VALUES
(@organisationID,
@AddressTo,
@Subject,
@Body,
@QueuedTime,
@TEMP,
@AddressSender,
@AddressFrom,
@IsHTML,
@AddressBccs)


SELECT EmailQueueID from tblEmailQueue
WHERE
[organisationID] = @organisationID
AND	[AddressTo] = @AddressTo
AND [Subject]  = @Subject
AND [Body] = @Body
AND [QueuedTime] = @QueuedTime
AND [SendStarted] = @TEMP
AND [AddressSender] = @AddressSender
AND [AddressFrom] = @AddressFrom
AND [IsHTML] = @IsHTML
AND [AddressBccs] = @AddressBccs
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_QueuedMessageAttachments]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcEmail_QueuedMessageAttachments]

@EmailQueueID bigint,
@ContentID nvarchar(100),
@Content varbinary(max)
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;


INSERT INTO tblEmailQueueLinkedResource
([EmailQueueID]
,[ContentID]
,[ByteStream])
VALUES
(@EmailQueueID
,@ContentID
,@Content)
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_Purge]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE procedure [prcEmail_Purge] as

begin

	INSERT INTO tblEmailPurged
		([ToEmail]
		,[ToName]
		,[FromEmail]
		,[FromName]
		,[CC]
		,[BCC]
		,[Subject]
		,[Body]
		,[DateCreated]
		,[OrganisationID])

	SELECT  
		case when ((CHARINDEX (''>'',AddressTo) > 0) and (CHARINDEX (''<'',AddressTo) > 0)) then SUBSTRING(AddressTo,CHARINDEX (''<'',AddressTo)+1,CHARINDEX (''>'',AddressTo)-CHARINDEX (''<'',AddressTo)-1) else AddressTo end
		,case when ((CHARINDEX (''>'',AddressTo) > 0) and (CHARINDEX (''<'',AddressTo) > 0)) then SUBSTRING(AddressTo,1,CHARINDEX (''<'',AddressTo)-1) else AddressTo end
		,case when ((CHARINDEX (''>'',AddressFrom) > 0) and (CHARINDEX (''<'',AddressFrom) > 0)) then SUBSTRING(AddressFrom,CHARINDEX (''<'',AddressFrom)+1,CHARINDEX (''>'',AddressFrom)-CHARINDEX (''<'',AddressFrom)-1) else AddressFrom end
		,case when ((CHARINDEX (''>'',AddressFrom) > 0) and (CHARINDEX (''<'',AddressFrom) > 0)) then SUBSTRING(AddressFrom,1,CHARINDEX (''<'',AddressFrom)-1) else AddressFrom end
		,''''
		,AddressBccs
		,Subject
		,Body
		,QueuedTime
		,tblEmailQueue.organisationID
	FROM 
		tblEmailQueue 
		
	DELETE FROM tblEmailQueue 
	
	
end

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_LogSentEmail]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE Procedure [prcEmail_LogSentEmail]
@toEmail	nvarchar(1000),
@toName	nvarchar(128),
@fromEmail	nvarchar(128),
@fromName	nvarchar(128),
@CC		nvarchar(1000) = '''',
@BCC 		nvarchar(1000) = '''',
@subject	nvarchar (256),
@body		ntext,
@organisationID	int
As

Insert Into
tblEmail
(
ToEmail,
ToName,
FromEmail,
FromName,
CC,
BCC,
Subject,
Body,
DateCreated,
OrganisationID
)

Values
(
@toEmail,
@toName,
@fromEmail,
@fromName,
@CC,
@BCC,
@subject,
@body,
GetUTCDate(),
@organisationID
)
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_GetNext]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcEmail_GetNext]
AS
BEGIN

  select
  tblEmailQueue.EmailQueueID
  into
  #tblEmailsToPurge
  FROM tblEmailQueue
  inner join tblOrganisation on tblOrganisation.OrganisationID = tblEmailQueue.organisationID  
  join tblAppConfig on name  = ''SEND_AUTO_EMAILS'' 
  where (tblOrganisation.StopEmails = 1 or upper(Value) = ''NO'')

  INSERT INTO tblEmailPurged
           ([ToEmail]
           ,[ToName]
           ,[FromEmail]
           ,[FromName]
           ,[CC]
           ,[BCC]
           ,[Subject]
           ,[Body]
           ,[DateCreated]
           ,[OrganisationID])
     
  SELECT  case when ((CHARINDEX (''>'',AddressTo) > 0) and (CHARINDEX (''<'',AddressTo) > 0)) then SUBSTRING(AddressTo,CHARINDEX (''<'',AddressTo)+1,CHARINDEX (''>'',AddressTo)-CHARINDEX (''<'',AddressTo)-1) else AddressTo end

      ,case when ((CHARINDEX (''>'',AddressTo) > 0) and (CHARINDEX (''<'',AddressTo) > 0)) then SUBSTRING(AddressTo,1,CHARINDEX (''<'',AddressTo)-1) else AddressTo end
	  ,case when ((CHARINDEX (''>'',AddressFrom) > 0) and (CHARINDEX (''<'',AddressFrom) > 0)) then SUBSTRING(AddressFrom,CHARINDEX (''<'',AddressFrom)+1,CHARINDEX (''>'',AddressFrom)-CHARINDEX (''<'',AddressFrom)-1) else AddressFrom end
      ,case when ((CHARINDEX (''>'',AddressFrom) > 0) and (CHARINDEX (''<'',AddressFrom) > 0)) then SUBSTRING(AddressFrom,1,CHARINDEX (''<'',AddressFrom)-1) else AddressFrom end
      ,''''
      ,AddressBccs
      ,Subject
      ,Body
      ,QueuedTime
      ,tblEmailQueue.organisationID
  FROM tblEmailQueue inner join
  #tblEmailsToPurge ON tblEmailQueue.EmailQueueID = #tblEmailsToPurge.EmailQueueID
  DELETE FROM tblEmailQueue WHERE EmailQueueID in (SELECT EmailQueueID FROM #tblEmailsToPurge) 

  DECLARE  @EmailQueueID INT
  SELECT @EmailQueueID = MIN (EmailQueueID)
  FROM tblEmailQueue
  WHERE ((SendStarted is NULL) OR (DATEADD(DAY,1,SendStarted) < GETUTCDATE()))
-- A SINGLE INSTANCE  WILL BE UPDATING THE TABLE SO DO NO MULTIUSER CODE
  SELECT TOP (1) EmailQueueID,OrganisationID,AddressTo,AddressBCCs,[Subject],body,AddressSender,AddressFrom,IsHTML,CASE WHEN DATEDIFF(d,QueuedTime,GETUTCDATE()) > 1 THEN 1 ELSE 0 END AS Retry
  FROM tblEmailQueue  WHERE @EmailQueueID =  EmailQueueID
  UPDATE tblEmailQueue SET SendStarted = GETUTCDATE()  WHERE @EmailQueueID =  EmailQueueID

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_GetAttachments]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcEmail_GetAttachments]
@EmailQueueID INT
AS
BEGIN
SELECT ContentID,ByteStream FROM tblEmailQueueLinkedResource WHERE EmailQueueID = @EmailQueueID


END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_EnableQueuedMessage]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcEmail_EnableQueuedMessage]

@EmailQueueID bigint
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

UPDATE tblEmailQueue
SET [SendStarted] = NULL
WHERE EmailQueueID = @EmailQueueID
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcDatabaseMail_SetupProfile]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE  Procedure [prcDatabaseMail_SetupProfile]

As

Set NoCount On

-- **** SETUP DATABASE MAIL ****

DECLARE @ProfileName VARCHAR(255)
DECLARE @AccountName VARCHAR(255)
DECLARE @SMTPAddress VARCHAR(255)
DECLARE @EmailAddress VARCHAR(128)
DECLARE @DisplayUser VARCHAR(128)
DECLARE @principal_sid varbinary(85)

SET @ProfileName = ''Salt_MailAccount'';
SET @AccountName = ''Salt_MailAccount'';
SELECT @SMTPAddress = Value FROM tblAppConfig WHERE Name = ''MailServer''
SELECT @EmailAddress = Value FROM tblAppConfig WHERE Name = ''FromEmail''
SELECT @DisplayUser = Value FROM tblAppConfig WHERE Name = ''FromName''

IF @EmailAddress IS NULL
SELECT @EmailAddress = Value FROM tblAppConfig WHERE Name = ''SupportEmail''

IF @DisplayUser IS NULL
SELECT @DisplayUser = Value FROM tblAppConfig WHERE Name = ''SupportEmail''

IF EXISTS (SELECT * FROM msdb.dbo.sysmail_account a WHERE a.name = @AccountName)
EXECUTE msdb.dbo.sysmail_update_account_sp
@account_name = @AccountName
,@email_address = @EmailAddress
,@display_name = @DisplayUser
,@mailserver_name = @SMTPAddress
ELSE
EXECUTE msdb.dbo.sysmail_add_account_sp
@account_name = @AccountName
,@email_address = @EmailAddress
,@display_name = @DisplayUser
,@mailserver_name = @SMTPAddress

IF NOT EXISTS (	SELECT *
FROM msdb.dbo.sysmail_profile p
WHERE p.name = @ProfileName
)
EXECUTE msdb.dbo.sysmail_add_profile_sp
@profile_name = @ProfileName

IF NOT EXISTS (	SELECT *
FROM msdb.dbo.sysmail_profileaccount pa
JOIN msdb.dbo.sysmail_profile p ON pa.profile_id = p.profile_id
JOIN msdb.dbo.sysmail_account a ON pa.account_id = a.account_id
WHERE p.name = @ProfileName AND a.name = @AccountName
)
EXECUTE msdb.dbo.sysmail_add_profileaccount_sp
@profile_name = @ProfileName
,@account_name = @AccountName
,@sequence_number = 1

SELECT @principal_sid = msdb.dbo.get_principal_sid(principal_id)
FROM msdb.sys.database_principals dp
WHERE dp.name = N''guest'' AND dp.type in (''U'',''S'',''G'')

IF NOT EXISTS (	SELECT *
FROM msdb.dbo.sysmail_principalprofile pp
JOIN msdb.dbo.sysmail_profile p ON pp.profile_id=p.profile_id
WHERE pp.principal_sid = @principal_sid AND p.name = @ProfileName
)
EXECUTE msdb.dbo.sysmail_add_principalprofile_sp
@principal_name=N''guest''
,@profile_name=@ProfileName
,@is_default=0
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_Calculate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/****** Object:  Stored Procedure dbo.prcUserCourseStatus_Calculate    Script Date: 7/04/2004 9:24:59 AM ******/



/****** Object:  Stored Procedure dbo.prcUserCourseStatus_Calculate    Script Date: 31/03/2004 10:47:32 AM ******/




/*Summary:
Returns the current course status for a user - course

Returns:
int CourseID

Called By:
trgUserQuizStatus
Calls:
trigger

Remarks:

QuizStatusID Status
------------ --------------------------------------------------
0            Unassigned
1            Not Started
2            Passed
3            Failed
4            Expired (Time Elapsed)
5            Expired (New Content)


CourseStatusID Status
-------------- --------------------------------------------------
0              Unassigned
1              InComplete
2              Complete

Author: Stepehn Clark
Date Created: 24 March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1 S K-Clark	7 March 2005	Access to a course but no modules in it is now considered for compliance as no access to the course
3.0.24 Li Zhang		09-02-2007		Avoid use the row count result of vwUserQuizStatus and vwUserModule in calculating the user course status

exec @intCurrentCourseStatus = prcUserCourseStatus_GetStatus @CourseID = @intCourseID, @UserID = @int@UserID
exec @intNewCourseStatus = prcUserCourseStatus_Calculate @CourseID = @intCourseID, @UserID = @intUserID

DECLARE @return_status int
EXEC @return_status = prcUserCourseStatus_Calculate @CourseID = 19, @userID = 1108
SELECT ''Return Status'' = @return_status


**/



CREATE       Procedure [prcUserCourseStatus_Calculate]
(
@CourseID int	-- The course ID
, @UserID int 	-- The user ID
)
AS
------------------------------------
Set Nocount On

--< if all the users results for this quiz are passed then the course is completed >--
Declare @intStatus int, -- Return Value
@intRowCount int

declare @tblUserQuizStatus table
(
ModuleID    int
, QuizStatusID int
, QuizFrequency int
, QuizPassMark int
, QuizScore   int
, DateCreated  smalldatetime
)

insert into
@tblUserQuizStatus
(
ModuleID
, QuizStatusID
, QuizFrequency
, QuizPassMark
, QuizScore
, DateCreated
)
select
vUQS.ModuleID
, vUQS.QuizStatusID
, vUQS.QuizFrequency
, vUQS.QuizPassMark
, vUQS.QuizScore
, vUQS.DateCreated

from
(
select
QuizStatus.UserQuizStatusID
, QuizStatus.UserID
, QuizStatus.ModuleID
, m.CourseID
, QuizStatus.QuizStatusID
, QuizStatus.QuizFrequency
, QuizStatus.QuizPassMark
, QuizStatus.QuizSessionID
, QuizStatus.QuizScore
, QuizStatus.DateCreated

from
tblUserQuizStatus QuizStatus
inner join tblModule m on m.ModuleID = QuizStatus.ModuleID AND m.CourseID = @CourseID
inner join
(
select
max(UserQuizStatusID) UserQuizStatusID --UserQuizStatusID is identity
from
tblUserQuizStatus
WHERE
tblUserQuizStatus.UserID = @userID
group by
UserID,moduleID
) currentStatus
on QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
where m.active = 1
) vUQS
inner join
(
Select
tU.UserID
, tU.FirstName
, tU.LastName
, tU.UnitID
, tU.OrganisationID
, tM.ModuleID
, tM.CourseID
, tC.Name ''CourseName''
, tM.Name
, tM.Sequence
, tM.Description
From
dbo.tblUser tU
--< get the courses a user has access to >--
Inner Join dbo.tblOrganisationCourseAccess tOCA
On  tOCA.OrganisationID = tU.OrganisationID
--< get the course details >--
Inner join dbo.tblCourse tC
On tC.CourseID = tOCA.GrantedCourseID
--< get the Active modules in a course >--
inner join dbo.tblModule tM
On tM.CourseID = tC.CourseID
and tM.Active = 1
--< get the details on which moduels a user is configured to access >--
Left Outer join dbo.tblUserModuleAccess tUsrMA
On  tUsrMA.UserID = tU.UserID
And tUsrMA.ModuleID = tM.ModuleID
--< get the details on which moduels a user''s Unit is excluded from  >--
Left Outer Join dbo.tblUnitModuleAccess tUnitMA
On  tUnitMA.UnitID = tU.UnitID
And tUnitMA.DeniedModuleID = tM.ModuleID
Where
tC.CourseID = @CourseID AND tU.UserID = @UserID 
--AND tU.Active = 1
--< Active users only >--
and tu.UnitID is not null
--< Get the modules that the user''s Unit is not denied >--
and (tUnitMA.DeniedModuleID  is null
--<  and the user does not have special access to  it>--
And tUsrMA.ModuleID is null)
--< or Get modules that the user has been specially  granted
or tUsrMA.Granted=1
) vUMA
on
vUQS.ModuleID = vUMA.ModuleID
and vUQS.CourseID = @CourseID
and vUQS.UserID = @userID
and vUMA.CourseID = @CourseID
and vUMA.UserID = @userID



-- get the rowcount
set @intRowCount = @@RowCount

-- if nothing was returned then there is something wrong (scheduled task has not been run ??)

if @intRowCount = 0
Begin --1
/***** this logic has been changed
Previoulsy:
If a person had access to a course but not to any modules
in the course then they still have access to the the course as far as compliance is concerned
Now:
If a person does not have access to any modules in a course then from the point of view of
compliance reporting they do not have access to the course
*/
return 0 -- unassigned ?
End --/1

-- if there are any results for anything other than passed then the course is incomplete
if exists (select ModuleID from @tblUserQuizStatus where QuizStatusID <> 2)
Begin --4
return  1 --Incomplete
End --/4

select * into #tblTemp from
(
Select
tU.UserID
, tU.FirstName
, tU.LastName
, tU.UnitID
, tU.OrganisationID
, tM.ModuleID
, tM.CourseID
, tC.Name ''CourseName''
, tM.Name
, tM.Sequence
, tM.Description
From
dbo.tblUser tU
--< get the courses a user has access to >--
Inner Join dbo.tblOrganisationCourseAccess tOCA
On  tOCA.OrganisationID = tU.OrganisationID
--< get the course details >--
Inner join dbo.tblCourse tC
On tC.CourseID = tOCA.GrantedCourseID
--< get the Active modules in a course >--
inner join dbo.tblModule tM
On tM.CourseID = tC.CourseID
and tM.Active = 1
--< get the details on which moduels a user is configured to access >--
Left Outer join dbo.tblUserModuleAccess tUsrMA
On  tUsrMA.UserID = tU.UserID
And tUsrMA.ModuleID = tM.ModuleID
--< get the details on which moduels a user''s Unit is excluded from  >--
Left Outer Join dbo.tblUnitModuleAccess tUnitMA
On  tUnitMA.UnitID = tU.UnitID
And tUnitMA.DeniedModuleID = tM.ModuleID
Where
tC.CourseID = @CourseID AND tU.UserID = @UserID 
-- AND tU.Active = 1
--< Active users only >--
and tu.UnitID is not null
--< Get the modules that the user''s Unit is not denied >--
and (tUnitMA.DeniedModuleID  is null
--<  and the user does not have special access to  it>--
And tUsrMA.ModuleID is null)
--< or Get modules that the user has been specially  granted
or tUsrMA.Granted=1
) as vwUserModuleAccess where userID = @UserID and courseID=@CourseID
SET @intRowCount = @@RowCount
--  all the quizes are passed then the course is complete
if  (select count(ModuleID) from @tblUserQuizStatus where QuizStatusID = 2) = @intRowCount
Begin --5
return 2 --Complete
End --/5
drop table #tblTemp

-- Code should never fall through to here, but just in case
return 1 -- Incomplete








' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_insert]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
Inserts a new line in the tblUserCourseStatus

Returns:
null

Called By:
trgUserQuizStatus
Calls:

Remarks:




Author: Stepehn Clark
Date Created: 24 March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	JH			07 Oct 2011		add error logging, allow updates to courses after all modules in those courses have been made inactive


**/
CREATE    procedure [prcUserCourseStatus_insert]
(
@UserID   int -- The User ID
, @ModuleID int -- The Module ID
, @StatusID int -- The Status ID Completed = 1 Incomplete = 0
)
As
------------------------

Declare @intCourse int,
@intInactiveCourse int
, @strModuleIDs varchar(200)
DECLARE @Err integer
IF @StatusID in (0,1) 
BEGIN 
	set @intCourse = (select top 1 CourseID from tblModule where ModuleID = @ModuleID and active = 1) --If no modules active don''t set status to "Not Started"
	if @intCourse is null
	begin
		--Raiserror (''error in prcUserCourseStatus_insert, module is inactive!'', 16, 1)
		--INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated]) VALUES(''prcUserCourseStatus_insert'',''prcUserCourseStatus_GetStatus'',''UserID=''+CAST(@UserID AS varchar(10)),''error - no active course!'',''ModuleID = ''+CAST(@ModuleID AS VARCHAR(10))+'', StatusID = ''+CAST(@StatusID AS VARCHAR(10)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) 
		return
	end
END
ELSE 
BEGIN
	set @intCourse = (select top 1 CourseID from tblModule where ModuleID = @ModuleID)   --Some quiz results but now all modules inactive so save the results
	if @intCourse is null
	begin
		Raiserror (''error in prcUserCourseStatus_insert, course does not exist!'', 16, 1)
		INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated]) VALUES(''prcUserCourseStatus_insert'',''prcUserCourseStatus_GetStatus'',''UserID=''+CAST(@UserID AS varchar(10)),''error - no active course!'',''ModuleID = ''+CAST(@ModuleID AS VARCHAR(10))+'', StatusID = ''+CAST(@StatusID AS VARCHAR(10)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) 
		return
	end
END
-------------------------------------------------------
--- Get the ModulesID''s as a comma seperated string
-------------------------------------------------------
set @strModuleIDs = '''' -- string to hold moduelids
select
@strModuleIDs = cast(ModuleID as varchar) + '','' + @strModuleIDs
from
(
Select
tU.UserID
, tU.FirstName
, tU.LastName
, tU.UnitID
, tU.OrganisationID
, tM.ModuleID
, tM.CourseID
, tC.Name ''CourseName''
, tM.Name
, tM.Sequence
, tM.Description
From
dbo.tblUser tU
--< get the courses a user has access to >--
Inner Join dbo.tblOrganisationCourseAccess tOCA
On  tOCA.OrganisationID = tU.OrganisationID
--< get the course details >--
Inner join dbo.tblCourse tC
On tC.CourseID = tOCA.GrantedCourseID
--< get the Active modules in a course >--
inner join dbo.tblModule tM
On tM.CourseID = tC.CourseID
and tM.Active = 1
--< get the details on which moduels a user is configured to access >--
Left Outer join dbo.tblUserModuleAccess tUsrMA
On  tUsrMA.UserID = tU.UserID
And tUsrMA.ModuleID = tM.ModuleID
--< get the details on which moduels a user''s Unit is excluded from  >--
Left Outer Join dbo.tblUnitModuleAccess tUnitMA
On  tUnitMA.UnitID = tU.UnitID
And tUnitMA.DeniedModuleID = tM.ModuleID
Where
tC.CourseID = @intCourse AND tU.UserID = @UserID AND
tU.Active = 1
--< Active users only >--
and tu.UnitID is not null
--< Get the modules that the user''s Unit is not denied >--
and (tUnitMA.DeniedModuleID  is null
--<  and the user does not have special access to  it>--
And tUsrMA.ModuleID is null)
--< or Get modules that the user has been specially  granted
or tUsrMA.Granted=1
) as tempTable
where
CourseID = @intCourse
and  UserID = @UserID
-------------------------------------------------------
--- insert the new values
-------------------------------------------------------

INSERT INTO
tblUserCourseStatus
(
UserID,
CourseID,
CourseStatusID,
ModulesAssigned,
DateCreated
)
VALUES
(
@UserID
, @intCourse
, @StatusID
, @strModuleIDs
, GETUTCDATE()
)
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserCourseStatus_insert'',''INSERT INTO tblUserCourseStatus'',''UserID=''+CAST(@UserID AS varchar(10)),''CourseID = ''+CAST(@intCourse AS VARCHAR(10)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) END




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_UpdateCourseStatus]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
for the record just in the tblUserQuizStatus:
-- get the old course status in tblUserCourseStatus
-- calculate the new course status
-- insert new course status into tblUserCourseStatus if old and new course status are different

called by:
prcUserQuizStatus_Update

Author: Li Zhang
Date Created: 24-10-2006
*/

CREATE PROCEDURE [prcUserQuizStatus_UpdateCourseStatus]
(
@UserID int
, @ModuleID int
)
AS
SET nocount ON
--SET xact_abort ON

DECLARE @intOldCourseStatus int
DECLARE @intNewCourseStatus int
DECLARE @intCourseID int

SET @intCourseID = (select CourseID from tblModule where ModuleID = @ModuleID)
DECLARE @Err integer
EXEC @intOldCourseStatus = prcUserCourseStatus_GetStatus @intCourseID, @UserID
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_UpdateCourseStatus'',''prcUserCourseStatus_GetStatus'',''UserID=''+CAST(@UserID AS varchar(10)),CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) END

IF @Err = 0 
BEGIN
	EXEC @intNewCourseStatus = prcUserCourseStatus_Calculate @intCourseID, @UserID
	SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_UpdateCourseStatus'',''prcUserCourseStatus_Calculate'',''UserID=''+CAST(@UserID AS varchar(10)),CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) END

	IF @Err = 0 
	BEGIN
		IF (@intOldCourseStatus = -1) or (@intOldCourseStatus <> @intNewCourseStatus)
		BEGIN
			EXEC prcUserCourseStatus_Insert @UserID, @ModuleID, @intNewCourseStatus
			SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_UpdateCourseStatus'',''prcUserCourseStatus_Insert'',''UserID=''+CAST(@UserID AS varchar(10)),CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) END

		END
		ELSE
		BEGIN
			IF NOT EXISTS (
			Select
			tU.UserID
			From
			dbo.tblUser tU
			--< get the courses a user has access to >--
			Inner Join dbo.tblOrganisationCourseAccess tOCA
			On  tOCA.OrganisationID = tU.OrganisationID
			--< get the course details >--
			Inner join dbo.tblCourse tC
			On tC.CourseID = tOCA.GrantedCourseID
			--< get the Active modules in a course >--
			inner join dbo.tblModule tM
			On tM.CourseID = tC.CourseID
			and tM.Active = 1
			--< get the details on which moduels a user is configured to access >--
			Left Outer join dbo.tblUserModuleAccess tUsrMA
			On  tUsrMA.UserID = tU.UserID
			And tUsrMA.ModuleID = tM.ModuleID
			--< get the details on which moduels a user''s Unit is excluded from  >--
			Left Outer Join dbo.tblUnitModuleAccess tUnitMA
			On  tUnitMA.UnitID = tU.UnitID
			And tUnitMA.DeniedModuleID = tM.ModuleID
			Where
			tC.CourseID = @intCourseID AND tU.UserID = @UserID AND
			tU.Active = 1
			--< Active users only >--
			and tu.UnitID is not null
			--< Get the modules that the user''s Unit is not denied >--
			and (tUnitMA.DeniedModuleID  is null
			--<  and the user does not have special access to  it>--
			And tUsrMA.ModuleID is null)
			--< or Get modules that the user has been specially  granted
			or tUsrMA.Granted=1
			)
			AND EXISTS (SELECT UserCourseStatusID FROM tblUserCourseStatus WHERE UserID = @UserID AND CourseID = @intCourseID AND CourseStatusID <> 0)
			BEGIN
				EXEC prcUserCourseStatus_Insert @UserID, @ModuleID, @StatusID = 0
				SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_UpdateCourseStatus'',''prcUserCourseStatus_Insert'',''UserID=''+CAST(@UserID AS varchar(10)),CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_UpdateCourseStatus'',1,1,null,getutcdate(),getutcdate()) END
			END
		END
	END	
END

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_Update_Quick]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/****** Object:  Stored Procedure dbo.prcUserQuizStatus_Update_Quick    Script Date: 3/05/2004 10:56:48 AM ******/

/* Summary:
Update quiz status for each user

Returns:

Called By:

Calls:
Nothing

Remarks:
This is a schedule job running every night to check there are any changes in the user quiz status based on current compliance rules.
If they are the same as the current status, ignore it, otherwise a new status will be created.

If a module is assigned to a user, and there is no activity for this module, the status will be  ''Not started''.
If a module is unassigned from a user, the status will be ''unassinged"(There are records in status table, but the module is not assigned to this user now)
If a module is set to inactive, the status will be ''unassinged''

All user-module pair need to be re-evaluated, as compliance rules may be changed since the user''s last toolbook activity.

------------ Decision Processes -------------

1. Get Current User Quiz status
-----------------------------------
1.1  Get all modules that are currently assigned to each users (CurrentAssignedModules)
and compliance rules

1.2. Get the last quiz activity for each user and module pair (StartedModules)

1.3. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)
a) Get a list of modules that is in the quiz status table that the last statuses are not Unassigned (0)(PreviousAssignedModules)
b) Get rid off all modules that are currently assigned to the users (from step 1)
c)All modules left are Unassigned(0)

1.4. Not Started Modules (1) (CurrentAssignedModules- StartedModules)
All currently assigned modules that don''t have any activity is Not Started (1)

1.5. Started Modules
a)If the last quiz is inactive, the status is Expired (New Content)(5)
b)If the last quiz is past the current quiz date/frequency, the status is Expired (Time Expired)(4)
c)If the last quiz is during the current quiz frequency, get the current pass mark, and check the quiz status
If user Failed the quiz, the status is Failed (3)
If user Passed the quiz, the status is Passed (2)

2. Update User Quiz status
----------------------------
If the last quiz status for each user is not the same as the current status, add the new status



------------ Data need to be recorded -------------

QuizFrequency	QuizPassMark	QuizScore
0  Unassigned:  		-		-		-
1  Not Started: 		Y		Y		-
2  Passed: 	 		Y		Y		Y
3  Failed: 	 		Y		Y		Y
4  Expired (Time Elapsed): 	Y		Y		-
5  Expired (New Content): 	Y		Y		-


Author: Jack Liu
Date Created: 20 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		1/5/2007		Added logic for new fields LessonCompletionStatus & QuizCompletionStatus
#2	mikev		9/5/2007		Added course completion logic. If a module is marked active or not active; to calculate if the course is complete.
#3	Mark Donald	21/9/2009		Added OrganisationName (control character) to License Warning emails

prcUserQuizStatus_Update_Quick

**/
CREATE   Procedure [prcUserQuizStatus_Update_Quick]
(
@OrgID int	-- comma separated organisationID
)
AS
Set Nocount On
declare @intHistoryID int

insert into tblModuleStatusUpdateHistory(startTime) values(getUTCdate());
set @intHistoryID = @@identity

--1. Get Current User Quiz status
--mikev : added QuizCompletionDate
/* UNITTEST: CurrentAssignedModules */
CREATE TABLE #tblCurrentUserQuizStatus
(
UserID int NOT NULL ,
ModuleID int NOT NULL ,
QuizStatusID int not NULL ,
QuizFrequency int NULL ,
QuizPassMark int NULL ,
QuizCompletionDate DateTime NULL,
QuizScore int NULL,
QuizSessionID uniqueidentifier NULL
)


/*
1.1  Get all modules that are currently assigned to each users (CurrentAssignedModules)
and current compliance rules
*/
-- mikev(1): added completion date

select
um.UserID,
um.ModuleID,
umr.QuizFrequency,
umr.QuizPassMark,
umr.QuizCompletionDate
into
#tblCurrentAssignedModules
from
(
Select
tU.UserID
, tU.UnitID
, tU.OrganisationID
, tM.ModuleID


From
dbo.tblUser tU
--< get the courses a user has access to >--
Inner Join dbo.tblOrganisationCourseAccess tOCA
On  tOCA.OrganisationID = tU.OrganisationID
--< get the course details >--
Inner join dbo.tblCourse tC
On tC.CourseID = tOCA.GrantedCourseID
--< get the Active modules in a course >--
inner join dbo.tblModule tM
On tM.CourseID = tC.CourseID
and tM.Active = 1
--< get the details on which moduels a user is configured to access >--
Left Outer join dbo.tblUserModuleAccess tUsrMA
On  tUsrMA.UserID = tU.UserID
And tUsrMA.ModuleID = tM.ModuleID
--< get the details on which moduels a user''s Unit is excluded from  >--
Left Outer Join dbo.tblUnitModuleAccess tUnitMA
On  tUnitMA.UnitID = tU.UnitID
And tUnitMA.DeniedModuleID = tM.ModuleID
Where
tU.OrganisationID = @OrgID AND
tU.Active = 1
--< Active users only >--
and tu.UnitID is not null
--< Get the modules that the user''s Unit is not denied >--
and (tUnitMA.DeniedModuleID  is null
--<  and the user does not have special access to  it>--
And tUsrMA.ModuleID is null)
--< or Get modules that the user has been specially  granted
or tUsrMA.Granted=1
) um
inner join
(
Select 	u.UnitID,
m.CourseID,
m.ModuleID,
case
when ur.unitID is null then cast(1 as bit)
else cast(0 as bit)
end as UsingDefault,
case
when (ur.LessonFrequency is null and ur.LessonCompletionDate is null and o.DefaultLessonCompletionDate is null) then
o.DefaultLessonFrequency
else
ur.LessonFrequency
end
as LessonFrequency,
case
when (ur.QuizFrequency is null and ur.QuizCompletionDate is null and o.DefaultQuizCompletionDate is null) then
o.DefaultQuizFrequency
else
ur.QuizFrequency
end
as QuizFrequency,
isNull(ur.QuizPassMark, o.DefaultQuizPassMark) as QuizPassMark,
case
when (ur.LessonFrequency is null and ur.LessonCompletionDate is null and not(o.DefaultLessonCompletionDate is null)) then
o.DefaultLessonCompletionDate
else
ur.LessonCompletionDate
end
as LessonCompletionDate,
case
when (ur.QuizFrequency is null and ur.QuizCompletionDate is null and not(o.DefaultQuizCompletionDate is null)) then
o.DefaultQuizCompletionDate
else
ur.QuizCompletionDate
end
as QuizCompletionDate
From tblOrganisationCourseAccess c
inner join tblModule m
on m.CourseID = c.GrantedCourseID
inner join tblOrganisation o  -- Get default compliance rules
on o.OrganisationID = c.OrganisationID
inner join tblUnit u
on u.OrganisationID = c.OrganisationID
left join tblUnitRule ur --Get the unit specific rules
on ur.ModuleID = m.ModuleID
and ur.UnitID=u.unitID
WHERE o.OrganisationID = @OrgID
) umr
on
umr.ModuleID  = um.ModuleID
and umr.UnitID = um.UnitID
and um.UnitID in (select UnitID from tblUnit where OrganisationID = @OrgID)
and um.UserID IN (select UserID from tblUser where OrganisationID = @OrgID)
/* /UNITTEST: CurrentAssignedModules */

-- select * from #tblCurrentAssignedModules
/*
1.2. Get the last quiz activity for each user and module pair (StartedModules)
*/
/* UNITTEST: StartedModules */
select
um.userID,
um.moduleID,
q.active,
qs.QuizScore,
qs.QuizSessionID,
qs.DateTimeCompleted
into
#tblStartedModules
from
#tblCurrentAssignedModules um
inner join
(
select
um.userID, um.moduleID, max(DateTimeCompleted)  as DateTimeCompleted
from
#tblCurrentAssignedModules um
inner join tblQuiz q
on q.ModuleID = um.ModuleID
inner join tblQuizSession qs
on
qs.QuizID=	q.quizID
and qs.userID = um.userID
and qs.DateTimeCompleted is not null
group by um.userID, um.moduleID
)
as LastQuizDate

on
LastQuizDate.userID = um.userID
and LastQuizDate.ModuleID = um.ModuleID

inner join tblQuiz q
on
q.ModuleID = um.ModuleID
inner join tblQuizSession qs
on
qs.QuizID=	q.quizID
and qs.userID = um.userID
and qs.DateTimeCompleted  = LastQuizDate.DateTimeCompleted
/* /UNITTEST: StartedModules */


-- select * from #tblStartedModules

/*
1.3. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)
a) Get a list of modules that is in the quiz status table that the last statuses are not Unassigned (0)(PreviousAssignedModules)
b) Get rid off all modules that are currently assigned to the users (from step 1)
c)All modules left are Unassigned(0)
*/

/* UNITTEST: Status_Unassigned */
insert into #tblCurrentUserQuizStatus
(
UserID,
ModuleID,
QuizStatusID
)
select
uqs.UserID,
uqs.ModuleID,
0  as QuizStatusID --Unassigned (0)
from
(
select
QuizStatus.UserQuizStatusID
, QuizStatus.UserID
, QuizStatus.ModuleID
, m.CourseID
, QuizStatus.QuizStatusID
, QuizStatus.QuizFrequency
, QuizStatus.QuizPassMark
, QuizStatus.QuizSessionID
, QuizStatus.QuizScore
, QuizStatus.DateCreated

from
tblUserQuizStatus QuizStatus
inner join tblModule m on m.ModuleID = QuizStatus.ModuleID
inner join
(
select
max(UserQuizStatusID) UserQuizStatusID --UserQuizStatusID is identity
from
tblUserQuizStatus
WHERE
tblUserQuizStatus.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
group by
UserID,moduleID
) currentStatus
on QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
where m.active = 1
) uqs
left join
#tblCurrentAssignedModules cam
on
cam.UserID = uqs.UserID
and cam.ModuleID = uqs.ModuleID
where
uqs.QuizStatusID<>0 --not Unassigned (0)
and cam.moduleID is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
/* /UNITTEST: Status_Unassigned */

/*
1.4. Not Started Modules (1) (CurrentAssignedModules- StartedModules)
All currently assigned modules that don''t have any activity is Not Started (1)
*/
-- mikev(1): added QuizCompletionDate
/* UNITTEST: Status_NotStarted */
insert into
#tblCurrentUserQuizStatus
(
UserID,
ModuleID,
QuizStatusID,
QuizFrequency,
QuizPassMark,
QuizCompletionDate
)
select
cam.UserID,
cam.ModuleID,
1  as QuizStatusID, --Not Started (1)
cam.QuizFrequency,
cam.QuizPassMark,
cam.QuizCompletionDate
from
#tblCurrentAssignedModules cam
left join
#tblStartedModules sm
on
sm.UserID = cam.UserID
and sm.ModuleID = cam.ModuleID
where
sm.moduleID is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
/* /UNITTEST: Status_NotStarted */
/*
EXPIRED NEW CONTENT IS NOW A MANUAL PROCESS
1.5. Started Modules
a)If the last quiz is inactive, the status is Expired (New Content)(5)
b)If the last quiz is past the current quiz frequency, the status is Expired (Time Expired)(4)
c)If the last quiz is during the current quiz frequency, get the current pass mark, and check the quiz status
If user Failed the quiz, the status is Failed (3)
If user Passed the quiz, the status is Passed (2)
*/

--	  	a)If the last quiz is inactive, the status is Expired (New Content)(5)


--		b)If the last quiz is past the current quiz frequency, the status is Expired (Time Expired)(4)
-- mikev(1): added QuizCompletionDate. Added criteria
/* UNITTEST: Status_TimeExpired */
insert into #tblCurrentUserQuizStatus
(
UserID,
ModuleID,
QuizStatusID,
QuizFrequency,
QuizPassMark,
QuizCompletionDate
)
select cam.UserID,
cam.ModuleID,
4  as QuizStatusID, --  Expired (Time Expired)(4)
cam.QuizFrequency,
cam.QuizPassMark,
cam.QuizCompletionDate
from #tblCurrentAssignedModules cam
inner join #tblStartedModules sm
on sm.UserID = cam.UserID
and sm.ModuleID = cam.ModuleID
where
(
(
cam.QuizCompletionDate is null
and DateDiff(day,dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID), dateadd(month, cam.QuizFrequency, dbo.udfUTCtoDaylightSavingTime(sm.DateTimeCompleted,@OrgID))) <= 0
)
or
(
isnull(DateDiff(day, getutcdate(), cam.QuizCompletionDate), 1) <= 0
)
)
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
/* /UNITTEST: Status_TimeExpired */

--		c)If the last quiz is during the current quiz frequency, get the current pass mark, and check the quiz status
--			If user Failed the quiz, the status is Failed (3)
--			If user Passed the quiz, the status is Passed (2)

-- mikev(1): added QuizCompletionDate and changed logic of criteria to use the date before the frequency
/* UNITTEST: Status_PassFail */
insert into #tblCurrentUserQuizStatus
(
UserID,
ModuleID,
QuizStatusID,
QuizFrequency,
QuizPassMark,
QuizCompletionDate,
QuizScore,
QuizSessionID
)
select cam.UserID,
cam.ModuleID,
case
when sm.QuizScore>=cam.QuizPassMark then 2 -- Passed (2)
else	3  --Failed (3)
end  as QuizStatusID,
cam.QuizFrequency,
cam.QuizPassMark,
cam.QuizCompletionDate,
sm.QuizScore,
sm.QuizSessionID
from #tblCurrentAssignedModules cam
inner join #tblStartedModules sm
on sm.UserID = cam.UserID
and sm.ModuleID = cam.ModuleID
where
not (
cam.QuizCompletionDate is null
and DateDiff(day,dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID), dateadd(month, cam.QuizFrequency, dbo.udfUTCtoDaylightSavingTime(sm.DateTimeCompleted,@OrgID))) <= 0
)
and cam.QuizCompletionDate is null
and cam.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
and (select top 1 QuizStatusID from tblUserQuizStatus where ModuleID = cam.ModuleID and UserID = cam.UserID order by UserQuizStatusID Desc) NOT IN (5)

/* /UNITTEST: Status_PassFail */
/*
2. Update User Quiz status
----------------------------
If the last quiz status for each user is not the same as the current status, add the new status
*/


/* UNITTEST: CourseStatus */
-- mikev(1): added cursor for quizcompletiondate
declare @cursor_UserID 	        int
declare @cursor_ModuleID 	    int
declare @cursor_QuizStatusID 	int
declare @cursor_QuizFrequency 	int
declare @cursor_QuizPassMark	int
declare @cursor_QuizCompletionDate	DateTime
declare @cursor_QuizScore	    int
declare @cursor_QuizSessionID   varchar(50)
declare @cursor_UserQuizStatusID int

-- mikev(1): added quizcompletiondate
declare @LastUser int
declare @LastModuleID int
declare @LastCourse int
declare @LastQuizStatusID int
declare @cursor_CourseID int
set @LastUser = -1
set @LastCourse = -1
set @LastQuizStatusID = -1
set  @LastModuleID = 0
DECLARE CurrentUserQuizStatus CURSOR
FOR


select
cs.UserID,
cs.ModuleID,
cs.QuizStatusID,
cs.QuizFrequency,
cs.QuizPassMark,
cs.QuizCompletionDate,
cs.QuizScore,
cs.QuizSessionID,
s.UserQuizStatusID,
Module.CourseID
from -- Any UserModules with current access but no tblUserQuizStatus record
#tblCurrentUserQuizStatus cs
inner join tblModule Module on module.moduleID = cs.ModuleID
left join
(  -- The UserModule quiz status for the latest quiz attempt
select
QuizStatus.UserQuizStatusID
, QuizStatus.UserID
, QuizStatus.ModuleID
, m.CourseID
, QuizStatus.QuizStatusID
, QuizStatus.QuizFrequency
, QuizStatus.QuizPassMark
, QuizStatus.QuizSessionID
, QuizStatus.QuizScore
, QuizStatus.DateCreated

from
tblUserQuizStatus QuizStatus
inner join tblModule m on m.ModuleID = QuizStatus.ModuleID
inner join
(
select
max(UserQuizStatusID) UserQuizStatusID --UserQuizStatusID is identity
from
tblUserQuizStatus
WHERE
tblUserQuizStatus.UserID in (select UserID from tblUser where OrganisationID = @OrgID)
group by
UserID,moduleID
) currentStatus
on QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
where m.active = 1
) s
on cs.userID = s.UserID
and cs.ModuleID = s.ModuleID
and cs.QuizStatusID = s.QuizStatusID
where
s.UserQuizStatusID is null
order by cs.UserID, 
case when (cs.QuizStatusID = 0) then 6 else cs.QuizStatusID end,
Module.CourseID
-- ordered so we can update course status on the last module in the course rather than for every module in the course

Open CurrentUserQuizStatus

FETCH NEXT FROM CurrentUserQuizStatus
Into
@cursor_UserID,@cursor_ModuleID,@cursor_QuizStatusID,@cursor_QuizFrequency,
@cursor_QuizPassMark,@cursor_QuizCompletionDate,@cursor_QuizScore,@cursor_QuizSessionID, @cursor_UserQuizStatusID, @cursor_CourseID
set @LastCourse = @cursor_CourseID
set @LastUser = @cursor_UserID
set @LastQuizStatusID = @cursor_QuizStatusID
set @LastModuleID = @cursor_ModuleID

DECLARE @Err integer
WHILE @@FETCH_STATUS = 0
BEGIN

insert into tblUserQuizStatus
(
UserID,
ModuleID,
QuizStatusID,
QuizFrequency,
QuizPassMark,
QuizCompletionDate,
QuizScore,
QuizSessionID
)
values
(
@cursor_UserID,
@cursor_ModuleID,
@cursor_QuizStatusID,
@cursor_QuizFrequency,
@cursor_QuizPassMark,
@cursor_QuizCompletionDate,
@cursor_QuizScore,
@cursor_QuizSessionID
)
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''insert into tblUserQuizStatus'',''UserID=''+CAST(@cursor_UserID AS varchar(10)),CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END

-- don''t update the course status for every module in the course - once per course is enough
-- do update the course status on every change in QuizStatus
if (@LastCourse != @cursor_CourseID) or (@LastUser != @cursor_UserID) or (@LastQuizStatusID != @cursor_QuizStatusID) EXEC prcUserQuizStatus_UpdateCourseStatus @LastUser, @LastModuleID

set @LastCourse = @cursor_CourseID
set @LastUser = @cursor_UserID
set @LastQuizStatusID = @cursor_QuizStatusID
set @LastModuleID = @cursor_ModuleID


FETCH NEXT FROM CurrentUserQuizStatus
Into
@cursor_UserID,@cursor_ModuleID,@cursor_QuizStatusID,@cursor_QuizFrequency,
@cursor_QuizPassMark,@cursor_QuizCompletionDate,@cursor_QuizScore,@cursor_QuizSessionID, @cursor_UserQuizStatusID, @cursor_CourseID


END
-- final course may not be done so update just to be safe
if (@LastUser != -1 ) EXEC prcUserQuizStatus_UpdateCourseStatus @cursor_UserID, @cursor_ModuleID
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''prcUserQuizStatus_UpdateCourseStatus'',''prcUserQuizStatus_UpdateCourseStatus'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END

-- Finished CurrentUserQuizStatus
CLOSE CurrentUserQuizStatus
DEALLOCATE CurrentUserQuizStatus




--              AT RISK OF EXPIRY


--DECLARE @DaysWarningBeforeExpiry int
--SELECT @DaysWarningBeforeExpiry = DaysWarningBeforeExpiry FROM tblOrganisation where OrganisationID = @OrgID
--IF (@DaysWarningBeforeExpiry IS NULL)
--BEGIN -- Default value of 30 days before quiz -- no longer use 30 days default
--	DECLARE @QuizExpiryDate DateTime
--	SELECT @QuizExpiryDate = dateadd(d,-30,QuizDueDate) FROM tblOrganisation where OrganisationID = @OrgID

--	delete from tblQuizExpiryAtRisk where OrganisationID = @OrgID
--	and not exists (select @OrgID,cam.UserID,
--	cam.ModuleID, DateDiff(day,dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID), dateadd(month, cam.QuizFrequency, dbo.udfUTCtoDaylightSavingTime(sm.DateTimeCompleted,@OrgID)))
--	from #tblCurrentAssignedModules cam
--	inner join #tblStartedModules sm
--	on sm.UserID = cam.UserID
--	and sm.ModuleID = cam.ModuleID
--	where
--	(
--		cam.QuizCompletionDate is null
--		and dbo.udfGetSaltOrgDate(@OrgID) < @QuizExpiryDate
--		and tblQuizExpiryAtRisk.UserID = cam.UserID
--		and tblQuizExpiryAtRisk.ModuleID = cam.ModuleID
--		and tblQuizExpiryAtRisk.OrganisationID = @OrgID
--	))
--	SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''delete from tblQuizExpiryAtRisk'',''delete from tblQuizExpiryAtRisk'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END



--	insert into tblQuizExpiryAtRisk -- add new users who meet the 30 days default rule
--	(
--	OrganisationID,
--	UserID,
--	ModuleID,
--	DaysToExpiry
--	)
--	select @OrgID,cam.UserID,
--	cam.ModuleID, 30
--	from #tblCurrentAssignedModules cam
--	inner join #tblStartedModules sm
--	on sm.UserID = cam.UserID
--	and sm.ModuleID = cam.ModuleID
--	where
--	(
--		cam.QuizCompletionDate is null
--		and dbo.udfGetSaltOrgDate(@OrgID) < @QuizExpiryDate
--	)
--	and not exists
--		(SELECT * FROM tblQuizExpiryAtRisk
--		where 	tblQuizExpiryAtRisk.UserID = cam.UserID
--		and tblQuizExpiryAtRisk.ModuleID = cam.ModuleID
--		and tblQuizExpiryAtRisk.OrganisationID = @OrgID)
--	SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''insert into tblQuizExpiryAtRisk'',''insert into tblQuizExpiryAtRisk'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END

--END





	delete from tblQuizExpiryAtRisk where OrganisationID = @OrgID   -- delete from ExpiryAtRisk those users who somehow are no longer at risk
	and not exists (
		--select @OrgID,cam.UserID,
		--cam.ModuleID, DateDiff(day,dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID), dateadd(month, cam.QuizFrequency, dbo.udfUTCtoDaylightSavingTime(sm.DateTimeCompleted,@OrgID)))
		--from #tblCurrentAssignedModules cam
		--inner join #tblStartedModules sm
		--on sm.UserID = cam.UserID
		--and sm.ModuleID = cam.ModuleID
		--where
		--(
		--	cam.QuizCompletionDate is null
		--	and DateDiff(day, dateadd(month, cam.QuizFrequency, dbo.udfUTCtoDaylightSavingTime(sm.DateTimeCompleted,@OrgID)),dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID)) <= @DaysWarningBeforeExpiry
		--	and tblQuizExpiryAtRisk.UserID = cam.UserID
		--	and tblQuizExpiryAtRisk.ModuleID = cam.ModuleID
		--	and tblQuizExpiryAtRisk.OrganisationID = @OrgID
		--)
		select @OrgID,cam.UserID,
		cam.ModuleID,
		DateDiff(day,dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID),
		dateadd(month, cam.QuizFrequency,
		dbo.udfUTCtoDaylightSavingTime(sm.DateTimeCompleted,@OrgID)))
		FROM #tblCurrentAssignedModules cam
		INNER JOIN #tblStartedModules sm	ON sm.UserID = cam.UserID	AND sm.ModuleID = cam.ModuleID
		INNER JOIN tblModule M ON M.moduleID = sm.moduleID
		INNER JOIN tblReminderEscalation RemEsc ON  RemEsc.CourseID = M.CourseID
		WHERE RemEsc.OrgID = @OrgID AND RemEsc.RemindUsers = 1 AND
		(
		(
			cam.QuizCompletionDate IS NULL
			and (dbo.udfUTCtoDaylightSavingTime(	getutcdate(),@OrgID)
					>
					DateAdd(                -- Expiry date minus days before expiry to warn user
									day
									,-RemEsc.DaysQuizExpiry
									,dateadd( -- Expiry date
										month
										, cam.QuizFrequency
										, dbo.udfUTCtoDaylightSavingTime(sm.DateTimeCompleted,@OrgID))) 
			 )
		)
		OR

			(
				cam.QuizCompletionDate IS NOT NULL
				and DateDiff(day, dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID), cam.QuizCompletionDate) <= RemEsc.DaysQuizExpiry
			)
		)
	)
	SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''delete from tblQuizExpiryAtRisk'',''delete from tblQuizExpiryAtRisk'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END



	insert into tblQuizExpiryAtRisk -- add users that are now AtRisk that were not already flagged as AtRisk
	(
		OrganisationID,
		UserID,
		ModuleID,
		DaysToExpiry
	)
	
	select @OrgID,cam.UserID,
	cam.ModuleID,
	CASE WHEN ( cam.QuizFrequency IS NULL )
	then DateDiff(day,dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID),
	QuizCompletionDate)

	ELSE
	DateDiff(day,dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID),
	dateadd(month, cam.QuizFrequency,
	dbo.udfUTCtoDaylightSavingTime(sm.DateTimeCompleted,@OrgID)))
	END 
	
	FROM #tblCurrentAssignedModules cam
	INNER JOIN #tblStartedModules sm	ON sm.UserID = cam.UserID	AND sm.ModuleID = cam.ModuleID
	INNER JOIN tblModule M ON M.moduleID = sm.moduleID
	INNER JOIN tblReminderEscalation RemEsc ON  RemEsc.CourseID = M.CourseID
	WHERE RemEsc.OrgID = @OrgID AND RemEsc.RemindUsers = 1 AND
	(
		(
			cam.QuizCompletionDate IS NULL
			and (dbo.udfUTCtoDaylightSavingTime(	getutcdate(),@OrgID)
					>
					DateAdd(                -- Expiry date minus days before expiry to warn user
									day
									,-RemEsc.DaysQuizExpiry
									,dateadd( -- Expiry date
										month
										, cam.QuizFrequency
										, dbo.udfUTCtoDaylightSavingTime(sm.DateTimeCompleted,@OrgID))) 
			 )
		)
	OR

		(
			cam.QuizCompletionDate IS NOT NULL
			and DateDiff(day, dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID), cam.QuizCompletionDate) <= RemEsc.DaysQuizExpiry
		)
	)
	and not exists
		(SELECT * FROM tblQuizExpiryAtRisk
		where 	tblQuizExpiryAtRisk.UserID = cam.UserID
		and tblQuizExpiryAtRisk.ModuleID = cam.ModuleID
		and tblQuizExpiryAtRisk.OrganisationID = @OrgID)
	SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''insert into tblQuizExpiryAtRisk'',''insert into tblQuizExpiryAtRisk'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END








drop table  #tblCurrentUserQuizStatus

drop table #tblCurrentAssignedModules

drop table #tblStartedModules
/* /UNITTEST: CourseStatus */


/* UNITTEST: Licensing */
EXEC prcDatabaseMail_SetupProfile -- incase email address etc has changed, re-setup.

-- Check who is missing license for current period, includes period turn over
declare @lic_CourseLicensingID int, @lic_UserID int
DECLARE LicensingLoop CURSOR
FOR
SELECT DISTINCT tblCourseLicensing.CourseLicensingID, vwUserModuleAccess.UserID
FROM tblCourseLicensing
INNER JOIN vwUserModuleAccess ON tblCourseLicensing.CourseID = vwUserModuleAccess.CourseID
AND tblCourseLicensing.OrganisationID = vwUserModuleAccess.OrganisationID
INNER JOIN tblUser ON vwUserModuleAccess.UserID = tblUser.UserID
LEFT OUTER JOIN	tblCourseLicensingUser ON tblCourseLicensing.CourseLicensingID = tblCourseLicensingUser.CourseLicensingID
WHERE tblCourseLicensing.DateStart <= GETUTCDATE()
AND tblCourseLicensing.DateEnd >= GETUTCDATE()
AND tblCourseLicensingUser.CourseLicensingID IS NULL
AND tblUser.Active = 1
AND vwUserModuleAccess.OrganisationID = @OrgID
Open LicensingLoop
FETCH NEXT FROM LicensingLoop
Into
@lic_CourseLicensingID, @lic_UserID
WHILE @@FETCH_STATUS = 0
BEGIN
IF NOT EXISTS(SELECT CourseLicensingID FROM tblCourseLicensingUser WHERE CourseLicensingID = @lic_CourseLicensingID and UserID = @lic_UserID)
BEGIN
INSERT INTO tblCourseLicensingUser(CourseLicensingID, UserID) VALUES (@lic_CourseLicensingID, @lic_UserID)
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''INSERT INTO tblCourseLicensingUser'',''INSERT INTO tblCourseLicensingUser'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END
END
FETCH NEXT FROM LicensingLoop
Into
@lic_CourseLicensingID, @lic_UserID
END

CLOSE LicensingLoop
DEALLOCATE LicensingLoop



-- WARNING EMAILS
-- License Warning
declare @licenseWarnEmail nvarchar(4000)
declare @licenseWarnEmail_Subject nvarchar(4000)
declare @emailLicenseWarnLicRecipients nvarchar(512)
declare @warn_lic_CourseName nvarchar(200),
@warn_lic_CourseLicensingID int,
@warn_lic_LicenseNumber int,
@warn_lic_LicenseWarnNumber int,
@warn_lic_RepNameSalt nvarchar(200),
@warn_lic_RepEmailSalt nvarchar(200),
@warn_lic_RepNameOrg nvarchar(200),
@warn_lic_RepEmailOrg nvarchar(200),
@warn_lic_LangCode nvarchar(10),
@warn_lic_LicensesUsed int,
@warn_lic_LicenseWarnEmail bit,
@warn_lic_OrganisationName nvarchar(50)

DECLARE LicenceNumberLoop CURSOR
FOR
SELECT
c.Name, l.CourseLicensingID, l.LicenseNumber, l.LicenseWarnNumber, l.RepNameSalt, l.RepEmailSalt,
l.RepNameOrg, l.RepEmailOrg, l.LangCode, COUNT(u.CourseLicensingUserID) AS LicensesUsed,
l.LicenseWarnEmail, OrganisationName
FROM
tblCourseLicensing l
INNER JOIN tblCourseLicensingUser u ON l.CourseLicensingID = u.CourseLicensingID
INNER JOIN tblCourse c ON l.CourseID = c.CourseID
LEFT JOIN tblOrganisation o ON l.OrganisationID = o.OrganisationID
WHERE
l.OrganisationID = @OrgID
GROUP BY
OrganisationName, l.CourseLicensingID, l.RepNameSalt, l.RepEmailSalt, l.RepNameOrg, l.RepEmailOrg, c.Name, l.LicenseNumber,
l.LicenseWarnNumber, l.LicenseWarnEmail, l.LangCode
HAVING
COUNT(u.CourseLicensingUserID) >= l.LicenseWarnNumber
AND l.LicenseWarnEmail = 1

Open LicenceNumberLoop
FETCH NEXT FROM LicenceNumberLoop
Into @warn_lic_CourseName,
@warn_lic_CourseLicensingID,
@warn_lic_LicenseNumber,
@warn_lic_LicenseWarnNumber,
@warn_lic_RepNameSalt,
@warn_lic_RepEmailSalt,
@warn_lic_RepNameOrg,
@warn_lic_RepEmailOrg,
@warn_lic_LangCode,
@warn_lic_LicensesUsed,
@warn_lic_LicenseWarnEmail,
@warn_lic_OrganisationName

WHILE @@FETCH_STATUS = 0
BEGIN
-- Get License Warning text in desired language.
SELECT     @licenseWarnEmail = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @warn_lic_LangCode) AND (tblLangInterface.LangInterfaceName = ''/ContentAdministration/Licensing/Default.aspx'') AND
(tblLangResource.LangResourceName = ''Email_LicenseWarn'') AND (tblLangValue.Active = 1)

SELECT     @licenseWarnEmail_Subject = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @warn_lic_LangCode) AND (tblLangInterface.LangInterfaceName = ''/ContentAdministration/Licensing/Default.aspx'') AND
(tblLangResource.LangResourceName = ''Email_LicenseWarn_Subject'') AND (tblLangValue.Active = 1)

-- {0} is receipient name, {1} is the license warning amount, {2} course name, {3} license limit, {4} name of contact person
-- {5} is organisation name
set @licenseWarnEmail = REPLACE(@licenseWarnEmail, ''{0}'', @warn_lic_RepNameOrg)
set @licenseWarnEmail = REPLACE(@licenseWarnEmail, ''{1}'', @warn_lic_LicenseWarnNumber)
set @licenseWarnEmail = REPLACE(@licenseWarnEmail, ''{2}'', @warn_lic_CourseName)
set @licenseWarnEmail = REPLACE(@licenseWarnEmail, ''{3}'', @warn_lic_LicenseNumber)
set @licenseWarnEmail = REPLACE(@licenseWarnEmail, ''{4}'', @warn_lic_RepNameSalt)
set @licenseWarnEmail = REPLACE(@licenseWarnEmail, ''{5}'', @warn_lic_OrganisationName)

set @licenseWarnEmail_Subject = REPLACE(@licenseWarnEmail_Subject, ''{0}'', @warn_lic_CourseName)
set @licenseWarnEmail_Subject = REPLACE(@licenseWarnEmail_Subject, ''{1}'', @warn_lic_OrganisationName)

select @emailLicenseWarnLicRecipients = @warn_lic_RepEmailOrg +'';''+@warn_lic_RepEmailSalt

--EXEC msdb.dbo.sp_send_dbmail
--@recipients = @emailLicenseWarnLicRecipients,
--@body = @licenseWarnEmail,
--@subject = @licenseWarnEmail_Subject,
--@profile_name = ''Salt_MailAccount''

-- Log emails sent
--exec prcEMail_LogSentEmail @toEmail = @warn_lic_RepEmailOrg, @toName = null, @fromEmail = ''support@blakedawson.com'', @fromName = ''Blake Dawson'', @subject = @licenseWarnEmail_Subject, @body = @licenseWarnEmail, @organisationID = @OrgID
--exec prcEMail_LogSentEmail @toEmail = @warn_lic_RepEmailSalt, @toName = null, @fromEmail = ''support@blakedawson.com'', @fromName = ''Blake Dawson'', @subject = @licenseWarnEmail_Subject, @body = @licenseWarnEmail, @organisationID = @OrgID

print ''queued numLics warning mail to : '' + @emailLicenseWarnLicRecipients

-- Unset flag and record date email sent
UPDATE tblCourseLicensing SET DateLicenseWarnEmailSent = getutcdate(), LicenseWarnEmail = 0 WHERE CourseLicensingID = @warn_lic_CourseLicensingID
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''UPDATE tblCourseLicensing'',''UPDATE tblCourseLicensing'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END

FETCH NEXT FROM LicenceNumberLoop
Into @warn_lic_CourseName,
@warn_lic_CourseLicensingID,
@warn_lic_LicenseNumber,
@warn_lic_LicenseWarnNumber,
@warn_lic_RepNameSalt,
@warn_lic_RepEmailSalt,
@warn_lic_RepNameOrg,
@warn_lic_RepEmailOrg,
@warn_lic_LangCode,
@warn_lic_LicensesUsed,
@warn_lic_LicenseWarnEmail,
@warn_lic_OrganisationName
END

CLOSE LicenceNumberLoop
DEALLOCATE LicenceNumberLoop
-- /License Warning


-- Expiry Warning
declare @expiryWarnEmail nvarchar(4000)
declare @expiryWarnEmail_Subject nvarchar(4000)
declare @emailLicenseWarnExpRecipients nvarchar(512)
DECLARE @warn_exp_CourseLicensingID int,
@warn_exp_CourseName nvarchar(200),
@warn_exp_DateWarn datetime,
@warn_exp_ExpiryWarnEmail bit,
@warn_exp_DateEnd datetime,
@warn_exp_RepNameSalt nvarchar(200),
@warn_exp_RepEmailSalt nvarchar(200),
@warn_exp_RepNameOrg nvarchar(200),
@warn_exp_RepEmailOrg nvarchar(200),
@warn_exp_LangCode nvarchar(10),
@warn_exp_OrganisationName nvarchar(50)

DECLARE LicenceExpiryLoop CURSOR
FOR
SELECT
l.CourseLicensingID, c.Name, l.DateWarn, l.ExpiryWarnEmail, l.DateEnd, l.RepNameSalt,
l.RepEmailSalt, l.RepNameOrg, l.RepEmailOrg, l.LangCode, OrganisationName
FROM
tblCourseLicensing l
INNER JOIN tblCourse c ON l.CourseID = c.CourseID
LEFT JOIN tblOrganisation o ON l.OrganisationID = o.OrganisationID
WHERE
l.DateWarn < GETUTCDATE()
AND l.ExpiryWarnEmail = 1
AND l.OrganisationID = @OrgID

Open LicenceExpiryLoop
FETCH NEXT FROM LicenceExpiryLoop
Into @warn_exp_CourseLicensingID,
@warn_exp_CourseName,
@warn_exp_DateWarn,
@warn_exp_ExpiryWarnEmail,
@warn_exp_DateEnd,
@warn_exp_RepNameSalt,
@warn_exp_RepEmailSalt,
@warn_exp_RepNameOrg,
@warn_exp_RepEmailOrg,
@warn_exp_LangCode,
@warn_exp_OrganisationName

WHILE @@FETCH_STATUS = 0
BEGIN
-- Get Expiry Warning text in desired language.
SELECT     @expiryWarnEmail = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @warn_exp_LangCode) AND (tblLangInterface.LangInterfaceName = ''/ContentAdministration/Licensing/Default.aspx'') AND
(tblLangResource.LangResourceName = ''Email_ExpiryWarn'') AND (tblLangValue.Active = 1)

SELECT     @expiryWarnEmail_Subject = tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @warn_exp_LangCode) AND (tblLangInterface.LangInterfaceName = ''/ContentAdministration/Licensing/Default.aspx'') AND
(tblLangResource.LangResourceName = ''Email_ExpiryWarn_Subject'') AND (tblLangValue.Active = 1)

-- {0} Receipient Name, {1} number days till expiry, {2} course name, {3} expiry date, {4} Salt rep name
-- {5} Organisation Name
set @expiryWarnEmail = REPLACE(@expiryWarnEmail, ''{0}'', @warn_exp_RepNameOrg)
set @expiryWarnEmail = REPLACE(@expiryWarnEmail, ''{1}'', DATEDIFF(dd,dbo.udfUTCtoDaylightSavingTime(getUTCdate(),@OrgID),dbo.udfUTCtoDaylightSavingTime(@warn_exp_DateEnd,@OrgID)))
set @expiryWarnEmail = REPLACE(@expiryWarnEmail, ''{2}'', @warn_exp_CourseName)
set @expiryWarnEmail = REPLACE(@expiryWarnEmail, ''{3}'', CONVERT(CHAR(10), dbo.udfUTCtoDaylightSavingTime(@warn_exp_DateEnd,@OrgID), 103))
set @expiryWarnEmail = REPLACE(@expiryWarnEmail, ''{4}'', @warn_exp_RepNameSalt)
set @expiryWarnEmail = REPLACE(@expiryWarnEmail, ''{5}'', @warn_exp_OrganisationName)

set @expiryWarnEmail_Subject = REPLACE(@expiryWarnEmail_Subject, ''{0}'', @warn_exp_CourseName)
set @expiryWarnEmail_Subject = REPLACE(@expiryWarnEmail_Subject, ''{1}'', @warn_exp_OrganisationName)

select @emailLicenseWarnExpRecipients = @warn_exp_RepEmailOrg +'';''+@warn_exp_RepEmailSalt

--EXEC msdb.dbo.sp_send_dbmail
--@recipients = @emailLicenseWarnExpRecipients,
--@body = @expiryWarnEmail,
--@subject = @expiryWarnEmail_Subject,
--@profile_name = ''Salt_MailAccount''

-- Log emails sent
--exec prcEMail_LogSentEmail @toEmail = @warn_exp_RepEmailOrg, @toName = null, @fromEmail = ''support@blakedawson.com'', @fromName = ''Blake Dawson'', @subject = @expiryWarnEmail_Subject, @body = @expiryWarnEmail, @organisationID = @OrgID
--exec prcEMail_LogSentEmail @toEmail = @warn_exp_RepEmailSalt, @toName = null, @fromEmail = ''support@blakedawson.com'', @fromName = ''Blake Dawson'', @subject = @expiryWarnEmail_Subject, @body = @expiryWarnEmail, @organisationID = @OrgID

print ''queued expiry mail to : '' + @emailLicenseWarnExpRecipients
-- Unset flag and record date email sent
UPDATE tblCourseLicensing SET DateExpiryWarnEmailSent = getutcdate(), ExpiryWarnEmail = 0 WHERE CourseLicensingID = @warn_exp_CourseLicensingID
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''UPDATE tblCourseLicensing'',''UPDATE tblCourseLicensing'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END


FETCH NEXT FROM LicenceExpiryLoop
Into @warn_exp_CourseLicensingID,
@warn_exp_CourseName,
@warn_exp_DateWarn,
@warn_exp_ExpiryWarnEmail,
@warn_exp_DateEnd,
@warn_exp_RepNameSalt,
@warn_exp_RepEmailSalt,
@warn_exp_RepNameOrg,
@warn_exp_RepEmailOrg,
@warn_exp_LangCode,
@warn_exp_OrganisationName
END

CLOSE LicenceExpiryLoop
DEALLOCATE LicenceExpiryLoop
-- /Expiry Warning
/* /UNITTEST: Licensing */


/* UNITTEST: ModuleNightly */
-- START Course status reconcile. If a module has been made active or inactive to run through all user and ensure that their course status is correct.
-- AS PER BUSINESS requirement
-- Get all changed modules
declare @c_CourseID int, @c_ModuleID int
DECLARE UpdatedModuleLOOP CURSOR
FOR
SELECT CourseID, ModuleID FROM tblModule WHERE(DateUpdated > GETUTCDATE() - 2)
Open UpdatedModuleLOOP

FETCH NEXT FROM UpdatedModuleLOOP
Into
@c_CourseID, @c_ModuleID

WHILE @@FETCH_STATUS = 0
BEGIN
-- Get all users related to this module
declare @c_UserID int
DECLARE UserLOOP CURSOR
FOR
SELECT UserID FROM tblUserModuleAccess WHERE ModuleID = @c_ModuleID
Open UserLOOP


FETCH NEXT FROM UserLOOP
Into
@c_UserID

WHILE @@FETCH_STATUS = 0
BEGIN
EXEC prcUserQuizStatus_UpdateCourseStatus @c_UserID, @c_ModuleID
SET @Err = @@ERROR; if @Err <> 0 BEGIN INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''prcUserQuizStatus_Update_Quick'',''prcUserQuizStatus_UpdateCourseStatus'',''prcUserQuizStatus_UpdateCourseStatus'',CAST(@Err AS varchar(50)),CAST(@Err AS varchar(50)),''prcUserQuizStatus_Update_Quick'',1,1,null,getutcdate(),getutcdate()) END

FETCH NEXT FROM UserLOOP
Into
@c_UserID
END

CLOSE UserLOOP
DEALLOCATE UserLOOP

FETCH NEXT FROM UpdatedModuleLOOP
Into
@c_CourseID, @c_ModuleID
END

CLOSE UpdatedModuleLOOP
DEALLOCATE UpdatedModuleLOOP
/* /UNITTEST: ModuleNightly */




/* UNITTEST: ExtendComplianceDate */
update tblOrganisation
set DefaultQuizCompletionDate = dateadd(year, 1, [DefaultQuizCompletionDate])
where DefaultQuizCompletionDate < getutcdate() and OrganisationID = @OrgID

update tblUnitRule
set QuizCompletionDate = dateadd(year, 1, [QuizCompletionDate])
where QuizCompletionDate < getutcdate() and UnitID IN (select UnitID from tblUnit where OrganisationID = @OrgID)
/* /UNITTEST: ExtendComplianceDate */


-- END Course status reconcile.


update tblOrganisation set CourseStatusLastUpdated = dbo.udfUTCtoDaylightSavingTime(getutcdate(),@OrgID) where OrganisationID = @OrgID

update tblModuleStatusUpdateHistory
set FinishTime = getutcdate()
where ModuleStatusUpdateHistoryID = @intHistoryID


SET QUOTED_IDENTIFIER OFF
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*

CALLS prcUserQuizStatus_Update_Quick

**/
CREATE   Procedure [prcUserQuizStatus_Update]
AS
Set Nocount On
declare @intHistoryID int

insert into tblModuleStatusUpdateHistory(startTime) values(getutcdate());
set @intHistoryID = @@identity


declare @cursor_OrgID	    int

DECLARE OrgList CURSOR
FOR
SELECT OrganisationID
from tblOrganisation
WHERE DATEDIFF (d,CourseStatusLastUpdated,dbo.udfUTCtoDaylightSavingTime(getutcdate(),OrganisationID)) > 0
order by OrganisationID desc

Open OrgList

FETCH NEXT FROM OrgList
Into
@cursor_OrgID

WHILE @@FETCH_STATUS = 0
BEGIN

exec prcUserQuizStatus_Update_Quick @cursor_OrgID
exec prcUserLessonStatus_Update_NO_TRIGGER_CurrentStatus_Quick @cursor_OrgID
print ''Completed Organisation: '' + Cast(@cursor_OrgID as varchar)

FETCH NEXT FROM OrgList Into @cursor_OrgID
END

CLOSE OrgList
DEALLOCATE OrgList



update tblModuleStatusUpdateHistory
set FinishTime = getutcdate()
where ModuleStatusUpdateHistoryID = @intHistoryID
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'




/*
Summary: Gets othe details of one Organisation
Parameters: 	@courseID integer
@userID integer
Returns:

Called By: User.cs
Calls: None

Remarks: Raises an error if either of the input parameters are null

Author: Gavin Buddis
Date Created: 2/4/04

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcUserCourseStatus_GetOne]
(
@userID int, 	-- The User ID
@courseID int, 	-- the Course ID
@OrgID int
)

As

If @courseID Is Null
Begin
Raiserror(''The Parameter @courseID was null.  @courseID does not accept Null values.'', 16, 1)
Return
End

If @userID Is Null
Begin
Raiserror(''The Parameter @userID was null.  @userID does not accept Null values.'', 16, 1)
Return
End

DECLARE
@modulesassigned varchar(1000), -- sql2000 doesn''t allow the naked column value (modulesassigned) to be used as a param for a table udf that''s used in a join
@coursestatusid int

SELECT
TOP 1 @modulesassigned = modulesassigned, @coursestatusid = coursestatusid
FROM
tblusercoursestatus
WHERE
userid = @userid
AND courseid = @courseid
ORDER BY
datecreated DESC

SELECT
TOP 1 @userid userid, @courseid courseid, @coursestatusid coursestatusid, @modulesassigned modulesassigned, dbo.udfUTCtoDaylightSavingTime(datecreated, @OrgID) as datecreated
FROM
tbluserquizstatus,
dbo.udfCsvToInt(@modulesassigned)
WHERE
moduleid = intvalue
AND userid = @userid
AND quizstatusid = 2 -- passed
ORDER BY
datecreated DESC

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourse_GetCompletionDate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
summary: get completion date for the last required component in a course is completed
parameters: userID int, courseID int
returns: datetimecompleted datetime

called by:
Author: Li Zhang
Date Created:

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/
CREATE Procedure [prcUserCourse_GetCompletionDate]
(@userID int,
@courseID int,
@OrgID int,
@courseCompletionDate datetime=null output
)
AS

Set Nocount On

/*
select
um.UserID,
um.ModuleID
into #tblCurrentAssignedModules
from vwUserModuleAccess um
inner join
vwUnitModuleRule umr
on umr.moduleID = um.moduleID
and umr.unitID = um.unitId
inner join
tblmodule m
on um.moduleId= m.moduleID
where
um.userID = @userID
and m.courseID = @courseID

--select * from #tblCurrentAssignedModules

select
um.userID,
um.moduleID,
qs.DateTimeCompleted
into
#tblStartedModules
from
#tblCurrentAssignedModules um
inner join
(
select
um.userID,
um.moduleID,
max(DateTimeCompleted) as DateTimeCompleted
from
#tblCurrentAssignedModules um
inner join tblQuiz q
on q.moduleID = um.ModuleID
inner join tblQuizSession qs
on qs.QuizID = q.quizID
and qs.userID = um.userId
and qs.datetimecompleted is not null
group by um.userID, um.moduleID
)as lastQuizDate
on lastquizdate.userID = um.userID
and lastquizdate.moduleID = um.moduleID
inner join tblQuiz q
on
q.moduleID = um.moduleID
inner join tblQuizSession qs
on qs.quizid = q.quizid
and qs.userid = um.userid
and qs.datetimecompleted = lastquizdate.datetimecompleted

select @courseCompletionDate = max(DateTimeCompleted) from #tblstartedmodules

*/


select top 1 @courseCompletionDate = dbo.udfUTCtoDaylightSavingTime(DateCreated, @OrgID) from tblUserCourseStatus where CourseID = @courseID and UserID = @userID and CourseStatusID = 2 order by DateCreated desc
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetUnassigned]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Returns the users that are not currently assigned to a unit.
This function never returns users who are salt administrators

Parameters: @OrganisationID 	Integer
Returns:
UserID,
First Name,
Last Name,
DateUpdated
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By: User.cs
Calls: Nothing

Remarks: Raises an error if the parameter is null

Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
7. IntegrityConstraintException
10. BusinessServiceException (General)

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

-- prcUser_GetUnassigned 1
*/
CREATE Procedure [prcUser_GetUnassigned]
@OrganisationID 	Integer
AS

Set NoCount On

-- Declarations
Declare @strErrorMessage Varchar(200) 		-- Holds the error message
Declare @intErrorNumber Integer			-- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

-- Validation
If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure prcUser_GetUnassigned''
Goto Finalise
End

-- Logic
Select
UserID,
LastName,
FirstName,
UserName,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @OrganisationID) as DateUpdated
From
tblUser
Where
OrganisationID=@OrganisationID
And
UnitID is null
And
UserTypeID <> 1
order by
LastName,
FirstName
-- Set the error message to successfull
Set @strErrorMessage = ''User successfully selected.''

-- Finalise the procedure
Goto Finalise

Finalise:
If(@intErrorNumber > 0)
Begin
Select
@intErrorNumber 	As ''ErrorNumber'',
@strErrorMessage 	As ''ErrorMessage''
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_UpdateDomainName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Updates the domain name for a orgaisation.
The domain name must be unique

This func is only available for Salt Admin

It is used for login

Remarks:
Exception:
0. Succeed
1. RecordNotFoundException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Jack Liu
Date Created: 16th of Sept  2005

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcOrganisation_UpdateDomainName]
(
@organisationID int,
@domainName nvarchar(100)
)

As

if exists(select 1
from tblOrganisation
where domainName=@domainName
and organisationID<>@organisationID)
begin
Select
4 As ''ErrorNumber'',
''Domain name is used by another organisation'' As ''ErrorMessage''
return
end
begin
Update tblOrganisation
set domainName =@domainName
where organisationID=@organisationID

select	0 As ''ErrorNumber'',
'''' As ''ErrorMessage''

end


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_ErrorStatusList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


Create  Procedure [prcErrorLog_ErrorStatusList]


as

SELECT
[ErrorStatusID],
[ErrorStatusDescription]
FROM
[tblErrorStatus]


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_ErrorLevelList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


Create  Procedure [prcErrorLog_ErrorLevelList]


as

SELECT
[ErrorLevelID],
[ErrorLevelDescription]
FROM
[tblErrorLevel]


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetByUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Given a user id returns the list of Active courses a user has access to
If the User id is ommited it returns all the courses
Returns:
Course ID

Called By: Home.aspx
Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 6 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



--------------------
prcCourse_GetByUser @userID=11

**/

CREATE  Proc [prcCourse_GetByUser]
(
@userID int = Null
)
AS
------------------------------------------
Set Nocount On
Select Distinct
CourseID
, Name
From
tblCourse tC
inner join tblOrganisationCourseAccess tOCA
on tC.CourseID = tOCA.GrantedCourseID
inner join tblUser tU
on tU.OrganisationID = tOCA.OrganisationID
Where
tC.Active = 1
and tU.UserID = isnull(@userID, tU.UserID)
Order By
tC.CourseID




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_EnabledLastPassed]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE Procedure [prcOrganisation_EnabledLastPassed]
(
@OrgID int
)
as
Select
ShowLastPassed
From
tblOrganisation
Where
OrganisationID = @OrgID
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserCourseStatus_Calc]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Calculate the latest course status for a user - course

Returns:
int CourseID

Called By:
prcQuizSession_GetEndQuizInfo
Calls:
Stored procedure

Remarks:

QuizStatusID Status
------------ --------------------------------------------------
0            Unassigned
1            Not Started
2            Passed
3            Failed
4            Expired (Time Elapsed)
5            Expired (New Content)


CourseStatusID Status
-------------- --------------------------------------------------
0              Unassigned
1              InComplete
2              Complete

Author: Li Zhang
Date Created: 13-10-2006
Modification History
-----------------------------------------------------------
v#	Author		Date			Description
3.0.24 Li Zhang		19-01-2007		Avoid use the row count result of vwUserQuizStatus and vwUserModule in calculating the user course status
3.0.25 Aaron Cripps	8/5/2007		Remove vwUserQuizStatus from join  replace with temp table using @UserID and @ModuleID filtering
**/



CREATE PROCEDURE [prcUserCourseStatus_Calc]
(
@CourseID int	-- The course ID
, @UserID int 	-- The user ID
, @NewQuizStatus int	-- New quiz status for calculating latest course status
, @ModuleID int -- quiz module ID
)
AS
------------------------------------
SET Nocount On

BEGIN

DECLARE @intStatus int, -- Return Value
@intRowCount int,
@intQuizFrequency int

DECLARE	@tblUserQuizStatus TABLE
(
ModuleID    int
, QuizStatusID int
)

--< select all user quiz status details before update >--
--< table to hold Quiz Status results > --
DECLARE @tblQuizStatus TABLE
(

UserID int,
ModuleID int,
CourseID int,
QuizStatusID int
)

insert into
@tblQuizStatus
(
UserID,
ModuleID,
CourseID,
QuizStatusID
)
--< select modification of vwUserQuizStatus but with additional filter for UserID and ModuleID >--
--< returns a greatly reduced number of rows in a shorter time >--
SELECT      QuizStatus.UserID, QuizStatus.ModuleID, m.CourseID, QuizStatus.QuizStatusID
FROM         dbo.tblUserQuizStatus AS QuizStatus INNER JOIN
dbo.tblModule AS m ON m.ModuleID = QuizStatus.ModuleID INNER JOIN
(SELECT     MAX(UserQuizStatusID) AS UserQuizStatusID
FROM          dbo.tblUserQuizStatus where UserID = @UserID
GROUP BY UserID, ModuleID ) AS currentStatus ON QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
WHERE     (m.Active = 1)


INSERT INTO
@tblUserQuizStatus
(
ModuleID
, QuizStatusID
)
SELECT
vUQS.ModuleID
, vUQS.QuizStatusID
FROM @tblQuizStatus vUQS
INNER JOIN vwUserModuleAccess vUMA
ON
vUQS.ModuleID = vUMA.ModuleID
AND vUMA.Userid = @UserID
AND vUMA.CourseID = @CourseID
AND vUQS.CourseID = @CourseID
AND vUQS.UserID = @UserID

--< get the rowcount >--

SET @intRowCount = @@RowCount

--< update the @tblUserQuizStatus with the latest user quiz details >--
--< when user sit the course for the first time >--
IF @intRowCount = 0
BEGIN

INSERT  INTO @tblUserQuizStatus
(	ModuleID
, QuizStatusID
)
VALUES
(
@ModuleID
, @NewQuizStatus
)
END

--< user who had sat some modules in the course >--
IF @intRowCount <> 0
BEGIN
--< user resit the same module >--
IF EXISTS (SELECT QuizStatusID FROM @tblUserQuizStatus WHERE ModuleID = @ModuleID)
BEGIN
--< quiz record exists, update quiz status >--
UPDATE @tblUserQuizStatus SET QuizStatusID = @NewQuizStatus WHERE ModuleID = @ModuleID
END
ELSE
BEGIN
INSERT  INTO @tblUserQuizStatus
(	ModuleID
, QuizStatusID
)
VALUES
(
@ModuleID
, @NewQuizStatus
)
END
END

--< star to calculate the latest course status >--
--< if there are any results for anything other than passed then the course is incomplete >--

IF EXISTS (SELECT ModuleID FROM @tblUserQuizStatus WHERE QuizStatusID <> 2)
BEGIN
--< Course status: Incomplete >--
RETURN  1
END

--< Get number of modules that the user has access to >--
select * into #tblTemp from vwUserModuleAccess where userID = @UserID and courseID=@CourseID
SET @intRowCount = @@RowCount

--<  all the quizes are passed then the course is complete >--
IF  (SELECT COUNT(ModuleID) FROM @tblUserQuizStatus WHERE QuizStatusID = 2) = @intRowCount
BEGIN
--< Course status: Complete >--
drop table #tblTemp
RETURN 2
END

--< User doesnt have access to any module in the course>--
IF (@intRowCount = 0)
BEGIN
RETURN 0
END

--< otherwise course incomplete >--
RETURN 1

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_SaveModuleAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Saves User module access settings

If the Unit Module Access profile is changed however
then the User Module Access profiles will be over-written with the new Unit Module Access profile.

Called By: User.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 17th of February 2004



Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUser_SaveModuleAccess 2, 1, ''1,2''

select * from tblModule


*/

CREATE  Procedure [prcUser_SaveModuleAccess]
(
@userID Int,
@courseID int,
@grantedModuleIDs varchar(500)
)

As

set nocount on

set xact_abort on
Begin Tran

-- Remove existing settings
Delete tblUserModuleAccess
from  tblUserModuleAccess uma
inner join tblModule m
on uma.ModuleID=m.ModuleID
where 	uma.UserID=@userID
and m.courseID = @courseID

--Insert new settings
insert into tblUserModuleAccess
(UserID,
ModuleID,
Granted
)
select @userID,
m.ModuleID,
case
when g.IntValue is null then 0
else 1
end as Granted
From tblModule m
left join dbo.udfCsvToInt(@grantedModuleIDs) as  g
on g.IntValue=m.moduleID
where CourseId= @courseID

--Update course status
Declare @intOldCourseStatus int
Declare @intNewCourseStatus int
Declare @ModuleID int

exec @intOldCourseStatus = prcUserCourseStatus_GetStatus @courseId, @userID
exec @intNewCourseStatus = prcUserCourseStatus_Calculate @courseID, @userID

IF (@intOldCourseStatus = -1) or (@intOldCourseStatus <> @intNewCourseStatus)
BEGIN
--Just need to get one of the modules of the course to pass into prcUserCourseStatus_Insert
set @moduleID = (select top 1 m.moduleId
From tblModule m
left join dbo.udfCsvToInt(@grantedModuleIDs) as  g
on g.IntValue=m.moduleID
where CourseId= @courseID and m.active=1)
EXEC prcUserCourseStatus_Insert @UserID, @ModuleID, @intNewCourseStatus
END

Commit tran

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetModuleAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/****** Object:  Stored Procedure dbo.prcUser_GetModuleAccess    Script Date: 30/03/2004 4:01:35 PM ******/
/*
Summary:
Gets user module access settings

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Peter Kneale    30/3/04    Filtered out inactive modules

prcUser_GetModuleAccess 1, 1

*/

CREATE   Procedure [prcUser_GetModuleAccess]
(
@userID Int,
@courseID int
)

As

set nocount on

declare @intUnitID int
select @intUnitID = unitID
from tblUser
where UserID = @userID

Select 	m.ModuleID,
m.Name,
case
when ((unitma.DeniedModuleID  is null
And userma.ModuleID is null)
or userma.Granted=1)  then 1
else 0 end as Granted
From tblModule m
left join tblUnitModuleAccess unitma
on m.ModuleID = unitma.DeniedModuleID
and unitma.UnitID=@intUnitID
left join tblUserModuleAccess userma
on m.ModuleID = userma.ModuleID
and userma.UserID=@userID
where
m.CourseId= @courseID
and
m.Active = 1
order by m.Sequence








' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SaveModuleRuleToAll]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Populate the compliance rules to all modules in the course

Called By: Unit.cs
Calls: None

Remarks:

Author: Jack Liu
Date Created: 18th of February 2004


Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_SaveModuleRuleToAll 1, 1

*/

CREATE  Procedure [prcUnit_SaveModuleRuleToAll]
(
@unitID Int,
@courseID int,
@lessonFrequency int,
@quizFrequency int,
@quizPassMark int,
@lessonCompletionDate DateTime = Null, -- Lesson completion date
@quizCompletionDate DateTime = Null, -- Quiz completion date
@adminUserID int,
@OrgID int
)

As

set nocount on

set xact_abort on
Begin Tran

set @lessonCompletionDate = dbo.udfDaylightSavingTimeToUTC(@lessonCompletionDate, @OrgID)
set @quizCompletionDate = dbo.udfDaylightSavingTimeToUTC(@quizCompletionDate, @OrgID)

Delete tblUnitRule
from tblUnitRule ur
inner join tblModule m
on  ur.ModuleID  = m.ModuleID
where ur.UnitID=@unitID
and m.CourseId= @courseID

insert into tblUnitRule
(
UnitID,
ModuleID,
LessonFrequency,
QuizFrequency,
QuizPassMark,
LessonCompletionDate,
QuizCompletionDate,
CreatedBy,
DateCreated
)
Select 	@unitID,
m.ModuleID,
@lessonFrequency,
@quizFrequency,
@quizPassMark,
@lessonCompletionDate,
@quizCompletionDate,
@adminUserID,
GETUTCDATE()
From tblModule m
where m.CourseId= @courseID

commit tran





' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SaveModuleAccess1]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Saves unit module access settings
This will overwrite the module access settings of users (Remove individual settings)

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_SaveModuleAccess 2, 1, ''1,2''


select * from tblModule


*/

CREATE  Procedure [prcUnit_SaveModuleAccess1]
(
@unitID Int,
@courseID int,
@grantedModuleIDs varchar(500)
)

As

set nocount on

set xact_abort on
Begin Tran

-- Remove existing settings
Delete tblUnitModuleAccess
from  tblUnitModuleAccess uma
inner join tblModule m
on uma.DeniedModuleID=m.ModuleID
where 	uma.UnitID=@unitID
and m.courseID = @courseID

-- Overwrite the module access settings of users (Remove individual settings)
Delete tblUserModuleAccess
from  tblUserModuleAccess uma
inner join tblUser u
on uma.UserID = u.UserID
inner join tblModule m
on uma.ModuleID=m.ModuleID
where 	u.UnitID=@unitID
and m.courseID = @courseID

--Insert new settings
insert into tblUnitModuleAccess
(UnitID,
DeniedModuleID
)
select @unitID,
m.ModuleID
From tblModule m
left join dbo.udfCsvToInt(@grantedModuleIDs) as  g
on g.IntValue=m.moduleID
where CourseId= @courseID
and g.IntValue is null


/*
-- update course status for users
declare @intOldCourseStatus int
declare @intNewCourseStatus int
declare @ModuleID int
declare @userID int

declare userIDCursor cursor
for SELECT DISTINCT u.UserID
FROM tblUser AS u
INNER JOIN tblUserCourseStatus AS ucs
ON u.UserID = ucs.UserID
WHERE (ucs.CourseID = @CourseID) AND (u.UnitID = @UnitID)

open userIDCursor

fetch next from userIDCursor into @userID while (@@FETCH_STATUS <> -1) begin if (@@FETCH_STATUS <> -2) begin exec @intOldCourseStatus = prcUserCourseStatus_GetStatus @courseID, @userID exec @intNewCourseStatus = prcUserCourseStatus_Calculate @courseID, @userID

if (@intOldCourseStatus = -1) or (@intOldCourseStatus <> @intNewCourseStatus) begin set @moduleID = (select top 1 m.moduleId from tblModule m left join dbo.udfCsvToInt(@grantedModuleIDs) as g on g.IntValue=m.moduleID where CourseID = @courseID) exec prcUserCourseStatus_Insert @userID, @ModuleID, @intNewCourseStatus end end fetch next from userIDCursor into @userID end close userIDCursor deallocate userIDCursor


*/
Commit tran


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_SaveModuleAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Saves unit module access settings
This will overwrite the module access settings of users (Remove individual settings)

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_SaveModuleAccess 2, 1, ''1,2''


select * from tblModule


*/

CREATE  Procedure [prcUnit_SaveModuleAccess]
(
@unitID Int,
@courseID int,
@grantedModuleIDs varchar(500)
)

As

set nocount on

set xact_abort on
Begin Tran

-- Remove existing settings
Delete tblUnitModuleAccess
from  tblUnitModuleAccess uma
inner join tblModule m
on uma.DeniedModuleID=m.ModuleID
where 	uma.UnitID=@unitID
and m.courseID = @courseID

-- Overwrite the module access settings of users (Remove individual settings)
Delete tblUserModuleAccess
from  tblUserModuleAccess uma
inner join tblUser u
on uma.UserID = u.UserID
inner join tblModule m
on uma.ModuleID=m.ModuleID
where 	u.UnitID=@unitID
and m.courseID = @courseID

--Insert new settings
insert into tblUnitModuleAccess
(UnitID,
DeniedModuleID
)
select @unitID,
m.ModuleID
From tblModule m
left join dbo.udfCsvToInt(@grantedModuleIDs) as  g
on g.IntValue=m.moduleID
where CourseId= @courseID
and g.IntValue is null



-- update course status for users
declare @intOldCourseStatus int
declare @intNewCourseStatus int
declare @ModuleID int
declare @userID int

declare userIDCursor cursor
for SELECT DISTINCT u.UserID
FROM tblUser AS u
INNER JOIN tblUserCourseStatus AS ucs
ON u.UserID = ucs.UserID
WHERE (ucs.CourseID = @CourseID) AND (u.UnitID = @UnitID)

open userIDCursor

fetch next from userIDCursor into @userID while (@@FETCH_STATUS <> -1) begin if (@@FETCH_STATUS <> -2) begin exec @intOldCourseStatus = prcUserCourseStatus_GetStatus @courseID, @userID exec @intNewCourseStatus = prcUserCourseStatus_Calculate @courseID, @userID

if (@intOldCourseStatus = -1) or (@intOldCourseStatus <> @intNewCourseStatus) begin set @moduleID = (select top 1 m.moduleId from tblModule m left join dbo.udfCsvToInt(@grantedModuleIDs) as g on g.IntValue=m.moduleID where CourseID = @courseID) exec prcUserCourseStatus_Insert @userID, @ModuleID, @intNewCourseStatus end end fetch next from userIDCursor into @userID end close userIDCursor deallocate userIDCursor



Commit tran


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetModuleAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/****** Object:  Stored Procedure dbo.prcUnit_GetModuleAccess    Script Date: 30/03/2004 3:56:31 PM ******/
/*
Summary:
Gets unit module access settings

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Peter Kneale 30/3/04        Filtered out inactive modules

prcUnit_GetModuleAccess 30, 1

*/

CREATE   Procedure [prcUnit_GetModuleAccess]
(
@unitID Int,
@courseID int
)

As

set nocount on

Select 	m.ModuleID,
m.Name,
case
when uma.unitID is null then 1
else 0
end as Granted
From tblModule m
left join tblUnitModuleAccess uma
on m.ModuleID = uma.DeniedModuleID
and uma.UnitID=@unitID
where
m.CourseId= @courseID
and
m.Active = 1
order by m.Sequence







' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_UnitCompliance]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/**

Summary:		Get the compliance rules for all the modules attached to selected units.
Called by:		UnitComplianceReport.rdl
Example call:	exec prcreport_unitcompliance 109, 0, ''4463,4464,4465''

Author:			Mark Donald
Date created:	05/01/2010

Modification history
-----------------------------------------------------------
Author		Date			Description



**/
CREATE PROCEDURE [prcReport_UnitCompliance]
(
@organisationID	int,
@IncludeInactive int,
@UnitIDs varchar(8000)
)

AS

SET NOCOUNT ON

SELECT
hierarchyname as unitpathway, c.[name] as coursename, r.[name] AS modulename,
CASE lessonfrequency WHEN 0 THEN NULL ELSE lessonfrequency END AS lessonfrequency,
CASE quizfrequency WHEN 0 THEN NULL ELSE quizfrequency END AS quizfrequency,
lessoncompletiondate AS lessonexpirydate,
quizcompletiondate AS quizexpirydate,
quizpassmark AS passmark,
CASE usingdefault WHEN 1 THEN ''Yes'' ELSE ''No'' END AS ''default''
FROM
vwunitmodulerule r
LEFT JOIN tblunitmoduleaccess a ON a.unitid = r.unitid AND r.moduleid = deniedmoduleid,
tblunit u,
tblunithierarchy h,
tblcourse c,
tblModule m
WHERE
h.unitid = u.unitid
AND r.unitid = u.unitid
AND c.courseid = r.courseid
AND r.moduleid = m.moduleid
AND u.organisationid = @organisationid
AND (@includeinactive = 1 OR u.active = 1)
AND a.unitid IS NULL
AND u.unitid IN (SELECT * FROM dbo.udfcsvtoint(@unitids))
ORDER BY
unitpathway, coursename, [sequence], modulename

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Trend]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
refer to section 16.5.5.2 of Func. Spec. returns avg. score
and num of user per module for a selected course and unit

Called By: Report.cs, TrendReport.aspx.cs
Calls: udfCsvToInt

Remarks: Raises an error if a parameter is null

Author: Claude Nehme
Date Created: 16th of February 2004

prcReport_Trend "1,2,3", 1,1

Modification History
-----------------------------------------------------------
v#	Author			Date			Description
#1	Peter Kneale 	03/03/04		Added ''Passed or Failed Users only''
#2	Jack Liu		05/03/04		Remove the hierarchy unit, change to flat file
#3	Jack Liu		14/09/05		Order the result by Module
and order by most recent(the last recorded status with specified passmark)
#4	Usman Tjiudri	11 Nov 2005		Include BoldMark indicator for the latest PassMark record.
#5	j hedlefs		09/06/2011		timezone

*/

CREATE     Procedure [prcReport_Trend]
(
@organisationID integer = null,
@unitIDs varchar(8000) = null,
@courseID integer = null,
@fromDateOrg datetime,
@toDateOrg datetime
)

as
DECLARE @fromDate 		datetime
DECLARE @toDate 		datetime
SET @fromDate = dbo.udfDaylightSavingTimeToUTC(@fromDateOrg,@OrganisationID)
SET @toDate = dbo.udfDaylightSavingTimeToUTC(@toDateOrg,@OrganisationID)

Set NoCount On

If @courseID Is Null
Begin
Raiserror(''The Parameter @courseID was null.  @courseID does not accept Null values.'', 16, 1)
Return
End

-- Temporary table to store the query for further data manipulation.
Declare @tblResult Table
(
Unit		nVarchar(200),
UnitID		Int,
Course		nVarchar(100),
CourseID	Int,
Module		nVarchar(100),
ModuleID	Int,
NumOfUsers	Int,
QuizCount int,
QuizPassMark	Int,
AvgScore	Int,
LastUserQuizStatusID Int,
BoldMark	Bit -- Indicator whether current record should be bold or not
)

If @unitIDs Is Null
Begin
Insert Into @tblResult
(
Unit,
UnitID,
Course,
CourseID,
Module,
ModuleID,
NumOfUsers,
QuizCount,
QuizPassMark,
AvgScore,
LastUserQuizStatusID
)
Select 	dbo.udfGetUnitPathway(un.UnitID) as Unit,
un.UnitID,
min(co.Name) as  Course,
co.CourseID,
min(mo.Name) as Module,
mo.ModuleID,
count(DISTINCT usr.UserID) as NumOfUsers,
count(usr.UserID) as QuizCount,
uqs.QuizPassMark,
avg(uqs.QuizScore) as AvgScore,
max(uqs.UserQuizStatusID) as LastUserQuizStatusID
From
tblUser usr
inner join tblUnit un on un.UnitID = usr.UnitID
inner join tblUserQuizStatus uqs on usr.UserID = uqs.UserID
and (uqs.QuizStatusID = 2 or uqs.QuizStatusID = 3) 	-- Passed or Failed Users only
and uqs.DateCreated between @fromDate and dateadd(dd,1,@toDate)
inner join tblModule mo on mo.ModuleID = uqs.ModuleID
inner join tblCourse co on mo.CourseID = co.CourseID and co.CourseID = @courseID
Where
usr.UnitID is not null
and 	usr.Active = 1
and 	un.OrganisationID = @organisationID
Group By
un.UnitID,
co.CourseID,
mo.ModuleID,
uqs.QuizPassMark
Order By
Unit,
Course,
Module,
LastUserQuizStatusID desc

End
Else
Begin
Insert Into @tblResult
(
Unit,
UnitID,
Course,
CourseID,
Module,
ModuleID,
NumOfUsers,
QuizCount,
QuizPassMark,
AvgScore,
LastUserQuizStatusID
)
Select	dbo.udfGetUnitPathway(un.UnitID) as Unit,
un.UnitID,
min(co.Name) as  Course,
co.CourseID,
min(mo.Name) as Module,
mo.ModuleID,
count(DISTINCT usr.UserID) as NumOfUsers,
count(usr.UserID) as QuizCount,
uqs.QuizPassMark,
avg(uqs.QuizScore) as AvgScore,
max(uqs.UserQuizStatusID) as LastUserQuizStatusID
From
tblUser usr
inner join tblUnit un on un.UnitID = usr.UnitID
inner join dbo.udfCsvToInt(@unitIDs) as selectedUnit on selectedUnit.IntValue= un.UnitID
inner join tblUserQuizStatus uqs on usr.UserID = uqs.UserID
and (uqs.QuizStatusID = 2 or uqs.QuizStatusID = 3) 	-- Passed or Failed Users only
and uqs.DateCreated between @fromDate and dateadd(dd,1,@toDate)
inner join tblModule mo on mo.ModuleID = uqs.ModuleID
inner join tblCourse co on mo.CourseID = co.CourseID and co.CourseID = @courseID
Where
usr.UnitID is not null
and 	usr.Active = 1
Group By
un.UnitID,
co.CourseID,
mo.ModuleID,
uqs.QuizPassMark
Order By
Unit,
Course,
Module,
LastUserQuizStatusID desc
End

-- Update BoldMark field for group of records (by Unit, Course and Module) with more than one version of pass mark.
Update @tblResult
Set BoldMark = 1
Where LastUserQuizStatusID In (
Select tb.QuizStatusID From
(Select UnitID, CourseID, ModuleID, Max(LastUserQuizStatusID) As QuizStatusID from @tblResult Group by UnitID, CourseID, ModuleID having count(*) > 1) As tb
)

-- Returning records to callers
Select * From @tblResult


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetSALTAdministrators]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'






/*Summary:
Gets a list of all SALT Administrators.  Restrict to those with
the specified Active status if specified.

Parameters:
@active Bit

Returns:
Nothing

Called By:
User.cs.

Calls:
Nothing

Remarks:

Author: Gavin Buddis
Date Created: 23rd March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE   Procedure [prcUser_GetSALTAdministrators]
(
@requestedByUserID Integer = Null, -- User ID of the currently logged in user
@OrgID int
)

As

Set NoCount On

Select
UserID,
Username,
FirstName,
case
When Active = 0 Then LastName + '' (I)''
Else LastName
End As LastName,
Email,
Active,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @OrgID),
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @OrgID)
From
tblUser
Where
(UserID <> @requestedByUserID)
And (UserTypeID = 1)



' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetQuizHistory]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Returns the quiz history for a given user for a given module
Parameters: @UserID integer, @ModuleID integer
Returns:

Recordset 1
Status,
QuizPassMark,
QuizScore,
DateCreated,
QuizStatusID,
QuizSessionID

Called By:
User.cs
Calls:


Remarks: Raises an error if the parameter is null

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

-- prcUser_GetQuizHistory 1,1
*/
CREATE Procedure [prcUser_GetQuizHistory]
@UserID 	Integer,		-- UserID of the user that we want the quiz history on
@ModuleID 	Integer,		-- Module ID from which we need the quiz history information
@OrgID int
As
Set NoCount On

--------------------------------------------------------------------
---- Declarations
--------------------------------------------------------------------

--------------------------------------------------------------------
---- Logic
----- Get the Users Quiz Details
--------------------------------------------------------------------

Select
Status,
QuizPassMark,
QuizScore,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @OrgID) as DateCreated,
tblUserQuizStatus.QuizStatusID,
QuizSessionID
From
tblUserQuizStatus, tblQuizStatus
Where
tblUserQuizStatus.QuizStatusID = tblQuizStatus.QuizStatusID
And
tblUserQuizStatus.UserID = @userID
And
tblUserQuizStatus.ModuleID = @moduleID

Order By
DateCreated desc
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetOneWithOwnTime]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets the details of one User
Parameters: @userID integer
Returns: UserID, FirstName, LastName, UserName, Password, Email, ExternalID, OrganisationID, UnitID, UserTypeID, Active, CreatedBy, DateCreated, UpdatedBy, DateUpdated

Called By: User.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Gavin Buddis
Date Created: 10th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcUser_GetOneWithOwnTime]
(
@userID Integer = null -- User ID
)

As
Set NoCount On

If @userID Is Null
Begin
Raiserror(''The Parameter @userID was null.  @userID does not accept Null values.'', 16, 1)
Return
End

Select
UserID,
FirstName,
LastName,
UserName,
Password,
Email,
ExternalID,
OrganisationID,
UnitID,
UserTypeID,
Active,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, OrganisationID) as DateCreated,
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, OrganisationID) as DateUpdated,
dbo.udfUserUTCtoDaylightSavingTime(LastLogin, @userID) as LastLogin,
TimeZoneID,
DelinquencyManagerEmail

From
tblUser
Where
UserID = @userID




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets the details of one User
Parameters: @userID integer
Returns: UserID, FirstName, LastName, UserName, Password, Email, ExternalID, OrganisationID, UnitID, UserTypeID, Active, CreatedBy, DateCreated, UpdatedBy, DateUpdated

Called By: User.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Gavin Buddis
Date Created: 10th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcUser_GetOne]
(
	@userID Integer = null -- User ID
)

As
begin 

	Set NoCount On

	If @userID Is Null
	Begin
		Raiserror(''The Parameter @userID was null.  @userID does not accept Null values.'', 16, 1)
		Return
	End

	Select
		UserID,
		FirstName,
		LastName,
		UserName,
		Password,
		Email,
		ExternalID,
		OrganisationID,
		UnitID,
		UserTypeID,
		Active,
		CreatedBy,
		dbo.udfUTCtoDaylightSavingTime(DateCreated, OrganisationID) as DateCreated,
		UpdatedBy,
		dbo.udfUTCtoDaylightSavingTime(DateUpdated, OrganisationID) as DateUpdated,
		dbo.udfUTCtoDaylightSavingTime(LastLogin, OrganisationID) as LastLogin,
		TimeZoneID,
		DelinquencyManagerEmail,
		NotifyMgr,
		NotifyUnitAdmin,
		NotifyOrgAdmin
	From
		tblUser
	Where
		UserID = @userID
END



' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetDetailsByEmailAndDomain]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets the details of one User by their email address
Parameters: @emailAddress varchar(100)
Returns: UserID, FirstName, LastName, UserName, Password, Email, ExternalID, OrganisationID, UnitID, UserTypeID, Active, CreatedBy, DateCreated, UpdatedBy, DateUpdated

Called By: User.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Gavin Buddis
Date Created: 10th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcUser_GetDetailsByEmailAndDomain]
(
@emailAddress varchar(100) = null, -- Email Address
@DomainName varchar(100)
)

As
Set NoCount On

If @emailAddress Is Null
Begin
Raiserror(''The Parameter @emailAddress was null.  @emailAddress does not accept Null values.'', 16, 1)
Return
End

Select TOP (1)
UserID,
FirstName,
LastName,
UserName,
Password,
Email,
ExternalID,
tblUSer.OrganisationID,
UnitID,
UserTypeID,
Active,
tblUser.CreatedBy,
dbo.udfUTCtoDaylightSavingTime(tblUser.DateCreated, tblOrganisation.OrganisationID),
tblUser.UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(tblUser.DateUpdated, tblOrganisation.OrganisationID)
From
tblUser
INNER JOIN tblOrganisation ON tblOrganisation.OrganisationID = tblUser.OrganisationID
Where
Email = @emailAddress
AND DomainName like @DomainName+''%''
AND tblUser.Active = 1
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetDetailsByEmail]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Gets the details of one User by their email address
Parameters: @emailAddress varchar(100)
Returns: UserID, FirstName, LastName, UserName, Password, Email, ExternalID, OrganisationID, UnitID, UserTypeID, Active, CreatedBy, DateCreated, UpdatedBy, DateUpdated

Called By: User.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Gavin Buddis
Date Created: 10th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcUser_GetDetailsByEmail]
(
@emailAddress varchar(100) = null, -- Email Address
@OrgID int
)

As
Set NoCount On

If @emailAddress Is Null
Begin
Raiserror(''The Parameter @emailAddress was null.  @emailAddress does not accept Null values.'', 16, 1)
Return
End

Select
UserID,
FirstName,
LastName,
UserName,
Password,
Email,
ExternalID,
OrganisationID,
UnitID,
UserTypeID,
Active,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @OrgID),
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @OrgID)
From
tblUser
Where
Email = @emailAddress
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetArchiveUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
-- =============================================
-- Author:		Li Zhang
-- Create date: June 2008
-- Description:
-- =============================================
CREATE PROCEDURE [prcUser_GetArchiveUsers]
@fromDate datetime,
@inclNewUsers int,
@orgID int,
@userID int
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

set @fromDate = dbo.udfDaylightSavingTimeToUTC(@fromDate, @orgID)

declare @SelectedUnitIDs table
(unid int)

declare @usertype int
DECLARE @tblTemp table(
LastLogin nvarchar(200),
FirstName nvarchar(200),
LastName nvarchar(200),
Username nvarchar(200),
ExternalID nvarchar(50),
Email nvarchar(100),
UserID int)


-- Get user type
Select @UserType = UserTypeID from tblUser Where UserID = @UserID

-- salt and org admins
IF (@UserType in(1,2))
Begin
insert into @SelectedUnitIDs
select unitID
from
tblUnit Where OrganisationID = @orgID

end

-- unit admin
IF (@UserType = 3)
Begin
insert into @SelectedUnitIDs
select 	u.unitID
from 	tblUnit as u
inner join tblUnitAdministrator as ua
on (u.unitID=ua.unitID)
and (ua.userID = @userID)
where 	(u.organisationID=@orgID)
end


-- get users haven''t login after @fromDate
insert into @tblTemp
select
dbo.udfUTCtoDaylightSavingTime(LastLogin, @orgID), FirstName, LastName, Username, ExternalID,Email, UserID
from
tblUser
join @SelectedUnitIDs on unid = unitid
where
LastLogin < @fromDate
and OrganisationID =  @orgID
and Active = ''true''




if @inclNewUsers = 1
begin
insert into @tblTemp
select
''Never'', FirstName, LastName, Username, ExternalID, Email, UserID
from
tblUser
join @SelectedUnitIDs on unid = unitid
where
LastLogin is null and DateUpdated < @fromDate
and OrganisationID =  @orgID and Active = ''true''
end


select * from @tblTemp

END



SET QUOTED_IDENTIFIER ON
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets details of one Unit

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 10th of February 2004

prcUnit_GetOne 5

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcUnit_GetOne]
(
@unitID Integer = null
)

As

If @unitID Is Null
Begin
Raiserror(''The Parameter @unitID was null.  @unitID does not accept Null values.'', 16, 1)
Return
End

Select
u.UnitID,
u.Name,
u.ParentUnitID,
u.Hierarchy,
dbo.udfGetUnitPathway(u.UnitID) as Pathway,
u.Active,
u.OrganisationID,
o.OrganisationName as Organisation,
u.CreatedBy,
dbo.udfUTCtoDaylightSavingTime(u.DateCreated, u.OrganisationID) as DateCreated,
u.UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(u.DateUpdated, u.OrganisationID) as DateUpdated
From
tblUnit u
left join tblOrganisation o
on u.OrganisationID = o.OrganisationID
Where	u.UnitID = @unitID
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_GetModuleRule]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary:
Gets unit module compliance rules

Called By: Unit.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Jack Liu
Date Created: 18th of February 2004


Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcUnit_GetModuleRule 1, 1

*/

CREATE  Procedure [prcUnit_GetModuleRule]
(
@unitID Int,
@courseID int
)

As

set nocount on

Select 	m.ModuleID,
m.Name,
umr.UsingDefault,
isnull(umr.LessonFrequency, 0) as LessonFrequency,
isnull(umr.QuizFrequency, 0) as QuizFrequency,
umr.QuizPassMark,
dbo.udfUTCtoDaylightSavingTime(umr.LessonCompletionDate, u.OrganisationID) as LessonCompletionDate,
dbo.udfUTCtoDaylightSavingTime(umr.QuizCompletionDate, u.OrganisationID) as QuizCompletionDate
From vwUnitModuleRule umr
inner join tblModule m 	on m.ModuleID=  umr.ModuleID
join tblUnit u on u.UnitID = umr.UnitID
where umr.UnitID = @unitID
and umr.CourseId= @courseID
order by m.Sequence
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Progress]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		Name: prcReport_Progress
**
**		Called by:
**
**		Auth: Mark Donald
**		Date: 11 Jan 2010
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**
*******************************************************************************/


CREATE PROCEDURE [prcReport_Progress]
(
@organisationID int,
@unitIDs varchar(8000),
@courseIDs varchar(8000),
@includeInactive int,
@classificationID int
)
AS
SET NOCOUNT ON;
BEGIN
DECLARE @currentstatus TABLE (usercoursestatusid int)
INSERT INTO @currentstatus
SELECT
max(usercoursestatusid) usercoursestatusid
FROM
tblusercoursestatus
GROUP BY
userid, courseid

SELECT
hierarchyname ''unitpathway'', lastname, firstname, CASE u.active WHEN 1 THEN NULL ELSE ''(i)'' END flag,
c.name coursename, externalid, email, username, [status] currentstatus, previousstatus, (
SELECT
convert(varchar(10), dbo.udfUTCtoDaylightSavingTime(max(datecreated),@OrganisationID), 103)
FROM
tblusercoursestatus
WHERE
userid = s.userid
AND courseid = s.courseid
AND coursestatusid = 2
) AS lastcompletiondate
FROM
tblusercoursestatus s
INNER JOIN tblcourse c ON
c.courseid = s.courseid
AND c.courseid IN (SELECT IntValue FROM dbo.udfCsvToInt(@courseIDs))
INNER JOIN tbluser u ON
u.userid = s.userid
AND u.unitid IN (SELECT IntValue FROM dbo.udfCsvToInt(@unitIDs))
LEFT JOIN (
SELECT
userid, courseid, max(usercoursestatusid) usercoursestatusid -- 2nd most recent record
FROM
tblusercoursestatus
WHERE
usercoursestatusid NOT IN (SELECT usercoursestatusid FROM @currentstatus)
GROUP BY
userid, courseid
) AS p ON
s.userid = p.userid
AND s.courseid = p.courseid
LEFT JOIN (
SELECT
usercoursestatusid, v.coursestatusid, [status] previousstatus
FROM
tblusercoursestatus v
INNER JOIN tblcoursestatus z ON
v.coursestatusid = z.coursestatusid
WHERE
z.coursestatusid > 0
) AS def2 ON
def2.usercoursestatusid = p.usercoursestatusid
LEFT JOIN tbluserclassification g ON
g.userid = u.userid,
tblunithierarchy h,
tblcoursestatus def,
@currentstatus r
WHERE
h.unitid = u.unitid
AND def.coursestatusid = s.coursestatusid
AND s.usercoursestatusid = r.usercoursestatusid
AND u.organisationid = @organisationID
AND (@includeInactive = 1 OR u.active = 1)
AND (@classificationID = 0 OR classificationID = @classificationID)
ORDER BY
unitpathway, lastname, firstname, coursename
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Licensing]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE Procedure [prcReport_Licensing]
(
@strCourseLicensingID varchar(8000),
@OrganisationID int
)
AS

BEGIN

IF (@strCourseLicensingID = ''0'')
BEGIN
SELECT
Header.Name as CourseName,
Header.LicenseNumber,
Header.Period,
Header.LicensesRemaining,
tblUnitHierarchy.HierarchyName as UnitPathway,
tblUser.FirstName + '' '' + tblUser.LastName AS FullName,
tblUser.ExternalID,
tblUser.Email,
dbo.udfUTCtoDaylightSavingTime(tblUser.DateCreated, @OrganisationID) as DateCreated,
tblUser.Active,
CASE
WHEN (tblUser.Active = 0 AND DateArchived IS NULL) THEN ''YES''
ELSE CONVERT(varchar, dbo.udfUTCtoDaylightSavingTime(DateArchived, @OrganisationID), 103)
END AS DateArchive,
Header.LicensesUsed
FROM tblCourseLicensingUser
INNER JOIN tblUser ON tblCourseLicensingUser.UserID = tblUser.UserID
INNER JOIN tblUnitHierarchy ON tblUser.UnitID = tblUnitHierarchy.UnitID
RIGHT JOIN tblCourseLicensing ON tblCourseLicensingUser.CourseLicensingID = tblCourseLicensing.CourseLicensingID
and tblCourseLicensing.OrganisationID = @OrganisationID
RIGHT JOIN (
SELECT	tblCourseLicensing.CourseLicensingID,
tblCourse.Name,
tblCourseLicensing.LicenseNumber,
CONVERT(varchar, dbo.udfUTCtoDaylightSavingTime(tblCourseLicensing.DateStart, @OrganisationID), 103) + '' - '' + CONVERT(varchar, dbo.udfUTCtoDaylightSavingTime(tblCourseLicensing.DateEnd, @OrganisationID), 103) AS Period,
tblCourseLicensing.LicenseNumber - coalesce(COUNT(tblCourseLicensingUser.CourseLicensingUserID),0) AS LicensesRemaining,
coalesce(COUNT(tblCourseLicensingUser.CourseLicensingUserID),0) AS LicensesUsed
FROM tblCourseLicensingUser AS tblCourseLicensingUser
RIGHT JOIN tblCourseLicensing ON  tblCourseLicensingUser.CourseLicensingID = tblCourseLicensing.CourseLicensingID
and tblCourseLicensing.OrganisationID = @OrganisationID
INNER JOIN tblCourse ON tblCourseLicensing.CourseID = tblCourse.CourseID
WHERE tblCourseLicensing.OrganisationID = @OrganisationID
GROUP BY tblCourse.Name, tblCourseLicensing.LicenseNumber, tblCourseLicensing.DateStart,
tblCourseLicensing.DateEnd, tblCourseLicensing.CourseLicensingID
HAVING      (tblCourseLicensing.DateStart < GETUTCDATE()) AND (dateadd(d,1,tblCourseLicensing.DateEnd) > GETUTCDATE())
) AS Header ON tblCourseLicensing.CourseLicensingID = Header.CourseLicensingID
order by tblUnitHierarchy.HierarchyName,Header.Name,tblUser.FirstName + '' '' + tblUser.LastName

END
ELSE
BEGIN
SELECT
Header.Name as CourseName,
Header.LicenseNumber,
Header.Period,
Header.LicensesRemaining,
tblUnitHierarchy.HierarchyName as UnitPathway,
tblUser.FirstName + '' '' + tblUser.LastName AS FullName,
tblUser.ExternalID,
tblUser.Email,
dbo.udfUTCtoDaylightSavingTime(tblUser.DateCreated, @OrganisationID) as DateCreated,
tblUser.Active,
CASE
WHEN (tblUser.Active = 0 AND DateArchived IS NULL) THEN ''YES''
ELSE CONVERT(varchar, dbo.udfUTCtoDaylightSavingTime(DateArchived, @OrganisationID), 103)
END AS DateArchive,
Header.LicensesUsed
FROM tblCourseLicensingUser
INNER JOIN tblUser ON tblCourseLicensingUser.UserID = tblUser.UserID
INNER JOIN tblUnitHierarchy ON tblUser.UnitID = tblUnitHierarchy.UnitID
RIGHT JOIN tblCourseLicensing ON tblCourseLicensingUser.CourseLicensingID = tblCourseLicensing.CourseLicensingID
and tblCourseLicensing.OrganisationID = @OrganisationID
RIGHT JOIN (
SELECT	tblCourseLicensing.CourseLicensingID,
tblCourse.Name,
tblCourseLicensing.LicenseNumber,
CONVERT(varchar, dbo.udfUTCtoDaylightSavingTime(tblCourseLicensing.DateStart, @OrganisationID), 103) + '' - '' + CONVERT(varchar, dbo.udfUTCtoDaylightSavingTime(tblCourseLicensing.DateEnd, @OrganisationID), 103) AS Period,
tblCourseLicensing.LicenseNumber - coalesce(COUNT(tblCourseLicensingUser.CourseLicensingUserID),0) AS LicensesRemaining,
coalesce(COUNT(tblCourseLicensingUser.CourseLicensingUserID),0) AS LicensesUsed
FROM tblCourseLicensingUser AS tblCourseLicensingUser
RIGHT JOIN tblCourseLicensing ON tblCourseLicensingUser.CourseLicensingID = tblCourseLicensing.CourseLicensingID
and tblCourseLicensing.OrganisationID = @OrganisationID
INNER JOIN tblCourse ON tblCourseLicensing.CourseID = tblCourse.CourseID
inner join dbo.udfCsvToInt(@strCourseLicensingID) as CourseLicensing on CourseLicensing.IntValue= tblCourseLicensing.CourseLicensingID
WHERE tblCourseLicensing.OrganisationID = @OrganisationID
GROUP BY tblCourse.Name, tblCourseLicensing.LicenseNumber, dbo.udfUTCtoDaylightSavingTime(tblCourseLicensing.DateStart, @OrganisationID),
dbo.udfUTCtoDaylightSavingTime(tblCourseLicensing.DateEnd, @OrganisationID), tblCourseLicensing.CourseLicensingID
) AS Header ON tblCourseLicensing.CourseLicensingID = Header.CourseLicensingID
order by tblUnitHierarchy.HierarchyName,Header.Name,tblUser.FirstName + '' '' + tblUser.LastName
END
END
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetAdminsInOrgPendingPolicy]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary:		Mainly just returns a list of unit admins that meet the flagged conditions

Parameters:		Comma separated list of userID:courseID
Returns:		table (lastname nvarchar(50), firstname nvarchar(50), userid int, email nvarchar(100), policy_name varchar(8000))

Called By:		BusinessServices.{Policy.GetAdminsInOrgPendingPolicy in Policy.cs
Calls:			None

Remarks:		None

Author:			John H
Date Created:	21 MAy 2010

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcPolicy_GetAdminsInOrgPendingPolicy]
@policy_ids varchar(8000),
@unit_ids varchar(8000),
@accepted varchar (20),
@acceptedDateFrom 		datetime,
@acceptedDateTo 		datetime
AS
BEGIN
SET NOCOUNT ON;

DECLARE @policies TABLE (policyid int)
DECLARE @selected_units TABLE (unitid int)
DECLARE @result TABLE (firstname nvarchar(50), lastname nvarchar(50), userid int, email nvarchar(100), new_policy_names varchar(8000), modified_policy_names varchar(8000), HierarchyName nvarchar(500))
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50),
@userid int, @admid int,
@new_policy_names varchar(8000),
@users_with_policies varchar(8000),
@modified_policy_names varchar(8000),
@strAccepted varchar(5),
@aunit int,@orgID int

IF @accepted = ''0''
BEGIN
SELECT @strAccepted = ''True''
END
ELSE
BEGIN
SELECT @strAccepted = ''False''
END



-- rip the unit selection
INSERT INTO @selected_units
SELECT
*
FROM
dbo.udfCsvToInt(@unit_ids)

SELECT @policy_ids = replace(rtrim(ltrim(replace(replace(replace(@policy_ids,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''
SELECT @aunit = (SELECT TOP (1) unitid FROM @selected_units)
SELECT @orgID = OrganisationID FROM tblUnit WHERE tblUnit.UnitID = @aunit


set @acceptedDateFrom = dbo.udfDaylightSavingTimeToUTC(@acceptedDateFrom, @orgID)
set @acceptedDateTo = dbo.udfDaylightSavingTimeToUTC(@acceptedDateTo, @orgID)

-- rip the policies into a table
INSERT INTO @policies
SELECT
*
FROM
dbo.udfCsvToInt(@policy_ids)



--	SELECT DISTINCT adm.UserID, hier.HierarchyName, adm.LastName, adm.FirstName,  adm.email, '''',''''
SELECT DISTINCT adm.UserID, unt.Name as HierarchyName, adm.LastName, adm.FirstName,  adm.email, '''',''''
FROM
@policies pols
INNER JOIN tblUserPolicyAccess polacs ON polacs.policyid = pols.policyid AND polacs.granted = ''True''
INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))
INNER JOIN tblUser usr ON usr.userid = polacs.userid AND usr.userid = polacd.userid AND usr.active = ''True''
INNER JOIN @selected_units su ON usr.unitid = su.unitid
INNER JOIN udf_GetAdminEmailsForORG(@orgID) uadm ON uadm.UnitID = su.unitid
INNER JOIN tblUnitHierarchy hier ON hier.UnitID = usr.UnitID
INNER JOIN tblUnit unt ON unt.UnitID = usr.UnitID
INNER JOIN tblUser adm ON adm.userid = uadm.userid
WHERE NOT EXISTS
(SELECT *
FROM
@policies Spols
INNER JOIN tblUserPolicyAccess Spolacs ON Spolacs.policyid = Spols.policyid AND Spolacs.granted = ''True''
INNER JOIN tblUserPolicyAccepted Spolacd ON Spolacd.policyid = Spols.policyid AND Spolacd.Accepted = @strAccepted
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))
INNER JOIN tblUser Susr ON Susr.userid = Spolacs.userid AND Susr.userid = Spolacd.userid AND Susr.active = ''True''
INNER JOIN @selected_units Ssu ON Susr.unitid = Ssu.unitid
INNER JOIN udf_GetAdminEmailsForORG(@orgID) Suadm ON Suadm.UnitID = Ssu.unitid
INNER JOIN tblUnitHierarchy Shier ON Shier.UnitID = Susr.UnitID
INNER JOIN tblUnit Sunt ON Sunt.UnitID = Susr.UnitID
INNER JOIN tblUser Sadm ON Sadm.userid = Suadm.userid and Sadm.UserID = adm.UserID
WHERE (hier.hierarchy LIKE Shier.hierarchy+'',%'') )





END

/****** Object:  StoredProcedure [dbo].[prcProfilePoints_Add]    Script Date: 07/07/2011 17:22:53 ******/
SET ANSI_NULLS ON
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcOrganisation_Update] (
@LangCode nvarchar(10),
@organisationID Integer = Null, -- ID of the organisation to update.
@organisationName nVarChar(50) = Null, -- The name of the organisation.
@notes nVarChar(4000) = Null, -- The notes for the organisation.
@logo VarChar(100) = Null, -- The name of the organisation logo image.
@lessonFrequency Integer = Null, -- Default Lesson frequency for the organisation.
@quizFrequency Integer = Null, -- Default Quiz frequency for the organisation.
@quizPassMark Integer = Null, -- Default Quiz pass mark for the organisation.
@lessonCompletionDate DateTime = Null, -- Default Lesson completion date
@quizCompletionDate DateTime = Null, -- Default Quiz completion date
@advancedReporting bit = 0,
@actionUserID Integer = Null, -- ID of the User that is making the changes.
@originalDateUpdated DateTime, -- original Date of the record.
@CPDReportName nvarchar(255) = Null, -- CPD Report Name
@AllocatedDiskSpace int = Null,
@inclLogo bit = 0,	-- include certificate logo
@PasswordLockout bit,
@TimeZoneID int = Null,
@ShowLastPassed bit =1
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

set @lessonCompletionDate = dbo.udfDaylightSavingTimeToUTC(@lessonCompletionDate, @organisationID)
set @quizCompletionDate = dbo.udfDaylightSavingTimeToUTC(@quizCompletionDate, @organisationID)
set @originalDateUpdated = dbo.udfDaylightSavingTimeToUTC(@originalDateUpdated, @organisationID)

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number
Declare @intUserTypeOrgAdmin Integer -- Holds the value for the OrgAdmin UserTypeID from the tblUserType table.
Declare @dtCurrentDateUpdated DateTime -- Holds the current date updated date.

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0
Select @intUserTypeOrgAdmin = UserTypeID From tblUserType Where Type = ''Organisation Administrator''
Select @dtCurrentDateUpdated = DateUpdated From tblOrganisation Where OrganisationID = @organisationID

-- Validation Routines
If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If Not Exists(Select * From tblUser Where UserID = @actionUserID And UserTypeID <= @intUserTypeOrgAdmin)
Begin
Set @intErrorNumber = 6
Set @strErrorMessage = ''You do not have access to modify this Organisation.''
Goto Finalise
End

If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If(@organisationName Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationName in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If Exists(Select * From tblOrganisation Where OrganisationName = @organisationName And OrganisationID != @organisationID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Organisation Name '' + @organisationName + '' already exists please choose another name for your Organisation.''
Goto Finalise
End

If(@notes Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @notes in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If(@logo Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @logo in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If(@lessonFrequency Is Null and @lessonCompletionDate Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @lessonFrequency, @lessonCompletionDate in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If(@quizFrequency Is Null and @quizCompletionDate Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @quizFrequency, @quizCompletionDate in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If(@quizPassMark Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @quizPassMark in stored procedure  prcOrganisation_Update''
Goto Finalise
End

If(@originalDateUpdated != @dtCurrentDateUpdated)
Begin
Set @intErrorNumber = 7
Set @strErrorMessage = ''The organisation''''s details have been updated by another user, you will need to refresh the organisation''''s details and re-enter your changes.  Click here to refresh.''
Goto Finalise
End

If Exists(Select * From tblOrganisation Where OrganisationID = @organisationID)
Begin
Update tblOrganisation
Set
OrganisationName = @organisationName,
Logo = @logo,
DefaultLessonFrequency = @lessonFrequency,
DefaultQuizFrequency = @quizFrequency,
DefaultQuizPassMark = @quizPassMark,
DefaultLessonCompletionDate = @lessonCompletionDate,
DefaultQuizCompletionDate = @quizCompletionDate,
advancedReporting = IsNull(@advancedReporting,advancedReporting),
UpdatedBy = @actionUserID,
DateUpdated = GETUTCDATE(),
CPDReportName = @CPDReportName,
AllocatedDiskSpace = @AllocatedDiskSpace,
IncludeCertificateLogo = @inclLogo,
PasswordLockout = @PasswordLockout,
TimeZoneID = @TimeZoneID,
ShowLastPassed=@ShowLastPassed
Where
OrganisationID = @organisationID

update tblOrganisationNotes
set
Notes = @notes
where OrganisationID = @OrganisationID
and LanguageID = (select LangID from tblLang where LangCode = @LangCode)
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''Record not found in stored procedure prcOrganisation_Update''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
''Successfully Updated'' As ''ErrorMessage''
End


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_SetAdministrator]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Sets a new Organisation Administrator.

Parameters:
@updateUserID Integer
@actionUserID Integer
@organisationID Integer
@originalDateUpdated Integer

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
6. PermissionDeniedException
7. IntegrityViolationException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 13th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE Procedure [prcOrganisation_SetAdministrator]
(
@updateUserID Integer, -- ID of the User that you wish to set Admin rights for.
@actionUserID Integer, -- ID of the User that is making the changes.
@organisationID Integer, -- ID of the Organisation that this user must belong to.
@originalDateUpdated DateTime -- original Date of the record.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

set @originalDateUpdated = dbo.udfDaylightSavingTimeToUTC(@originalDateUpdated, @organisationID)

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

declare @intActionUserTypeID integer
Declare @dtCurrentDateUpdated DateTime -- Holds the current date updated date.

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Select @dtCurrentDateUpdated = dbo.udfUTCtoDaylightSavingTime(DateUpdated, @organisationID) From tblUser Where UserID = @updateUserID
Select @dtCurrentDateUpdated = DateUpdated From tblUser Where UserID = @updateUserID

-- Validation Routines
If(@updateUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdministrator''
Goto Finalise
End

If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdministrator''
Goto Finalise
End

select @intActionUserTypeID =UserTypeID
from tblUser
where UserID = @actionUserID

--if action user is not  Salt Administrator(1) or Org Administrator
If (@intActionUserTypeID>2)
Begin
Set @intErrorNumber = 6
Set @strErrorMessage = ''You do not have access to modify this User.  Click here to return to the login page.''
Goto Finalise
End

If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdministrator''
Goto Finalise
End

If(@originalDateUpdated != @dtCurrentDateUpdated)
Begin
Set @intErrorNumber = 7
Set @strErrorMessage = ''The user''''s details have been updated by another user, you will need to refresh the users details and re-enter your changes.  Click here to refresh.''
Goto Finalise
End

If Exists(Select * From tblUser Where UserID = @updateUserID)
Begin
Update tblUser
Set
UserTypeID = 2, -- Org admin
DateUpdated = GETUTCDATE()
Where
UserID = @updateUserID

delete
from tblUnitAdministrator
where userID = @updateUserID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''Record not found @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_RemoveAdministrator]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'




/*Summary:
Updates the specified Organisation Administrator to be a SALT User.

Parameters:
@updateUserID Integer
@actionUserID Integer
@organisationID Integer
@originalDateUpdated DateTime

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
6. PermissionDeniedException
7. IntegrityViolationException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 13th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE  Procedure [prcOrganisation_RemoveAdministrator]
(
@updateUserID Integer = Null, -- ID of the User that you wish to set Admin rights for.
@actionUserID Integer = Null, -- ID of the User that is making the changes.
@organisationID Integer = Null, -- ID of the Organisation that this user must belong to.
@originalDateUpdated DateTime -- original Date of the record.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

set @originalDateUpdated = dbo.udfDaylightSavingTimeToUTC(@originalDateUpdated, @organisationID)

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number
Declare @intUserTypeUser Integer -- Holds the value for the User UserTypeID from the tblUserType table.
Declare @intUserTypeOrgAdmin Integer -- Holds the value for the OrgAdmin UserTypeID from the tblUserType table.
Declare @dtCurrentDateUpdated DateTime -- Holds the current date updated date.

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0
Select @intUserTypeUser = UserTypeID From tblUserType Where Type = ''User''
Select @intUserTypeOrgAdmin = UserTypeID From tblUserType Where Type = ''Organisation Administrator''
Select @dtCurrentDateUpdated = DateUpdated From tblUser Where UserID = @updateUserID

-- Validation Routines
If(@updateUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If Not Exists(Select * From tblUser Where UserID = @actionUserID And UserTypeID <= @intUserTypeOrgAdmin)
Begin
Set @intErrorNumber = 6
Set @strErrorMessage = ''You do not have access to modify this User.  Click here to return to the login page.''
Goto Finalise
End

If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If(@originalDateUpdated != @dtCurrentDateUpdated)
Begin
Set @intErrorNumber = 7
Set @strErrorMessage = ''The user''''s details have been updated by another user, you will need to refresh the users details and re-enter your changes.  Click here to refresh.''
Goto Finalise
End

If Exists(Select * From tblUser Where UserID = @updateUserID)
Begin
Update tblUser
Set
UserTypeID = @intUserTypeUser
Where
UserID = @updateUserID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''Record not found @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End





' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_RemoveAdmin]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Updates the specified Organisation Administrator to be a SALT User.

Parameters:
@updateUserID Integer
@actionUserID Integer
@organisationID Integer
@originalDateUpdated DateTime

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
6. PermissionDeniedException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 13th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE   Procedure [prcOrganisation_RemoveAdmin]
(
@updateUserID Integer = Null, -- ID of the User that you wish to set Admin rights for.
@actionUserID Integer = Null, -- ID of the User that is making the changes.
@organisationID Integer = Null, -- ID of the Organisation that this user must belong to.
@originalDateUpdated DateTime -- original Date of the record.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

set @originalDateUpdated = dbo.udfDaylightSavingTimeToUTC(@originalDateUpdated, @organisationID)

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number
Declare @intUserTypeUser Integer -- Holds the value for the User UserTypeID from the tblUserType table.
Declare @intUserTypeOrgAdmin Integer -- Holds the value for the OrgAdmin UserTypeID from the tblUserType table.
Declare @dtCurrentDateUpdated DateTime -- Holds the current date updated date.

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0
Select @intUserTypeUser = UserTypeID From tblUserType Where Type = ''User''
Select @intUserTypeOrgAdmin = UserTypeID From tblUserType Where Type = ''Organisation Administrator''
Select @dtCurrentDateUpdated = DateUpdated From tblUser Where UserID = @updateUserID

-- Validation Routines
If(@updateUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If Not Exists(Select * From tblUser Where UserID = @actionUserID And UserTypeID <= @intUserTypeOrgAdmin)
Begin
Set @intErrorNumber = 6
Set @strErrorMessage = ''You do not have access to modify this User.  Click here to return to the login page.''
Goto Finalise
End

If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If(@originalDateUpdated != @dtCurrentDateUpdated)
Begin
Set @intErrorNumber = 7
Set @strErrorMessage = ''The user''''s details have been updated by another user, you will need to refresh the users details and re-enter your changes.  Click here to refresh.''
Goto Finalise
End

If Exists(Select * From tblUser Where UserID = @updateUserID)
Begin
Update tblUser
Set
UserTypeID = @intUserTypeUser
Where
UserID = @updateUserID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''Record not found @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End



' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcUser_Update] 
(
	@userID Integer = Null,
	@unitID Integer = Null,
	@firstName nvarchar(50) = Null,
	@lastName nvarchar(50) = Null,
	@userName nvarchar(100) = Null,
	@email nvarchar(100) = null,
	@active bit = null,
	@userTypeID Integer = Null,
	@updatedByUserID Integer = Null,
	@dateUpdated datetime = Null,
	@password nvarchar(50) = Null,
	@oldPassword nvarchar(50) = Null,
	@externalID nvarchar(50) = Null,
	@TimeZoneID Integer = Null,
	@DelinquencyManagerEmail nvarchar(100) = Null,
	@NotifyUnitAdmin bit = null,
	@NotifyOrgAdmin bit = null,
	@NotifyMgr bit = null
)

As BEGIN

	Set NoCount On
	Set Xact_Abort On

	Begin Transaction

	-- Declarations
	Declare @strErrorMessage Varchar(200) -- Holds the error message
	Declare @OrgTimeZone Integer -- Holds the ORG timezone
	Declare @intErrorNumber Integer -- Holds the error number
	Declare @UpdatedByUserTypeID Integer -- Holds the UserTypeID for the Updating user.
	Declare @blnChangePassword bit			-- Boolean value to indentify update of the password
	Declare @strCurrentPassword nvarchar(50) -- Holds the current password in the DB for this user
	Declare @strCurrentUserName nvarchar(100) -- Holds the current username in the DB for this user
	Declare @strCurrentEmail nvarchar(100) -- Holds the current email in the DB for this user
	Declare @organisationID Integer -- Used to set the OrgID to null when updating a SALT Administrator
	Declare @dteCurrentDateUpdated datetime -- Holds the current dateupdated in the DB for this user

	-- Initialise variables
	Set @strErrorMessage = ''''
	Set @intErrorNumber = 0
	Set @blnChangePassword = 0

	-- PARAMETER VALIDATION
	--==============================================================

	-- Verify @UnitID and OrgID
	Select
		@organisationID = OrganisationID
	From
		tblUser
	Where
		UserID = @userID

	--==================================================
	-- If 0 passed in (for a SALT Admin), insert nulls for
	-- Unit and Org IDs
	if (@UnitID = 0)
	begin
		Set @UnitID = null
		Set @OrganisationID = null
	end

	Select
		@OrgTimeZone = TimeZoneID
	From
		tblOrganisation
	Where
		OrganisationID = @OrganisationID

	if (@OrgTimeZone = @TimeZoneID)
	begin
		Set @TimeZoneID = null
	end

	--Missing or Null parameter {0} in stored procedure prcUser_Update
	--Validate Parameter @userID
	If(@userID Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcUser_Update''
		Goto Finalise
	End

	-- If user type is not SALT Administrator, validate parameter @UnitID
	If(@userTypeID <> 1)
	Begin
		If(@unitID Is Null)
		Begin
			Set @intErrorNumber = 5
			Set @strErrorMessage = ''Missing or Null parameter @unitID in stored procedure prcUser_Update''
			Goto Finalise
		End
	End

	--Validate Parameter @firstName
	If(@firstName Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @firstName in stored procedure prcUser_Update''
		Goto Finalise
	End

	--Validate Parameter @lastName
	If(@lastName Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @lastName in stored procedure prcUser_Update''
		Goto Finalise

	End

	--Validate Parameter @userName
	If(@userName Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @userName in stored procedure prcUser_Update''
		Goto Finalise
	End

	--Validate Parameter @email
	If(@email Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @email in stored procedure prcUser_Update''
		Goto Finalise
	End

	--Validate Parameter @active
	If(@active Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure prcUser_Update''
		Goto Finalise
	End

	--Validate Parameter @userTypeID
	If(@userTypeID Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @userTypeID in stored procedure prcUser_Update''
		Goto Finalise
	End

	--Validate Parameter @updatedByUserID
	If(@updatedByUserID Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @updatedByUserID in stored procedure prcUser_Update''
		Goto Finalise
	End

	--Validate Parameter @dateUpdated
	If(@dateUpdated Is Null)
	Begin
		Set @intErrorNumber = 5
		Set @strErrorMessage = ''Missing or Null parameter @dateUpdated in stored procedure prcUser_Update''
		Goto Finalise
	End

	-- Validate User Exists
	--=========================================================
	If Not Exists(Select * From tblUser Where UserID = @userID)
	Begin
		Set @intErrorNumber = 1
		Set @strErrorMessage = ''This record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''
		Goto Finalise
	End

	-- If a unit was specified make sure it exists
	--=========================================================
	If (@unitID Is Not Null)
	Begin
		If Not Exists(Select * From tblUnit Where UnitID = @unitID)
		Begin
			Set @intErrorNumber = 11
			Set @strErrorMessage = ''The specified unit could be found or may not be active.''
			Goto Finalise
		End
	End

	-- Integrity Constraint
	--=========================================================
	Select
		@dteCurrentDateUpdated = DateUpdated
	from
		tblUser
	Where
		UserID = @userID


	/*If (DateDiff(s, @dteCurrentDateUpdated, @dateUpdated) <> 0)
	Begin
	Set @intErrorNumber = 7
	Set @strErrorMessage = ''This record has already been updated by another user, please refresh your screen. If the problem persists please contact your administrator.''
	Goto Finalise
	End */


	-- Validate Passwords
	--=======================

	-- get Updating User, UserTypeID
	Select
		@UpdatedByUserTypeID = UserTypeID
	from
		tblUser
	Where
		UserID = @updatedByUserID

	if(@UpdatedByUserTypeID = 4)
	Begin

		-- SALT User
		If (@password Is Not Null or @oldPassword Is Not Null)
		Begin
			If(@password Is Null)
			Begin
				Set @intErrorNumber = 5
				Set @strErrorMessage = ''Missing or Null parameter @password in stored procedure prcUser_Update''
				Goto Finalise
			End

			If(@oldPassword Is Null)
			Begin
				Set @intErrorNumber = 5
				Set @strErrorMessage = ''Missing or Null parameter @oldPassword in stored procedure prcUser_Update''
				Goto Finalise
			End

			-- Get the current password in the DB
			Select
				@strCurrentPassword = Password
			From
				tblUser
			Where
				UserID = @userID

			-- Ensure old password match current password otherwise error
			if(@oldPassword <> @strCurrentPassword)
			Begin
				Set @intErrorNumber = 4
				Set @strErrorMessage = ''Your old password was entered incorrectly so the user details have not been saved. ''
				Set @strErrorMessage = @strErrorMessage + ''Please try again and if the problem persists please contact your administrator.''
				Goto Finalise
			End

			Set @blnChangePassword = 1
		End
	End
	else
	Begin
		-- Administrator
		-- if there is a value in @oldPassword then admin is attempting to update their own password
		if(@oldPassword Is Not Null)
			Begin
			-- Get the current password in the DB
			Select
				@strCurrentPassword = Password
			From
				tblUser
			Where
				UserID = @userID

			-- Ensure old password match current password otherwise error
			if(@oldPassword <> @strCurrentPassword)
			Begin
				Set @intErrorNumber = 4
				Set @strErrorMessage = ''Your old password was entered incorrectly so the user details have not been saved. ''
				Set @strErrorMessage = @strErrorMessage + ''Please try again and if the problem persists please contact your administrator.''
				Goto Finalise
			End

			Set @blnChangePassword = 1
		End

		If(@password Is Not Null)
		Begin
			Set @blnChangePassword = 1
		End
	End

	-- Validate Permisions
	--========================================
	if(@UpdatedByUserTypeID = 4)
	Begin
	-- Salt User can only update themselves
	if(@UpdatedByUserID <> @UserID)
	Begin
	Set @intErrorNumber = 41
	Set @strErrorMessage = ''You do not have the permissions required to update this user.''
	Goto Finalise
	End
	End


	-- Validate Unique UserName
	--========================================
	Select
	@strCurrentUserName = UserName
	From
	tblUser
	Where
	UserID = @userID

	-- Check for uniqueness if the username is changing
	if(@strCurrentUserName <> @userName)
	Begin
	If(@userTypeID <> 1)
	begin
	if Exists(Select * from tblUser where UserName = @userName and (organisationID=@organisationID or organisationID is null))
	Begin
	Set @intErrorNumber = 42
	Set @strErrorMessage = @userName
	Goto Finalise
	End
	end
	else
	begin
	if Exists(Select * from tblUser where UserName = @userName)
	Begin
	Set @intErrorNumber = 42
	Set @strErrorMessage = @userName
	Goto Finalise
	End
	end
	End


	-- Validate Unique UserName
	--========================================
	Select
	@strCurrentEmail = Email
	From
	tblUser
	Where
	UserID = @userID

	-- Check for uniqueness if the email address is changing
	if(@strCurrentEmail <> @email)
	If Exists(Select * From tblUser Where Email = @email)
	Begin
	Set @intErrorNumber = 43
	Set @strErrorMessage = @email
	Goto Finalise
	End


	-- only update if the user is moved to a new unit (so new unit is diff from the current unit)
	if (select unitid from tblUser where userid=@userid) <> @unitid
	begin


	-- update the profile access of the user
	-- give the user access to profiles for the selected unit
	update tbluserprofileperiodaccess set granted = 1
	where	userid = @userid
	and profileperiodid in (
	select profileperiodid from tblunitprofileperiodaccess where
	unitid = @unitID and granted = 1)

	-- give the user access to the policies for the selected unit.
	/*update tbluserpolicyaccess set granted = 1
	where	userid = @userid
	and policyid in (
	select policyid from tblunitpolicyaccess where
	unitid = @unitID and granted = 1)*/

	update upa1
	set upa1.granted = upa2.granted
	from tbluserpolicyaccess upa1
	inner join tblunitpolicyaccess upa2
	on upa1.policyid=upa2.policyid
	inner join tblPolicy p
	on upa1.policyid=p.policyid
	where
	upa1.userid=@userid and upa2.unitid=@unitid
	and p.deleted=0

	end



	-- Execute Update
	--===============================================================
	-- Update the record in tblUser
	if(@blnChangePassword = 1)
	Begin
		-- Update with password change
		Update 
			tblUser
		Set
			FirstName = @firstName,
			LastName = @lastName,
			UserName = @userName,
			Password = @password,
			Email = @email,
			OrganisationID = @organisationID,
			UnitID = @unitID,
			UserTypeID = @userTypeID,
			Active = @active,
			UpdatedBy = @updatedByUserID,
			DateUpdated = getutcDate(),
			ExternalID = @externalID,
			TimeZoneID = @TimeZoneID,
			DelinquencyManagerEmail = @DelinquencyManagerEmail,
			NotifyMgr = @NotifyMgr,
			NotifyOrgAdmin = @NotifyOrgAdmin,
			NotifyUnitAdmin =@NotifyUnitAdmin
		Where
			UserID = @userID
	End
	Else
	Begin
		Update 
			tblUser
		Set
			FirstName = @firstName,
			LastName = @lastName,
			UserName = @userName,
			Email = @email,
			UnitID = @unitID,
			UserTypeID = @userTypeID,
			Active = @active,
			UpdatedBy = @updatedByUserID,
			DateUpdated = getutcDate(),
			ExternalID = @externalID,
			TimeZoneID = @TimeZoneID,
			DelinquencyManagerEmail = @DelinquencyManagerEmail,
			NotifyMgr = @NotifyMgr,
			NotifyOrgAdmin = @NotifyOrgAdmin,
			NotifyUnitAdmin =@NotifyUnitAdmin
		Where
			UserID = @userID
	End


	update tblUser set DateArchived = getutcdate() where Active = 0 and DateArchived IS NULL AND UserID = @userID
	update tblUser set DateArchived = null where Active = 1 and NOT(DateArchived IS NULL) AND UserID = @userID


	-- update the user current status
	declare courseIDCursor cursor
	for
	select
	grantedcourseid
	from
	tblOrganisationCourseAccess oca
	where
	organisationid = (select organisationid from tblUser where userid=@userid)


	/*-- update course status for users
	declare @intOldCourseStatus int
	declare @intNewCourseStatus int
	declare @courseID int
	declare @moduleID int


	open courseIDCursor

	fetch next from courseIDCursor into @courseid
	while (@@FETCH_STATUS <> -1)
	begin
	if (@@FETCH_STATUS <> -2)
	begin
	exec @intOldCourseStatus = prcUserCourseStatus_GetStatus @courseID, @userID
	exec @intNewCourseStatus = prcUserCourseStatus_Calculate @courseID, @userID

	--select * from tbluser where userid=@userid

	--select * from tblUsercoursestatus where userid=@userid and courseid=@courseid

	print ''CourseID: '' + convert(varchar(10), @courseid)
	print ''Old Course Status : '' + convert(varchar(10), @intOldCourseStatus)
	print ''New Course Status : '' + convert(varchar(10), @intNewCourseStatus)

	if (@intOldCourseStatus <> -1) and (@intOldCourseStatus <> @intNewCourseStatus)
	begin
	print ''Insert''

	set @moduleID = (select top 1 m.moduleId from tblModule m where CourseID = @courseID and  and m.active = 1)  --prcUserCourseStatus_Insert will not update if module is inactive
	--print ''ModuleID: '' + convert(varchar(10), @moduleid)  + ''\n''
	exec prcUserCourseStatus_Insert @userID, @ModuleID, @intNewCourseStatus
	end
	end

	fetch next from courseIDCursor into @courseid
	end

	close courseIDCursor deallocate courseIDCursor*/



	-- Set the error message to successfull
	Set @strErrorMessage = ''Successfully Updated''

	-- Finalise the procedure
	Goto Finalise


	Finalise:
	If(@intErrorNumber > 0)
	Begin
	Rollback Transaction
	Select
	@intErrorNumber As ''ErrorNumber'',
	@strErrorMessage As ''ErrorMessage''
	End
	Else
	Begin
	Commit Transaction
	Select
	@intErrorNumber As ''ErrorNumber'',
	@strErrorMessage As ''ErrorMessage''
	End
END

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_PoliciesTotals]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/******************************************************************************
**		File: dbo.prcReport_PoliciesTotals.PRC
**		Name: prcReport_PoliciesTotals
**		Desc: For counting user policy acceptance by policy
**
**		Return values:
**			Policy
**			UnitPathway
**			Lastname
**			Firstname
**			Email
**			UserID
**			Accepted
**			DateAccepted
**
**		Called by:
**
**		Parameters:
**			@organisationID Integer = ''0''
**			@policyIDs varchar(8000) = ''0''
**			@unitIDs varchar(8000) = ''0''
**			@dateFrom datetime = Null
**			@dateTo datetime = Null
**			@acceptanceStatus varchar(20) = ''BOTH''
**			@includeInactiveUsers varchar(5) = ''false''
**
**		Input							Output
**     ----------							-----------
**
**		Auth: Mark Donald
**		Date: 14 Aug 2009
**
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		--------		--------				-------------------------------------------
**
*******************************************************************************/

CREATE PROCEDURE [prcReport_PoliciesTotals]
@organisationID Integer = 0,
@policyIDs varchar(8000) = ''0'',
@unitIDs varchar(8000) = ''0'',
@dateFromOrg datetime = Null,
@dateToOrg datetime = Null,
@acceptanceStatus varchar(20) = ''BOTH'',
@includeInactiveUsers varchar(5) = ''false''
AS
BEGIN
DECLARE @dateFrom 		datetime
DECLARE @dateTo 		datetime
SET @dateFrom = dbo.udfDaylightSavingTimeToUTC(@dateFromOrg,@OrganisationID)
SET @dateTo = dbo.udfDaylightSavingTimeToUTC(@dateToOrg,@OrganisationID)


SET NOCOUNT ON;
select
pol.PolicyName AS policy,
count (*) as totalusers,
sum(CASE WHEN ua1.Accepted = 1  and (ua1.DateAccepted >= @dateFrom and ua1.DateAccepted <= @dateTo) THEN 1 ELSE 0 END) AS totalaccepted,
sum(CASE WHEN ua1.Accepted = 1  and (ua1.DateAccepted >= @dateFrom and ua1.DateAccepted <= @dateTo) THEN 0 ELSE 1 END) AS totalnotaccepted
from tblPolicy pol
join tblOrganisation org on org.OrganisationID = pol.Organisationid and org.OrganisationID = @OrganisationID
join tblUser on tblUser.OrganisationID = org.OrganisationID and (@includeInactiveUsers=''true'' or tblUser.Active=1) and tblUser.UnitID in (select IntValue from dbo.udfCsvToInt(@unitIDs))
join tblUserPolicyAccepted ua1 on pol.PolicyID = ua1.PolicyID and tblUser.UserID = ua1.UserID
join tblUnitHierarchy on tblUser.UnitID = tblUnitHierarchy.UnitID
left join tblUserPolicyAccess upa on upa.PolicyID = pol.PolicyID and upa.UserID = tblUser.Userid
where upa.granted = 1 and pol.Active = 1 and pol.Deleted = 0 and pol.uploaddate between @dateFrom and @dateTo
and pol.PolicyID in ( select IntValue from dbo.udfCsvToInt(@policyIDs ) )
and (
--Condition A - ACCEPTED
( @acceptanceStatus=''ACCEPTED'' and exists(select * from tblUserPolicyAccepted where pol.PolicyID = tblUserPolicyAccepted.PolicyID and tblUser.UserID = tblUserPolicyAccepted.UserID and tblUserPolicyAccepted.DateAccepted >= @dateFrom and tblUserPolicyAccepted.DateAccepted <= @dateTo and tblUserPolicyAccepted.Accepted = 1 ) )
or
--Condition B - NOT_ACCEPTED
( @acceptanceStatus=''NOT_ACCEPTED'' and not exists(select * from tblUserPolicyAccepted where pol.PolicyID = tblUserPolicyAccepted.PolicyID and tblUser.UserID = tblUserPolicyAccepted.UserID and tblUserPolicyAccepted.DateAccepted >= @dateFrom and tblUserPolicyAccepted.DateAccepted <= @dateTo and tblUserPolicyAccepted.Accepted = 1) )
or
--Condition C - BOTH
@acceptanceStatus=''BOTH''
)
--and (@includeInactiveUsers=''true'' and exists )
group by pol.PolicyName
--ORDER BY policy, unitpathway, lastname, firstname

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_PoliciesGrandTotal]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/******************************************************************************
**		File: dbo.prcReport_PoliciesGrandTotal.PRC
**		Name: prcReport_PoliciesGrandTotal
**		Desc: counts total distinct users in policies report - basically, it''s a copy
**				of that report with the selects changed to return a total instead of data
**
**		Parameters:
**			@organisationID Integer = ''0''
**			@policyIDs varchar(8000) = ''0''
**			@unitIDs varchar(8000) = ''0''
**			@dateFrom datetime = Null
**			@dateTo datetime = Null
**			@acceptanceStatus varchar(20) = ''BOTH''
**			@includeInactiveUsers varchar(5) = ''false''
**
**		Input							Output
**     ----------							-----------
**
**		Auth: Mark Donald
**		Date: 27 Aug 2009
**
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		--------		--------				-------------------------------------------
**		09/06/2011	j hedlefs			timezone
*******************************************************************************/
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
CREATE Procedure [prcReport_PoliciesGrandTotal]
@organisationID Integer = ''0'',
@policyIDs varchar(8000) = ''0'',
@unitIDs varchar(8000) = ''0'',
@dateFromOrg datetime = Null,
@dateToOrg datetime = Null,
@acceptanceStatus varchar(20) = ''BOTH'',
@includeInactiveUsers varchar(5) = ''false''
AS
BEGIN
SET NOCOUNT ON;
DECLARE @dateFrom 		datetime
DECLARE @dateTo 		datetime
SET @dateFrom = dbo.udfDaylightSavingTimeToUTC(@dateFromOrg,@OrganisationID)
SET @dateTo = dbo.udfDaylightSavingTimeToUTC(@dateToOrg,@OrganisationID)

select
count(distinct tblUser.userid) as TotalDistinctUsers
from tblPolicy pol
join tblOrganisation org on org.OrganisationID = pol.Organisationid and org.OrganisationID = @OrganisationID
join tblUser on tblUser.OrganisationID = org.OrganisationID and (@includeInactiveUsers=''true'' or tblUser.Active=1) and tblUser.UnitID in (select IntValue from dbo.udfCsvToInt(@unitIDs))
join tblUserPolicyAccepted ua1 on pol.PolicyID = ua1.PolicyID and tblUser.UserID = ua1.UserID
join tblUnitHierarchy on tblUser.UnitID = tblUnitHierarchy.UnitID
left join tblUserPolicyAccess upa on upa.PolicyID = pol.PolicyID and upa.UserID = tblUser.Userid
where upa.granted = 1 and pol.Active = 1 and pol.Deleted = 0 and pol.uploaddate between @dateFrom and @dateTo
and pol.PolicyID in ( select IntValue from dbo.udfCsvToInt(@policyIDs ) )
and (
--Condition A - ACCEPTED
( @acceptanceStatus=''ACCEPTED'' and exists(select * from tblUserPolicyAccepted where pol.PolicyID = tblUserPolicyAccepted.PolicyID and tblUser.UserID = tblUserPolicyAccepted.UserID and tblUserPolicyAccepted.DateAccepted >= @dateFrom and tblUserPolicyAccepted.DateAccepted <= @dateTo and tblUserPolicyAccepted.Accepted = 1 ) )
or
--Condition B - NOT_ACCEPTED
( @acceptanceStatus=''NOT_ACCEPTED'' and not exists(select * from tblUserPolicyAccepted where pol.PolicyID = tblUserPolicyAccepted.PolicyID and tblUser.UserID = tblUserPolicyAccepted.UserID and tblUserPolicyAccepted.DateAccepted >= @dateFrom and tblUserPolicyAccepted.DateAccepted <= @dateTo and tblUserPolicyAccepted.Accepted = 1) )
or
--Condition C - BOTH
@acceptanceStatus=''BOTH''
)
--and (@includeInactiveUsers=''true'' and exists )

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Policies]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/******************************************************************************
**		File: dbo.prcReport_Policies.PRC
**		Name: prcReport_Policies
**		Desc: For reporting of Policy acceptance by users
**
**		Return values:
**			Policy
**			UnitPathway
**			Lastname
**			Firstname
**			Email
**			Accepted
**			DateAccepted
**
**		Called by:
**
**		Parameters:
**			@organisationID Integer = ''0''
**			@policyIDs varchar(8000) = ''0''
**			@unitIDs varchar(8000) = ''0''
**			@dateFrom datetime = Null
**			@dateTo datetime = Null
**			@acceptanceStatus varchar(20) = ''BOTH''
**			@includeInactiveUsers varchar(5) = ''false''
**
**		Input							Output
**     ----------							-----------
**
**		Auth: Chris Plewright
**		Date: 31 Jul 2008
**
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		--------		--------				-------------------------------------------
**		14/08/2009		Mark Donald				More detail in Order By clause
**												+ extra column (userid) in result set
**		09/06/2011		J hedlefs				tIMEZONE
*******************************************************************************/
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
CREATE Procedure [prcReport_Policies]
@organisationID Integer = ''0'',
@policyIDs varchar(8000) = ''0'',
@unitIDs varchar(8000) = ''0'',
@dateFromOrg datetime = Null,
@dateToOrg datetime = Null,
@acceptanceStatus varchar(20) = ''BOTH'',
@includeInactiveUsers varchar(5) = ''false''
AS

BEGIN

SET NOCOUNT ON;
DECLARE @dateFrom 		datetime
DECLARE @dateTo 		datetime
SET @dateFrom = dbo.udfDaylightSavingTimeToUTC(@dateFromOrg,@OrganisationID)
SET @dateTo = dbo.udfDaylightSavingTimeToUTC(@dateToOrg,@OrganisationID)

select
Policy = pol.PolicyName + '' ('' + pol.PolicyFileName + '')'',
UnitPathway = tblUnitHierarchy.HierarchyName,
--tblUser.Lastname,
CASE
WHEN tblUser.Active = 0 then LastName + '' (I)''
ELSE LastName
END AS LastName,
tblUser.Firstname,
tblUser.Email,
tblUser.userid,
Accepted = case when ua1.Accepted = 1  and (ua1.DateAccepted >= @dateFrom and ua1.DateAccepted <= @dateTo) then ''Yes'' else ''No'' end,
case when ua1.DateAccepted >= @dateFrom and ua1.DateAccepted <= @dateTo then  dbo.udfUTCtoDaylightSavingTime(ua1.DateAccepted,@OrganisationID)  else null end as DateAccepted
from tblPolicy pol
join tblOrganisation org on org.OrganisationID = pol.Organisationid and org.OrganisationID = @OrganisationID
join tblUser on tblUser.OrganisationID = org.OrganisationID and (@includeInactiveUsers=''true'' or tblUser.Active=1) and tblUser.UnitID in (select IntValue from dbo.udfCsvToInt(@unitIDs))
join tblUserPolicyAccepted ua1 on pol.PolicyID = ua1.PolicyID and tblUser.UserID = ua1.UserID
join tblUnitHierarchy on tblUser.UnitID = tblUnitHierarchy.UnitID
left join tblUserPolicyAccess upa on upa.PolicyID = pol.PolicyID and upa.UserID = tblUser.Userid
where upa.granted = 1 and pol.Active = 1 and pol.Deleted = 0 and pol.uploaddate between @dateFrom and @dateTo
and pol.PolicyID in ( select IntValue from dbo.udfCsvToInt(@policyIDs ) )
and (
--Condition A - ACCEPTED
( @acceptanceStatus=''ACCEPTED'' and exists(select * from tblUserPolicyAccepted where pol.PolicyID = tblUserPolicyAccepted.PolicyID and tblUser.UserID = tblUserPolicyAccepted.UserID and tblUserPolicyAccepted.DateAccepted >= @dateFrom and tblUserPolicyAccepted.DateAccepted <= @dateTo and tblUserPolicyAccepted.Accepted = 1 ) )
or
--Condition B - NOT_ACCEPTED
( @acceptanceStatus=''NOT_ACCEPTED'' and not exists(select * from tblUserPolicyAccepted where pol.PolicyID = tblUserPolicyAccepted.PolicyID and tblUser.UserID = tblUserPolicyAccepted.UserID and tblUserPolicyAccepted.DateAccepted >= @dateFrom and tblUserPolicyAccepted.DateAccepted <= @dateTo and tblUserPolicyAccepted.Accepted = 1) )
or
--Condition C - BOTH
@acceptanceStatus=''BOTH''
)
--and (@includeInactiveUsers=''true'' and exists )
ORDER BY policy, unitpathway, lastname, firstname

END


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetUsersByPolicyAndUnit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary:		Compiles a %POLICY_NAMES% block and returns it with a bunch of user info for sending email to that user
(Mainly just returns a list of users and the policies that they are assigned to (that meet the flagged conditions))

Parameters:		Comma separated list of userID:courseID
Returns:		table (lastname nvarchar(50), firstname nvarchar(50), userid int, email nvarchar(100), policy_name varchar(8000))

Called By:		BusinessServices.{Policy.GetUsersByPolicyAndUnit in Policy.cs
Calls:			None

Remarks:		None

Author:			Mark Donald (John R copied prcCourse_UserMashup - no optimising attempted as execution time expected to be small)
Date Created:	13 Nov 2009 (copied 18/05/2010)

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcPolicy_GetUsersByPolicyAndUnit]
@policy_ids varchar(8000),
@unit_ids varchar(8000),
@accepted varchar (20),
@acceptedDateFrom 		datetime,
@acceptedDateTo 		datetime
AS
BEGIN
SET NOCOUNT ON;

DECLARE @policies TABLE (policyid int)
DECLARE @selected_units TABLE (unitid int)
DECLARE @result TABLE (firstname nvarchar(50), lastname nvarchar(50), userid int, email nvarchar(100), new_policy_names varchar(8000), modified_policy_names varchar(8000), HierarchyName nvarchar(500))
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50),
@userid int,
@new_policy_names varchar(8000),
@modified_policy_names varchar(8000),
@strAccepted varchar(5)



IF @accepted = ''0''
BEGIN
SELECT @strAccepted = ''True''
END
ELSE
BEGIN
SELECT @strAccepted = ''False''
END



-- rip the user selection
INSERT INTO @selected_units
SELECT
*
FROM
dbo.udfCsvToInt(@unit_ids)

-- clean up the input so it resembles ''userid:policyid,userid:policyid,''
SELECT @policy_ids = replace(rtrim(ltrim(replace(replace(replace(@policy_ids,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''

-- rip the policies into a table
INSERT INTO @policies
SELECT
*
FROM
dbo.udfCsvToInt(@policy_ids)
-- Note to self: String operations take hundreds of times longer than cursor operations so first think of a way to limit the number of string operations, then get rid of the cursors.
SELECT @new_policy_names = ''''
SELECT @modified_policy_names = ''''
DECLARE concatenator CURSOR READ_ONLY FOR
SELECT DISTINCT
usr.userid
FROM
@policies pols
INNER JOIN tblUserPolicyAccess polacs ON polacs.policyid = pols.policyid AND polacs.granted = ''True''
INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))

INNER JOIN tblUser usr ON usr.userid = polacs.userid AND usr.userid = polacd.userid AND usr.active = ''True''
INNER JOIN @selected_units su ON usr.unitid = su.unitid
OPEN concatenator
FETCH NEXT FROM concatenator INTO @userid
WHILE @@FETCH_STATUS = 0
BEGIN
SELECT
@new_policy_names = @new_policy_names + [PolicyName] + char(13) + char(10) + char(9)
FROM
tblpolicy pol
INNER JOIN @policies pols ON	pol.policyid = pols.policyid
INNER JOIN tblUserPolicyAccess polacc ON polacc.policyid = pol.policyid AND polacc.granted = ''True''
INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))

INNER JOIN tblUser usr ON usr.userid = polacc.userid AND usr.active = ''True'' AND usr.userid = @userid

SELECT @new_policy_names = substring(@new_policy_names, 1, len(@new_policy_names) - 3)

INSERT INTO
@result
SELECT
usr.firstname, usr.lastname, usr.userid, usr.email, @new_policy_names, @modified_policy_names, hier.HierarchyName
FROM
tbluser usr
INNER JOIN tblUnitHierarchy hier ON hier.UnitID = usr.UnitID
WHERE
userid = @userid
SELECT @new_policy_names = ''''
SELECT @modified_policy_names = ''''
FETCH NEXT FROM concatenator INTO @userid
END
CLOSE concatenator
DEALLOCATE concatenator


--Get Data in report format
SELECT
DISTINCT UserID, HierarchyName, LastName, FirstName,  email, new_policy_names, modified_policy_names

FROM @result
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetPoliciesAssignedToUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*
Summary:		Compiles a %POLICY_NAMES% block and returns it with a bunch of user info for sending email to that user
(Mainly just returns a list of users and the policies that they are assigned to (that meet the flagged conditions))

Parameters:		Comma separated list of userID:courseID
Returns:		table (lastname nvarchar(50), firstname nvarchar(50), userid int, email nvarchar(100), policy_name varchar(8000))

Called By:		BusinessServices.{Policy.prcPolicy_GetUsersByPolicyAndUnit in Policy.cs
Calls:			None

Remarks:		None

Author:			Mark Donald (John R copied prcCourse_UserMashup - no optimising attempted as execution time expected to be small)
Date Created:	13 Nov 2009 (copied 18/05/2010)

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcPolicy_GetPoliciesAssignedToUsers]
@policy_ids varchar(8000),
@user_ids varchar(8000),
@accepted varchar (20),
@acceptedDateFrom 		datetime,
@acceptedDateTo 		datetime,
@OrgID int
AS

BEGIN
SET NOCOUNT ON;

set @acceptedDateFrom = dbo.udfDaylightSavingTimeToUTC(@acceptedDateFrom, @OrgID)
set @acceptedDateTo = dbo.udfDaylightSavingTimeToUTC(@acceptedDateTo, @OrgID)

DECLARE @policies TABLE (policyid int)
DECLARE @selected_users TABLE (userid int)
DECLARE @result TABLE (firstname nvarchar(50), lastname nvarchar(50), userid int, email nvarchar(100), new_policy_names varchar(8000), modified_policy_names varchar(8000), HierarchyName nvarchar(500))
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50),
@userid int,
@new_policy_names varchar(8000),
@modified_policy_names varchar(8000),
@strAccepted varchar(5)



IF @accepted = ''0''
BEGIN
SELECT @strAccepted = ''True''
END
ELSE
BEGIN
SELECT @strAccepted = ''False''
END



-- rip the user selection
INSERT INTO @selected_users
SELECT
*
FROM
dbo.udfCsvToInt(@user_ids)

-- clean up the input so it resembles ''userid:policyid,userid:policyid,''
SELECT @policy_ids = replace(rtrim(ltrim(replace(replace(replace(@policy_ids,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''

-- rip the policies into a table
INSERT INTO @policies
SELECT
*
FROM
dbo.udfCsvToInt(@policy_ids)
-- Note to self: String operations take hundreds of times longer than cursor operations so first think of a way to limit the number of string operations, then get rid of the cursors.
SELECT @new_policy_names = ''''
SELECT @modified_policy_names = ''''
DECLARE concatenator CURSOR READ_ONLY FOR
SELECT DISTINCT
userid
FROM
@selected_users
OPEN concatenator
FETCH NEXT FROM concatenator INTO @userid
WHILE @@FETCH_STATUS = 0
BEGIN
SELECT
@new_policy_names = @new_policy_names + [PolicyName] + char(13) + char(10) + char(9)
FROM
tblpolicy pol
INNER JOIN @policies pols ON	pol.policyid = pols.policyid
INNER JOIN tblUserPolicyAccess polacc ON polacc.policyid = pol.policyid AND polacc.granted = ''True'' AND polacc.userid = @userid
INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted AND polacd.userid = @userid
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))
INNER JOIN tblUser usr ON usr.userid = polacc.userid AND usr.active = ''True'' AND usr.userid = @userid

SELECT @new_policy_names = substring(@new_policy_names, 1, len(@new_policy_names) - 3)

INSERT INTO
@result
SELECT
usr.firstname, usr.lastname, usr.userid, usr.email, @new_policy_names, @modified_policy_names, hier.HierarchyName
FROM
tbluser usr
INNER JOIN tblUnitHierarchy hier ON hier.UnitID = usr.UnitID
WHERE
userid = @userid
SELECT @new_policy_names = ''''
SELECT @modified_policy_names = ''''
FETCH NEXT FROM concatenator INTO @userid
END
CLOSE concatenator
DEALLOCATE concatenator


--Get Data in report format
SELECT
DISTINCT UserID, HierarchyName, LastName, FirstName,  email, new_policy_names, modified_policy_names

FROM @result
END




' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetAcceptedUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Stored procedure to obtain the number of users who have accepted the policy
i.e. been allocated points for policy in current profile period

Parameters:
@OrganisationID int
@PolicyID int

Called By:

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

*/
create procedure [prcPolicy_GetAcceptedUsers]
(
@OrganisationID int,
@PolicyID int
)
as

select count(*) from
tblPolicy pol
join tblUserPolicyAccepted upa
on pol.PolicyID = upa.PolicyID
join tblUser u
on u.UserID = upa.UserID
where pol.PolicyID = @PolicyID
and pol.OrganisationID = @OrganisationID
and upa.Accepted = 1
and u.Active = 1

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_AdminMashup]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary:		Compiles a bunch of info based on the selected units/policies then filters it based on administrator selection
Parameters:		Comma separated list of userID:policyID, comma separated list of adminID (unit administrators)
Returns:		table (lastname firstname userid email policy_names)

Called By:		BusinessServices.policy.GetAdminMashup in policy.cs
Calls:			None

Remarks:		None

Author:			Mark Donald
Date Created:	20 Jan 2010

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcPolicy_AdminMashup]
@organisationID int,
@unitIDs 			varchar(MAX),
@policyIDs 			varchar(8000),
@input_csv varchar(8000),
@adminids varchar(8000),
@classificationID 	int,
@policyStatus	int,
@acceptedDateFrom 		datetime,
@acceptedDateTo 		datetime,
@includeInactive	int
AS
BEGIN
SET NOCOUNT ON;


set @acceptedDateFrom = dbo.udfDaylightSavingTimeToUTC(@acceptedDateFrom, @organisationID)
set @acceptedDateTo = dbo.udfDaylightSavingTimeToUTC(@acceptedDateTo, @organisationID)

declare @tblUserUnit table
(
UserID int,
UnitID int
)


declare @tblUnit table
(
unitID int
)

declare @tblUnitAdministrator table
(
unitID int,
AdminUserID int
)
Set Nocount On
Declare
@CONST_NOT_ACCEPTED     int,
@CONST_ACCEPTED     	int,
@CONST_UNKNOWN          int


set @CONST_NOT_ACCEPTED	= 0
set @CONST_ACCEPTED	    = 1
set @CONST_UNKNOWN		= 2


DECLARE @Units TABLE (UnitID INT)
DECLARE @policies TABLE (policyID INT)
DECLARE @policiesWithAccess TABLE (policyID INT PRIMARY KEY, [name] nvarchar(100))
DECLARE @UserModuleWithAccess TABLE (UserID INT, ModuleID INT, UnitID INT, PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE (ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE (UserID INT, UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @UsersQuizStatusNOTSTARTED TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @mashup TABLE (userid int, policyid int)
DECLARE @selectedadmin TABLE (adminid int)
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50)

INSERT INTO
@policies
SELECT
*
FROM
dbo.udfCsvToInt(@policyIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

INSERT INTO
@selectedadmin
SELECT
*
FROM
dbo.udfCsvToInt(@adminids)

if @policyStatus = @CONST_ACCEPTED
BEGIN
SELECT

untadm.UserID, usr.Email, adm.FirstName, adm.LastName, pol.policyID, pol.PolicyName, usr.FirstName, usr.LastName
FROM
@policies ps
INNER JOIN tblPolicy pol ON ps.policyID = pol.policyID
INNER JOIN tblUserPolicyAccepted polacp ON polacp.policyID = pol.policyID AND polacp.Accepted = ''True'' AND COALESCE(polacp.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom AND COALESCE(polacp.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo
INNER JOIN tblUserPolicyAccess polacs ON polacs.policyID = pol.policyID AND polacs.Granted = ''True'' AND polacp.userID = polacs.userID
INNER JOIN tblUser usr ON usr.userID = polacp.userID
INNER JOIN tblUnitAdministrator untadm ON untadm.UnitID = usr.UserID
INNER JOIN tblUser adm ON adm.UserID = untadm.UserID
WHERE pol.organisationID = @organisationID;
END
else
BEGIN
SELECT

untadm.UserID, usr.Email, adm.FirstName, adm.LastName, pol.policyID, pol.PolicyName, usr.FirstName, usr.LastName
FROM
@policies ps
INNER JOIN tblPolicy pol ON ps.policyID = pol.policyID
INNER JOIN tblUserPolicyAccepted polacp ON polacp.policyID = pol.policyID AND polacp.Accepted = ''False''
INNER JOIN tblUserPolicyAccess polacs ON polacs.policyID = pol.policyID AND polacs.Granted = ''True'' AND polacp.userID = polacs.userID
INNER JOIN tblUser usr ON usr.userID = polacp.userID
INNER JOIN tblUnitAdministrator untadm ON untadm.UnitID = usr.UserID
INNER JOIN tblUser adm ON adm.UserID = untadm.UserID
WHERE pol.organisationID = @organisationID;

END

END




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcVersion_Set]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Set the product version with version ID

Parameters:


Returns:
None

Called By:
Database Configuration

Calls:
None

Remarks:

Author: Jack Liu
Date Created: 8/March/2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


*/

CREATE procedure [prcVersion_Set]
(
@version varchar(50)
)
as
set nocount on

update tblVersion
set version =@version


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcVersion_Get]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Get the current product version

Parameters:


Returns:
None

Called By:
Database Configuration

Calls:
None

Remarks:

Author: Jack Liu
Date Created: 8/March/2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


*/

CREATE procedure [prcVersion_Get]
as
set nocount on

select version from tblVersion


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetPercentExpectedEmails]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 15/06/2011
-- Description:	Calculates the percentage of expected emails sent in the last day
--				The percentage is calculated on the average workload
--				(averaged over last 7 days)
-- =============================================
CREATE FUNCTION [udfGetPercentExpectedEmails]
(
@OrgName nvarchar(50)
)
RETURNS int
AS
BEGIN
-- Declare the return variable here
DECLARE @ExpectedEmails int
DECLARE @EmailsinLastDay int
DECLARE @EmailsinLast7days int

SET @EmailsinLastDay = (SELECT COUNT(OrganisationID) FROM dbo.tblEmail
WHERE OrganisationID = (SELECT OrganisationID FROM tblOrganisation WHERE OrganisationName = @OrgName) AND
DateCreated BETWEEN DATEADD(DAY, -1, GETUTCDATE()) AND GETUTCDATE())

SET @EmailsinLast7days = (SELECT COUNT(OrganisationID) FROM dbo.tblEmail
WHERE OrganisationID = (SELECT OrganisationID FROM tblOrganisation WHERE OrganisationName = @OrgName) AND
DateCreated BETWEEN DATEADD(DAY, -7, GETUTCDATE()) AND GETUTCDATE())

IF (@EmailsinLast7days <> 0)
BEGIN
SET @ExpectedEmails = ((@EmailsinLastDay * 7 * 100)/@EmailsinLast7days)
END
ELSE
SET @ExpectedEmails = 0

-- Return the result of the function
RETURN @ExpectedEmails

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_ImportPreview]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/****** Object:  StoredProcedure [dbo].[prcUser_ImportPreview]    Script Date: 07/15/2008 12:42:55 ******/

/*
Summary: Uploads the details from an XML document to the tblUser table
Parameters:
@userXML text The XML document containing the User data.
@ID Integer ID of either the Organisation or Unit
@hierachy VarChar(12) hierachy where the call to upload useres was made from. can only be Organisation or Unit.
@userID Integer = null -- ID of user inporting the xmlData
Returns:
two Result sets

One: The first result set has the totals for the Upload
Total of Records in the XML File
Total of Successfully Inserted Records
Total of Already Existing Records
Total of  Records with error details

Two: The second result set holds the detail of the records that failed to insert.
RecordNumber
Username
Password
Firstname
Lastname
Email
ExternalID
ClassificationName
ClassificationOption

Called By:
User.cs
Calls:
sp_xml_preparedocument -- system stored procedure to ALTER  an internal representation of the XML document.
sp_xml_removedocument -- system stored procesure to remove the previously created representation of the XML document.

Remarks: The XML document must be well formed otherwise the process will fail.

Process
--1. Get the Organisation ID and unit ID
--2. Get a list of users that will be imported
--3. Data Validation
any other validation???
--4. Insert valid user data to user  and  user classification tables
--5. Get the summary report of the imported users
--6. Get all records with details of errors found in the data records

Author: Peter Vranich
Date Created: 10th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date		Description
#1	Peter Kneale	23/2/04		Changed name from prcImportUsers to prcUser_Import
#2	jack Liu	9/03/04		Reorganize the process and put comments
#3	Peter Kneale	2/12/2004	An empty Extenal ID is now treated as a null value.
#4	Jack Liu	14/09/2005	Validate UnitID, the unitID must be inside the specified organisation
UserName is unique per organisation
#5  Li Zhang	Jul	2008	added unique field for updating existing user data
#5  						the actual function of insert/update to the user data are not perform in this stored procedure
#5							it''s used to prepare preview user data record before importing user data records to tblUser

Test:
exec prcUser_Import @userXMLData = ''<BDWUserUpload><User Username="imported22" Firstname="Imported" Lastname="User1" Email="imported.user1@bdw.com" ExternalID="IU1">
<CustomClassifications><CustomClassification Name="State" Option="NSW"/></CustomClassifications>
</User>
<User Username="imported22" Firstname="Imported" Lastname="User2" Email="imported.user2@bdw.com" ExternalID="IU2">
<CustomClassifications><CustomClassification Name="State" Option="ACT"/></CustomClassifications>
</User></BDWUserUpload>'', @ID = 18, @hierachy = ''Organisation'', @userID = 1100
*/

CREATE    Procedure [prcUser_ImportPreview]
(
	@userXMLData nText = null, 	-- XML document
	@ID Integer = null,		-- ID
	@hierachy nVarChar(12) = null, 	-- hierachy where the call to upload useres was made from.
	--can only be Organisation or Unit.
	@userID Integer = null, 		-- ID of user importing the xmlData
	@uniqueField Integer = null
)

As
Begin

	Set NoCount On

	Set Xact_Abort On
	Begin Transaction


	--Declarations
	-- OrganisationID of the Unit that the Users are being imported too.
	Declare @intOrganisationID Integer
	Declare @intUnitID Integer

	Declare @hdoc Integer 			-- Is the document handle of the internal representation of an XML document.
	Declare @strRowPattern Varchar(19) 	-- The row pattern to be used with the OPENXML statement.
	Declare @intRecordCountTotal Integer 	-- Number of rows inserted
	-- Set the rowpattern for the Openxml statement.
	Set @strRowPattern = ''/BDWUserUpload/User''

	Declare @constant_EmailAddress int
	Declare @constant_UserName int

	set @constant_EmailAddress  = 1
	set @constant_UserName = 2

	--1. Get the Organisation ID and unit ID
	If(@hierachy = ''Unit'')
	Begin
		set @intUnitID = @ID
		-- Get the OrganisationID for this Unit.
		Select
		@intOrganisationID = OrganisationID
		From
		tblUnit
		Where
		UnitID = @ID
	end
	else
		begin
		set @intUnitID = null
		set @intOrganisationID = @ID
	end

	--2. Get a list of users that will be imported
	-- Create a temp table to hold the values from the XML document
	Create Table #xmlUserData
	(
		TempUserID				Integer Identity(1, 1),
		UnitID					int default(null),
		Username				nVarchar(50) COLLATE database_default Not Null,
		Password				nVarchar(50) COLLATE database_default Not Null,
		Firstname				nVarchar(50) COLLATE database_default,
		Lastname				nVarchar(50) COLLATE database_default,
		Email					nVarchar(50) COLLATE database_default  Not Null,
		ExternalID				nVarchar(50) COLLATE database_default,
		ClassificationName		nVarchar(50) COLLATE database_default,
		ClassificationOption	Varchar(50)  COLLATE database_default,
		Status					int  default(Null),-- ErrorFound:1, Updated:2, Added:3
		Reason					varchar(1000)  COLLATE database_default,
		ErrField				varchar(255) default(Null),
		Archive					varchar (1) default(''2''),
		NotifyUnitAdmin			nVarchar(3) COLLATE database_default default(''No''),
		NotifyOrgAdmin			nVarchar(3) COLLATE database_default default(''No''),
		ManagerNotification		nVarchar(3) COLLATE database_default default(''No''),
		ManagerToNotify			nVarchar(50) COLLATE database_default default(null),
		UpdField				varchar(255) default ('''')
	)


	Exec sp_xml_preparedocument @hdoc Output, @userXMLData

	-- Get the records from the XML file and insert them into the temp table.

	Insert Into #xmlUserData
	(
		UnitID,
		Username,
		Password,
		Firstname,
		Lastname,
		Email,
		ExternalID,
		Archive,
		ClassificationName,
		ClassificationOption,
		NotifyUnitAdmin,
		NotifyOrgAdmin,
		ManagerNotification,
		ManagerToNotify
	)
	Select
		*
	From
		OpenXml(@hdoc, @strRowPattern)
	With
	(
		UnitID					int		''@UnitID'',
		Username				nVarchar(50) ''@Username'',
		Password				nVarchar(50) ''@Password'',
		Firstname				nVarchar(50) ''@Firstname'',
		Lastname				nVarchar(50) ''@Lastname'',
		Email					nVarchar(50) ''@Email'',
		ExternalID				nVarchar(50) ''@ExternalID'',
		Archive					nVarchar (1)		''@Archive'',
		ClassificationName		Varchar(50) ''CustomClassifications/CustomClassification/@Name'',
		ClassificationOption	Varchar(50) ''CustomClassifications/CustomClassification/@Option'',
		NotifyUnitAdmin			nVarchar (3)		''@NotifyUnitAdmin'',
		NotifyOrgAdmin			nVarchar (3)		''@NotifyOrgAdmin'',
		ManagerNotification		nVarchar (3)		''@ManagerNotification'',
		ManagerToNotify			nVarchar (50)		''@ManagerToNotify''
	)


	-- Ensure that any values that should be null havent been cast to 0 instead of NULL
	Update
		#xmlUserData
	Set
		UnitID = null
	Where
		UnitID = 0

	Update
		#xmlUserData
	Set
		ErrField = ''''

	--======================================================--
	-- SECURITY												--
	--======================================================--
	Declare @UserType int	-- the type of the user

	-- Get user type
	Select @UserType = UserTypeID from tblUser Where UserID = @UserID

	-- Salt Administrator
	-----------------------------
	--IF (@UserType = 1)
	-- This user is allowed to perform any action


	-- Organisation Administrator
	-----------------------------
	IF (@UserType = 2)
	Begin
		-- See if any units in the temp table are not found in this organisation
		Update
			#xmlUserData
		Set
			Status = 1,
			Reason = ''Reason1'',
			ErrField = '';6''
		Where
			UnitID is not null
			and UnitID not in (select UnitID from tblUnit Where OrganisationID = @intOrganisationID)
	End

	-- Unit Administrator
	IF (@UserType = 3)
	Begin
		-- A table of units that this user can administer
		Create Table #AdministerableUnits
		(
			UnitID int
		)

		-- populate the list
		Insert into
			#AdministerableUnits
		select
			u.UnitID
		from
			tblUnit as u
			inner join tblUnitAdministrator as ua on (u.unitID=ua.unitID) and (ua.userID = @userID)

		-- update rows that arent present in the users list of administerbale units.
		Update
			#xmlUserData
		Set
			Status = 1,
			Reason = ''Reason2'',
			ErrField = #xmlUserData.ErrField + '';6''
		Where
			UnitID is not null
			and
			UnitID not in (select UnitID from #AdministerableUnits)
		
		--check that the unitadmin is not updating the org admin
		
		if @uniqueField= @constant_EmailAddress  
		begin
			-- join on the email address
			update 
				#xmlUserData
			set
				Status= 1,
				Reason = ''Reason2'',
				ErrField = #xmlUserData.ErrField +'';1''
			From
				#xmlUserData
				inner Join tblUser As usr
					On #xmlUserData.Email = usr.Email and usr.UserTypeID <3
		end
		else begin
			-- join on the username
			update 
				#xmlUserData
			set
				Status= 1,
				Reason = ''Reason2'',
				ErrField = #xmlUserData.ErrField +'';1''
			From
				#xmlUserData
				inner Join tblUser As usr
					On #xmlUserData.Username = usr.Username and usr.UserTypeID <3
		end
		
		
		Drop table #AdministerableUnits
	End

	-- Normal User
	if (@UserType = 4)
	Begin
		Select ''Status1'' as ''Status''
		Select *, 0 as ''RecordNumber'' from #xmlUserData
		Rollback
		return
	End
	--======================================================--
	-- SECURITY FINISHED									--
	--======================================================--


	-- Get the total number of records to be processed.
	Set @intRecordCountTotal = @@Rowcount
	if ((select count(1) from #xmlUserData) > 1000)
	Begin
		Select ''Status2'' as ''Status''
		Select *, 0 as ''RecordNumber'' from #xmlUserData
		Rollback
		return
	End
	-- remove the internal representation of the XML Document.
	Exec sp_xml_removedocument @hdoc

	--3. Data Validation

	-- Validate that specified units exist (not active or not in this organisation).
	-- and the unitID must be inside the specified organisation -#4
	Update
		#xmlUserData
	Set
		Status = 1,
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason3'',
		ErrField = '';6''
	Where	
		UnitID is not null
		And
		UnitID not in (select UnitID from tblUnit Where Active=1 and OrganisationID = @intOrganisationID)


	--fields that connot be deleted and have a ^ to be treated as NC

	update 
		#xmlUserData
	set
		--UnitID = case when UnitID=''^'' then '''' else unitid end,
		Username= case when Username = ''^''  or username is null then '''' else Username end,
		Password = case when Password = ''^'' then '''' else password end,
		Firstname= case when Firstname =  ''^'' then '''' else firstname end,
		Lastname = case when Lastname = ''^'' then '''' else lastname end,
		Email = case when Email = ''^'' OR Email IS NULL then '''' else email end,
		Archive = case when Archive = ''^'' then '''' else archive end,
		NotifyUnitAdmin = case when NotifyUnitAdmin = ''^'' then '''' else notifyunitadmin end,
		NotifyOrgAdmin = case when NotifyOrgAdmin  = ''^'' then '''' else NotifyOrgAdmin end,
		ManagerNotification = case when ManagerNotification = ''^'' then '''' else ManagerNotification end
		
	
	
	/*-- if the unique field is email address and its blank then error
	if @uniqueField = @constant_EmailAddress 
	begin
		update 
			#xmlUserData
		set
			Reason = ''Reason10'', -- change this to the correct reason
			Status = 1,
			ErrField  = '';5''
		where Email =''''
	end
	
	
	if @uniqueField = @constant_UserName
	begin 
		update 
			#xmlUserData
		set
			Reason = ''Reason10'', -- change this to the correct reason
			Status = 1,
			ErrField  = '';1''
		where Username =''''
	
	end */
	
	
	-- Get a list of users whose user names already exist
	-- when unique field is username, and username is found in database, update record
	Update
		#xmlUserData
	Set
		Status = CASE @uniqueField 
			WHEN @constant_UserName THEN
				ISNULL(#xmlUserData.Status,2)
			ELSE
				case when usr.email = #xmlUserData.Email then
					ISNULL(#xmlUserData.Status,2)
				else
					1
				end
			END,
		Reason = CASE @uniqueField 
			WHEN @constant_UserName	THEN
				#xmlUserData.Reason
			ELSE
				case when usr.email = #xmlUserData.Email then
					#xmlUserData.Reason
				else
					isNull(#xmlUserData.Reason+''; '','''')+ ''Reason4''
				end
			END,
		ErrField = CASE @uniqueField 
			WHEN @constant_UserName THEN
				#xmlUserData.ErrField
			ELSE
				case when usr.email = #xmlUserData.Email then
					#xmlUserData.ErrField
				else
					#xmlUserData.ErrField+'';1''
				end
			END
	From
		#xmlUserData
		inner Join tblUser As usr
			On #xmlUserData.Username = usr.Username and (usr.OrganisationID = @intOrganisationID or usr.OrganisationID is null)


	-- Get a list of users whose email addresses already exist
	-- Business logic changed:
	--when unique field is email address, and email address is exists, update record
	Update
		#xmlUserData
	Set
		Reason = CASE @uniqueField 
				WHEN @constant_EmailAddress THEN
					case when  (@intOrganisationID = usr.organisationid) then
						#xmlUserData.Reason
					else
						isNull(#xmlUserData.Reason+''; '','''')+ ''Reason5''
					end
				ELSE
					case when #xmlUserData.Email = usr.Email and @intOrganisationID = usr.organisationid then
						#xmlUserData.Reason
					else
						isNull(#xmlUserData.Reason+''; '','''')+ ''Reason5''
					end
				END,
		Status = CASE @uniqueField WHEN @constant_EmailAddress THEN
					case when  (@intOrganisationID = usr.organisationid) then
						ISNULL(#xmlUserData.Status,2)
					else
						1
					end
				ELSE
					case when #xmlUserData.Email = usr.Email and @intOrganisationID = usr.organisationid then
						ISNULL(#xmlUserData.Status,2)
					else
						1
					end
				END,
		ErrField = CASE @uniqueField WHEN @constant_EmailAddress THEN
						case when  (@intOrganisationID = usr.organisationid) then
							#xmlUserData.ErrField
						else
							#xmlUserData.ErrField + '';5''
						end
					ELSE
						case when #xmlUserData.Email = usr.Email and @intOrganisationID = usr.organisationid	then
							#xmlUserData.ErrField
						else
							#xmlUserData.ErrField + '';5''
						end
					END
	From
		#xmlUserData
		inner Join tblUser As usr On #xmlUserData.Email = usr.Email

	--Get a list of users whose user name are duplicated in this batch
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason6'',
		Status = 1,
		ErrField = #xmlUserData.ErrField + '';1''
	From
		#xmlUserData
		inner  join #xmlUserData u2 On #xmlUserData.Username = u2.Username and u2.TempUserID>#xmlUserData.TempUserID

	-- This adds the reason code to the other records with the duplicated user name
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason6'',
		Status = 1,
		ErrField = #xmlUserData.ErrField + '';1''
	From
		#xmlUserData
		inner  join #xmlUserData u2 On #xmlUserData.Username = u2.Username and u2.TempUserID<#xmlUserData.TempUserID 
			and #xmlUserData.TempUserID not in
				(	select u3.TempUserID 
					from #xmlUserData u3
						inner  join #xmlUserData u4 On u3.Username = u4.Username 
									and u4.TempUserID>u3.TempUserID
				)

	--Get a list of users whos username is the same as their password
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason7'',
		Status = 1,
		ErrField = #xmlUserData.ErrField + '';1;2''
	From
		#xmlUserData
	Where
		UserName = Password

	--Get a list of users whose email addresses are duplicated in this batch
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason8'',
		Status = 1,
		ErrField = #xmlUserData.ErrField + '';5''
	From
		#xmlUserData
		inner  join #xmlUserData u2 On #xmlUserData.Email = u2.Email 
					and u2.TempUserID>#xmlUserData.TempUserID
	where #xmlUserData.Email <>''''

	-- This adds the reason code to the other records with the duplicated emails
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason8'',
		Status = 1,
		ErrField = #xmlUserData.ErrField + '';5''
	From
		#xmlUserData
		inner  join #xmlUserData u2 on #xmlUserData.Email = u2.Email and u2.TempUserID<#xmlUserData.TempUserID
					and #xmlUserData.TempUserID not in
						(	select u3.TempUserID 
							from #xmlUserData u3
								inner  join #xmlUserData u4	On u3.Email = u4.Email
										and u4.TempUserID>u3.TempUserID
						)
	where #xmlUserData.Email <>''''


	-- Get a list of users who are missing a first or last name
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason9'',
		Status = 1,
		ErrField = #xmlUserData.ErrField +'';3''
	Where
		len(FirstName) = 0
		and Status <> 2 -- allow empty value with update user

	-- Get a list of users who are missing a first or last name
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason9'',
		Status = 1,
		ErrField = #xmlUserData.ErrField +'';4''
	Where
		len(LastName) = 0
		and Status <> 2 -- allow empty value with update user

	-- check that the archive bit has been set
	Update
		#xmlUserData
	Set
		Reason = isNull(#xmlUserData.Reason+''; '','''')+ ''Reason11'',
		Status = 1,
		ErrField = #xmlUserData.ErrField +'';7'',
		Archive = null
	Where
		Archive = 2

	-- Change made for consistancy - see bug ID 269 for further info.
	-- Empty string values for External ID should be NULLs
	UPDATE 
		#xmlUserData
	SET
		[ExternalID]=NULL
	WHERE
		[ExternalID]=''''

	UPDATE 
		#xmlUserData
	SET
		Status = 3
		--Reason = ''Add User''
	WHERE
		Status is null 
		and	Reason is null
		
		
		
	-- flag the fields that have changed using email as unique field (ie email clearly is not being changed)
	if (@uniqueField = @constant_EmailAddress) begin
	

		-- username has changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Username != u.UserName and xd.Username != '''' then xd.UpdField +'';1'' else xd.UpdField end						
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		-- password has changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Password!=u.Password  and xd.password != '''' then xd.UpdField +'';2'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
			
		-- firstname change
		update
			#xmlUserData
		set 
			UpdField = case when xd.Firstname!=u.FirstName  and xd.firstname != '''' then xd.UpdField +'';3'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		-- last name changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Lastname!=u.LastName and xd.lastname != '''' then xd.UpdField +'';4'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		--external id changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.externalid!=u.externalID  and xd.externalid != '''' then xd.UpdField +'';6'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2	
		
		
		-- unit id changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.UnitID!=u.UnitID  and xd.unitid != '''' then xd.UpdField +'';7'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
			
		
		-- archive bit changed	
		update
			#xmlUserData
		set 
			UpdField = case when xd.Archive = u.Active and xd.archive != '''' then xd.UpdField +'';8'' else xd.UpdField end -- if archive 1 then active 0
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		-- user classification type or value has changed
		update
			#xmlUserData
		set 
			UpdField = case when (xd.ClassificationName !=ct.Name) or (xd.ClassificationOption != c.Value)  then xd.UpdField +'';9'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and xd.ErrField is null and xd.Status = 2
			join tblUserClassification uc on uc.UserID = u.UserID
			join tblClassification c on c.ClassificationID = uc.ClassificationID
			join tblClassificationType ct on ct.ClassificationTypeID = c.ClassificationTypeID
			
		
		-- unit admin notification flag has changed
		update
			#xmlUserData
		set 
			UpdField = case when (case when xd.NotifyUnitAdmin =''Yes'' then 1 when xd.NotifyUnitAdmin =''No'' then 0 else '''' end) != u.NotifyUnitAdmin and xd.NotifyUnitAdmin != '''' then xd.UpdField +'';10'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
		-- org admin notification flag has changed
		update
			#xmlUserData
		set 
			UpdField = case when (case when xd.NotifyOrgAdmin= ''Yes'' then 1 when xd.NotifyOrgAdmin =''No'' then 0 else '''' end )!= u.NotifyOrgAdmin and xd.NotifyOrgAdmin != '''' then xd.UpdField +'';11'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
		-- manager notification flag has changed
		update
			#xmlUserData
		set 
			UpdField = case when (case when xd.ManagerNotification = ''Yes'' then 1 when xd.ManagerNotification =''No'' then 0 else '''' end ) != u.NotifyMgr and xd.ManagerNotification != '''' then xd.UpdField +'';12'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
		-- notification managers email has changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.ManagerToNotify != u.DelinquencyManagerEmail and xd.ManagerToNotify != '''' then xd.UpdField +'';13'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Email = u.Email and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
			
		
		
	end
	else if (@uniqueField = @constant_UserName) 
	begin
	
		-- password has changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Password!=u.Password  and xd.password  != '''' then xd.UpdField +'';2'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''') and xd.Status = 2
			
		-- firstname changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Firstname!=u.FirstName and xd.firstname != '''' then xd.UpdField +'';3'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		-- last name changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Lastname!=u.LastName and xd.lastname != ''''  then xd.UpdField +'';4'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		-- email changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.Email!=u.Email and xd.email != '''' then xd.UpdField +'';5'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		--external id changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.externalid!=coalesce(u.externalID,'''')  and xd.externalid != '''' then xd.UpdField +'';6'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2	
			
		-- unit id changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.UnitID!=u.UnitID  and xd.unitid != '''' then xd.UpdField +'';7'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
			
		-- archive bit changed	
		update
			#xmlUserData
		set 
			UpdField = case when xd.Archive = u.Active and xd.archive  != '''' then xd.UpdField +'';8'' else xd.UpdField end -- if archive 1 then active 0
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2		
			
		-- user classification type or value has changed
		update
			#xmlUserData
		set 
			UpdField = case when (xd.ClassificationName !=ct.Name) or (xd.ClassificationOption != c.Value)  then xd.UpdField +'';9'' else xd.UpdField end
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
			join tblUserClassification uc on uc.UserID = u.UserID
			join tblClassification c on c.ClassificationID = uc.ClassificationID
			join tblClassificationType ct on ct.ClassificationTypeID = c.ClassificationTypeID
			
		
		-- unit admin notification flag has changed
		update
			#xmlUserData
		set 
			UpdField = case when (case when xd.NotifyUnitAdmin = ''Yes'' then 1 when xd.NotifyUnitAdmin =''No'' then 0 else '''' end) != u.NotifyUnitAdmin and xd.NotifyUnitAdmin != '''' then xd.UpdField +'';10'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
		-- org admin notification flag has changed
		update
			#xmlUserData
		set 
			UpdField = case when (case when xd.NotifyOrgAdmin = ''Yes'' then 1 when xd.NotifyOrgAdmin =''No'' then 0 else '''' end ) != u.NotifyOrgAdmin and xd.NotifyOrgAdmin != '''' then xd.UpdField +'';11'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
		-- manager notification flag has changed
		update
			#xmlUserData
		set 
			UpdField = case when (case when xd.ManagerNotification = ''Yes'' then 1 when xd.ManagerNotification= ''No'' then 0 else '''' end ) != u.NotifyMgr and xd.ManagerNotification != '''' then xd.UpdField +'';12'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
		-- notification managers email has changed
		update
			#xmlUserData
		set 
			UpdField = case when xd.ManagerToNotify != u.DelinquencyManagerEmail and xd.ManagerToNotify != '''' then xd.UpdField +'';13'' else xd.UpdField end 
		from 
			#xmlUserData xd join tblUser u  on xd.Username = u.UserName and (xd.ErrField is null or xd.ErrField = '''')  and xd.Status = 2
		
		
	end
	
	
	Select
		''Status'' = ''Status5''
		
	Select
		tmp.TempUserID As ''RowNumber'',
		tmp.Username,
		tmp.Password,
		tmp.Firstname,
		tmp.Lastname,
		tmp.Email,
		UnitID,
		tmp.Status,
		tmp.Reason as Reason,
		tmp.ClassificationOption,
		tmp.ClassificationName,
		tmp.ExternalID,
		tmp.ErrField,
		tmp.UpdField,
		tmp.Archive,
		tmp.NotifyUnitAdmin,
		tmp.NotifyOrgAdmin,
		tmp.ManagerNotification,
		tmp.ManagerToNotify
	From
		#xmlUserData As tmp

	drop table #xmlUserData
	commit

	SET ANSI_NULLS ON
END' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_UserDetails]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE  PROCEDURE [prcReport_UserDetails]
(
@OrganisationID int,
@IncludeInactiveUsers int,
@UnitIDs varchar(8000)
)
AS
SET NOCOUNT ON

IF (@IncludeInactiveUsers=0)
BEGIN

SELECT
uh.HierarchyName as UnitPathway,
u.UserID,
FirstName,
LastName,
u.UnitID,
Email,
UserName,
ExternalID,
ct.Name as GroupBy,
c.Value as Value
FROM
tblUser u
LEFT JOIN tblUserClassification uc on u.UserID = uc.UserID
LEFT JOIN tblClassification c on uc.ClassificationID = c.ClassificationID
LEFT JOIN tblClassificationType ct on c.ClassificationTypeID = ct.ClassificationTypeID
LEFT JOIN tblUnitHierarchy uh on u.UnitID = uh.UnitID
WHERE
u.Active = 1
AND
u.OrganisationID = @OrganisationID
AND
u.UnitID IN (SELECT * FROM dbo.udfCsvToInt(@UnitIDs) as tblUnitIDs)

ORDER BY
uh.HierarchyName, LastName

END

ELSE
BEGIN
SELECT
uh.HierarchyName as UnitPathway,
u.UserID,
FirstName,
CASE
WHEN u.Active = 0 then u.LastName + '' (I)''
ELSE u.LastName
END AS LastName,
u.UnitID,
Email,
UserName,
ExternalID,
ct.Name as GroupBy ,
c.Value as Value
FROM
tblUser u
LEFT JOIN tblUserClassification uc on u.UserID = uc.UserID
LEFT JOIN tblClassification c on uc.ClassificationID = c.ClassificationID
LEFT JOIN tblClassificationType ct on c.ClassificationTypeID = ct.ClassificationTypeID
LEFT JOIN tblUnitHierarchy uh on u.UnitID = uh.UnitID
WHERE

u.OrganisationID = @OrganisationID
AND
u.UnitID IN (SELECT * FROM dbo.udfCsvToInt(@UnitIDs) as tblUnitIDs)

--Active = (IsNull(@Active,1))

ORDER BY
uh.HierarchyName, LastName

END

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_UnitAdministrators]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/**

Summary:		Get a list of existing unit administrators for an organisation, by unit.

Returns:		Result set

Called By:		UnitAdministratorReport.rdl

Example call:	execute prcReport_UnitAdministrators 109
(use this for testing inside SQL management studio)

Author:			Mark Donald

Date Created:	30/07/2009

Modification History
-----------------------------------------------------------
Author		Date			Description



**/
CREATE PROCEDURE [prcReport_UnitAdministrators]
(
@organisationID	int,
@IncludeInactive int,
@UnitIDs varchar(8000)
)

AS

set nocount on

SELECT
dbo.udfGetUnitPathway(t.unitid) AS unitpathway,
lastname,
firstname,
CASE WHEN u.active = 1 THEN '''' ELSE ''(i)'' END AS flag,
username,
email,
externalid,
groupby,
[value]
FROM
tblunitadministrator ua, tblunit t, tbluser u
LEFT JOIN (
SELECT userid, ct.[name] as groupby, c.[value]
FROM tbluserclassification uc, tblclassification c, tblclassificationtype ct
WHERE c.classificationid = uc.classificationid
AND c.classificationtypeid = ct.classificationtypeid
) AS i ON i.userid = u.userid
WHERE
ua.userid = u.userid AND t.unitid = ua.unitid
AND usertypeid=3 --Unit administrator(3)
AND t.organisationid = @organisationID
AND (@IncludeInactive = 1 OR u.active = 1)
AND t.unitid IN (SELECT * FROM dbo.udfCsvToInt(@UnitIDs))
ORDER BY
unitpathway, lastname, firstname

' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_HistoricAdminSummaryOptimised]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfReport_HistoricAdminSummary    Script Date: 20/04/2004 8:25:58 AM ******/
/*Summary:
Get the Current or historic user module status  based on the search criteria
See the remarks below.
Returns: table
Called By: Current historic Admin Report
Calls:
Remarks:
1. Get User and course List based on search criteria
1.1 Get Unit List
1.1.1 If unit ids are passed in, convert the CSV format to a table
1.1.2 If no unit is selected, get a list of of all units that the admin user has permission to access
1.2 Get User list Based on the first name and last name in the search cirteria
1.3 Get Course list Based on the selected course in the search criteria and Used can select multiple Courses
2. Get the User Quiz and Lesson status up to the effective date
2.1 If there is no effective date is passed in, get the current module status
2.2 If there is effective date, get the module status up to the effective date
3.  Get a list of the user''s quiz and lesson historic status
Author: Jack Liu
Date Created: 1 Mar 2004
Modification History
-----------------------------------------------------------
v#	Author		Date				Description
#1.1	Usman Tjiudri	10/11/2005	Performance tuning:
- use temp-table to populate Unit Pathway
- join the temp-table to populate tblResult
instead of using udfGetUnitPathway function in the join.
#2.0	Serguei Chkaroupine 28/02/06 -New insert statement for histric admin report
- it will insert all lessons that match current quizmodule pair
- Current admin report performance fix. Added WHERE statement to
most of the insert statements.
#3	Mark Donald	27/07/2009			add userName and userEmail params
#4	William Tio	01/12/2009
- remove the wrong logic to exclude the user quiz/lesson status
- replace with ''not exists''

select * from dbo.udfReport_HistoricAdminSummary(3, '''', ''1,2,3,4'','''','''',NULL,NULL,''20040222'',4)
--------------------
**/

CREATE                Function [udfReport_HistoricAdminSummaryOptimised]
(
@organisationID 	Int,
@unitIDs			Varchar(8000),
@courseIDs			Varchar(8000),
@userFirstName		Varchar(50),
@userLastName		Varchar(50),
@userName			Varchar(100),
@userEmail			Varchar(100),
@effectiveDate 		Datetime,
@adminUserID		Int,
@classificationID 	Int,
@defaultDate		DateTime,
@inclInactive		int
)
Returns @tblResult Table
(
-- General
Unit			nVarchar(200),
[User]			nVarchar(100),
Course			nVarchar(100),
Module			nVarchar(100),
[Sequence]		Int,
-- Quiz Specific
QuizStatus		Varchar(50),
QuizScore		Int,
QuizStatusDate	Datetime,
-- Lesson Specific
LessonStatus	Varchar(50),
-- Hidden
UnitID			Int,
UserID			Int,
UserName		nVarchar(100),
ExternalID		nVarchar(50),
CourseID		Int,
ModuleID		Int,
Active	int
)
As Begin

--Variables declarations
DECLARE @UserTypeID 	INT
DECLARE @tblUnit 				Table(UnitID INT PRIMARY KEY(UnitID))
DECLARE @tblUser 				Table(UserID INT, UnitID INT, Active INT)
DECLARE @tblCourse 				Table(CourseID INT, [Name] NVARCHAR(100) PRIMARY KEY(CourseID))
DECLARE @CoursesWithAccess 		TABLE (CourseID INT PRIMARY KEY(CourseID))
DECLARE @UserModuleWithAccess 	TABLE(UserID INT, ModuleID INT, UnitID INT PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules 			TABLE(ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @tblUserQuizStatus 		Table
(
[UserQuizStatusID] [int] Not Null,
[UserID] [int] Not Null,
[ModuleID] [int] Not Null,
[QuizStatusID] [int] Not Null,
[QuizScore] [int] Null,
[DateCreated] [datetime] Not Null
)
DECLARE @tblUserLessonStatus 	Table
(
[UserLessonStatusID] [int] ,
[UserID] [int] ,
[ModuleID] [int] ,
[LessonStatusID] [int] ,
[DateCreated] [datetime]
)
DECLARE @vwUserModuleAccess table
(
UserID INT not null,
FirstName varchar(255),
LastName varchar(255),
UnitID INT,
OrganisationID INT,
ModuleID INT,
CourseID INT,
CourseName nvarchar(100),
[Name] nvarchar(100),
Sequence INT,
Description nvarchar(1000)
)

DECLARE @tblOrganisationCourseAccess table
(
OrganisationID int,
GrantedCourseID int
)
---------------------------------------------------------------------------------------------

--set the default date depending on effective date
set @defaultdate = coalesce (@effectivedate,@defaultdate)
---------------------------------------------------------------------------------------------

--Check If Unit ID is specified
IF @unitIDs IS NULL
BEGIN
--Check User Type
SELECT
@UserTypeID = UserTypeID
FROM
tblUser
WHERE UserID = @adminUserID

--Get all units in Organisation if user is Salt Admin(1) or Org admin (2)
IF (@UserTypeID = 1 Or @UserTypeID = 2)
BEGIN
INSERT INTO
@tblUnit (UnitID)
SELECT
UnitID
FROM
tblUnit
WHERE OrganisationID = @OrganisationID
END

--Get units that the user is admministrator if user is Unit Admin(3)
IF (@UserTypeID = 3)
BEGIN
INSERT INTO
@tblUnit (UnitID)
SELECT
U.UnitID
FROM
tblUnit U INNER JOIN tblUnitAdministrator UA ON
UA.UnitID = U.UnitID AND
UA.UserID = @adminUserID
WHERE
U.OrganisationID = @OrganisationID
END
END
ELSE
BEGIN
--Seperate comma seperated values as Table rows
INSERT INTO @tblUnit SELECT * FROM  dbo.udfCsvToInt(@unitIDs)
END
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
--FirstName, Last Name, etc specified in search criteria
IF (@userFirstName IS NULL) 	SET @userFirstName = ''''
IF (@userLastName IS NULL) 		SET @userLastName = ''''
IF (@userName IS NULL) 			SET @userName = ''''
IF (@userEmail IS NULL) 		SET @userEmail = ''''

INSERT INTO
@tblUser (UserID, UnitID, Active)
SELECT DISTINCT
U.UserID, U.UnitID, U.Active
FROM
tblUser U INNER JOIN @tblUnit UN ON	U.UnitID = UN.UnitID
and datediff(day,U.datecreated,@defaultdate)>=0-- created on or b4 specified date
LEFT JOIN tblUserClassification UC ON UC.UserID  = U.UserID
WHERE
U.FirstName Like ''%'' + @userFirstName + ''%'' AND
LastName Like ''%'' + @userLastName + ''%'' AND
UserName Like ''%'' + @userName + ''%'' AND
Email Like ''%'' + @userEmail + ''%'' AND
--AND have the Custom Classification option
--If classification is Any (0), This will find users of any Custom Classification
((@classificationID = 0) OR (UC.classificationID = @classificationID)) AND
--inclInactive = 0: do not include inactive user
--inclInactive = 1: include inactive user
(U.Active = CASE @inclInactive WHEN 0 THEN 1 ELSE U.Active END) AND
(U.OrganisationID = @OrganisationID)

---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
-- Search criteria contains Course ID''s
INSERT INTO
@tblCourse (CourseID, [Name])
SELECT
C.CourseID, C.[Name]
FROM
dbo.udfCsvToInt(@courseIDs) CA INNER JOIN tblCourse C ON
CA.intValue = C.CourseID AND C.Active = 1

-- added to deal with past courses - adds past course to intermediate @tblOrganisationCourseAccess table
-- to mimic it being a current course so results will be returned
insert into
@tblOrganisationCourseAccess (OrganisationID, GrantedCourseID)
select
@Organisationid, C.CourseID
from
dbo.udfCsvToInt(@courseIDs) CA inner join tblCourse C on
CA.intValue = C.CourseID and C.Active = 1

INSERT INTO @vwUserModuleAccess   SELECT   tU.UserID, tU.FirstName, tU.LastName, tU.UnitID, tU.OrganisationID, tM.ModuleID, tM.CourseID, tC.Name AS CourseName, tM.Name, tM.Sequence,
tM.Description
FROM         tblUser AS tU INNER JOIN
@tblUser tbU on tbU.UserID = tU.UserID
inner join
@tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID INNER JOIN
tblCourse AS tC ON tC.CourseID = tOCA.GrantedCourseID INNER JOIN
tblModule AS tM ON tM.CourseID = tC.CourseID AND tM.Active = 1 LEFT OUTER JOIN
tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID
WHERE     tM.CourseID in (SELECT courseid from @tblCourse ) AND (tU.UnitID IS NOT NULL) AND (tUnitMA.DeniedModuleID IS NULL) AND (tUsrMA.ModuleID IS NULL) OR
(tUsrMA.Granted = 1)
--select * from @vwUserModuleAccess where UnitID is null

INSERT INTO @UserModuleWithAccess
SELECT DISTINCT UserID, ModuleID, UnitID FROM @vwUserModuleAccess where UnitID is not null

INSERT INTO @tblUserQuizStatus
(
[UserQuizStatusID],
[UserID],
[ModuleID],
[QuizStatusID],
[QuizScore],
[DateCreated]
)
SELECT
A.[UserQuizStatusID],
A.[UserID],
A.[ModuleID],
A.[QuizStatusID],
A.[QuizScore],
A.[DateCreated]
FROM
(
SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID AND B.QuizStatusID <> 0
AND DateDiff(day, B.DateCreated, @effectiveDate)>=0
GROUP BY
A.UserID, A.ModuleID
) B, tblUserQuizStatus A, @tblUser C
WHERE
A.UserQuizStatusID = B.LatestQuizID AND B.UserID = C.UserID AND A.UserID = C.UserID
-- li June 2008:
-- User who has access to a module but doesn''t have a record in tblUserQuizStatus is a new user
-- this logic will include new user in the current and historic admin report before user quiz status
-- is updated by overnight job

INSERT INTO @tblUserQuizStatus
(
[UserQuizStatusID],
[UserID],
[ModuleID],
[QuizStatusID],
[QuizScore],
[DateCreated]
)
SELECT
0, -- UserQuizStatusID
A.[UserID],
A.[ModuleID],
1, -- QuizStatus: Not Started
null, -- QuizScore
@defaultDate -- DateCreated (here set to @defaultdate which is passed in as getDate())
FROM @UserModuleWithAccess A
join  @tblUser B on A.UserID = B.UserID
-- User doesn''t have quiz activities
/* WT: this part is replaced with not exists, the logic below will subtract userid with moduleid
where  A.UserID  + ''-'' + A.MODULEID NOT IN
(	Select D.UserID + ''-'' + D.Moduleid
from @tblUserQuizStatus D
where datediff(day, d.datecreated, @defaultdate)>=0)*/
where not exists
(	Select D.UserID, D.Moduleid
from @tblUserQuizStatus D
where datediff(day, d.datecreated, @defaultdate)>=0
and D.Userid=B.userid and D.moduleid=A.moduleid
)
-- end logic for including new user''s quiz status



Insert Into @tblUserLessonStatus
(
[UserLessonStatusID],
[UserID],
[ModuleID],
[LessonStatusID],
[DateCreated]
)
Select
A.[UserLessonStatusID],
A.[UserID],
A.[ModuleID],
A.[LessonStatusID],
A.[DateCreated]
FROM
(
SELECT
B.UserID, B.ModuleID, MAX(B.UserLessonStatusID) AS ''LatestLessonStatusID''
FROM
@UserModuleWithAccess A, tblUserLessonStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID AND
DateDiff(day, B.DateCreated, @effectiveDate)>=0 AND
B.LessonStatusID <> 0 --Unassigned
GROUP BY
B.UserID, B.ModuleID
) B, tblUserLessonStatus A, @tblUser C
WHERE
A.UserLessonStatusID = B.LatestLessonStatusID AND B.UserID = C.UserID AND A.UserID = C.UserID

-- start logic for including new user''s lesson status
INSERT INTO @tblUserLessonStatus
(
[UserLessonStatusID],
[UserID],
[ModuleID],
[LessonStatusID],
[DateCreated]
)
SELECT
0, -- UserLessonStatusID
A.[UserID],
A.[ModuleID],
1, -- LessonStatus: Not Started
@defaultDate -- DateCreated (here set to @defaultdate which is passed in as getDate())
FROM @UserModuleWithAccess A
join  @tblUser B on A.UserID = B.UserID
where
-- User doesn''t have lesson activities for the date entered
/* WT: this part is replaced with not exists, the logic below will subtract userid with moduleid
A.UserID + ''-'' + A.Moduleid NOT IN
(	Select D.UserID + ''-'' + D.Moduleid
from @tblUserLessonStatus D
where datediff(day, d.datecreated, @defaultdate)>=0 )*/
not exists
(	Select D.UserID, D.Moduleid
from @tblUserLessonStatus D
where datediff(day, d.datecreated, @defaultdate)>=0
and D.Userid=B.userid and D.moduleid=A.moduleid
)
-- end logic for including new user''s lesson status

---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
-- This part fixes migration issue (note this will affect historic admin report only as it does supply effective date)
-- It will insert userid, moduleid and earliest lesson status for each quiz that does not have lesson record yet
-- into @tblUserLessonStatus
Insert Into @tblUserLessonStatus
(
[UserLessonStatusID],
[UserID],
[ModuleID],
[LessonStatusID],
[DateCreated]
)
SELECT 1,
A.[UserID],
A.[ModuleID],
B.LessonStatusID,
A.DateCreated
FROM (
SELECT
A.UserID, A.ModuleID, MIN(A.DateCreated) AS ''DateCreated''
FROM
tblUserLessonStatus A, @tblUser B
WHERE
A.UserID = B.UserID
GROUP BY
A.UserID, A.ModuleID
) A , tblUserLessonStatus B WHERE

A.UserID = B.UserID AND A.ModuleID = B.ModuleID AND A.DateCreated = B.DateCreated AND
(CAST(A.UserID AS VARCHAR(10)) + CAST(A.ModuleID AS VARCHAR(10)))
NOT IN (SELECT CAST(A.UserID AS VARCHAR(10)) + CAST(A.ModuleID AS VARCHAR(10)) FROM @tblUserLessonStatus)


---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
Insert Into @tblResult
(
Unit,
[User],
Course,
Module,
[Sequence],
QuizStatus,
QuizStatusDate,	-- These columns have been reordered
QuizScore,	    -- These columns have been reordered
LessonStatus,
UnitID,
UserID,
UserName,
ExternalID,
CourseID,
ModuleID
)
Select distinct
-- General
up.HierarchyName 				As Unit, -- Unit Name
[User] = CASE u.Active when 0 then u.LastName + '' '' + u.FirstName + ''(i)'' ELSE u.LastName + '' '' + u.FirstName End , -- User Full Name
c.Name			  				As Course, -- Course Name
m.Name			  				As Module, -- Module Name
m.Sequence						As Sequence,
-- Quiz Specific
qs.Status						As QuizStatus,
dbo.udfUTCtoDaylightSavingTime(uqs.DateCreated, @organisationID) as QuizStatusDate,	-- These columns have been reordered
uqs.QuizScore 				    as QuizScore,		-- These columns have been reordered
-- Lesson Specific
ls.status 						As LessonStatus,
-- Hidden
u.UnitID						As UnitID,
u.UserID						As UserID,
u.UserName						As UserName,
u.ExternalID						As ExternalID,
c.CourseID						As CourseID,
m.ModuleID						As ModuleID
--u.Active						As Active
From @tblUserQuizStatus uqs
Inner Join tblQuizStatus qs On qs.QuizStatusID = uqs.QuizStatusID
inner Join @tblUser us 	On us.UserID = uqs.UserID
Inner Join tblUser u On u.UserID = us.UserID
INNER Join tblUnitHierarchy up On up.UnitID = u.UnitID
INNER Join tblModule m On m.ModuleID = uqs.ModuleID
INNER Join @tblCourse c On c.CourseID = m.CourseID
INNER Join @tblUserLessonStatus uls On uls.UserID = u.UserID And uls.ModuleID = m.ModuleID
INNER Join tblLessonStatus ls On ls.LessonStatusID = uls.LessonStatusID
where @effectivedate is null or (datediff(day,uqs.datecreated,@effectivedate)>=0 and datediff(day, uls.datecreated, @effectivedate)>=0)
RETURN
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_AdminSummaryReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
This will show the Current or historic Admin Report

See the remarks below.

Returns:

Called By: Current Admin Report
Calls:

Remarks:

1. Get the Current or historic user module status  based on the search criteria

2.  Group and sort the result
2.1    Group by Unit_User
Columns output:
Unit,
[User],
Course,
Module,
QuizStatus,
QuizScore,
QuizStatusDate,
LessonStatus

2.2    Group by Course
Columns output:
Course,
Module,
Unit,
[User],
QuizStatus,
QuizScore,
QuizStatusDate,
LessonStatus

then sorted by, either:
QuizScore
Last Name
QuizStatusDate


Author: Jack Liu
Date Created: 1 Mar 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Mark Donald	27/07/2009		add userName and userEmail params
#2  J hedlefs   09/06/2011      timezone


prcReport_AdminSummaryReport 3, '''', ''1,2,3,4'','''','''',NULL,NULL,''20040222'',''Unit_User'','''',4
prcReport_AdminSummaryReport 3, '''', ''1,2,3,4'','''','''',NULL,NULL,null,''Course'',''QuizDate'',4

--------------------

**/

CREATE      procedure [prcReport_AdminSummaryReport]
(
@organisationID 	int,
@unitIDs		Varchar(MAX),
@courseIDs		Varchar(8000),
@userFirstName		nVarchar(50),
@userLastName		nVarchar(50),
@userName			nVarchar(100),
@userEmail			nVarchar(100),
@effectiveDateOrg 		datetime,
@groupBy		nVarchar(50),
@sortBy			nVarchar(50),
@adminUserID		int,
@classificationID 	int,
@inclInactive	int -- Flag for including inactive user or not
--@inclInactive = 0: do not include inactive users
--@inclInactive = 1: include inactive users
)
As
set nocount on
/*
1. Get the Current or historic user module status  based on the search criteria
Unit,
[User],
Course,
Module,
QuizStatus,
QuizScore,
QuizStatusDate,
LessonStatus,
UnitID,
UserID,
CourseID,
ModuleID
*/

DECLARE @defaultDate DATETIME
SET @defaultDate = getUTCdate()

if  not ( @sortBy  = ''QUIZ_SCORE'' or @sortBy  = ''QUIZ_DATE'' or @sortBy  = ''LAST_NAME'')
Begin
-- sort order is not QUIZ_SCORE, QUIZ_DATE or LAST_NAME
set @sortBy = ''LAST_NAME''
End
Declare @tblResult TABLE
(
-- General
Unit		nVarchar(200),
[User]		nVarchar(100),
Course		nVarchar(100),
Module		nVarchar(100),
[Sequence]  Int,
-- Quiz Specific
QuizStatus	nvarchar(50),
QuizScore	Int,
QuizStatusDate	DateTime,
-- Lesson Specific
LessonStatus	nvarchar(50),
-- Hidden
UnitID		Int,
UserID		Int,
UserName	nvarchar(100),
ExternalID	nvarchar(50),
CourseID	Int,
ModuleID	Int,
Active		Int,
ClassificationName nvarchar(50),  -- This may need to be changed when multiple classifications become needed.
ClassificationValue nvarchar(50)
)
Insert Into
@tblResult
select
Results.*,
tblClassificationType.Name,
tblClassification.Value
from
-- ***************************** Timezone conversion is done in the UDF **********************************************
dbo.udfReport_HistoricAdminSummaryOptimised(@organisationID,@unitIDs,@courseIDs,@userFirstName,@userLastName,@userName,@userEmail,@effectiveDateOrg,@adminUserID,@classificationID,@defaultDate,@inclInactive)
-- *******************************************************************************************************************
as Results
left join
tblUserClassification on tblUserClassification.UserID = Results.UserID
left join
tblClassification on tblClassification.ClassificationID = tblUserClassification.ClassificationID
left join
tblClassificationType on tblClassification.ClassificationTypeID = tblClassificationType.ClassificationTypeID
/*
2.  Group and sort the result
2.1    Group by Unit/User
Columns output:
Unit,
[User],
Course,
Module,
QuizStatus,
QuizScore,
QuizStatusDate,
LessonStatus
*/
if (@groupBy = ''Unit_User'')
begin
select
Unit,
[User],
Course,
Module,
QuizStatus,
QuizScore,
QuizStatusDate,
LessonStatus,
UnitID,
UserID,
UserName,
ExternalID,
CourseID,
ModuleID,
Active,
ClassificationName,
ClassificationValue
from @tblResult
order by Unit, UnitID, [User], userID,  Course, CourseID, [Sequence]
end
/*
2.2    Group by Course
Columns output:
Course,
Module,
Unit,
[User],
QuizStatus,
QuizScore,
QuizStatusDate,
LessonStatus
then sorted by, either:
QuizScore
Last Name
QuizStatusDate
*/
else -- (@groupBy = ''Course'')
begin
if (@sortBy = ''QUIZ_SCORE'')
begin
select
*
from @tblResult
order by Course, CourseID, [Sequence], Unit, UnitID, QuizScore desc,[user]
end
else if (@sortBy = ''QUIZ_DATE'')
begin
select
*
from @tblResult
order by Course, CourseID, [Sequence], Unit, UnitID, QuizStatusDate desc,[user]
end
else -- order by ''LAST_NAME''
begin
select
*
from @tblResult
order by Course, CourseID, [Sequence], Unit, UnitID, [user]
end
end


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[ToUTC]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [ToUTC]
(
@LocalTime DateTime
)
RETURNS DateTime
AS
BEGIN
IF (@LocalTime is null) RETURN null

DECLARE @DSTTime datetime
DECLARE @UTC_Offset int
DECLARE @Timezone datetime
DECLARE @offset_mins int, @hours_start int, @day_start int, @week_start int, @month_start int, @hours_end int, @day_end int, @week_end int, @month_end int, @year_end int , @year_start int
SELECT @UTC_Offset = TZ.OffsetUTC , @Timezone = TZ.TimezoneID
FROM tblTimeZone TZ
INNER JOIN tblAppConfig App ON  App.Value=TZ.WrittenName
--WHERE TZ.TimeZoneID = Org.TimeZoneID
IF (@UTC_Offset IS NULL)
BEGIN
Set @DSTTime = ''1 Jan 1900'' --  create an "error" that will be apparent in Report
END
ELSE
BEGIN
Set @DSTTime = DATEADD(minute,-@UTC_Offset,@LocalTime )
SELECT  @offset_mins = offset_mins, --get definition of the (at most) 1 definition that may cover the datetime
@hours_start = hours_start, --overlapping definitions removed by GUI so only 1 result returned
@day_start = day_start,
@week_start = week_start,
@month_start = month_start,
@hours_end = hours_end,
@day_end = day_end,
@week_end = week_end,
@month_end = month_end
FROM tblTimeZoneDaylightSavingRules
WHERE  TimezoneID = @Timezone
AND @LocalTime >= first_start_date
AND @LocalTime <= last_end_date
Set @year_start = year(@LocalTime) --now calculate the exact start and end dates and times for the year under consideration

DECLARE @Period_start datetime, @period_end datetime
Set @year_start = year(@LocalTime)
set @year_end = year(@LocalTime)

if (month(@LocalTime) <= @month_end) and (@month_start > @month_end) set @year_start = @year_start - 1   -- rule spans december 31 so adjust

IF(@month_start > @month_end) and (month(@LocalTime) >= @month_start) set @year_end = @year_start + 1  -- rule spans december 31 so adjust

--IF(@month_start > @month_end) set @year_end = @year_start + 1 else set @year_end = @year_start
--DECLARE @Period_start datetime, @period_end datetime

set @Period_start = ''1 jan 2000'' -- start with a known datetime
set @year_start = @year_start - 2000
Set @Period_start = DATEADD(year,@year_start,@Period_start) -- then set the year correctly
-- Then move to the correct month
Set @Period_start = DATEADD(month,@month_start-1,@Period_start)
-- Then move to the correct week (let week 5 slide to the next month for now)
Set @Period_start = DATEADD(week,@week_start-1,@Period_start)
-- Now move FORWARD to the correct day (say) the 5th sunday of february
Declare @day_offset int
if (@day_start >=  DatePart(weekday,@Period_start) ) set @day_offset = @day_start -  DatePart(weekday,@Period_start) else  set @day_offset = @day_start -  DatePart(weekday,@Period_start) + 7
Set @Period_start = DATEADD(day,@day_offset,@Period_start)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_start) > @month_start) set @Period_start = DATEADD(week,-1,@Period_start)
Set @Period_start = DATEADD(minute,@hours_start,@Period_start)  ---TODO check if offset applied OK for 1 hour either side of daylight saving start and end

set @Period_end = ''1 jan 2000'' -- start with a known datetime
set @year_end = @year_end - 2000
Set @Period_end = DATEADD(year,@year_end,@Period_end) -- then adjust it to match the definition
Set @Period_end = DATEADD(month,@month_end-1,@Period_end)
Set @Period_end = DATEADD(week,@week_end-1,@Period_end)
if (@day_end >=  DatePart(weekday,@Period_end) ) set @day_offset = @day_end -  DatePart(weekday,@Period_end) else  set @day_offset = @day_end -  DatePart(weekday,@Period_end) + 7
Set @Period_end = DATEADD(day,@day_offset,@Period_end)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_end) > @month_end) set @Period_end = DATEADD(week,-1,@Period_end)
Set @Period_end = DATEADD(minute,@hours_end,@Period_end)  ---TODO check if offset applied OK for 1 hour either side of daylight saving start and end
--Set @Period_end = DATEADD(minute,-@offset_mins,@Period_end) -- end time is quoted with daylight savings included


IF (@LocalTime >= @Period_start)
AND (@LocalTime < @Period_end) set @DSTTime = DATEADD(minute,-@offset_mins,@DSTTime)
END
RETURN @DSTTime
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGridExport_PeriodicRS]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcGridExport_PeriodicRS]

	@Param1 NVarChar(4000),
	@Param2 NVarChar(4000),
	@Param3 NVarChar(4000),
	@CurrentCultureName NVarChar(4000),
	@Expanded bit
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @OrgID int
	Declare @UserID int
	DECLARE @Sort NVarChar(4000)
	SET @OrgID=@Param1
	SET @UserID=@Param2
	SET @Sort=@Param3
	DECLARE @SQL NVarChar(4000)
	DECLARE @LangID NVarChar(4000)
		SELECT @LangID=LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName 
		IF @LangID IS NULL 
		BEGIN
			SET @LangID=2
		END

IF (@Expanded = 1)
BEGIN

	 SET @SQL=
	 --N''SELECT   ''''Report Title'''', ''''Report Type'''',''''Report Interval'''',''''Date Created'''',''''Report Starts On'''',''''Report Ends On'''',''''Next Run'''',''''Report Owner'''',''''Administration Level'''',''''Report Delivered To;'''',''''Unique ID''''    UNION ALL ''+
N''SELECT rs.ReportTitle as C1,
ri.ReportName as C2,
CAST(rs.ReportFrequency AS varchar(5))+'''' ''''+
CASE
WHEN (rs.ReportFrequencyPeriod=''''D'''') THEN
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.1''''))
WHEN (rs.ReportFrequencyPeriod=''''W'''') THEN
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.2''''))
WHEN (rs.ReportFrequencyPeriod=''''M'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.3''''))
ELSE
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.3''''))
END AS C3, 
convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(rs.DateCreated,rs.ParamOrganisationID),113) as C4 , 
convert(varchar (11),rs.ReportStartDate,113) as C5 ,  
CASE WHEN rs.ReportEndDate IS NULL THEN ''''--'''' ELSE  convert(varchar (11),rs.ReportEndDate,113)  END as C6, 
CASE WHEN rs.NextRun IS NULL THEN ''''--'''' ELSE  convert(varchar (11),rs.NextRun,113)  END as C7, 
(u.FirstName + '''' '''' + u.LastName) as C8,
CASE WHEN u.UserTypeID=1 THEN ''''APP ADMIN''''
WHEN u.UserTypeID=2 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''GLOBAL.UserControls.AdminMenu.ascx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''lblAdminMenuOrganisation''''))
WHEN u.UserTypeID=3 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''GLOBAL.UserControls.AdminMenu.ascx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''lblAdminMenuUnit''''))
ELSE  (SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''GLOBAL.UserControls.AdminMenu.ascx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''lblAdminMenuUser''''))
END as C9,
ccu.Email as C10,
rs.ScheduleID as C11
FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID=ri.ReportID
INNER JOIN dbo.tblUser u ON u.UserID=rs.UserID
INNER JOIN dbo.tblUserType ut ON u.UserTypeID=ut.UserTypeID
INNER JOIN (SELECT ScheduleId,UserID FROM tblCCList UNION ALL SELECT ScheduleId,UserID FROM tblReportSchedule) as cc ON  cc.ScheduleId=rs.ScheduleId
INNER JOIN tblUser ccu ON cc.UserID=ccu.UserID
WHERE rs.ParamOrganisationID=''+@Param1+'' AND rs.IsPeriodic !=''''N''''	ORDER BY ''+ @Sort
END
ELSE
BEGIN
	 SET @SQL = 
	 --N''SELECT   ''''Report Title'''', ''''Report Type'''',''''Report Interval'''',''''Date Created'''',''''Report Starts On'''',''''Report Ends On'''',''''Next Run'''',''''Report Owner'''',''''Administration Level'''',''''Report Delivered To;'''',''''Unique ID''''    UNION ALL ''+
N''SELECT rs.ReportTitle as C1,
ri.ReportName as C2, 
CAST(rs.ReportFrequency AS varchar(5))+'''' ''''+
CASE 
WHEN (rs.ReportFrequencyPeriod = ''''D'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.1''''))
WHEN (rs.ReportFrequencyPeriod = ''''W'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.2''''))
WHEN (rs.ReportFrequencyPeriod = ''''M'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.3''''))
ELSE 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.3''''))
END AS C3, 
convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(rs.DateCreated,rs.ParamOrganisationID),113) as C4, 
convert(varchar (11),rs.ReportStartDate,113) as C5,
CASE WHEN rs.ReportEndDate IS NULL THEN ''''--'''' ELSE  convert(varchar (11),rs.ReportEndDate,113)  END as C6,
CASE WHEN rs.NextRun IS NULL THEN ''''--'''' ELSE  convert(varchar (11),rs.NextRun,113)  END as C7,
(u.FirstName + '''' '''' + u.LastName) as C8,
CASE WHEN u.UserTypeID = 1 THEN ''''APP ADMIN''''
WHEN u.UserTypeID = 2 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''GLOBAL.UserControls.AdminMenu.ascx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''lblAdminMenuOrganisation''''))
WHEN u.UserTypeID = 3 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''GLOBAL.UserControls.AdminMenu.ascx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''lblAdminMenuUnit'''')) 
ELSE  (SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''GLOBAL.UserControls.AdminMenu.ascx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''lblAdminMenuUser'''')) 
END as C9,
CASE WHEN ((SELECT count(*) FROM tblCCList WHERE tblCCList.ScheduleID = rs.ScheduleID) > 0) THEN (Convert(varchar, (SELECT 1+count(*) FROM tblCCList WHERE tblCCList.ScheduleID = rs.ScheduleID)) + '''' Recepients'''') ELSE u.Email  END as C10,
rs.ScheduleID as C11
FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID		inner JOIN dbo.tblUser u ON u.UserID = rs.UserID		inner JOIN dbo.tblUserType ut ON u.UserTypeID = ut.UserTypeID				WHERE rs.ParamOrganisationID = ''+@Param1+'' AND rs.IsPeriodic != ''''N''''		ORDER BY ''+ @Sort
END

	EXEC dbo.sp_executesql @SQL

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGridExport_PeriodicPDF]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcGridExport_PeriodicPDF]

	@Param1 NVarChar(4000),
	@Param2 NVarChar(4000),
	@Param3 NVarChar(4000),
	@CurrentCultureName NVarChar(4000)
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @OrgID int
	Declare @UserID int
	DECLARE @Sort NVarChar(4000)
	SET @OrgID = @Param1
	SET @UserID = @Param2
	SET @Sort = @Param3
	DECLARE @SQL NVarChar(4000)
	DECLARE @LangID NVarChar(4000)
		SELECT @LangID = LangID FROM tblLang where tblLang.LangCode =   @CurrentCultureName 
		IF @LangID IS NULL 
		BEGIN
			SET @LangID = 2
		END

	--DECLARE @CCList TABLE(ScheduleId int, CC int)
	--INSERT INTO @CCList(ScheduleId, CC) 
	--	(SELECT ccl.ScheduleId, Count(UserId) as CC FROM tblCCList ccl
	--		GROUP BY ccl.ScheduleId
	--		HAVING ccl.ScheduleId In 
	--			(SELECT rs.ScheduleId FROM tblReportSchedule rs
	--			INNER JOIN dbo.tblUser u ON u.UserID = rs.UserID WHERE ParamOrganisationID = @OrgID))

	 SET @SQL = 
	 --N''SELECT   ''''Report Title'''', ''''Report Type'''',''''Report Interval'''',''''Date Created'''',''''Report Starts On'''',''''Report Ends On'''',''''Next Run'''',''''Report Owner'''',''''Administration Level'''',''''Report Delivered To;'''',''''Unique ID''''    UNION ALL ''+
N''SELECT rs.ReportTitle,
ri.ReportName, 
CAST(rs.ReportFrequency AS varchar(5))+'''' ''''+
CASE 
WHEN (rs.ReportFrequencyPeriod = ''''D'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.1''''))
WHEN (rs.ReportFrequencyPeriod = ''''W'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.2''''))
WHEN (rs.ReportFrequencyPeriod = ''''M'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.3''''))
ELSE 
(SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''/Reporting/PeriodicReport.aspx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''optPeriodType.3''''))
END AS ReportInterval, 
convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(rs.DateCreated,rs.ParamOrganisationID),113) as DateCreated , 
convert(varchar (11),rs.ReportStartDate,113) as StartDate ,  
CASE WHEN rs.ReportEndDate IS NULL THEN ''''--'''' ELSE  convert(varchar (11),rs.ReportEndDate,113)  END as EndDate, 
CASE WHEN rs.NextRun IS NULL THEN ''''--'''' ELSE  convert(varchar (11),rs.NextRun,113)  END as NextRun, 
(u.FirstName + '''' '''' + u.LastName) as Username,
CASE WHEN u.UserTypeID = 1 THEN ''''APP ADMIN''''
WHEN u.UserTypeID = 2 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''GLOBAL.UserControls.AdminMenu.ascx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''lblAdminMenuOrganisation''''))
WHEN u.UserTypeID = 3 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''GLOBAL.UserControls.AdminMenu.ascx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''lblAdminMenuUnit'''')) 
ELSE  (SELECT LangEntryValue
FROM tblLangValue
where LangID = ''+@LangID+''
and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = ''''GLOBAL.UserControls.AdminMenu.ascx''''  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = ''''lblAdminMenuUser'''')) 
END as AdministrationLevel,
CASE WHEN ((SELECT count(*) FROM tblCCList WHERE tblCCList.ScheduleID = rs.ScheduleID) > 0) THEN (Convert(varchar, (SELECT 1+count(*) FROM tblCCList WHERE tblCCList.ScheduleID = rs.ScheduleID)) + '''' Recepients'''') ELSE u.Email  END as DeliveredTo,
rs.ScheduleID as UniqueID
FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID		inner JOIN dbo.tblUser u ON u.UserID = rs.UserID		inner JOIN dbo.tblUserType ut ON u.UserTypeID = ut.UserTypeID				WHERE rs.ParamOrganisationID = ''+@Param1+'' AND rs.IsPeriodic != ''''N''''		ORDER BY ''+ @Sort

	EXEC dbo.sp_executesql @SQL

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGridExport_PeriodicCSV]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcGridExport_PeriodicCSV]

	@Param1 NVarChar(4000),
	@Param2 NVarChar(4000),
	@Param3 NVarChar(4000),
	@CurrentCultureName NVarChar(4000)
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @OrgID int
	Declare @UserID int
	DECLARE @Sort NVarChar(4000)
	SET @OrgID=@Param1
	SET @UserID=@Param2
	SET @Sort=@Param3
	DECLARE @SQL NVarChar(4000)
	DECLARE @LangID NVarChar(4000)
		SELECT @LangID=LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName 
		IF @LangID IS NULL 
		BEGIN
			SET @LangID=2
		END

	--DECLARE @CCList TABLE(ScheduleId int, CC int)
	--INSERT INTO @CCList(ScheduleId, CC) 
	--	(SELECT ccl.ScheduleId, Count(UserId) as CC FROM tblCCList ccl
	--		GROUP BY ccl.ScheduleId
	--		HAVING ccl.ScheduleId In 
	--			(SELECT rs.ScheduleId FROM tblReportSchedule rs
	--			INNER JOIN dbo.tblUser u ON u.UserID=rs.UserID WHERE ParamOrganisationID=@OrgID))

	 SET @SQL=
	 --N''SELECT   ''''Report Title'''', ''''Report Type'''',''''Report Interval'''',''''Date Created'''',''''Report Starts On'''',''''Report Ends On'''',''''Next Run'''',''''Report Owner'''',''''Administration Level'''',''''Report Delivered To;'''',''''Unique ID''''    UNION ALL ''+
N''SELECT rs.ReportTitle,
ri.ReportName,
CAST(rs.ReportFrequency AS varchar(5))+'''' ''''+
CASE
WHEN (rs.ReportFrequencyPeriod=''''D'''') THEN
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.1''''))
WHEN (rs.ReportFrequencyPeriod=''''W'''') THEN
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.2''''))
WHEN (rs.ReportFrequencyPeriod=''''M'''') THEN 
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.3''''))
ELSE
(SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''/Reporting/PeriodicReport.aspx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''optPeriodType.3''''))
END AS ReportInterval, 
convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(rs.DateCreated,rs.ParamOrganisationID),113) as DateCreated , 
convert(varchar (11),rs.ReportStartDate,113) as StartDate ,  
CASE WHEN rs.ReportEndDate IS NULL THEN ''''--'''' ELSE  convert(varchar (11),rs.ReportEndDate,113)  END as EndDate, 
CASE WHEN rs.NextRun IS NULL THEN ''''--'''' ELSE  convert(varchar (11),rs.NextRun,113)  END as NextRun, 
(u.FirstName + '''' '''' + u.LastName) as Username,
CASE WHEN u.UserTypeID=1 THEN ''''APP ADMIN''''
WHEN u.UserTypeID=2 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''GLOBAL.UserControls.AdminMenu.ascx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''lblAdminMenuOrganisation''''))
WHEN u.UserTypeID=3 THEN (SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''GLOBAL.UserControls.AdminMenu.ascx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''lblAdminMenuUnit''''))
ELSE  (SELECT LangEntryValue
FROM tblLangValue
where LangID=''+@LangID+''
and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=''''GLOBAL.UserControls.AdminMenu.ascx'''')
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''''lblAdminMenuUser''''))
END as AdministrationLevel,
ccu.Email as DeliveredTo,
rs.ScheduleID as UniqueID
FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID=ri.ReportID
INNER JOIN dbo.tblUser u ON u.UserID=rs.UserID
INNER JOIN dbo.tblUserType ut ON u.UserTypeID=ut.UserTypeID
INNER JOIN (SELECT ScheduleId,UserID FROM tblCCList UNION ALL SELECT ScheduleId,UserID FROM tblReportSchedule) as cc ON  cc.ScheduleId=rs.ScheduleId
INNER JOIN tblUser ccu ON cc.UserID=ccu.UserID
WHERE rs.ParamOrganisationID=''+@Param1+'' AND rs.IsPeriodic !=''''N''''	ORDER BY ''+ @Sort

	EXEC dbo.sp_executesql @SQL

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGridExport_Headers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcGridExport_Headers]
	@LangInterfaceName NVarChar(4000),
	@CurrentCultureName NVarChar(20)

AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @OrgID int
	Declare @UserID int
	DECLARE @Sort NVarChar(4000)

	DECLARE @SQL NVarChar(4000)
	DECLARE @LangID NVarChar(40)
		SELECT @LangID=LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName 
		IF @LangID IS NULL 
		BEGIN
			SET @LangID=2
		END

SELECT
(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C1'') ) as C1,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C2'') ) as C2,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C3'') ) as C3,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C4'') ) as C4,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C5'') ) as C5,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C6'') ) as C6,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C7'') ) as C7,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C8'') ) as C8,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C9'') ) as C9,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C10'') ) as C10,(SELECT LangEntryValue
FROM tblLangValue
where LangID=@LangID and LangInterfaceID=
(SELECT LangInterfaceID
FROM tblLangInterface
where LangInterfaceName=@LangInterfaceName)
and LangResourceID=
(SELECT LangResourceID
FROM tblLangResource
where LangResourceName=''C11'') ) as C11

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetTimezoneDaylightRules]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 18/06/2011
-- Description:	Gets daylight saving rules for timezone and start year
-- =============================================
CREATE PROCEDURE [prcGetTimezoneDaylightRules]
@TimezoneId int,
@RuleID int
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

SELECT tz.WrittenName AS WrittenName, tzd.start_year AS StartYear, tzd.end_year AS EndYear, tzd.offset_mins AS Offset,
tzd.hours_start AS TimeStart, tzd.day_start AS WeekdayStart, tzd.week_start AS WeekStart, tzd.month_start AS MonthStart,
tzd.hours_end AS TimeEnd, tzd.day_end AS WeekdayEnd, tzd.week_end AS WeekEnd, tzd.month_end AS MonthEnd
FROM tblTimeZoneDaylightSavingRules tzd JOIN tblTimeZone tz ON tzd.TimezoneID = tz.TimeZoneID
WHERE tzd.TimezoneID=@TimezoneId AND tzd.TimezoneRuleID=@RuleID

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetSet_MailFlag]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'create  Procedure [prcGetSet_MailFlag]
(
@OrganisationID int,
@getSet int,
@UserID int
)

As
begin 
	if (@getSet =1)
	begin
		update tblOrganisation set StopEmails = case when StopEmails = 0 then 1 else 0 end, 
			DateUpdated = GETDATE(), UpdatedBy = @UserID 
		where OrganisationID = @OrganisationID
	end
	
	select stopemails from tblOrganisation where organisationID = @OrganisationID
end
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLanguage_ReportLabels]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE Procedure [prcLanguage_ReportLabels]
@LangCode varchar(10) = ''en-AU'',
@LangInterfaceName varchar(200) = ''Report.Summary''
As

DECLARE NameValueLOOP CURSOR
FOR
SELECT     tblLangResource.LangResourceName, tblLangValue.LangEntryValue
FROM         tblLang INNER JOIN
tblLangValue ON tblLang.LangID = tblLangValue.LangID INNER JOIN
tblLangResource ON tblLangValue.LangResourceID = tblLangResource.LangResourceID INNER JOIN
tblLangInterface ON tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID
WHERE     (tblLang.LangCode = @LangCode) AND (tblLangInterface.LangInterfaceName = @LangInterfaceName or tblLangInterface.LangInterfaceName = ''Report.GLOBAL'')
AND (tblLangValue.Active = 1)

Open NameValueLOOP

declare @cursor_Name nvarchar(200)
declare @cursor_Value nvarchar(4000)

FETCH NEXT FROM NameValueLOOP INTO @cursor_Name, @cursor_Value

declare @fieldList as nvarchar(4000)
set @fieldList = ''''

WHILE @@FETCH_STATUS = 0
BEGIN

if @fieldList <> ''''
BEGIN
set @fieldList = @fieldList + '', ''
END

set @fieldList = @fieldList + ''N'''''' + @cursor_Value + '''''' as '' + @cursor_Name
FETCH NEXT FROM NameValueLOOP INTO @cursor_Name, @cursor_Value
END
CLOSE NameValueLOOP
DEALLOCATE NameValueLOOP

declare @createTable as nvarchar(4000)
set @createTable = ''SELECT '' + @fieldList

EXEC(@createTable)


SET QUOTED_IDENTIFIER OFF
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetReminderEscalations]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE PROCEDURE [prcGetReminderEscalations]
(
	@orgID int
)
	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from interfering with SELECT statements.
	SET NOCOUNT ON

	select 
		re.RemEscId,
		re.CourseId,
		c.Name as CourseName,
		case when re.RemindUsers= 1 then ''Yes'' else ''No'' end as RemindUsers,
		re.NumOfRemNotfy,
		re.RepeatRem,
		case when re.NotifyMgr = 1 then ''Yes'' else ''No'' end as NotifyMgr,
		case when re.IsCumulative = 1 then ''Yes'' else ''No'' end as  IsCumulative,
		re.NotifyMgrDays,
		case when re.QuizExpiryWarn =1 then ''Yes'' else ''No'' end as QuizExpiryWarn,
		re.DaysQuizExpiry
	from
		tblReminderEscalation re
			join tblCourse c on c.CourseID = re.CourseId and c.Active = 1
	where 
		OrgId = @orgID
    
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAppConfig_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Updates configuration details.

Parameters:


Returns:
None

Called By:
AppConfig.cs

Calls:
None

Remarks:
Exception:
0. Succeed
1. RecordNotFoundException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Jack Liu
Date Created: 24th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcAppConfig_Update]
(
@name nVarchar(50),
@value nvarchar(4000)
)

As
if (not exists(select name
from tblAppConfig
where name=@name))
begin
Select
1 As ''ErrorNumber'',
''Record not found'' As ''ErrorMessage''
end
else
begin
Update tblAppConfig
set value =@value
where name=@name

select	0 As ''ErrorNumber'',
'''' As ''ErrorMessage''

end




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAppConfig_GetMailServices]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Get mail services 
Parameters:
Returns:

Called By:
Calls:

Remarks:

Author: VDL
Date Created: 04 Jan 2012

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

create Procedure [prcAppConfig_GetMailServices]
As
begin 

	Set Nocount On

	Select
		Name,
		Value
	From
		tblAppConfig
	where 
		Name like ''MailService_%''

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAppConfig_GetList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Get a list of application configuration
Parameters:
Returns:

Called By:
Calls:

Remarks:

Author: Jack Liu
Date Created: 24th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcAppConfig_GetList]
As

Set Nocount On

Select
Name,
Value
From
tblAppConfig
order by Name





' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Updates a Course.

Parameters:
@courseID
@name
@notes
@active
@userID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Course.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Gavin Buddis
Date Created: 16 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE  Procedure [prcCourse_Update]
(
@courseID Integer = Null,
@name nVarchar(100) = Null,
@notes nVarchar(1000) = Null,
@active Bit = 1,
@userID Integer = Null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @courseID
If(@courseID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @courseID in stored procedure prcCourse_Update''
Goto Finalise
End

-- Validate that the Caption for this link doesn''t exist.
If Exists(Select * From tblCourse Where [Name] = @name And courseID != @courseID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Name '' + @name + '' already exists please choose another Name.''
Goto Finalise
End

--Validate Parameter @name
If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure prcCourse_Update''
Goto Finalise
End

--Validate Parameter @notes
If(@notes Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @notes in stored procedure prcCourse_Update''
Goto Finalise
End

--Validate Parameter @active
If(@active Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure prcCourse_Update''
Goto Finalise
End

--Validate Parameter @userID
If(@userID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcCourse_Update''
Goto Finalise
End

If Exists(Select * From tblCourse Where CourseID = @courseID)
Begin
-- Update the record in tblCourse
Update tblCourse
Set
[Name] = @name,
Notes = @notes,
Active = @active,
UpdatedBy = @userID,
DateUpdated = GetUTCDate()
Where
CourseID = @courseID

-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Updated''

-- Finalise the procedure
Goto Finalise
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''

Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_MailServerURL]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcAutomatedEmails_MailServerURL]

AS
BEGIN
SELECT Value FROM tblAppConfig WHERE Name = ''MailServer''
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcDeleteTimezoneDaylightSavingRule]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 18/06/2011
-- Description:	Deletes Daylight saving rule for timezone
-- =============================================
CREATE PROCEDURE [prcDeleteTimezoneDaylightSavingRule]
@TimezoneId int,
@RuleID int
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

DELETE FROM tblTimeZoneDaylightSavingRules
WHERE TimezoneID=@TimezoneId AND TimezoneRuleID=@RuleID
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_OrganisationsToNotify]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE   Procedure [prcAutomatedEmails_OrganisationsToNotify]
AS
Set Nocount On



declare @OrgID	    int

SELECT @OrgID = cast(coalesce((SELECT top 1 OrganisationID
from tblOrganisation
WHERE DelinquenciesLastNotified < CourseStatusLastUpdated) ,-1) as varchar(50))

update tblOrganisation set DelinquenciesLastNotified = CourseStatusLastUpdated where @OrgID = OrganisationID

select @OrgID
return @OrgID


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcgetEscalationConfigForCourse ]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


CREATE PROCEDURE [prcgetEscalationConfigForCourse ]
(
	@orgID int ,
	@courseID int	
)
AS
BEGIN
	
	
	select
		*
	from 
		tblReminderEscalation 
	where 
		CourseId =@courseID
		and OrgId= @orgID
	
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetTimeZoneWrittenName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


Create Procedure [prcOrganisation_GetTimeZoneWrittenName]
(
@OrgID int 		-- Organisation ID
)

As

Set NoCount On

-- Declarations
Declare @userID Integer

-- Validation
If (@OrgID Is Null)
Begin
Raiserror(''The Parameter @OrgID was null.  @OrgID does not accept Null values.'', 16, 1)
Return
End

-- Logic

Select
WrittenName
From
tblOrganisation ORG
inner join tblTimeZone TZ on ORG.TimeZoneID = TZ.TimeZoneID

WHERE ORG.OrganisationID = @OrgID


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetTimeZoneStandardName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


Create Procedure [prcOrganisation_GetTimeZoneStandardName]
(
@OrgID int 		-- Organisation ID
)

As

Set NoCount On

-- Declarations
Declare @userID Integer

-- Validation
If (@OrgID Is Null)
Begin
Raiserror(''The Parameter @OrgID was null.  @OrgID does not accept Null values.'', 16, 1)
Return
End

-- Logic

Select
WrittenName
From
tblOrganisation ORG
inner join tblTimeZone TZ on ORG.TimeZoneID = TZ.TimeZoneID

WHERE ORG.OrganisationID = @OrgID


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetTimeZone]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



CREATE Procedure [prcOrganisation_GetTimeZone]
(
@OrganisationID int
)

As

select TimeZoneID from tblOrganisation where organisationID = @OrganisationID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLocalisationGet]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcLocalisationGet]
	@LangInterfaceName NVarChar(4000),
	@LangResourceName NVarChar(4000),
	@CurrentCultureName NVarChar(4000)
AS
BEGIN
	DECLARE @LangID VarChar(4)
		SELECT @LangID = LangID FROM tblLang where tblLang.LangCode =   @CurrentCultureName
		IF @LangID IS NULL 
		BEGIN
			SELECT @LangID = LangID FROM tblLang where tblLang.LangCode = ''en_AU''
		END
	DECLARE @LangEntryValue NVarChar(4000)
SELECT @LangEntryValue = LangEntryValue
FROM tblLangValue
where LangID = @LangID and LangInterfaceID = 
	(SELECT LangInterfaceID
	FROM tblLangInterface
	where LangInterfaceName = @LangInterfaceName  )
and LangResourceID = 
	(SELECT LangResourceID
	FROM tblLangResource
	where LangResourceName = @LangResourceName)
	
	IF @LangEntryValue is NULL
	BEGIN
		SET @LangEntryValue = '' ''
		IF  @LangResourceName = ''lblPageTitle''
			BEGIN
				SELECT @LangEntryValue =  [Value]
				FROM tblAppConfig
				WHERE ''AppName''  = Name
			END
	END
	SELECT @LangEntryValue
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_GetUnitAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get''s a list of units that have access to a profile

Parameters:
@organisationID Integer
@ProfileID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcProfile_GetUnitAccess]
(
--@ProfileID int,
@ProfilePeriodID int
)
as
set nocount on

select
UnitID
from tblUnitProfilePeriodAccess
where ProfilePeriodID = @ProfilePeriodID
and Granted=1

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_SetUserAccessByUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s a users that have access to a profile

Parameters:
@PolicyID integer
@UserID integer
@Granted bit

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: Feb 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcPolicy_SetUserAccessByUser]
(
@PolicyID int,
@UserID int,
@Granted bit
)
as
set nocount on

update tblUserPolicyAccess
set Granted = @Granted
where PolicyID = @PolicyID
and UserID = @UserID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_SetUnitAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s a list of units that have access to a profile

Parameters:
@PolicyID integer
@UnitID integer

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: Feb 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcPolicy_SetUnitAccess]
(
@PolicyID int,
@UnitID int
)
as
set nocount on

update tblUnitPolicyAccess
set Granted = 1
where PolicyID = @PolicyID
and UnitID = @UnitID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_ResetUnitAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Reset''s all Unit''s access to profile to 0

Parameters:
@ProfileID integer

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: Feb 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcPolicy_ResetUnitAccess]
(
@PolicyID int
)
as
set nocount on


update tblUnitPolicyAccess
set Granted = 0
where PolicyID = @PolicyID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetUnitAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get''s a list of units that have access to a policy

Parameters:
@PolicyID

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: Feb 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcPolicy_GetUnitAccess]
(
@PolicyID int
)
as
set nocount on

select
UnitID
from tblUnitPolicyAccess
where PolicyID = @PolicyID
and Granted=1

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetCPDReportName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE   Procedure [prcReport_GetCPDReportName]
(
@OrgID int
)

As

select CPDReportName from tblorganisation where OrganisationID= @OrgID
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetListByUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets a list of all Courses a user can access
Parameters: None
Returns:

Called By: BusinessServices.Course.GetCourseListAccessableToUser
Calls: None

Remarks: None

Author: Stephen Kenendy-Clark
Date Created: 04th of May 2004

prcCourse_GetListByUser 11
Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcCourse_GetListByUser]
(
@userid  int -- The UserID
)

As

-------------------------------------------------------------
-- Return Select
-------------------------------------------------------------
Select distinct
c.[CourseID]
, c.[Name]
, c.[Notes]
, c.[Active]
, c.[CreatedBy]
, dbo.udfUTCtoDaylightSavingTime(c.[DateCreated], vUMA.OrganisationID)
, c.[UpdatedBy]
, dbo.udfUTCtoDaylightSavingTime(c.[DateUpdated], vUMA.OrganisationID)
From
[tblCourse] c
inner Join vwUserModuleAccess vUMA
on vUMA.CourseID = c.CourseID
and vUMA.userid = @userid
order by c.Name
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTotalNumberofMails]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE PROCEDURE [prcTotalNumberofMails]
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

SELECT COUNT(*) FROM tblEmail

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUpdateOrgDeliquency]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra
-- Create date: 17/06/2011
-- Description:	Update Delinquency settings for Organisation
-- =============================================
CREATE PROCEDURE [prcUpdateOrgDeliquency]

@OrgID int,
@WarnMgrsofDeliquentUsers bit,
@WarnUsersofDelinquency bit,
@NumberOfReminders int,
@DelinquencyPeriod int,
@DelinquencyReminderPeriod int,
@DaysWarningBeforeExpiry int,
@IncludeLogo bit,
@QuizDueDate datetime

AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

UPDATE tblOrganisation SET --WarnMgrsofDeliquentUsers = @WarnMgrsofDeliquentUsers,
--WarnUsersofDelinquency = @WarnUsersofDelinquency,
--NumberOfReminders = @NumberOfReminders,
--DelinquencyPeriod = @DelinquencyPeriod,
--DelinquencyReminderPeriod = @DelinquencyReminderPeriod,
--DaysWarningBeforeExpiry = @DaysWarningBeforeExpiry,
IncludeLogoOnCorrespondence = @IncludeLogo,
QuizDueDate = @QuizDueDate
WHERE OrganisationID = @OrgID
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_SaveCCUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 6/12/2011
-- Description:	Saves the CC users for periodic report
-- =============================================
CREATE PROCEDURE [prcReport_SaveCCUser] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int = 0, 
	@UserId int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF NOT EXISTS (SELECT * FROM tblCCList WHERE ScheduleId = @ScheduleId AND UserID = @UserId)
	BEGIN
		INSERT INTO tblCCList (UserID,ScheduleID) VALUES (@UserId, @ScheduleId)
	END

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcRequiresEffectiveDate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 9/11/2011
-- Description:	Checks if report type requires effective date in order to decide whether the parent page of periodic control has to disable effective date
-- =============================================
CREATE PROCEDURE [prcRequiresEffectiveDate] 
	-- Add the parameters for the stored procedure here
	@ReportId int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT RequiresParamEffectiveDate FROM tblReportInterface
		WHERE ReportID=@ReportId	
 
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcRequiresDateFromDateTo]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 9/11/2011
-- Description:	checks if report contains datefrom and dateto controls to disable when more than once control is selected for periodic report
-- =============================================
CREATE PROCEDURE [prcRequiresDateFromDateTo] 
	-- Add the parameters for the stored procedure here
	@ReportId int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    SELECT RequiresParamDateFrom & RequiresParamDateTo FROM tblReportInterface WHERE ReportID=@ReportId
     
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetTypeFromID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 10/11/2011
-- Description:	Gets report type name from report id
-- =============================================
CREATE PROCEDURE [prcReport_GetTypeFromID] 
	-- Add the parameters for the stored procedure here
	@ReportId int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT ReportName FROM tblReportInterface
		WHERE ReportID = @ReportId
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetReportRequiredParameters]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcReport_GetReportRequiredParameters]
@ReportID int
AS
BEGIN
SELECT [ReportID]
,[ReportName]
,[RDLname]
,[RequiresParamCompleted]
,[RequiresParamStatus]
,[RequiresParamFailCount]
,[RequiresParamCourseID]
,[RequiresParamCourseIDs]
,[RequiresParamHistoricCourseIDs]
,[RequiresParamUnitIDs]
,[RequiresParamAllUnits]
,[RequiresParamTimeExpired]
,[RequiresParamTimeExpiredPeriod]
,[RequiresParamQuizStatus]
,[RequiresParamGroupBy]
,[RequiresParamGroupingOption]
,[RequiresParamFirstName]
,[RequiresParamLastName]
,[RequiresParamUserName]
,[RequiresParamEmail]
,[RequiresParamIncludeInactive]
,[RequiresParamSubject]
,[RequiresParamBody]
,[RequiresParamDateTo]
,[RequiresParamDateFrom]
,[RequiresParamProfileID]
,[RequiresParamProfilePeriodID]
,[RequiresParamOnlyUsersWithShortfall]
,[ParamLangInterfaceName]
,[RequiresParamEffectiveDate]
,[RequiresParamSortBy]
,[RequiresParamClassificationID]
,[RequiresParamServerURL]
,[RequiresParamToDate]
,[RequiresParamFromDate]
,[RequiresParamUserID]
,[RequiresParamAdminUserID]
,[RequiresParamOrganisationID]

FROM tblReportInterface
WHERE ReportID = @ReportID
end
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetTZIDfromFLBName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra
-- Create date: 27/06/2011
-- Description:	Gets the timezone id from its display name
-- =============================================
CREATE PROCEDURE [prcTimeZone_GetTZIDfromFLBName]
@FLBName nvarchar(240)
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

SELECT TimeZoneID FROM tblTimeZone WHERE FLB_Name LIKE ''%'' + @FLBName + ''%''

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetTimeZoneWrittenName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



CREATE Procedure [prcTimeZone_GetTimeZoneWrittenName]
(
@TimeZoneID int
)

As

select WrittenName from tblTimeZone where TimeZoneID = @TimeZoneID




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetTimeZoneID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



CREATE Procedure [prcTimeZone_GetTimeZoneID]
(
@WrittenName varchar(60),
@TimeZoneID int output
)

As

select @TimeZoneID = coalesce(TimeZoneID,1) from tblTimeZone where upper(WrittenName) = upper(@WrittenName)
select @TimeZoneID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetTimeZoneFLBName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE Procedure [prcTimeZone_GetTimeZoneFLBName]
(
@TimeZoneID int
)

As

select FLB_Name from tblTimeZone where TimeZoneID = @TimeZoneID
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE Procedure [prcTimeZone_GetList]

As

SELECT TimeZoneID
,WrittenName
,OffsetUTC
,FLB_Name
FROM tblTimeZone
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_GetFLBNamefromTZID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra
-- Create date: 29/06/2011
-- Description:	Gets the FLB Name of timezone from id
-- =============================================
CREATE PROCEDURE [prcTimeZone_GetFLBNamefromTZID]
@TimezoneID int
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

SELECT FLB_Name FROM tblTimeZone WHERE TimeZoneID=@TimezoneID

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetEmailOnBehalfOf]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [udfGetEmailOnBehalfOf]
(
@OrgID int
)
RETURNS nvarchar(255)
AS
BEGIN
	DECLARE @OnBehalfOf nvarchar(255)
	SELECT @OnBehalfOf = [Value]
	  FROM tblAppConfig
	  WHERE [Name] = ''Email_OnBehalfOf''
RETURN @OnBehalfOf
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetEmailsinHour]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 14/06/2011
-- Description:	Gets emails delivered in last 1 hour
-- =============================================
CREATE FUNCTION [udfGetEmailsinHour]
(
@OrgName nvarchar(50)
)
RETURNS int
AS
BEGIN
-- Declare the return variable here
DECLARE @EmailsinHour int

-- Add the T-SQL statements to compute the return value here
SET @EmailsinHour = (SELECT COUNT(OrganisationID) FROM dbo.tblEmail
WHERE OrganisationID = (SELECT OrganisationID FROM tblOrganisation WHERE OrganisationName = @OrgName) AND
DateCreated BETWEEN DATEADD(hour, -1, GETUTCDATE()) AND GETUTCDATE())

-- Return the result of the function
RETURN @EmailsinHour

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetEmailsinDay]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [udfGetEmailsinDay]
(
@OrgName nvarchar(50)
)
RETURNS int
AS
BEGIN
-- Declare the return variable here
DECLARE @EmailsinDay int

-- Add the T-SQL statements to compute the return value here
SET @EmailsinDay = (SELECT COUNT(OrganisationID) FROM dbo.tblEmail
WHERE OrganisationID = (SELECT OrganisationID FROM tblOrganisation WHERE OrganisationName = @OrgName) AND
DateCreated BETWEEN DATEADD(DAY, -1, GETUTCDATE()) AND GETUTCDATE())

-- Return the result of the function
RETURN @EmailsinDay

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportListUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 18/10/2011
-- Description:	Gets the list of periodic reports for a user
-- =============================================
CREATE PROCEDURE [prcGetPeriodicReportListUser]
(
	@OrgID int,
	@Username varchar(50)
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @CCList TABLE(ScheduleId int, CC int)
	INSERT INTO @CCList(ScheduleId, CC) 
		(SELECT ccl.ScheduleId, Count(UserId) as CC FROM tblCCList ccl
			GROUP BY ccl.ScheduleId
			HAVING ccl.ScheduleId In 
				(SELECT rs.ScheduleId FROM tblReportSchedule rs
				JOIN dbo.tblUser u ON u.UserID = rs.UserID))

	SELECT rs.ScheduleID, rs.ReportID, rs.UserID, rs.ReportTitle, ri.ReportName, 
	(convert(varchar, rs.ReportFrequency) + (CASE rs.ReportFrequencyPeriod WHEN ''D'' THEN '' Days'' WHEN ''W'' THEN '' Weeks'' WHEN ''M'' THEN '' Months'' WHEN ''Y'' THEN '' Years'' END)) AS ReportFrequency, 
	convert(varchar(11), rs.DateCreated, 113) as DateCreated,
	convert(varchar(11), rs.ReportStartDate, 113) as ReportStartDate, 
	convert(varchar(11), rs.ReportEndDate, 113) as ReportEndDate, 
	convert(varchar(11), rs.NextRun, 113) as NextRun, (u.FirstName + '' '' + u.LastName) as Username, ut.Type, 
	CASE WHEN (ccl.CC > 0) THEN (Convert(varchar, (ccl.CC + 1)) + '' Recepients'') ELSE u.UserName END as CCUser
		FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID
		JOIN dbo.tblUser u ON u.UserID = rs.UserID
		JOIN dbo.tblUserType ut ON u.UserTypeID = ut.UserTypeID
		LEFT JOIN @CCList ccl ON ccl.ScheduleId = rs.ScheduleId
		WHERE rs.ParamOrganisationID = @OrgID AND rs.IsPeriodic != ''N''
		AND u.UserName = @Username AND (u.UserTypeID <> 1 OR u.UserTypeID = 3)
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportListOnInactivateUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 21/10/2011
-- Description:	Gets the list of periodic reports on inactivating user
-- =============================================
CREATE PROCEDURE [prcGetPeriodicReportListOnInactivateUser]
(
	@OrgID int,
	@Username varchar(50)
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  	SELECT rs.ScheduleID, rs.UserID, ri.ReportID, rs.ReportTitle, u.Username, ri.ReportName, rs.ReportFrequency
	FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID
	JOIN dbo.tblUser u ON u.UserID = rs.UserID
	WHERE rs.ParamOrganisationID = @OrgID AND 
	(u.Username=@Username OR rs.scheduleid in 
	(select scheduleid from tblCCList ccl JOIN 
	tblUser tu ON tu.userid = ccl.userid where tu.username = @Username))
END
-- OR ' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportListOnInactivateEmail]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 21/10/2011
-- Description:	Gets the list of periodic reports on inactivating user
-- =============================================
CREATE PROCEDURE [prcGetPeriodicReportListOnInactivateEmail]
(
	@OrgID int,
	@Email varchar(50)
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

  	SELECT rs.ScheduleID, rs.UserID, ri.ReportID, rs.ReportTitle, u.Username, ri.ReportName, rs.ReportFrequency
	FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID
	JOIN dbo.tblUser u ON u.UserID = rs.UserID
	WHERE rs.ParamOrganisationID = @OrgID AND 
	(u.Email=@Email OR rs.scheduleid in 
	(select scheduleid from tblCCList ccl JOIN 
	tblUser tu ON tu.userid = ccl.userid where tu.Email=@Email))
END
-- OR 
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportListOnInactivateBulkUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 21/10/2011
-- Description:	Gets the list of periodic reports on bulk inactivating users
-- =============================================
CREATE PROCEDURE [prcGetPeriodicReportListOnInactivateBulkUsers]
(
	@OrgID int
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @InActivatedUsers TABLE(UserID int, Processed bit)
	INSERT INTO @InActivatedUsers(UserID, Processed) (SELECT UserID, Processed from tblBulkInactiveUsers WHERE Processed = 0)

	SELECT rs.ScheduleID, rs.UserID, ri.ReportID, rs.ReportTitle, u.Username, ri.ReportName, rs.ReportFrequency
		FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID
		JOIN dbo.tblUser u ON u.UserID = rs.UserID
		WHERE rs.ParamOrganisationID = @OrgID
		AND u.UserID in (SELECT UserID FROM @InActivatedUsers)
			
	UPDATE tblBulkInactiveUsers SET Processed = 1 
		WHERE UserID in (SELECT UserID FROM @InActivatedUsers)
		
	DELETE FROM tblBulkInactiveUsers WHERE Processed = 1

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicReportList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 30/09/2011
-- Description:	Gets the list of periodic reports
-- =============================================
CREATE PROCEDURE [prcGetPeriodicReportList]
(
	@OrgID int
) 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @CCList TABLE(ScheduleId int, CC int)
	INSERT INTO @CCList(ScheduleId, CC) 
		(SELECT ccl.ScheduleId, Count(UserId) as CC FROM tblCCList ccl
			GROUP BY ccl.ScheduleId
			HAVING ccl.ScheduleId In 
				(SELECT rs.ScheduleId FROM tblReportSchedule rs
				JOIN dbo.tblUser u ON u.UserID = rs.UserID))

	SELECT rs.ScheduleID, rs.ReportID, rs.UserID, rs.ReportTitle, ri.ReportName, 
	(convert(varchar, rs.ReportFrequency) + (CASE rs.ReportFrequencyPeriod WHEN ''D'' THEN '' Days'' WHEN ''W'' THEN '' Weeks'' WHEN ''M'' THEN '' Months'' WHEN ''Y'' THEN '' Years'' END)) AS ReportFrequency, 
	convert(varchar(11), rs.DateCreated, 113) as DateCreated,
	convert(varchar(11), rs.ReportStartDate, 113) as ReportStartDate, 
	convert(varchar(11), rs.ReportEndDate, 113) as ReportEndDate, 
	convert(varchar(11), rs.NextRun, 113) as NextRun, (u.FirstName + '' '' + u.LastName) as Username, ut.Type, 
	CASE WHEN (ccl.CC > 0) THEN (Convert(varchar, (ccl.CC + 1)) + '' Recepients'') ELSE u.UserName END as CCUser
		FROM dbo.tblReportSchedule rs JOIN dbo.tblReportInterface ri ON rs.ReportID = ri.ReportID
		JOIN dbo.tblUser u ON u.UserID = rs.UserID
		JOIN dbo.tblUserType ut ON u.UserTypeID = ut.UserTypeID
		LEFT JOIN @CCList ccl ON ccl.ScheduleId = rs.ScheduleId
		WHERE rs.ParamOrganisationID = @OrgID AND rs.IsPeriodic != ''N''

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_Add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Add a new Organisation.

Parameters:
@intOrganisationID Integer OutPut
@organisationID Integer
@organisationName VarChar(50)
@notes VarChar(1000)
@logo VarChar(100)
@lessonFrequency Integer
@quizFrequency Integer
@quizPassMark Integer
@CPDReportName nvarchar(255)
@AllocatedDiskSpace Integer = Null
@InclLogo bit = 0,
@PasswordLockout bit = 0
@TimeZoneID int = Null


Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
4. UniqueViolationException
5. MissingParameterException
6. PermissionDeniedException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 18th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		30/4/2007		Added @lessonCompletionDate and @quizCompletionDate
#2  aaronc		May 2008		Added @CPDReportName
#3	aaronc		June 2008		Added @AllocatedDiskSpace
#4  aaronc		June2008		Addition of organisation record to tblOrganisationCPDPolicyAccess
#5  vdl			08 June 2011	Time zone

**/
CREATE    Procedure [prcOrganisation_Add]
(
@intOrganisationID Integer OutPut, -- The ID of the newly created organisation.
@organisationName nVarChar(50) = Null, -- The name of the organisation.
@notes nVarChar(4000) = Null, -- The notes for the organisation.
@logo VarChar(100) = Null, -- The name of the organisation logo image.
@lessonFrequency Integer = Null, -- Default Lesson frequency for the organisation.
@quizFrequency Integer = Null, -- Default Quiz frequency for the organisation.
@quizPassMark Integer = Null, -- Default Quiz pass mark for the organisation.
@lessonCompletionDate DateTime = Null, -- Default Lesson completion date
@quizCompletionDate DateTime = Null, -- Default Quiz completion date
@advancedReporting bit = 0,
@actionUserID Integer = Null, -- ID of the User that is making the changes.
@CPDReportName nvarchar(255) = Null, -- CPD Report Name
@AllocatedDiskSpace Integer = Null, -- Allocated Disk Space
@InclLogo bit = 0, -- include Certificate Logo
@PasswordLockout bit = 0,
@TimeZoneID int = Null,
@ShowLastPassed bit = 1
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number
Declare @intUserTypeOrgAdmin Integer -- Holds the value for the OrgAdmin UserTypeID from the tblUserType table.

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0
Select @intUserTypeOrgAdmin = UserTypeID From tblUserType Where Type = ''Organisation Administrator''

-- Validation Routines
If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_Add''
Goto Finalise
End

If Not Exists(Select * From tblUser Where UserID = @actionUserID And UserTypeID <= @intUserTypeOrgAdmin)
Begin
Set @intErrorNumber = 6
Set @strErrorMessage = ''You do not have access to modify this Organisation.''
Goto Finalise
End

If(@organisationName Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationName in stored procedure prcOrganisation_Add''
Goto Finalise
End

If Exists(Select * From tblOrganisation Where OrganisationName = @organisationName)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Organisation Name '' + @organisationName + '' already exists please choose another name for your Organisation.''
Goto Finalise
End

If(@notes Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @notes in stored procedure prcOrganisation_Add''
Goto Finalise
End

If(@logo Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @logo in stored procedure prcOrganisation_Add''
Goto Finalise
End

If(@lessonFrequency Is Null and @lessonCompletionDate Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @lessonFrequency, @lessonCompletionDate in stored procedure prcOrganisation_Add''
Goto Finalise
End

If(@quizFrequency Is Null and @quizCompletionDate Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @quizFrequency, @quizCompletionDate in stored procedure prcOrganisation_Add''
Goto Finalise
End

If(@quizPassMark Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @quizPassMark in stored procedure prcOrganisation_Add''
Goto Finalise
End

Insert Into tblOrganisation
(
OrganisationName,
Logo,
DefaultLessonFrequency,
DefaultQuizFrequency,
DefaultQuizPassMark,
--	DefaultLessonCompletionDate,
--	DefaultQuizCompletionDate,
advancedReporting,
CreatedBy,
CPDReportName,
AllocatedDiskSpace,
IncludeCertificateLogo,
PasswordLockout,
TimeZoneID,
ShowLastPassed
)
Values
(
@organisationName,
@logo,
@lessonFrequency,
@quizFrequency,
@quizPassMark,
--	@lessonCompletionDate,
--	@quizCompletionDate,
@advancedReporting,
@actionUserID,
@CPDReportName,
@AllocatedDiskSpace,
@InclLogo,
@PasswordLockout,
@TimeZoneID,
@ShowLastPassed
)


Select @intOrganisationID = @@Identity

-- lesson completion datetime to utc
set @lessonCompletionDate = dbo.udfDaylightSavingTimeToUtc (@lessonCompletionDate, @intOrganisationID)

-- quiz completion time to utc
set @quizCompletionDate = dbo.udfDaylightSavingTimeToUtc (@quizCompletionDate, @intOrganisationID)


--update the org with these utc dates
update
tblOrganisation
set
DefaultLessonCompletionDate = @lessonCompletionDate,
DefaultQuizCompletionDate = @quizCompletionDate
where
OrganisationID =  @intOrganisationID



insert into tblOrganisationCPDAccess
(
OrganisationID,
GrantCPDAccess
)
values
(
@intOrganisationID,
0 -- no access initially
)

insert into tblOrganisationPolicyAccess
(
OrganisationID,
GrantPolicyAccess
)
values
(
@intOrganisationID,
0 -- no access initially
)

-- Add values to tblOrganisationNotes
Declare LangIDLOOP CURSOR
for
select LangID from tblLang

open LangIDLOOP

declare @LangID int

FETCH NEXT from LangIDLOOP into @LangID
while @@FETCH_STATUS = 0
BEGIN

insert into tblOrganisationNotes
(
OrganisationID,
LanguageID,
Notes
)
values
(
@intOrganisationID,
@LangID,
@notes
)
FETCH NEXT from LangIDLOOP into @LangID
END
close LangIDLOOP
deallocate LangIDLOOP

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
''Successfully Added'' As ''ErrorMessage''
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_HistoricUserQuizStatus]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfReport_HistoricUserQuizStatus    Script Date: 20/04/2004 8:25:58 AM ******/

/*Summary:
gets the historic quiz results for each user(up to effective date)

Returns:
Table

Called By:
Calls:

Remarks:


Author:
Jack Liu
Date Created: 1 March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


--------------------
-- SELECT * FROM dbo.udfReport_HistoricUserQuizStatus(''20040229'')

**/

CREATE   function [udfReport_HistoricUserQuizStatus]
(
@effectiveDate datetime
)
Returns table
as
return 	select
QuizStatus.UserQuizStatusID
, QuizStatus.UserID
, QuizStatus.ModuleID
, m.CourseID
, QuizStatus.QuizStatusID
, QuizStatus.QuizFrequency
, QuizStatus.QuizPassMark
, QuizStatus.QuizScore
, QuizStatus.DateCreated

from
tblUserQuizStatus QuizStatus
inner join tblModule m on m.ModuleID = QuizStatus.ModuleID
inner join
(
select
max(UserQuizStatusID) UserQuizStatusID --UserQuizStatusID is identity
from
tblUserQuizStatus
where DateDiff(day, DateCreated, @effectiveDate)>=0
group by
UserID,moduleID
) HistoricStatus
on QuizStatus.UserQuizStatusID = HistoricStatus .UserQuizStatusID
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_HistoricUserLessonStatus]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfReport_HistoricUserLessonStatus    Script Date: 20/04/2004 8:25:58 AM ******/

/*Summary:
gets the historic lesson results for each user(up to effective date)

Returns:
Table

Called By:
Calls:

Remarks:


Author:
Jack Liu
Date Created: 1 March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


--------------------
-- SELECT * FROM dbo.udfReport_HistoricUserLessonStatus(''20040229'')

**/

CREATE  function [udfReport_HistoricUserLessonStatus]
(
@effectiveDate datetime
)
Returns table
as
return select 	LessonStatus.UserLessonStatusID,
LessonStatus.UserID,
LessonStatus.ModuleID,
m.CourseID,
LessonStatus.LessonStatusID,
LessonStatus.LessonFrequency,
LessonStatus.DateCreated
from tblUserLessonStatus LessonStatus
inner join tblModule m
on m.ModuleID = LessonStatus.ModuleID
inner join (select max(UserLessonStatusID) UserLessonStatusID
from tblUserLessonStatus
where DateDiff(day, DateCreated, @effectiveDate)>=0
group by 	UserID,moduleID) HistoricStatus
on LessonStatus.UserLessonStatusID = HistoricStatus.UserLessonStatusID
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_HistoricAdminSummary]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfReport_HistoricAdminSummary    Script Date: 20/04/2004 8:25:58 AM ******/


/*Summary:
Get the Current or historic user module status  based on the search criteria

See the remarks below.

Returns: table

Called By: Current historic Admin Report
Calls:

Remarks:

1. Get User and course List based on search criteria
1.1 Get Unit List
1.1.1 If unit ids are passed in, convert the CSV format to a table
1.1.2 If no unit is selected, get a list of of all units that the admin user has permission to access
1.2 Get User list Based on the first name and last name in the search cirteria
1.3 Get Course list Based on the selected course in the search criteria and Used can select multiple Courses
2. Get the User Quiz and Lesson status up to the effective date
2.1 If there is no effective date is passed in, get the current module status
2.2 If there is effective date, get the module status up to the effective date
3.  Get a list of the user''s quiz and lesson historic status

Author: Jack Liu
Date Created: 1 Mar 2004

Modification History
-----------------------------------------------------------
v#	Author		Date				Description
#1.1	Usman Tjiudri	10/11/2005	Performance tuning:
- use temp-table to populate Unit Pathway
- join the temp-table to populate tblResult
instead of using udfGetUnitPathway function in the join.
#2.0	Serguei Chkaroupine 28/02/06 -New insert statement for histric admin report
- it will insert all lessons that match current quizmodule pair
- Current admin report performance fix. Added WHERE statement to
most of the insert statements.

select * from dbo.udfReport_HistoricAdminSummary(3, '''', ''1,2,3,4'','''','''',''20040222'',4)

--------------------

**/
--instead of using udfGetUnitPathway function in the join.

--select * from dbo.udfReport_HistoricAdminSummary(3, '''', ''1,2,3,4'','''','''',''20040222'',4)

--------------------



CREATE         Function [udfReport_HistoricAdminSummary]
(
@organisationID 	Int,
@unitIDs			Varchar(8000),
@courseIDs			Varchar(8000),
@userFirstName		nVarchar(50),
@userLastName		nVarchar(50),
@effectiveDate 		Datetime,
@adminUserID		Int,
@classificationID 	Int
)
Returns @tblResult Table
(
-- General
Unit			nVarchar(200),
[User]			nVarchar(100),
Course			nVarchar(100),
Module			nVarchar(100),
[Sequence]		Int,

-- Quiz Specific
QuizStatus		Varchar(50),
QuizScore		Int,
QuizStatusDate	Datetime,

-- Lesson Specific
LessonStatus	Varchar(50),

-- Hidden
UnitID			Int,
UserID			Int,
UserName		nVarchar(100),
ExternalID		nVarchar(50),
CourseID		Int,
ModuleID		Int
)
As Begin
Declare @userTypeID Int
Declare @tblUnit 	Table(UnitID Int)
Declare @tblUser 	Table(UserID Int)
Declare @tblCourse 	Table(CourseID Int, Name nVarchar(50))
Declare @tblUnitPathway Table(UnitID Int, Pathway nVarchar(200)) -- New table

Declare @tblUserQuizStatus Table
(
[UserQuizStatusID] [int] Not Null,
[UserID] [int] Not Null,
[ModuleID] [int] Not Null,
[QuizStatusID] [int] Not Null,
[QuizScore] [int] Null,
[DateCreated] [datetime] Not Null
)

Declare @tblUserLessonStatus Table
(
[UserLessonStatusID] [int] ,
[UserID] [int] ,
[ModuleID] [int] ,
[LessonStatusID] [int] ,
[DateCreated] [datetime]
)


/*
1. Get User and course List based on search criteria
1.1 Get Unit List
1.1.1 If unit ids are passed in, convert the CSV format to a table
1.1.2 If no unit is selected, get a list of of all units that the admin user has permission to access
1.2 Get User list
Based on the first name and last name in the search cirteria
1.3 Get Course list
Based on the selected course in the search criteria
Used can select multiple Courses
*/

If @unitIDs Is Null Set @unitIDs = ''''

If (@unitIDs !='''')
Begin
Insert Into @tblUnit (UnitID)
Select intValue
From dbo.udfCsvToInt(@unitIDs)
End
Else
Begin
Select @userTypeID = userTypeID
From tblUser
Where userID = @adminUserID

--Get all units in that organisation if user is Salt Admin(1) or Org admin (2)
If (@userTypeID=1 Or @userTypeID=2)
Begin
Insert Into @tblUnit (UnitID)
Select UnitID
From tblUnit
Where OrganisationID = @OrganisationID
End
--Get units that the user is admministrator if user is Unit Admin(3)
Else If (@userTypeID=3)
Begin
Insert Into @tblUnit (UnitID)
Select u.UnitID
From tblUnit u
Inner Join tblUnitAdministrator ua On ua.UnitID = u.UnitID And ua.userID = @AdminUserID
Where u.OrganisationID = @OrganisationID
End
End

--FirstName or Last Name specified in search criteria
If (@userFirstName Is Null) Set @userFirstName = ''''
If (@userLastName Is Null) Set @userLastName = ''''

Insert Into @tblUser (UserID)
Select	u.UserID
From tblUser u
Inner Join @tblUnit unit On u.UnitID = unit.UnitID
Left Join tblUserClassification uc On uc.UserID  = u.UserID
Where u.FirstName Like ''%'' + @userFirstName + ''%''
And LastName Like ''%'' + @userLastName + ''%''
And --AND have the Custom Classification option
--If classification is Any (0), This will find users of any Custom Classification
( (@classificationID =0) Or (uc.classificationID = @classificationID) )
And (u.Active=1)
AND (u.OrganisationID = @OrganisationID)

-- Search criteria contains course id''s
Insert Into @tblCourse (CourseID, Name)
Select c.CourseID, c.name
From dbo.udfCsvToInt(@courseIDs) ca
Inner Join tblCourse c On ca.intValue = c.CourseID

/*
2. Get the User Quiz and Lesson status up to the effective date
2.1 If there is no effective date is passed in, get the current module status
2.2 If there is effective date, get the module status up to the effective date
*/

If (@effectiveDate Is Null)
Begin
Insert Into @tblUserQuizStatus
(
[UserQuizStatusID],
[UserID],
[ModuleID],
[QuizStatusID],
[QuizScore],
[DateCreated]
)
Select
[UserQuizStatusID],
[UserID],
[ModuleID],
[QuizStatusID],
[QuizScore],
[DateCreated]
From vwUserQuizStatus
Where QuizStatusID <> 0
AND UserID in  (SELECT UserID FROM @tblUser)

Insert Into @tblUserLessonStatus
(
[UserLessonStatusID],
[UserID],
[ModuleID],
[LessonStatusID],
[DateCreated]
)
Select
[UserLessonStatusID],
[UserID],
[ModuleID],
[LessonStatusID],
[DateCreated]
From vwUserLessonStatus
Where LessonStatusID <> 0
AND UserID in  (SELECT UserID FROM @tblUser)
End

Else

Begin
Insert Into @tblUserQuizStatus
(
[UserQuizStatusID],
[UserID],
[ModuleID],
[QuizStatusID],
[QuizScore],
[DateCreated]
)
Select
[UserQuizStatusID],
[UserID],
[ModuleID],
[QuizStatusID],
[QuizScore],
[DateCreated]
From dbo.udfReport_HistoricUserQuizStatus(@effectiveDate)
Where QuizStatusID <> 0
AND UserID in  (SELECT UserID FROM @tblUser)

Insert Into @tblUserLessonStatus
(
[UserLessonStatusID],
[UserID],
[ModuleID],
[LessonStatusID],
[DateCreated]
)
Select
[UserLessonStatusID],
[UserID],
[ModuleID],
[LessonStatusID],
[DateCreated]
From dbo.udfReport_HistoricUserLessonStatus(@effectiveDate)
Where LessonStatusID <> 0
AND UserID in  (SELECT UserID FROM @tblUser)


-- This part fixes migration issue (note this will affect historic admin report only as it does supply effective date)
-- It will insert userid, moduleid and earliest lesson status for each quiz that does not have lesson record yet
-- into @tblUserLessonStatus
Insert Into @tblUserLessonStatus
(
[UserLessonStatusID],
[UserID],
[ModuleID],
[LessonStatusID],
[DateCreated]
)
Select
1,
uls.[UserID],
uls.[ModuleID],
uls.LessonStatusID,
uls.DateCreated
From  @tblUserQuizStatus uqs
INNER JOIN tblUserLessonStatus uls
ON uqs.UserID = uls.UserID AND uqs.ModuleID = uls.ModuleID
INNER JOIN
(
-- this derived table gets earliest lesson datecreated in a group
SELECT  UserID, ModuleID, min(DateCreated) as DateCreated
FROM tblUserLessonStatus
WHERE UserID in (SELECT UserID FROM @tblUser)
GROUP BY UserID, ModuleID --, DateCreated
) as els -- Earliest Lesson Status
ON els.UserID = uls.UserID AND els.ModuleID = uls.ModuleID AND els.DateCreated = uls.DateCreated
WHERE NOT EXISTS
(
SELECT 1 FROM @tblUserLessonStatus uls
WHERE uqs.UserID = uls.UserID and uqs.ModuleID = uls.ModuleID
)
AND uls.UserID in (SELECT UserID FROM @tblUser)



End

/* Populate Unit Pathway using temp-table */
Insert Into @tblUnitPathway
Select UnitID As [UnitID], dbo.udfGetUnitPathway(UnitID) As [Pathway]
From @tblUnit
--Order By tblUnit.UnitID
-- sp_help udfCsvToInt
/* 3.  Get the user''s quiz and lesson status details */
Insert Into @tblResult
(
Unit,
[User],
Course,
Module,
[Sequence],
QuizStatus,
QuizStatusDate,	-- These columns have been reordered
QuizScore,	    -- These columns have been reordered
LessonStatus,
UnitID,
UserID,
UserName,
ExternalID,
CourseID,
ModuleID
)
Select
-- General
up.Pathway 						As Unit, -- Unit Name
u.LastName + '' '' + u.FirstName  As ''User'', -- User Full Name
c.Name			  				As Course, -- Course Name
m.Name			  				As Module, -- Module Name
m.Sequence						As Sequence,

-- Quiz Specific
qs.Status						As QuizStatus,
uqs.DateCreated 			    as QuizStatusDate,	-- These columns have been reordered
uqs.QuizScore 				    as QuizScore,		-- These columns have been reordered

-- Lesson Specific
ls.status 						As LessonStatus,

-- Hidden
u.UnitID						As UnitID,
u.UserID						As UserID,
u.UserName						As UserName,
u.ExternalID						As ExternalID,
c.CourseID						As CourseID,
m.ModuleID						As ModuleID

From @tblUserQuizStatus uqs
Inner Join tblQuizStatus qs On qs.QuizStatusID = uqs.QuizStatusID
Inner Join @tblUser us 	On us.UserID = uqs.UserID
Inner Join tblUser u On u.UserID = us.UserID
INNER Join @tblUnitPathway up On up.UnitID = u.UnitID
INNER Join tblModule m On m.ModuleID = uqs.ModuleID
INNER Join @tblCourse c On c.CourseID = m.CourseID
INNER Join @tblUserLessonStatus uls On uls.UserID = u.UserID And uls.ModuleID = m.ModuleID
INNER Join tblLessonStatus ls On ls.LessonStatusID = uls.LessonStatusID


Return
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CompletedUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'








/*Summary:
Given a user id returns the list of courses / modules and the latest results for that user
If the User id is ommited it returns results for all users
Returns:
Course ID

Called By:
Home.aspx via Businessservices.Report.GetCompletedUsersReport
Calls:
udfReport_CompletUsers_logic
udfReport_IncompletUsers_logic
Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 18 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1  Liz Dionisio(UW)	8/11/2005		Added Username, Email and ExternalID to returned recordset
#2  Mark Donald	24/07/2009		Add LastCompleted column to incomplete users select statement

prcReport_CompletedUsers @unitIDs=''1,2,3,4'' , @courseID=1 , @completed = 0

--------------------

**/

CREATE          Proc [prcReport_CompletedUsers]

(
@organisationID Integer,		-- Organisation of the current user
@unitIDs varchar(MAX) = '''',	-- string of unit id''s
@courseID int,			-- course ID to restrict search to
@effectiveDate datetime = Null,	-- Effective date as at when to run the report
@completed bit = 0 		-- Completed or incompleted flag
-- 1 = True = completed users
-- 0 = false (default) = not comleted or INcompleted users
)

AS
------------------------------------------
Set Nocount On
If @completed = 1
Begin
SELECT
f.userid, unitid, firstname, lastname, unitpathway,
dbo.udfUTCtoDaylightSavingTime(max(q.datecreated), @organisationID) as date, --date
username, email, externalid
FROM
dbo.udfreport_completeuserslogic(@organisationid, @unitids, @courseid, @effectivedate) f,
tbluserquizstatus q,
tblmodule m
WHERE
m.courseid = @courseid
AND q.moduleid = m.moduleid
AND q.userid = f.userid
AND quizstatusid = 2 -- passed
GROUP BY
f.userid, unitid, firstname, lastname, unitpathway, username, email, externalid
ORDER BY
unitpathway, lastname, firstname
End
Else
Begin
Select
userID
, unitID
, FirstName
, LastName
, UnitPathway
, LastCompleted
, Username
, Email
, ExternalID
From
dbo.udfReport_IncompleteUsersLogic(@organisationID, @unitIDs, @courseID,@effectiveDate)
Order By
UnitPathway, LastName, FirstName
End
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_UserSearch]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Returns results of search for users on Assign Users tab of CPDdetail.aspx

Returns:

Called By:

Calls:

Remarks:
The searching units will include all children and grandchildren
Only return users that logged on user has permission to see


Author: Aaron Cripps
Date Created: July 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

CREATE  Procedure  [prcProfile_UserSearch]
(
@organisationID  Int,
@ProfileID int,
@ProfilePeriodID int,
@parentUnitIDs  Varchar(8000),
@firstName	nVarchar(50),
@lastName	nVarchar(50),
@userName	nVarChar(100),
@Email		nVarChar(100),
@ExternalID nVarChar(50),
@adminUserID		Int,
@Type nvarchar(50)
)
As
Set Nocount On

Declare @intUserTypeID Int

Select @intUserTypeID = UserTypeID
From tblUser
Where userID = @adminUserID


if  @ProfilePeriodID is null
Set @ProfilePeriodID =0


--Check Data
If @parentUnitIDs is null
set @parentUnitIDs =''''

If @firstName is null
Set @firstName = ''''

Set @firstName =rtrim(@firstName)

If @lastName is null
Set @lastName = ''''

Set @lastName =rtrim(@lastName)

If @userName is null
Set @userName = ''''

set @userName = rtrim(@userName)

if @Email is null
set @Email = ''''

set @Email = rtrim(@Email)

if @ExternalID is null
set @ExternalID = ''''

set @ExternalID = rtrim(@ExternalID)

if @Type = ''search''
Begin
Select
us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(dbo.udfUTCtoDaylightSavingTime(us.LastLogin, @organisationID) as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active,
uppa.Granted

From tblUnit un, tblUser us, tblUserProfilePeriodAccess uppa

Where (un.OrganisationID = @organisationID)
and
(
us.Active=1
)
--0. Join Unit and User tables
and (
un.UnitID = us.UnitID
)
-- Join User and UserProfilePeriodAccess tables
and (
us.UserID = uppa.UserID
)
and (
uppa.ProfilePeriodID = @ProfilePeriodID
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
and (
un.UnitID in
(
Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
)
or (@parentUnitIDs='''')
)
--2. User firstname contains the entered text
and (
(firstname like ''%''+ @firstName + ''%'')
or (firstname ='''')
)
--3. User lastname contains the entered text
and (
(lastname like ''%''+ @lastName + ''%'')
or (lastname ='''')
)
-- User username contains the entered text
and (
(username like ''%'' + @userName + ''%'')
or (userName='''')
)
-- User email contains the entered text
and (
(email like ''%'' + @Email + ''%'')
or (email='''') or (email is null)
)
-- User externalid contains the entered text
and (
(externalID like ''%'' + @ExternalID + ''%'')
or (externalID = '''') or (externalid is null)
)
--4. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
Order By Name
End
else if @Type = ''view''
Begin
Select
us.UserID,
us.UserName,
us.FirstName,
case
When us.Active = 0 then us.LastName + ''(I)''
Else us.LastName
end as LastName,
case
When us.LastLogin Is Null then ''Never''
Else cast(dbo.udfUTCtoDaylightSavingTime(us.LastLogin, @organisationID) as varchar)
end as LastLogin,
dbo.udfGetUnitPathway(us.UnitID) as Pathway,
us.Active,
uppa.Granted

From tblUnit un, tblUser us, tblUserProfilePeriodAccess uppa

Where (un.OrganisationID = @organisationID)
and
(
us.Active=1
)
--0. Join Unit and User tables
and (
un.UnitID = us.UnitID
)
-- Join User and UserProfilePeriodAccess tables
and (
us.UserID = uppa.UserID
)
and (
uppa.ProfilePeriodID = @ProfilePeriodID
)
--1. Within the selected Parent Units (can select multiple units)
--The unit hierarchy contains the parent Unit ID
--and (
--un.UnitID in
--	(
--		Select IntValue from dbo.udfCsvToInt(@parentUnitIDs)
--	)
--	or (@parentUnitIDs='''')
--	)
--2. User firstname contains the entered text
--and (
--	(firstname like ''%''+ @firstName + ''%'')
--	or (firstname ='''')
--    )
--3. User lastname contains the entered text
--and (
--	(lastname like ''%''+ @lastName + ''%'')
--	or (lastname ='''')
--    )
-- User username contains the entered text
--and (
--	(username like ''%'' + @userName + ''%'')
--	or (userName='''')
--	)
-- User email contains the entered text
--and (
--	(email like ''%'' + @Email + ''%'')
--	or (email='''') or (email is  null)
--	)
-- User externalid contains the entered text
--and (
--	(externalID like ''%'' + @ExternalID + ''%'' )
--	or (externalID = '''') or (externalid is null)
--	)
--4. Permission
--Salt Administrator(1), Organisation Administrator(2) has permission to access all units
--Unit Administrator(3) only has permission to those that he is administrator
and (
(@intUserTypeID<3)
or (un.UnitID in (select UnitID from tblUnitAdministrator where UserID=@adminUserID))
)
and uppa.Granted=1
Order By Name
End

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_SetAdmin]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Sets a new Organisation Administrator.

Parameters:
@updateUserID Integer
@actionUserID Integer
@organisationID Integer
@originalDateUpdated Integer

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
6. PermissionDeniedException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 13th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE  Procedure [prcOrganisation_SetAdmin]
(
@updateUserID Integer = Null, -- ID of the User that you wish to set Admin rights for.
@actionUserID Integer = Null, -- ID of the User that is making the changes.
@organisationID Integer = Null, -- ID of the Organisation that this user must belong to.
@originalDateUpdated Integer -- original Date of the record.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

set @originalDateUpdated = cast(dbo.udfDaylightSavingTimeToUTC(@originalDateUpdated, @organisationID) as integer)

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number
Declare @intUserTypeOrgAdmin Integer -- Holds the value for the OrgAdmin UserTypeID from the tblUserType table.
Declare @dtCurrentDateUpdated DateTime -- Holds the current date updated date.

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0
Select @intUserTypeOrgAdmin = UserTypeID From tblUserType Where Type = ''Organisation Administrator''
Select @dtCurrentDateUpdated = dbo.udfUTCtoDaylightSavingTime(DateUpdated, @organisationID) From tblUser Where UserID = @updateUserID

-- Validation Routines
If(@updateUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If Exists(Select * From tblUser Where UserID = @actionUserID And UserTypeID = @intUserTypeOrgAdmin)
Begin
Set @intErrorNumber = 6
Set @strErrorMessage = ''You do not have access to modify this User.  Click here to return to the login page.''
Goto Finalise
End

If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

If(@originalDateUpdated != @dtCurrentDateUpdated)
Begin
Set @intErrorNumber = 7
Set @strErrorMessage = ''The user''''s details have been updated by another user, you will need to refresh the users details and re-enter your changes.  Click here to refresh.''
Goto Finalise
End

If Exists(Select * From tblUser Where UserID = @updateUserID)
Begin
Update tblUser
Set
UserTypeID = @intUserTypeOrgAdmin
Where
UserID = @updateUserID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''Record not found @userID in stored procedure prcOrganisation_SetAdmin''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Gets a list of all users that are not organisation administrators for the specified organisation.

Parameters:
@organisationID Integer
@firstName Varchar(50) = ''''
@lastname Varchar(50) = ''''

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:

Author: Peter Vranich
Date Created: 17th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE    Procedure [prcOrganisation_GetUsers]
(
@organisationID Integer = Null, -- ID of the Organisation to get the users from.
@firstName nVarchar(50) = '''', -- First name of the user(s) to search for.
@lastname nVarchar(50) = '''' -- Last name of the user(s) to search for.
)

As

Set NoCount On

-- Declarations
Declare @intUserTypeOrgAdmin Integer -- Holds the value for the OrgAdmin UserTypeID from the tblUserType table.

-- Initialisation
Select @intUserTypeOrgAdmin = UserTypeID From tblUserType Where Type = ''Organisation Administrator''

If(@firstName Is Null)
Begin
Set @firstName = ''''
End

If(@lastName Is Null)
Begin
Set @lastName = ''''
End


Select
UserID,
FirstName,
LastName,
Email,
OrganisationID,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, OrganisationID) as DateCreated,
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, OrganisationID) as DateUpdated
From
tblUser
Where
((OrganisationID = @organisationID)
And (FirstName Like ''%'' + @firstName + ''%'')
And (LastName Like ''%'' + @lastName + ''%'')
And (UserTypeID > @intUserTypeOrgAdmin)
And (UnitID Is Not Null)
And (Active = 1))
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetAdminList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Gets a List of all the Administrators for a particular organisation.

Parameters:
@organisationID

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
None

Author: Peter Vranich
Date Created: 12th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE   Procedure [prcOrganisation_GetAdminList]
(
@organisationID Integer = Null -- ID of the Organisation that you wish to get the Admins for.
)

As

Select
UserID,
FirstName,
LastName,
Email,
OrganisationID,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @organisationID) as DateCreated,
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @organisationID) as DateUpdated
From
tblUser
Where
((OrganisationID = @organisationID)
And (UserTypeID = 2)
And (Active = 1))
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_EmailReportUserSearch]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
The e-mail report allows an administrator to e-mail users
who have failed or not completed their quizzes.
It can also email administrators notifying them of
users that they are responsible for who have failed or not
completed their quizzes.

Quiz Status
QuizStatusID Status
------------ --------------------------------------------------
0            Unassigned
1            Not Started
2            Passed
3            Failed
4            Expired (Time Elapsed)
5            Expired (New Content)

Course Status
CourseStatusID Status
-------------- --------------------------------------------------
0              Unassigned
1              InComplete
2              Complete

CourseModuleStatus enum
--------------------------------------------------
Complete	= 1,
Failed		= 2,
NotStarted	= 3,
Unknown		= 4

When "Course/Module Status" is set to "Complete"
This will find users that:
- Belong to any of the Units in @unitIDs
- AND are currently assigned Modules from the selected Course
- AND have the Custom Classification option
- AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
- AND the event that made them complete happened some time in the time-period in question

exec prcReport_EmailReportUserSearch
@organisationID = 3,
@unitIDs = ''5,6,7'',
@courseID = 5,
@classificationID = 1,
@courseModuleStatus = 0,
@quizDateFrom = ''Jan  1 2004 12:00:00:000AM'',
@quizDateTo = ''Sep 17 2004 11:59:59:000PM''

exec prcReport_EmailReportUserSearch
@organisationID = 3,
@unitIDs = ''5,6,7'',
@courseID = 5,
@classificationID = 1,
@courseModuleStatus = 3,
@quizDateFrom = ''Jan  1 2004 12:00:00:000AM'',
@quizDateTo = ''Sep 17 2004 11:59:59:000PM''


*/
CREATE        Proc [prcReport_EmailReportUserSearch]
(
@organisationID		int,
@unitIDs 			varchar(MAX),
@courseIDs 			varchar(8000),
@classificationID 	int,
@courseModuleStatus	int,
@quizDateFromOrg 		datetime,
@quizDateToOrg 		datetime,
@includeInactive	int
)
AS
------------------------------------------
Set Nocount On
DECLARE @quizDateFrom 		datetime
DECLARE @quizDateTo 		datetime
SET @quizDateFrom = dbo.udfDaylightSavingTimeToUTC(@quizDateFromOrg,@OrganisationID)
SET @quizDateTo = dbo.udfDaylightSavingTimeToUTC(@quizDateToOrg,@OrganisationID)


Declare
@CONST_INCOMPLETE     	int,
@CONST_COMPLETE     	int,
@CONST_FAILD            int,
@CONST_NOTSTARTED 	    int,
@CONST_UNKNOWN 	        int,
@CONST_EXPIRED_TIMELAPSED int,
@CONST_EXPIRED_NEWCONTENT int

set @CONST_INCOMPLETE	= 0
set @CONST_COMPLETE	    = 1
set @CONST_FAILD		= 2
set @CONST_NOTSTARTED	= 3
set @CONST_EXPIRED_TIMELAPSED	= 4
set @CONST_EXPIRED_NEWCONTENT  = 5

DECLARE @Units TABLE (UnitID INT)
DECLARE @Courses TABLE (CourseID INT)
DECLARE @CoursesWithAccess TABLE (CourseID INT PRIMARY KEY, [name] nvarchar(100))
DECLARE @UserModuleWithAccess TABLE (UserID INT, ModuleID INT, UnitID INT, PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE (ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE (UserID INT, UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @UsersQuizStatusNOTSTARTED TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

INSERT INTO
@Courses
SELECT
*
FROM
dbo.udfCsvToInt(@courseIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

--Get Rid of courses which do not have access to specified org
INSERT INTO
@CoursesWithAccess
SELECT
A.CourseID, [name]
FROM
@Courses A, tblOrganisationCourseAccess B, tblCourse C
WHERE
A.CourseID = B.GrantedCourseID
AND B.OrganisationID = @organisationID
AND A.CourseID = C.CourseID
AND C.Active = 1

--Get All the users for all specfied units
INSERT INTO
@Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
join  @Units B on A.UnitID = B.UnitID
join  tblUnit C on B.UnitID = C.UnitID  AND C.Active = 1
WHERE
@includeinactive =1 or A.Active = 1 -- show all or only active users



if @courseModuleStatus = @CONST_COMPLETE or @courseModuleStatus = @CONST_INCOMPLETE
begin -- completed / -- InComplete
--------------------
-- Completed --
--------------------
-- A user is completed if they became complete and remained completed in the period of interest
-- the query only needs to check to see status at the max date in this period as a line item
-- as tblUserCourseStatus is only writen to when an event occours that would
-- change the status.
-- When "Course/Module Status" is set to "Complete"
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question
--------------------
-- InComplete
--------------------
-- A user is in-completed if for any reason they are not complete but do have access to the course
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Incomplete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question

SELECT
DISTINCT cast(A.UserID AS varchar(10)) + '':'' + cast(A.courseid AS varchar(10)) userid
FROM
(SELECT
A.UserID, D.UnitID, D.FirstName, D.LastName + case when D.Active <> 1 then ''(i)'' else '''' end as ''LastName'',
dbo.udfUTCtoDaylightSavingTime(D.DateCreated, @organisationID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime(D.DateArchived, @organisationID) as DateArchived, A.CourseID
FROM
(SELECT
A.UserID, A.CourseID, MAX(A.UserCourseStatusID) AS ''LatestCourseStatus''
FROM
tblUserCourseStatus A, @CoursesWithAccess B
WHERE
A.DateCreated < DATEADD(DD, 1, @quizDateTo)
and A.CourseID = B.CourseID
GROUP BY
A.UserID, A.CourseID
) A, @Users B, tblUserCourseStatus C, tblUser D
WHERE
A.UserID = B.UserID
AND B.UserID = C.UserID
AND A.LatestCourseStatus = C.UserCourseStatusID
AND (C.DateCreated BETWEEN @quizDateFrom AND @quizDateTo)
AND C.CourseStatusID = case @courseModuleStatus
when @CONST_COMPLETE then 2   -- Complete
when @CONST_INCOMPLETE then 1 -- InComplete
end
AND A.UserID = D.UserID
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
LEFT JOIN tblUnitHierarchy F ON F.UnitID = A.UnitID
WHERE
--If classification is Any (0), This will find users of any Custom Classification
(@classificationID =0 OR tblUserClassification.classificationID = @classificationID)
AND A.UserID IN (select UserID from tblUser where OrganisationID = @organisationID and Active = 1)
END -- completed / -- InComplete


if @courseModuleStatus = @CONST_FAILD or @courseModuleStatus = @CONST_EXPIRED_TIMELAPSED or @courseModuleStatus = @CONST_EXPIRED_NEWCONTENT
begin -- Failed
--------------------
-- Failed  --
--------------------
-- When "Course/Module Status" is set to "Failed"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND took a quiz, for a Module within the selected Course, within the date range and failed it
--  - AND who currently have a status other than "Passed" for that same quiz
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
)A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID

INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID = case @courseModuleStatus
when @CONST_FAILD then 3   -- Failed
when @CONST_EXPIRED_TIMELAPSED then 4 -- Expired time lapsed
when @CONST_EXPIRED_NEWCONTENT then 5 -- Expired new content
end

--Get Data in report format
SELECT
DISTINCT cast(A.UserID AS varchar(10)) + '':'' + cast(courseid AS varchar(10)) userid
FROM
(select
distinct userid, moduleid
from
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D, tblUnitHierarchy C
WHERE
A.UserID = B.UserID
AND B.UnitID = C.UnitID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
end --/ Failed


-- Not started --

if @courseModuleStatus = @CONST_NOTSTARTED
begin -- Not started - Any
--------------------
-- Not started  --
--------------------
-- When "Course/Module Status" is set to "Not Started"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND who have not started ANY of the quizes they have access to in this course
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
) A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID
AND (B.DateCreated BETWEEN @quizDateFrom AND @quizDateTo)

--select * from @UsersNQuizStatus

--Get User with Quiz NOT STARTED
INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID NOT IN (2,3)
AND UserID NOT IN (SELECT UserID FROM @UsersNQuizStatus WHERE QuizStatusID IN (2,3))

--select * from @UsersQuizStatusNOTSTARTED
--select distinct userid,moduleid from @UsersQuizStatusNOTSTARTED

--Get Data in report format
SELECT
DISTINCT cast(A.UserID AS varchar(10)) + '':'' + cast(courseid AS varchar(10)) userid
FROM
(SELECT
DISTINCT A.UserID, B.UnitID, B.FirstName, B.LastName, B.active,
dbo.udfUTCtoDaylightSavingTime(B.DateCreated, @OrganisationID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime(B.DateArchived, @OrganisationID) as DateArchived,
courseid
FROM
(SELECT
DISTINCT userid, moduleid
FROM
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D
WHERE
A.UserID = B.UserID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
LEFT JOIN tblUnitHierarchy B ON B.UnitID = A.UnitID
WHERE
--If classification is Any (0), This will find users of any Custom Classification
@classificationID =0 OR tblUserClassification.classificationID = @classificationID

end --/ Not started - Any


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_EmailReportToAdministrators]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Get a list of users that will appear in the administrtors email list

Returns:
AdminUserID,UserUnitID,Administrator Email,Administrator Name, Administrator''s Unit, User Unit, User name
AdminUserID,UserUnitID,Administrator Email,Administrator Name, Administrator''s Unit, User Unit, User name
AdminUserID,UserUnitID,Administrator Email,Administrator Name, Administrator''s Unit, User Unit, User name
AdminUserID,UserUnitID,Administrator Email,Administrator Name, Administrator''s Unit, User Unit, User name
AdminUserID,UserUnitID,Administrator Email,Administrator Name, Administrator''s Unit, User Unit, User name

order by AdminUserID,UserUnitID

Called By: Email report
Calls:

Remarks:

Sending to Administrators
If "Administrators" was selected as the Recipient Type, then the email will be sent to the administrators of the user''s Units.

If a user belongs to a Unit that does not have its own administrator, the email will go to the Organisation Administrators.

Only one email will be sent to each administrator.

Within the body of the email for each administrator will be the list of users who are in the Units which they administer. (See Appendix A).
The list will group the users into Units and have the Unit name as the heading for each group.



Author:Jack Liu
Date Created: 27 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcReport_EmailReportToAdministrators 3, ''42,48,11''

select * from tbluser where userID = 42

--------------------

**/

CREATE Proc [prcReport_EmailReportToAdministrators]
(
@organisationID int,
@unitIDs 			varchar(MAX),
@courseIDs 			varchar(8000),
@classificationID 	int,
@courseModuleStatus	int,
@quizDateFrom 		datetime,
@quizDateTo 		datetime,
@includeInactive	int
)

AS

Set Nocount On
DECLARE @quizDateFromOrg 		datetime
DECLARE @quizDateToOrg 		datetime
SET @quizDateFromOrg = dbo.udfDaylightSavingTimeToUTC(@quizDateFrom,@OrganisationID)
SET @quizDateToOrg = dbo.udfDaylightSavingTimeToUTC(@quizDateTo,@OrganisationID)

declare @tblUserUnit table
(
UserID int,
UnitID int
)


declare @tblUnit table
(
unitID int
)

declare @tblUnitAdministrator table
(
unitID int,
AdminUserID int
)
Set Nocount On
Declare
@CONST_INCOMPLETE     	int,
@CONST_COMPLETE     	int,
@CONST_FAILD            int,
@CONST_NOTSTARTED 	    int,
@CONST_UNKNOWN 	        int,
@CONST_EXPIRED_TIMELAPSED int,
@CONST_EXPIRED_NEWCONTENT int

set @CONST_INCOMPLETE	= 0
set @CONST_COMPLETE	    = 1
set @CONST_FAILD		= 2
set @CONST_NOTSTARTED	= 3
set @CONST_EXPIRED_TIMELAPSED	= 4
set @CONST_EXPIRED_NEWCONTENT  = 5

DECLARE @Units TABLE (UnitID INT)
DECLARE @Courses TABLE (CourseID INT)
DECLARE @CoursesWithAccess TABLE (CourseID INT PRIMARY KEY, [name] nvarchar(100))
DECLARE @UserModuleWithAccess TABLE (UserID INT, ModuleID INT, UnitID INT, PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE (ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE (UserID INT, UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @UsersQuizStatusNOTSTARTED TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

INSERT INTO
@Courses
SELECT
*
FROM
dbo.udfCsvToInt(@courseIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

--Get Rid of courses which do not have access to specified org
INSERT INTO
@CoursesWithAccess
SELECT
A.CourseID, [name]
FROM
@Courses A, tblOrganisationCourseAccess B, tblCourse C
WHERE
A.CourseID = B.GrantedCourseID
AND B.OrganisationID = @organisationID
AND A.CourseID = C.CourseID
AND C.Active = 1

--Get All the users for all specfied units
INSERT INTO
@Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
join  @Units B on A.UnitID = B.UnitID
join  tblUnit C on B.UnitID = C.UnitID  AND C.Active = 1
WHERE
@includeinactive =1 or A.Active = 1 -- show all or only active users



if @courseModuleStatus = @CONST_COMPLETE or @courseModuleStatus = @CONST_INCOMPLETE
begin -- completed / -- InComplete
--------------------
-- Completed --
--------------------
-- A user is completed if they became complete and remained completed in the period of interest
-- the query only needs to check to see status at the max date in this period as a line item
-- as tblUserCourseStatus is only writen to when an event occours that would
-- change the status.
-- When "Course/Module Status" is set to "Complete"
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question
--------------------
-- InComplete
--------------------
-- A user is in-completed if for any reason they are not complete but do have access to the course
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Incomplete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question

INSERT INTO @tblUserUnit(UserID, UnitID)
SELECT
DISTINCT A.UserID, A.UnitID
FROM
(SELECT
A.UserID, D.UnitID
FROM
(SELECT
A.UserID, A.CourseID, MAX(A.UserCourseStatusID) AS ''LatestCourseStatus''
FROM
tblUserCourseStatus A, @CoursesWithAccess B
WHERE
A.DateCreated < DATEADD(DD, 1, @quizDateToOrg)
and A.CourseID = B.CourseID
GROUP BY
A.UserID, A.CourseID
) A, @Users B, tblUserCourseStatus C, tblUser D
WHERE
A.UserID = B.UserID
AND B.UserID = C.UserID
AND A.LatestCourseStatus = C.UserCourseStatusID
AND (C.DateCreated BETWEEN @quizDateFromOrg AND @quizDateToOrg)
AND C.CourseStatusID = case @courseModuleStatus
when @CONST_COMPLETE then 2   -- Complete
when @CONST_INCOMPLETE then 1 -- InComplete
end
AND A.UserID = D.UserID
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
WHERE
--If classification is Any (0), This will find users of any Custom Classification
(@classificationID =0 OR tblUserClassification.classificationID = @classificationID)
AND A.UserID IN (select UserID from tblUser where OrganisationID = @organisationID and Active = 1)
ORDER BY
A.UserID, A.UnitID
END -- completed / -- InComplete


if @courseModuleStatus = @CONST_FAILD or @courseModuleStatus = @CONST_EXPIRED_TIMELAPSED or @courseModuleStatus = @CONST_EXPIRED_NEWCONTENT
begin -- Failed
--------------------
-- Failed  --
--------------------
-- When "Course/Module Status" is set to "Failed"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND took a quiz, for a Module within the selected Course, within the date range and failed it
--  - AND who currently have a status other than "Passed" for that same quiz
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
)A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID

INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID = case @courseModuleStatus
when @CONST_FAILD then 3   -- Failed
when @CONST_EXPIRED_TIMELAPSED then 4 -- Expired time lapsed
when @CONST_EXPIRED_NEWCONTENT then 5 -- Expired new content
end

--Get Data in report format
INSERT INTO @tblUserUnit(UserID, UnitID)
SELECT
DISTINCT A.UserID, UnitID
FROM
(select
distinct userid, moduleid
from
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D
WHERE
A.UserID = B.UserID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
ORDER BY
A.UserID, UnitID
end --/ Failed


-- Not started --

if @courseModuleStatus = @CONST_NOTSTARTED
begin -- Not started - Any
--------------------
-- Not started  --
--------------------
-- When "Course/Module Status" is set to "Not Started"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND who have not started ANY of the quizes they have access to in this course
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
) A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID
AND (B.DateCreated BETWEEN @quizDateFromOrg AND @quizDateToOrg)

--select * from @UsersNQuizStatus

--Get User with Quiz NOT STARTED
INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID NOT IN (2,3)
AND UserID NOT IN (SELECT UserID FROM @UsersNQuizStatus WHERE QuizStatusID IN (2,3))

--select * from @UsersQuizStatusNOTSTARTED
--select distinct userid,moduleid from @UsersQuizStatusNOTSTARTED

--Get Data in report format
INSERT INTO @tblUserUnit(UserID, UnitID)
SELECT
A.UserID, UnitID
FROM
(SELECT
DISTINCT A.UserID, B.UnitID
FROM
(SELECT
DISTINCT userid, moduleid
FROM
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D
WHERE
A.UserID = B.UserID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
WHERE
--If classification is Any (0), This will find users of any Custom Classification
@classificationID =0 OR tblUserClassification.classificationID = @classificationID
ORDER BY
A.UserID, UnitID

end --/ Not started - Any


insert into @tblUnit(UnitID)
select distinct UnitID
from @tblUserUnit

---If "Administrators" was selected as the Recipient Type, then the email will be sent to the administrators of the users Units.
insert into @tblUnitAdministrator (UnitID, AdminUserID)
select u.UnitID, ua.UserID
from @tblUnit u
inner join tblUnitAdministrator ua
on ua.UnitID = u.UnitID
inner join tblUser us
on us.UserID = ua.UserID and us.UserTypeID = 3 --Unit Administrator

--If a user belongs to a Unit that does not have its own administrator, the email will go to the Organisation Administrators.
insert into @tblUnitAdministrator (UnitID, AdminUserID)
select u.UnitID, us.UserID
from tblUser us
cross join @tblUnit u
where us.OrganisationID = @organisationID
and us.UserTypeID = 2 -- Organisation Administrator
and u.UnitID not in (select UnitID from @tblUnitAdministrator)
and us.Active = 1


-- Tidy up the results
SELECT
DISTINCT adminuserid userid, hierarchyname, lastname, firstname,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @OrganisationID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime(DateArchived, @OrganisationID) as DateArchived,
NULL courseid
FROM
@tblunitadministrator a
INNER JOIN tbluser u ON userid = a.adminuserid
INNER JOIN tblunithierarchy h ON h.unitid = u.unitid
WHERE
u.active = 1
ORDER BY
hierarchyname, adminuserid
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_EmailReportDistinctUsers]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Used to build the CC list on step 2 of the report

Quiz Status
QuizStatusID Status
------------ --------------------------------------------------
0            Unassigned
1            Not Started
2            Passed
3            Failed
4            Expired (Time Elapsed)
5            Expired (New Content)

Course Status
CourseStatusID Status
-------------- --------------------------------------------------
0              Unassigned
1              InComplete
2              Complete

CourseModuleStatus enum
--------------------------------------------------
Complete	= 1,
Failed		= 2,
NotStarted	= 3,
Unknown		= 4

When "Course/Module Status" is set to "Complete"
This will find users that:
- Belong to any of the Units in @unitIDs
- AND are currently assigned Modules from the selected Course
- AND have the Custom Classification option
- AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
- AND the event that made them complete happened some time in the time-period in question

exec prcReport_EmailReportDistinctUsers
@organisationID = 3,
@unitIDs = ''5,6,7'',
@courseID = 5,
@classificationID = 1,
@courseModuleStatus = 0,
@quizDateFrom = ''Jan  1 2004 12:00:00:000AM'',
@quizDateTo = ''Sep 17 2004 11:59:59:000PM''

exec prcReport_EmailReportDistinctUsers
@organisationID = 3,
@unitIDs = ''5,6,7'',
@courseID = 5,
@classificationID = 1,
@courseModuleStatus = 3,
@quizDateFrom = ''Jan  1 2004 12:00:00:000AM'',
@quizDateTo = ''Sep 17 2004 11:59:59:000PM''


*/
CREATE        Proc [prcReport_EmailReportDistinctUsers]
(
@organisationID		int,
@unitIDs 			varchar(MAX),
@courseIDs 			varchar(8000),
@classificationID 	int,
@courseModuleStatus	int,
@quizDateFromOrg 		datetime,
@quizDateToOrg 		datetime,
@includeInactive	int
)
AS
------------------------------------------
Set Nocount On

DECLARE @quizDateFrom 		datetime
DECLARE @quizDateTo 		datetime
SET @quizDateFrom = dbo.udfDaylightSavingTimeToUTC(@quizDateFromOrg,@OrganisationID)
SET @quizDateTo = dbo.udfDaylightSavingTimeToUTC(@quizDateToOrg,@OrganisationID)




Declare
@CONST_INCOMPLETE     	int,
@CONST_COMPLETE     	int,
@CONST_FAILD            int,
@CONST_NOTSTARTED 	    int,
@CONST_UNKNOWN 	        int,
@CONST_EXPIRED_TIMELAPSED int,
@CONST_EXPIRED_NEWCONTENT int

set @CONST_INCOMPLETE	= 0
set @CONST_COMPLETE	    = 1
set @CONST_FAILD		= 2
set @CONST_NOTSTARTED	= 3
set @CONST_EXPIRED_TIMELAPSED	= 4
set @CONST_EXPIRED_NEWCONTENT  = 5

DECLARE @Units TABLE (UnitID INT)
DECLARE @Courses TABLE (CourseID INT)
DECLARE @CoursesWithAccess TABLE (CourseID INT PRIMARY KEY, [name] nvarchar(100))
DECLARE @UserModuleWithAccess TABLE (UserID INT, ModuleID INT, UnitID INT, PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE (ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE (UserID INT, UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @UsersQuizStatusNOTSTARTED TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

INSERT INTO
@Courses
SELECT
*
FROM
dbo.udfCsvToInt(@courseIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

--Get Rid of courses which do not have access to specified org
INSERT INTO
@CoursesWithAccess
SELECT
A.CourseID, [name]
FROM
@Courses A, tblOrganisationCourseAccess B, tblCourse C
WHERE
A.CourseID = B.GrantedCourseID
AND B.OrganisationID = @organisationID
AND A.CourseID = C.CourseID
AND C.Active = 1

--Get All the users for all specfied units
INSERT INTO
@Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
join  @Units B on A.UnitID = B.UnitID
join  tblUnit C on B.UnitID = C.UnitID  AND C.Active = 1
WHERE
@includeinactive =1 or A.Active = 1 -- show all or only active users



if @courseModuleStatus = @CONST_COMPLETE or @courseModuleStatus = @CONST_INCOMPLETE
begin -- completed / -- InComplete
--------------------
-- Completed --
--------------------
-- A user is completed if they became complete and remained completed in the period of interest
-- the query only needs to check to see status at the max date in this period as a line item
-- as tblUserCourseStatus is only writen to when an event occours that would
-- change the status.
-- When "Course/Module Status" is set to "Complete"
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question
--------------------
-- InComplete
--------------------
-- A user is in-completed if for any reason they are not complete but do have access to the course
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Incomplete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question

SELECT
DISTINCT A.UserID, F.HierarchyName, A.FirstName, A.LastName, dbo.udfUTCtoDaylightSavingTime(A.DateCreated, @organisationID) as DateCreated, dbo.udfUTCtoDaylightSavingTime(A.DateArchived, @organisationID) as DateArchived
FROM
(SELECT
A.UserID, D.UnitID, D.FirstName, D.LastName + case when D.Active <> 1 then ''(i)'' else '''' end as ''LastName'',
D.DateCreated as DateCreated, D.DateArchived as DateArchived, A.CourseID
FROM
(SELECT
A.UserID, A.CourseID, MAX(A.UserCourseStatusID) AS ''LatestCourseStatus''
FROM
tblUserCourseStatus A, @CoursesWithAccess B
WHERE
A.DateCreated < DATEADD(DD, 1, @quizDateTo)
and A.CourseID = B.CourseID
GROUP BY
A.UserID, A.CourseID
) A, @Users B, tblUserCourseStatus C, tblUser D
WHERE
A.UserID = B.UserID
AND B.UserID = C.UserID
AND A.LatestCourseStatus = C.UserCourseStatusID
AND (C.DateCreated BETWEEN @quizDateFrom AND @quizDateTo)
AND C.CourseStatusID = case @courseModuleStatus
when @CONST_COMPLETE then 2   -- Complete
when @CONST_INCOMPLETE then 1 -- InComplete
end
AND A.UserID = D.UserID
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
LEFT JOIN tblUnitHierarchy F ON F.UnitID = A.UnitID
WHERE
--If classification is Any (0), This will find users of any Custom Classification
(@classificationID =0 OR tblUserClassification.classificationID = @classificationID)
AND A.UserID IN (select UserID from tblUser where OrganisationID = @organisationID and Active = 1)
ORDER BY
F.HierarchyName, A.LastName, A.FirstName
END -- completed / -- InComplete


if @courseModuleStatus = @CONST_FAILD or @courseModuleStatus = @CONST_EXPIRED_TIMELAPSED or @courseModuleStatus = @CONST_EXPIRED_NEWCONTENT
begin -- Failed
--------------------
-- Failed  --
--------------------
-- When "Course/Module Status" is set to "Failed"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND took a quiz, for a Module within the selected Course, within the date range and failed it
--  - AND who currently have a status other than "Passed" for that same quiz
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
)A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID

INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID = case @courseModuleStatus
when @CONST_FAILD then 3   -- Failed
when @CONST_EXPIRED_TIMELAPSED then 4 -- Expired time lapsed
when @CONST_EXPIRED_NEWCONTENT then 5 -- Expired new content
end

--Get Data in report format
SELECT
DISTINCT A.UserID, C.HierarchyName, B.FirstName, B.LastName + case when B.Active <> 1 then ''(i)'' else '''' end as ''LastName'',
dbo.udfUTCtoDaylightSavingTime(B.DateCreated, @OrganisationID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime(B.DateArchived, @OrganisationID) as DateArchived
FROM
(select
distinct userid, moduleid
from
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D, tblUnitHierarchy C
WHERE
A.UserID = B.UserID
AND B.UnitID = C.UnitID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
ORDER BY
C.HierarchyName, B.LastName + case when B.Active <> 1 then ''(i)'' else '''' end, B.FirstName
end --/ Failed


-- Not started --

if @courseModuleStatus = @CONST_NOTSTARTED
begin -- Not started - Any
--------------------
-- Not started  --
--------------------
-- When "Course/Module Status" is set to "Not Started"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND who have not started ANY of the quizes they have access to in this course
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
) A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID
AND (B.DateCreated BETWEEN @quizDateFrom AND @quizDateTo)

--select * from @UsersNQuizStatus

--Get User with Quiz NOT STARTED
INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID NOT IN (2,3)
AND UserID NOT IN (SELECT UserID FROM @UsersNQuizStatus WHERE QuizStatusID IN (2,3))

--select * from @UsersQuizStatusNOTSTARTED
--select distinct userid,moduleid from @UsersQuizStatusNOTSTARTED

--Get Data in report format
SELECT
DISTINCT A.UserID, B.HierarchyName, A.LastName+ case when A.Active <> 1 then ''(i)'' else '''' end as ''LastName'',
A.FirstName,
dbo.udfUTCtoDaylightSavingTime(A.DateCreated, @OrganisationID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime(A.DateArchived, @OrganisationID) as DateArchived
FROM
(SELECT
DISTINCT A.UserID, B.UnitID, B.FirstName, B.LastName, B.active, B.DateCreated, B.DateArchived, courseid
FROM
(SELECT
DISTINCT userid, moduleid
FROM
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D
WHERE
A.UserID = B.UserID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
LEFT JOIN tblUnitHierarchy B ON B.UnitID = A.UnitID
WHERE
--If classification is Any (0), This will find users of any Custom Classification
@classificationID =0 OR tblUserClassification.classificationID = @classificationID
ORDER BY
B.HierarchyName, A.LastName+ case when A.Active <> 1 then ''(i)'' else '''' end, A.FirstName

end --/ Not started - Any


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CourseStatusSearch]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		File:
**		Name: prcReport_CourseStatusSearch
**		Desc: Given a list of unit IDs, course IDs,
**
**		This template can be customized:
**
**		Return values:
**
**		Called by:
**
**		Parameters:
**		Input							Output
**     ----------							-----------
**
**		Auth:
**		Date:
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		23/07/2009	Mark Donald			Add @classificationID parameter and use
**										it to filter the insert into @Users
**		17/08/2009	Mark Donald			Change column order of ''fail option''
**										select statement to match others
**
*******************************************************************************/

--exec prcReport_CourseStatusSearch 109, ''4463,4464,4465,4469,4478,4479'', ''92'', 3, ''1997-01-01'',''2011-07-01'', 0, 0
CREATE       Procedure [prcReport_CourseStatusSearch]
(
@organisationID		int,
@unitIDs 		varchar(8000),
@courseIDs 		varchar(8000),
@courseModuleStatus	int,
@dateFromOrg 		datetime,
@dateToOrg 		datetime,
@IncludeInactive int,
@classificationID int
)
AS

begin
------------------------------------------
DECLARE @dateFrom 		datetime
DECLARE @dateTo 		datetime
SET @dateFrom = dbo.udfDaylightSavingTimeToUTC(@dateFromOrg,@OrganisationID)
SET @dateTo = dbo.udfDaylightSavingTimeToUTC(@dateToOrg,@OrganisationID)

Set Nocount On

Declare
@CONST_INCOMPLETE     	int,
@CONST_COMPLETE     	int,
@CONST_FAILD            int,
@CONST_NOTSTARTED 	    int,
@CONST_EXPIRED_TIMELAPSED		int,
@CONST_EXPIRED_NEWCONTENT		int

set @CONST_INCOMPLETE	= 0
set @CONST_COMPLETE	= 1
set @CONST_FAILD	= 2
set @CONST_NOTSTARTED	= 3
set @CONST_EXPIRED_TIMELAPSED   = 4
set @CONST_EXPIRED_NEWCONTENT	= 5

DECLARE @Units TABLE
(
UnitID INT PRIMARY KEY(UnitID)
)

DECLARE @Courses TABLE
(
CourseID INT PRIMARY KEY(CourseID)
)

DECLARE @CoursesWithAccess 	TABLE (CourseID INT PRIMARY KEY(CourseID))
DECLARE @UserModuleWithAccess TABLE(UserID INT, ModuleID INT, UnitID INT PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE(ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE(UserID INT , UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus
TABLE
(
UserID	INT,
ModuleID INT,
LatestQuizID INT,
QuizStatusID INT,
QuizScore INT
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

DECLARE @UsersQuizStatusNOTSTARTED
TABLE
(
UserID	INT,
ModuleID INT,
LatestQuizID INT,
QuizStatusID INT,
QuizScore INT
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

INSERT INTO @Courses SELECT * FROM dbo.udfCsvToInt(@courseIDs)

INSERT INTO @Units SELECT * FROM  dbo.udfCsvToInt(@unitIDs)

--Get Rid of courses which do not have access to specified org
INSERT INTO @CoursesWithAccess
SELECT A.CourseID FROM @Courses A, tblOrganisationCourseAccess B, tblCourse C
WHERE A.CourseID = B.GrantedCourseID AND B.OrganisationID = @organisationID AND
A.CourseID = C.CourseID AND C.Active = 1

--Get All the users for all specfied units, matching Custom Classification option (if provided)
INSERT INTO @Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
join @Units B on A.UnitID = B.UnitID
join tblUnit C on B.UnitID = C.UnitID AND C.Active = 1
LEFT JOIN tblUserClassification uc ON uc.UserID  = A.UserID
WHERE
A.Active = CASE @IncludeInactive WHEN 0 THEN 1 ELSE A.Active END
AND ((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification



if @courseModuleStatus = @CONST_COMPLETE or @courseModuleStatus = @CONST_INCOMPLETE
begin -- completed / -- InComplete
--------------------
-- Completed --
--------------------
-- A user is completed if they became complete and remained completed in the period of interest
-- the query only needs to check to see status at the max date in this period as a line item
-- as tblUserCourseStatus is only writen to when an event occours that would
-- change the status.
-- When "Course/Module Status" is set to "Complete"
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question
--------------------
-- InComplete
--------------------
-- A user is in-completed if for any reason they are not complete but do have access to the course
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Courses
-- - AND have (at the end of the time-period in question) got a status of Incomplete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question

--Find the latest status of courses
SELECT
A.UserID, D.UnitID,
D.FirstName,
D.LastName,
case when D.Active = 1 then ''''  else ''(i)'' end as Flag,
F.HierarchyName AS ''UnitPathWay'',
dbo.udfUTCtoDaylightSavingTime( C.DateCreated , @organisationID)as ''Date'',
D.Username as ''UserName'',
D.Email as ''Email'',
D.ExternalID as ''ExternalID'',
E.[Name] as ''CourseName'',
dbo.udfUTCtoDaylightSavingTime(D.DateCreated, @organisationID)as ''DateCreated'',
case when D.Active =0 then coalesce(dbo.udfUTCtoDaylightSavingTime(D.DateArchived,@organisationid ),dbo.udfUTCtoDaylightSavingTime(D.DateUpdated,@organisationid)) end  as ''DateArchived''
FROM
(SELECT
A.UserID, A.CourseID, MAX(A.UserCourseStatusID) AS ''LatestCourseStatus''
FROM
tblUserCourseStatus A, @CoursesWithAccess B
WHERE
A.DateCreated < DATEADD(DD, 1, @dateTo)
and
A.CourseID = B.CourseID
GROUP BY
A.UserID, A.CourseID
) A,
@Users B, tblUserCourseStatus C, tblUser D, tblCourse E, tblUnitHierarchy F
WHERE
A.UserID = B.UserID AND B.UserID = C.UserID AND
A.LatestCourseStatus = C.UserCourseStatusID AND
(C.DateCreated BETWEEN @dateFrom AND dateadd(d,1,@dateTo)) AND
C.CourseStatusID = case @courseModuleStatus
when @CONST_COMPLETE then 2   -- Complete
when @CONST_INCOMPLETE then 1 -- InComplete
end AND
A.UserID = D.UserID AND A.CourseID = E.CourseID AND
D.UnitID = F.UnitID
ORDER BY
CourseName, UnitPathWay, LastName, FirstName

end -- completed / -- InComplete


if @courseModuleStatus = @CONST_FAILD or @courseModuleStatus = @CONST_EXPIRED_TIMELAPSED or @courseModuleStatus = @CONST_EXPIRED_NEWCONTENT
begin -- Failed
--------------------
-- Failed  --
--------------------
-- When "Course/Module Status" is set to "Failed"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Courses
--  - AND took a quiz, for a Module within the selected Course, within the date range of DateCreated in UserQuizStatus and failed it
--  - AND who currently have a status other than "Passed" for that same quiz
--------------------

--Find All Modules for all units with access

INSERT INTO @UserModuleWithAccess
SELECT DISTINCT A.UserID, A.ModuleID, A.UnitID FROM
(
SELECT A.UserID, A.ModuleID, A.UnitID
FROM vwUserModuleAccess A where courseid in (SELECT courseid from @Courses) )A, @Users B
Where A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO @UsersNQuizStatus
SELECT DISTINCT
A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(
SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID) A,
tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID AND
A.LatestQuizID = B.UserQuizStatusID AND
(B.DateCreated BETWEEN @dateFrom AND dateadd(d,1,@dateTo))

INSERT INTO @UsersQuizStatusNOTSTARTED
SELECT * FROM @UsersNQuizStatus WHERE QuizStatusID = case @courseModuleStatus
when @CONST_FAILD then 3   -- Failed
when @CONST_EXPIRED_TIMELAPSED then 4 -- Expired time lapsed
when @CONST_EXPIRED_NEWCONTENT then 5 -- Expired new content
end

--Get Data in report format
SELECT DISTINCT
A.UserID,
B.UnitID AS ''Unit'' ,
B.FirstName,
B.LastName,
case when B.Active = 1 then ''''  else ''(i)'' end  as Flag,
E.HierarchyName AS ''UnitPathWay'',
dbo.udfUTCtoDaylightSavingTime( C.DateCreated,@organisationID) AS ''Date'',
B.UserName,
B.Email,
B.ExternalID,C.Name AS ''CourseName'',
dbo.udfUTCtoDaylightSavingTime(B.DateCreated,@organisationID) AS ''DateCreated'',
case when B.Active =0 then coalesce(dbo.udfUTCtoDaylightSavingTime(B.DateArchived, @OrganisationID), dbo.udfUTCtoDaylightSavingTime(B.DateUpdated, @OrganisationID)) end as ''DateArchived''
FROM
(
select distinct userid, moduleid from @UsersQuizStatusNOTSTARTED) A,
tblUser B, tblCourse C, tblModule D, tblUnitHierarchy E
WHERE
A.UserID = B.UserID AND B.Active = 1 AND
A.ModuleID = D.ModuleID AND
B.UnitID = E.UnitID AND
D.CourseID = C.CourseID AND C.Active = 1 AND D.Active = 1
ORDER BY
CourseName, UnitPathWay, LastName, FirstName

end --/ Failed


-- Not started --

if @courseModuleStatus = @CONST_NOTSTARTED
begin -- Not started - Any
--------------------
-- Not started  --
--------------------
-- When "Course/Module Status" is set to "Not Started"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Courses
--  - AND who have not started ANY of the quizes they have access to in this course within the selected date range(DateCreated in vwUserQuizStatus)
--------------------


--Find All Modules for all units with access

INSERT INTO @UserModuleWithAccess
SELECT DISTINCT A.UserID, A.ModuleID, A.UnitID FROM
(
SELECT A.UserID, A.ModuleID, A.UnitID
FROM vwUserModuleAccess A where courseid in (SELECT courseid from @Courses) )A, @Users B
Where A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO @UsersNQuizStatus
SELECT  DISTINCT
A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(
SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID AND
A.LatestQuizID = B.UserQuizStatusID AND
(B.DateCreated BETWEEN @dateFrom AND dateadd(d,1,@dateTo))


--Get User with Quiz NOT STARTED
INSERT INTO @UsersQuizStatusNOTSTARTED
SELECT * FROM @UsersNQuizStatus WHERE QuizStatusID NOT IN (2,3,4,5) AND
UserID NOT IN (SELECT UserID FROM @UsersNQuizStatus WHERE QuizStatusID IN (2,3,4,5))


--Get Data in report format
SELECT DISTINCT
A.UserID,
B.UnitID ,
B.FirstName,
B.LastName,
case when B.Active = 1 then '''' else ''(i)'' end  as Flag,
dbo.udfGetUnitPathway(B.UnitID) AS ''UnitPathWay'',
dbo.udfUTCtoDaylightSavingTime(C.DateCreated,@organisationID) AS ''Date'',
B.UserName,
B.Email,
B.ExternalID,
C.Name AS ''CourseName'',
dbo.udfUTCtoDaylightSavingTime(B.DateCreated,@OrganisationID) as ''DateCreated'',
case when B.Active =0 then coalesce(dbo.udfUTCtoDaylightSavingTime(B.DateArchived,@OrganisationID),dbo.udfUTCtoDaylightSavingTime(B.DateUpdated,@OrganisationID)) end as ''DateArchived''
FROM
(select distinct userid, moduleid from @UsersQuizStatusNOTSTARTED) A,
tblUser B, tblCourse C, tblModule D, tblUnitHierarchy E
WHERE
A.UserID = B.UserID AND B.Active = 1 AND
A.ModuleID = D.ModuleID AND B.UnitID = E.UnitID AND
D.CourseID = C.CourseID AND C.Active = 1 AND D.Active = 1
ORDER BY
CourseName, UnitPathWay, LastName, FirstName

end --/ Not started - Any
END
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CourseStatusGrandTotal]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		Name: prcReport_CourseStatusGrandTotal
**		Desc: a copy of prcreport_CourseStatusSearch, but with select statements
**				altered to return a total, instead of a list of data.
**
**		Return values: Grand Total distinct users in Course Status report
**
**		Called by:
**
**		Parameters:
**		Input							Output
**     ----------							-----------
**
**		Auth: Mark Donald
**		Date: 27 Aug 2009
**
*******************************************************************************/

CREATE       Procedure [prcReport_CourseStatusGrandTotal]
(
@organisationID		int,
@unitIDs 		varchar(8000),
@courseIDs 		varchar(8000),
@courseModuleStatus	int,
@dateFromOrg 		datetime,
@dateToOrg 		datetime,
@IncludeInactive int,
@classificationID int
)
AS
------------------------------------------
Set Nocount On
DECLARE @dateFrom 		datetime
DECLARE @dateTo 		datetime
SET @dateFrom = dbo.udfDaylightSavingTimeToUTC(@dateFromOrg,@OrganisationID)
SET @dateTo = dbo.udfDaylightSavingTimeToUTC(@dateToOrg,@OrganisationID)
Declare
@CONST_INCOMPLETE     	int,
@CONST_COMPLETE     	int,
@CONST_FAILD            int,
@CONST_NOTSTARTED 	    int,
@CONST_EXPIRED_TIMELAPSED		int,
@CONST_EXPIRED_NEWCONTENT		int

set @CONST_INCOMPLETE	= 0
set @CONST_COMPLETE	= 1
set @CONST_FAILD	= 2
set @CONST_NOTSTARTED	= 3
set @CONST_EXPIRED_TIMELAPSED   = 4
set @CONST_EXPIRED_NEWCONTENT	= 5

DECLARE @Units TABLE
(
UnitID INT PRIMARY KEY(UnitID)
)

DECLARE @Courses TABLE
(
CourseID INT PRIMARY KEY(CourseID)
)

DECLARE @CoursesWithAccess 	TABLE (CourseID INT PRIMARY KEY(CourseID))
DECLARE @UserModuleWithAccess TABLE(UserID INT, ModuleID INT, UnitID INT PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE(ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE(UserID INT , UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus
TABLE
(
UserID	INT,
ModuleID INT,
LatestQuizID INT,
QuizStatusID INT,
QuizScore INT
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

DECLARE @UsersQuizStatusNOTSTARTED
TABLE
(
UserID	INT,
ModuleID INT,
LatestQuizID INT,
QuizStatusID INT,
QuizScore INT
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)

INSERT INTO @Courses SELECT * FROM dbo.udfCsvToInt(@courseIDs)

INSERT INTO @Units SELECT * FROM  dbo.udfCsvToInt(@unitIDs)

--Get Rid of courses which do not have access to specified org
INSERT INTO @CoursesWithAccess
SELECT A.CourseID FROM @Courses A, tblOrganisationCourseAccess B, tblCourse C
WHERE A.CourseID = B.GrantedCourseID AND B.OrganisationID = @organisationID AND
A.CourseID = C.CourseID AND C.Active = 1

--Get All the users for all specfied units, matching Custom Classification option (if provided)
INSERT INTO @Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
join @Units B on A.UnitID = B.UnitID
join tblUnit C on B.UnitID = C.UnitID AND C.Active = 1
LEFT JOIN tblUserClassification uc ON uc.UserID  = A.UserID
WHERE
A.Active = CASE @IncludeInactive WHEN 0 THEN 1 ELSE A.Active END
AND ((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification



if @courseModuleStatus = @CONST_COMPLETE or @courseModuleStatus = @CONST_INCOMPLETE
begin -- completed / -- InComplete
--------------------
-- Completed --
--------------------
-- A user is completed if they became complete and remained completed in the period of interest
-- the query only needs to check to see status at the max date in this period as a line item
-- as tblUserCourseStatus is only writen to when an event occours that would
-- change the status.
-- When "Course/Module Status" is set to "Complete"
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question
--------------------
-- InComplete
--------------------
-- A user is in-completed if for any reason they are not complete but do have access to the course
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Courses
-- - AND have (at the end of the time-period in question) got a status of Incomplete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question

--Find the latest status of courses
SELECT
count(distinct A.UserID) AS TotalDistinctUsers
FROM
(
SELECT
A.UserID, A.CourseID, MAX(A.UserCourseStatusID) AS ''LatestCourseStatus''
FROM
tblUserCourseStatus A, @CoursesWithAccess B
WHERE
A.DateCreated < DATEADD(DD, 1, @dateTo)
and
A.CourseID = B.CourseID
GROUP BY
A.UserID, A.CourseID
) A, @Users B, tblUserCourseStatus C, tblUser D, tblCourse E, tblUnitHierarchy F
WHERE
A.UserID = B.UserID AND B.UserID = C.UserID AND
A.LatestCourseStatus = C.UserCourseStatusID AND
(C.DateCreated BETWEEN @dateFrom AND dateadd(d,1,@dateTo)) AND
C.CourseStatusID = case @courseModuleStatus
when @CONST_COMPLETE then 2   -- Complete
when @CONST_INCOMPLETE then 1 -- InComplete
end AND
A.UserID = D.UserID AND A.CourseID = E.CourseID AND
D.UnitID = F.UnitID

end -- completed / -- InComplete


if @courseModuleStatus = @CONST_FAILD or @courseModuleStatus = @CONST_EXPIRED_TIMELAPSED or @courseModuleStatus = @CONST_EXPIRED_NEWCONTENT
begin -- Failed
--------------------
-- Failed  --
--------------------
-- When "Course/Module Status" is set to "Failed"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Courses
--  - AND took a quiz, for a Module within the selected Course, within the date range of DateCreated in UserQuizStatus and failed it
--  - AND who currently have a status other than "Passed" for that same quiz
--------------------

--Find All Modules for all units with access

INSERT INTO @UserModuleWithAccess
SELECT DISTINCT A.UserID, A.ModuleID, A.UnitID FROM
(
SELECT A.UserID, A.ModuleID, A.UnitID
FROM vwUserModuleAccess A where courseid in (SELECT courseid from @Courses) )A, @Users B
Where A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO @UsersNQuizStatus
SELECT DISTINCT
A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(
SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID AND
A.LatestQuizID = B.UserQuizStatusID AND
(B.DateCreated BETWEEN @dateFrom AND dateadd(d,1,@dateTo))

INSERT INTO @UsersQuizStatusNOTSTARTED
SELECT * FROM @UsersNQuizStatus WHERE QuizStatusID = case @courseModuleStatus
when @CONST_FAILD then 3   -- Failed
when @CONST_EXPIRED_TIMELAPSED then 4 -- Expired time lapsed
when @CONST_EXPIRED_NEWCONTENT then 5 -- Expired new content
end

--Get Data in report format
SELECT
count(distinct A.UserID) AS TotalDistinctUsers
FROM
(select distinct userid, moduleid from @UsersQuizStatusNOTSTARTED) A,
tblUser B, tblCourse C, tblModule D, tblUnitHierarchy E
WHERE
A.UserID = B.UserID AND B.Active = 1 AND
A.ModuleID = D.ModuleID AND
B.UnitID = E.UnitID AND
D.CourseID = C.CourseID AND C.Active = 1 AND D.Active = 1

end --/ Failed


-- Not started --

if @courseModuleStatus = @CONST_NOTSTARTED
begin -- Not started - Any
--------------------
-- Not started  --
--------------------
-- When "Course/Module Status" is set to "Not Started"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Courses
--  - AND who have not started ANY of the quizes they have access to in this course within the selected date range(DateCreated in vwUserQuizStatus)
--------------------


--Find All Modules for all units with access

INSERT INTO @UserModuleWithAccess
SELECT DISTINCT A.UserID, A.ModuleID, A.UnitID FROM
(
SELECT A.UserID, A.ModuleID, A.UnitID
FROM vwUserModuleAccess A where courseid in (SELECT courseid from @Courses) )A, @Users B
Where A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO @UsersNQuizStatus
SELECT  DISTINCT
A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(
SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID AND A.ModuleID = B.ModuleID AND
A.LatestQuizID = B.UserQuizStatusID AND
(B.DateCreated BETWEEN @dateFrom AND dateadd(d,1,@dateTo))


--Get User with Quiz NOT STARTED
INSERT INTO @UsersQuizStatusNOTSTARTED
SELECT * FROM @UsersNQuizStatus WHERE QuizStatusID NOT IN (2,3,4,5) AND
UserID NOT IN (SELECT UserID FROM @UsersNQuizStatus WHERE QuizStatusID IN (2,3,4,5))


--Get Data in report format
SELECT
count(distinct A.UserID) AS TotalDistinctUsers
FROM
(select distinct userid, moduleid from @UsersQuizStatusNOTSTARTED) A,
tblUser B, tblCourse C, tblModule D, tblUnitHierarchy E
WHERE
A.UserID = B.UserID AND B.Active = 1 AND
A.ModuleID = D.ModuleID AND B.UnitID = E.UnitID AND
D.CourseID = C.CourseID AND C.Active = 1 AND D.Active = 1

end --/ Not started - Any


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_CompletedUsersDetails]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Given an list of incomplete users, derive all of the module status explaining why the users
are incomplete

Returns:
Table of Incomplete Users with the module status details

Called By:
Reporting/Advanced/CompletedUsersReport.aspx

Calls:
udfReport_IncompletUsers_logic

Remarks:


Author:
Yoppy Suwanto

Date Created: 05 Mar 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1  Mark Donald	24/07/2009		Add LastCompleted col to selects

prcReport_CompletedUsersDetails @unitIDs=''1,2,3,4'' , @courseID=1 , @completed = 0
prcReport_CompletedUsersDetails @organisationid=11, @unitIDs=null , @courseID=53, @effectivedate = null

--------------------

**/
CREATE            Proc [prcReport_CompletedUsersDetails]
(
@organisationID Integer,	-- Organisation of the current user
@unitIDs varchar(8000) = '''',	-- string of unit id''s
@courseID int,					-- course ID to restrict search to
@effectiveDateOrg datetime = Null	-- Effective date as at when to run the report
--@completed bit = 0 			-- always run for incomplete status
)
AS
begin
/*
declare @orgid int
declare @courseid int
declare @unitids varchar(8000)
declare @effectivedate datetime

set @orgid = 11
set @courseid = 53
set @unitids = null
set @effectivedate = ''4 August 2007''
*/

DECLARE @effectiveDate DateTime
SET @effectiveDate = dbo.udfDaylightSavingTimeToUTC(@effectiveDateOrg,@OrganisationID)

if (@effectiveDateOrg is null)
/*
-- Report on current latest date
*/
Begin

select max(userquizstatusid) userquizstatusid
into #tmpUserQuizStatus
from tblUserQuizStatus
where userid in (select userid from tblUser where organisationid = @organisationID)
and moduleid in (select moduleid from tblModule where courseid = @courseid)
group by userid, moduleid

Select
IU.userID
, IU.unitID
, IU.FirstName
, IU.LastName
, IU.UnitPathway
, case when lastcompleted is null then ''Never'' else convert(varchar(10),dbo.udfUTCtoDaylightSavingTime(LastCompleted,@OrganisationID),103) end  as LastCompleted
, IU.Username
, IU.Email
, IU.ExternalID
, tM.[name] as ''Module''
, tQS.status
--,tM.moduleid
--,tUQS.quizstatusid
--,tUQS.userquizstatusid

From
dbo.udfReport_IncompleteUsersLogic(@organisationID, @unitIDs, @courseID,null) IU
inner join tblUserQuizStatus tUQS
on tUQS.userid = IU.userid
--inner join tmpUserQuizStatis UQS
--      on tUQS.userquizstatusid = UQS.userquizstatusid
inner join tblModule tM
on tUQS.moduleid = tM.moduleid
inner join tblQuizStatus tQS
on tQS.quizstatusid = tUQS.quizstatusid

Where
--tUQS.quizstatusid <> 2 --Every status except pass quiz status
tUQS.quizstatusid in (1,3,4,5)
and tUQS.moduleid in (select moduleid from tblModule where courseid = @courseid)
and tUQS.userquizstatusid in (select userquizstatusid from #tmpUserQuizStatus)

Order By
UnitPathway, LastName, FirstName,  tM.sequence

drop table #tmpUserQuizStatus

end

Else
-- Report results up to the effective date
Begin


select max(userquizstatusid) userquizstatusid
into #tmpUserQuizStatusDate
from tblUserQuizStatus
where userid in (select userid from tblUser where organisationid = @organisationID)
and moduleid in (select moduleid from tblModule where courseid = @courseid)
and Datecreated < @effectiveDate
group by userid, moduleid

Select
IU.userID
, IU.unitID
, IU.FirstName
, IU.LastName
, IU.UnitPathway
, case when lastcompleted is null then ''Never'' else convert(varchar(10),dbo.udfUTCtoDaylightSavingTime(LastCompleted,@OrganisationID),103) end  as LastCompleted
, IU.Username
, IU.Email
, IU.ExternalID
, tM.[name] as ''Module Name''
, tQS.status
--,tM.moduleid
--,tUQS.quizstatusid
--,tUQS.userquizstatusid

From
dbo.udfReport_IncompleteUsersLogic(@organisationID, @unitIDs, @courseID,@effectiveDate) IU
inner join tblUserQuizStatus tUQS
on tUQS.userid = IU.userid
--inner join tmpUserQuizStatis UQS
--      on tUQS.userquizstatusid = UQS.userquizstatusid
inner join tblModule tM
on tUQS.moduleid = tM.moduleid
inner join tblQuizStatus tQS
on tQS.quizstatusid = tUQS.quizstatusid

Where
--tUQS.quizstatusid <> 2 --Every status except pass quiz status
tUQS.quizstatusid in (1,3,4,5)
and tUQS.moduleid in (select moduleid from tblModule where courseid = @courseid)
and tUQS.userquizstatusid in (select userquizstatusid from #tmpUserQuizStatusDate)

Order By
UnitPathway, LastName, FirstName, tM.sequence

drop table #tmpUserQuizStatusDate

end
END

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_AtRiskGrandTotal]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		File:
**		Name: prcReport_AtRisk
**		Desc: Returns a list of users who have failed a quiz the specified
**				of times.
**
**		Auth: Mark Donald
**		Date: 23 Dec 2009
**
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**    09/06/2011	j hedlefs			timezone
*******************************************************************************/


CREATE       Procedure [prcReport_AtRiskGrandTotal]
(
@organisationID int,
@unitIDs varchar(8000),
@courseIDs varchar(8000),
@failCounter int,
@dateFrom datetime,
@dateTo datetime,
@classificationID int
)
AS
SET NOCOUNT ON

DECLARE @Units TABLE (UnitID INT PRIMARY KEY(UnitID))
DECLARE @Courses TABLE (CourseID INT PRIMARY KEY(CourseID))
DECLARE @Users TABLE(UserID INT , UnitID INT PRIMARY KEY(UserID, UnitID))

INSERT INTO @Courses SELECT * FROM dbo.udfCsvToInt(@courseIDs)
INSERT INTO @Units SELECT * FROM  dbo.udfCsvToInt(@unitIDs)

--Get All the users for all specfied units, matching Custom Classification option (if provided)
INSERT INTO @Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
JOIN @Units B ON A.UnitID = B.UnitID
JOIN tblUnit C ON B.UnitID = C.UnitID AND C.Active = 1
LEFT JOIN tblUserClassification uc ON uc.UserID  = A.UserID
WHERE
A.Active = 1
AND ((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification

BEGIN
SELECT
count(DISTINCT s.userid) AS TotalDistinctUsers
FROM
(SELECT
q.userid, moduleid,
sum(CASE quizstatusid WHEN 3 THEN 1 ELSE 0 END) AS failnumber,
max(userquizstatusid) AS currentstatusid
FROM
tbluserquizstatus q, tbluser u
WHERE
q.userid = u.userid
AND organisationid = @organisationID
AND q.datecreated BETWEEN dbo.udfDaylightSavingTimeToUTC(@dateFrom,@OrganisationID) AND dateadd(dd, 1, dbo.udfDaylightSavingTimeToUTC(@dateTo,@OrganisationID))
GROUP BY
q.userid, moduleid
HAVING
sum(CASE quizstatusid WHEN 3 THEN 1 ELSE 0 END) >= @failCounter) s
LEFT JOIN tblusermoduleaccess a ON
a.userid = s.userid AND a.moduleid = s.moduleid
JOIN tbluser u ON
u.userid = s.userid
LEFT JOIN tblunitmoduleaccess n ON
n.unitid = u.unitid AND s.moduleid = deniedmoduleid,
tbluserquizstatus uq,
@Users x,
@Courses w,
tblmodule m,
tblcourse c,
tblquizstatus q,
tblunithierarchy h
WHERE
(
(deniedmoduleid IS NULL AND a.moduleid IS NULL)
OR a.granted = 1
)
AND uq.userquizstatusid = s.currentstatusid
AND x.userid = s.userid
AND m.moduleid = s.moduleid
AND c.courseid = m.courseid
AND w.courseid = m.courseid
AND q.quizstatusid = uq.quizstatusid
AND h.unitid = u.unitid

END

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_AtRisk]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		File:
**		Name: prcReport_AtRisk
**		Desc: Returns a list of users who have failed a quiz the specified
**				of times.
**
**		Auth: Mark Donald
**		Date: 23 Dec 2009
**
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**      09/06/2011	j hedlefs			timezone
*******************************************************************************/


CREATE       Procedure [prcReport_AtRisk]
(
@organisationID int,
@unitIDs varchar(8000),
@courseIDs varchar(8000),
@failCounter int,
@dateFrom datetime,
@dateTo datetime,
@classificationID int
)
AS
SET NOCOUNT ON

DECLARE @Units TABLE (UnitID INT PRIMARY KEY(UnitID))
DECLARE @Courses TABLE (CourseID INT PRIMARY KEY(CourseID))
DECLARE @Users TABLE(UserID INT , UnitID INT PRIMARY KEY(UserID, UnitID))

INSERT INTO @Courses SELECT * FROM dbo.udfCsvToInt(@courseIDs)
INSERT INTO @Units SELECT * FROM  dbo.udfCsvToInt(@unitIDs)

--Get All the users for all specfied units, matching Custom Classification option (if provided)
INSERT INTO @Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
JOIN @Units B ON A.UnitID = B.UnitID
JOIN tblUnit C ON B.UnitID = C.UnitID AND C.Active = 1
LEFT JOIN tblUserClassification uc ON uc.UserID  = A.UserID
WHERE
A.Active = 1
AND ((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification

BEGIN
SELECT
s.userid, s.moduleid, hierarchyname as unitpathway, lastname, firstname, externalid, email, username, c.[name] as coursename, m.[name] as modulename, failnumber, [status] as currentstatus
FROM
(SELECT
q.userid, moduleid,
sum(CASE quizstatusid WHEN 3 THEN 1 ELSE 0 END) AS failnumber,
max(userquizstatusid) AS currentstatusid
FROM
tbluserquizstatus q, tbluser u
WHERE
q.userid = u.userid
AND organisationid = @organisationID
AND q.datecreated BETWEEN dbo.udfDaylightSavingTimeToUTC(@dateFrom,@OrganisationID) AND dateadd(dd, 1, dbo.udfDaylightSavingTimeToUTC(@dateTo,@OrganisationID))
GROUP BY
q.userid, moduleid
HAVING
sum(CASE quizstatusid WHEN 3 THEN 1 ELSE 0 END) >= @failCounter) s
LEFT JOIN tblusermoduleaccess a ON
a.userid = s.userid AND a.moduleid = s.moduleid
JOIN tbluser u ON
u.userid = s.userid
LEFT JOIN tblunitmoduleaccess n ON
n.unitid = u.unitid AND s.moduleid = deniedmoduleid,
tbluserquizstatus uq,
@Users x,
@Courses w,
tblmodule m,
tblcourse c,
tblquizstatus q,
tblunithierarchy h
WHERE
(
(deniedmoduleid IS NULL AND a.moduleid IS NULL)
OR a.granted = 1
)
AND uq.userquizstatusid = s.currentstatusid
AND x.userid = s.userid
AND m.moduleid = s.moduleid
AND c.courseid = m.courseid
AND w.courseid = m.courseid
AND q.quizstatusid = uq.quizstatusid
AND h.unitid = u.unitid
ORDER BY
unitpathway, lastname, firstname
END

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_ActiveInactive]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE Procedure [prcReport_ActiveInactive]
(
@FromDate	datetime,
@ToDate		datetime,
@CourseIDs	varchar(8000),
@OrganisationID int,
@IncludeInactive int
)
AS

/******************************************************************************
**		File:
**		Name: dbo.prcReport_ActiveInactive
**		Desc:
**
**		This template can be customized:
**
**		Return values:
**
**		Called by:   Active INactive Users Report
**
**		Parameters:
**		Input							Output
**     ----------							-----------
**		Comma separated course id''s
**
**		Auth: Serguei Chkaroupine
**		Date: 5/01/2006
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**		23/03/07	Yoppy Suwanto			Added a new colum Unit Pathway and sorted by it
**		21/07/09	Mark Donald				Order by LastName, FirstName
**		24/03/11	John Hedlefs			Timezone conversions
*******************************************************************************/

BEGIN

SELECT distinct
tblUnitHierarchy.HierarchyName as UnitPathway,
uma.[UserID],
uma.[LastName],
uma.[FirstName],
CASE
WHEN tblUser.Active <> 1 THEN ''(i)''
ELSE ''''
END as Flag
,tblUser.[ExternalID]
,tblUser.[Email]
,tblUser.[UserName]
,[CourseName]
-- used to count inactive users (RS does not counts nulls)
,CASE
WHEN Active = 0 THEN 1
ELSE NULL
END as Active,
dbo.udfUTCtoDaylightSavingTime(tblUser.DateCreated,@OrganisationID) as ''DateCreated'',
dbo.udfUTCtoDaylightSavingTime(case when Active = 0 then coalesce(tblUser.DAteArchived,tblUser.DateUpdated) end,@OrganisationID) as ''DateArchived''
FROM
-- derived table UserModuleAccess
(SELECT
tU.UserID,
tU.FirstName,
tU.LastName,
tU.UnitID,
tU.OrganisationID,
tM.ModuleID,
tM.CourseID,
tC.Name AS CourseName

FROM
dbo.tblUser AS tU INNER JOIN
dbo.tblOrganisationCourseAccess AS tOCA ON tOCA.OrganisationID = tU.OrganisationID INNER JOIN
dbo.tblCourse AS tC ON tC.CourseID = tOCA.GrantedCourseID INNER JOIN
dbo.tblModule AS tM ON tM.CourseID = tC.CourseID AND tM.Active = 1 LEFT OUTER JOIN
dbo.tblUserModuleAccess AS tUsrMA ON tUsrMA.UserID = tU.UserID AND tUsrMA.ModuleID = tM.ModuleID LEFT OUTER JOIN
dbo.tblUnitModuleAccess AS tUnitMA ON tUnitMA.UnitID = tU.UnitID AND tUnitMA.DeniedModuleID = tM.ModuleID

WHERE
(tU.UnitID IS NOT NULL) AND
(tUnitMA.DeniedModuleID IS NULL) AND
(tUsrMA.ModuleID IS NULL) OR
(tUsrMA.Granted = 1)
)
as uma -- end derived table UserModuleAccess
LEFT JOIN tblUser on uma.UserID = tblUser.UserID
LEFT JOIN tblUnitHierarchy on tblUnitHierarchy.UnitID = tblUser.UnitID

WHERE
uma.OrganisationID = @OrganisationID
AND CourseID in (SELECT * FROM dbo.udfCsvToInt(@CourseIDs))
AND tblUser.DateCreated between dbo.udfDaylightSavingTimeToUTC(@FromDate,@OrganisationID) and dbo.udfDaylightSavingTimeToUTC(@ToDate,@OrganisationID)
and tblUser.Active = (case when @includeinactive =0 then 1 else tbluser.active end )

ORDER BY
UnitPathway,
uma.[LastName],
uma.[FirstName]

--Order By CourseName


END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_UpdateEndQuizInfo]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Update record in tblQuizSession
Insert record into tblUserQuizStatus
Insert record into tblUserCourseStatus

Returns:
data table

Called By:
ToolBook.cs: UpdateEndQuizInfo

Author: Li Zhang
Date Created: 13-10-2006
Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		1/5/2007		Added QuizCompletionDate
**/

CREATE PROCEDURE [prcQuizSession_UpdateEndQuizInfo]
(
@QuizSessionID	varchar(50) -- unique GUID that identifies this toolbook quiz session
, @Duration	int -- the duration in seconds of the quiz as mesured by toolbook
, @Score 	int -- the score as mesured by toolbook
, @UserID	int	-- user id
, @QuizID	int -- quiz id
, @PassMark	int	-- quiz pass mark
, @UnitID	int	-- user''s unit id
, @ModuleID	int -- quiz module id
, @CourseID	int -- module course id
, @OldCourseStatus	int -- course status before update
, @NewQuizStatus int -- the quiz status
, @NewCourseStatus	int	-- course status after update
, @QuizFrequency	int -- quiz frequency
, @QuizCompletionDate	datetime -- quiz completiondate
)
AS
SET nocount on
SET xact_abort on
BEGIN TRANSACTION

declare @OrgID int
select @OrgID = organisationID from tblUnit where tblUnit.UnitID=@UnitID

set @QuizCompletionDate = dbo.udfDaylightSavingTimeToUTC(@QuizCompletionDate, @OrgID)

DECLARE @dateCreated datetime
SET @dateCreated = GETUTCDATE()

IF EXISTS
(
SELECT QuizSessionID
FROM tblQuizSession
WHERE QuizSessionID = @QuizSessionID
AND	DateTimeStarted IS NOT NULL
AND DateTimeCompleted IS NULL
)
BEGIN
-- < update tblQuizSession >--
UPDATE tblQuizSession
SET DateTimeCompleted = @dateCreated
, Duration = @Duration
, QuizScore = @Score
, QuizPassMark = @PassMark
WHERE
QuizSessionID = @QuizSessionID

--< insert into tblUserQuizStatus >--
INSERT INTO
tblUserQuizStatus
(
UserID,
ModuleID,
QuizStatusID,
QuizFrequency,
QuizPassMark,
QuizCompletionDate,
QuizScore,
QuizSessionID,
DateCreated
)
VALUES
(
@UserID,
@ModuleID,
@NewQuizStatus,
@QuizFrequency,
@PassMark,
@QuizCompletionDate,
@Score,
@QuizSessionID,
@dateCreated
)

--< insert into tblUserCourseStatus >--
IF (@OldCourseStatus = -1) or (@OldCourseStatus <> @NewCourseStatus)
BEGIN
EXEC prcUserCourseStatus_Insert @UserID, @ModuleID, @NewCourseStatus
END
ELSE
BEGIN
IF NOT EXISTS (SELECT UserID FROM vwUserModuleAccess where UserID = @UserID AND CourseID = @CourseID) AND
EXISTS (SELECT UserCourseStatusID FROM tblUserCourseStatus WHERE UserID = @UserID AND CourseID = @CourseID AND CourseStatusID <> 0)
BEGIN
EXEC prcUserCourseStatus_Insert @UserID, @ModuleID, @NewCourseStatus = 0
END
END

END

COMMIT TRANSACTION


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetUserAndPoliciesForAdmins]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:		Compiles a %USER-POLICY_NAMES% block and returns it with a bunch of user info for sending email to that user


Parameters:		Comma separated list of adminuserID,policyID,unitID
Returns:		table (lastname nvarchar(50), firstname nvarchar(50), userid int, email nvarchar(100), policy_name varchar(8000))

Called By:		BusinessServices.{Policy.GetUserAndPoliciesForAdmins in Policy.cs
Calls:			None

Remarks:		None

Author:			John H
Date Created:	21 May 2010

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcPolicy_GetUserAndPoliciesForAdmins]
@admin_ids varchar(8000),
@policy_ids varchar(8000),
@unit_ids varchar(8000),
@accepted varchar (20),
@acceptedDateFrom 		datetime,
@acceptedDateTo 		datetime,
@OrgID int
AS
BEGIN
	SET NOCOUNT ON;

	set @acceptedDateFrom = dbo.udfDaylightSavingTimeToUTC(@acceptedDateFrom, @OrgID)
	set @acceptedDateTo = dbo.udfDaylightSavingTimeToUTC(@acceptedDateTo, @OrgID)

	DECLARE @policies TABLE (policyid int)
	DECLARE @selected_units TABLE (unitid int)
	DECLARE @selected_admins TABLE (userid int)
	DECLARE @result TABLE (firstname nvarchar(50), policyname nvarchar(50), userid int, email nvarchar(100), user_list varchar(8000), PolicyID int, HierarchyName nvarchar(500))

	DECLARE
	@pos int,
	@colon_pos int,
	@temp varchar(50),
	@admid int , @PolicyID int,
	@PolicyName varchar(8000),
	@user_list varchar(8000),
	@users_with_policies varchar(8000),
	@modified_policy_names varchar(8000),
	@strAccepted varchar(5),
	@aunit int


	IF @accepted = ''0''
	BEGIN
	SELECT @strAccepted = ''True''
	END
	ELSE
	BEGIN
	SELECT @strAccepted = ''False''
	END



	-- rip the unit selection
	INSERT INTO @selected_units
	SELECT
	*
	FROM
	dbo.udfCsvToInt(@unit_ids)

	SELECT @aunit = (SELECT TOP (1) unitid FROM @selected_units)

	-- rip the admin selection
	INSERT INTO @selected_admins
	SELECT
	*
	FROM
	dbo.udfCsvToInt(@admin_ids)




	SELECT @policy_ids = replace(rtrim(ltrim(replace(replace(replace(@policy_ids,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''

	-- rip the policies into a table
	INSERT INTO @policies
	SELECT
	*
	FROM
	dbo.udfCsvToInt(@policy_ids)
	-- Note to self: String operations take hundreds of times longer than cursor operations so first think of a way to limit the number of string operations, then get rid of the cursors.

	SELECT @user_list = ''''
	DECLARE concatenator CURSOR READ_ONLY FOR
	SELECT DISTINCT
	uadm.userid , pol.PolicyName, pol.policyid
	FROM
	tblpolicy pol
	INNER JOIN @policies pols ON pol.policyid = pols.policyid
	INNER JOIN tblUserPolicyAccess polacc ON polacc.policyid = pol.policyid AND polacc.granted = ''True''
	INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
	AND (
	((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))

	INNER JOIN tblUser u ON u.userid = polacc.userid AND u.userid = polacd.userid AND u.active = ''True''
	INNER JOIN udf_GetAdminEmailsForORG(@orgID) uadm ON u.UnitID = uadm.unitid
	INNER JOIN tblUnitHierarchy hier ON hier.UnitID = u.UnitID
	INNER JOIN @selected_units su ON su.unitID = u.unitid
	INNER JOIN @selected_admins sa on sa.userid = uadm.userid
	ORDER BY uadm.userid
	OPEN concatenator
	FETCH NEXT FROM concatenator INTO @admID , @policyName, @PolicyID
	WHILE @@FETCH_STATUS = 0
	BEGIN
	SELECT @user_list = COALESCE(@user_list,'''') +  char(13) + char(10) + char(9)  + u.FirstName + '' '' + u.LastName
	FROM
	tblpolicy pol
	INNER JOIN @policies pols ON pol.policyid = pols.policyid AND pol.policyid = @PolicyID
	INNER JOIN tblUserPolicyAccess polacc ON polacc.policyid = pol.policyid AND polacc.granted = ''True''
	INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
	AND (
	((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))

	INNER JOIN tblUser u ON u.userid = polacc.userid AND u.userid = polacd.userid AND u.active = ''True''
	INNER JOIN udf_GetAdminEmailsForORG(@orgID) uadm ON u.UnitID = uadm.unitid AND uadm.userid = @admid
	INNER JOIN tblUnitHierarchy hier ON hier.UnitID = u.UnitID
	INNER JOIN @selected_units su ON su.unitID = u.unitid
	ORDER BY u.LastName , u.FirstName

	INSERT INTO
	@result
	SELECT
	adm.firstName+'' ''+adm.lastname, @policyName, adm.userid, adm.email, @user_list, @PolicyID, unt.HierarchyName
	FROM
	tblUser adm
	INNER JOIN tblUnitHierarchy unt ON unt.unitid = adm.unitid AND adm.userid = @admID AND adm.active = ''True''

	SELECT @user_list = ''''

	FETCH NEXT FROM concatenator INTO @admID , @policyName, @PolicyID
	END
	CLOSE concatenator
	DEALLOCATE concatenator


	--Get Data in report format
	SELECT
	DISTINCT UserID, HierarchyName, PolicyName, FirstName,  email, user_list, PolicyID
	FROM @result
END




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetPoliciesInUnit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*
Summary:		Compiles a %POLICY_NAMES% block and returns it with a bunch of user info for sending email to that user
(Mainly just returns a list of policies that are assigned to users that meet the flagged conditions)
Parameters:		Comma separated list of userID:courseID
Returns:		table (lastname nvarchar(50), firstname nvarchar(50), userid int, email nvarchar(100), policy_name varchar(8000))

Called By:		BusinessServices.{Policy.prcPolicy_GetUsersByPolicyAndUnit in Policy.cs
Calls:			None

Remarks:		None

Author:			Mark Donald (John R copied prcCourse_UserMashup - no optimising attempted as execution time expected to be small)
Date Created:	13 Nov 2009 (copied 18/05/2010)

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcPolicy_GetPoliciesInUnit]
@policy_ids varchar(8000),
@unit_ids varchar(8000),
@accepted varchar (20),
@acceptedDateFrom 		datetime,
@acceptedDateTo 		datetime,
@OrgID int
AS
BEGIN
SET NOCOUNT ON;

set @acceptedDateFrom = dbo.udfDaylightSavingTimeToUTC(@acceptedDateFrom, @OrgID)
set @acceptedDateTo = dbo.udfDaylightSavingTimeToUTC(@acceptedDateTo, @OrgID)

DECLARE @policies TABLE (policyid int)
DECLARE @selected_units TABLE (unitid int)
DECLARE @result TABLE (policy_names varchar(8000))
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50),
@userid int,
@policy_names varchar(8000),
@modified_policy_names varchar(8000),
@strAccepted varchar(5)



IF @accepted = ''0''
BEGIN
SELECT @strAccepted = ''True''
END
ELSE
BEGIN
SELECT @strAccepted = ''False''
END



-- rip the user selection
INSERT INTO @selected_units
SELECT
*
FROM
dbo.udfCsvToInt(@unit_ids)

-- clean up the input so it resembles ''userid:policyid,userid:policyid,''
SELECT @policy_ids = replace(rtrim(ltrim(replace(replace(replace(@policy_ids,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''

-- rip the policies into a table
INSERT INTO @policies
SELECT
*
FROM
dbo.udfCsvToInt(@policy_ids)
-- Note to self: String operations take hundreds of times longer than cursor operations so first think of a way to limit the number of string operations, then get rid of the cursors.


SELECT DISTINCT pol.PolicyName
FROM
@policies pols
INNER JOIN tblPolicy pol ON pol.PolicyID = pols.PolicyID
INNER JOIN tblUserPolicyAccess polacs ON polacs.policyid = pols.policyid AND polacs.granted = ''True''
INNER JOIN tblUserPolicyAccepted polacd ON polacd.policyid = pols.policyid AND polacd.Accepted = @strAccepted
AND (
((COALESCE(polacd.DateAccepted,CAST(''1/1/1980'' AS DateTime)) >= @acceptedDateFrom) AND (COALESCE(polacd.DateAccepted,CAST(''1/1/2999'' AS DateTime)) < @acceptedDateTo))OR (@strAccepted = ''False''))

INNER JOIN tblUser usr ON usr.userid = polacs.userid AND usr.userid = polacd.userid AND usr.active = ''True''
INNER JOIN @selected_units su ON usr.unitid = su.unitid
END




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_AdminMashup]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:		Compiles a bunch of info based on the selected units/courses then filters it based on administrator selection
Parameters:		Comma separated list of userID:courseID, comma separated list of adminID (unit administrators)
Returns:		table (lastname firstname userid email course_names)

Called By:		BusinessServices.Course.GetAdminMashup in Course.cs
Calls:			None

Remarks:		None

Author:			Mark Donald
Date Created:	20 Jan 2010

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcCourse_AdminMashup]
@organisationID int,
@unitIDs 			varchar(MAX),
@courseIDs 			varchar(8000),
@input_csv varchar(8000),
@adminids varchar(8000),
@classificationID 	int,
@courseModuleStatus	int,
@quizDateFrom 		datetime,
@quizDateTo 		datetime,
@includeInactive	int
AS
BEGIN
SET NOCOUNT ON;


set @quizDateFrom = dbo.udfDaylightSavingTimeToUTC(@quizDateFrom, @organisationID)
set @quizDateTo = dbo.udfDaylightSavingTimeToUTC(@quizDateTo, @organisationID)

declare @tblUserUnit table
(
UserID int,
UnitID int
)


declare @tblUnit table
(
unitID int
)

declare @tblUnitAdministrator table
(
unitID int,
AdminUserID int,
firstname nvarchar(200),
lastname nvarchar(200)
)
Set Nocount On
Declare
@CONST_INCOMPLETE     	int,
@CONST_COMPLETE     	int,
@CONST_FAILD            int,
@CONST_NOTSTARTED 	    int,
@CONST_UNKNOWN 	        int,
@CONST_EXPIRED_TIMELAPSED int,
@CONST_EXPIRED_NEWCONTENT int

set @CONST_INCOMPLETE	= 0
set @CONST_COMPLETE	    = 1
set @CONST_FAILD		= 2
set @CONST_NOTSTARTED	= 3
set @CONST_EXPIRED_TIMELAPSED	= 4
set @CONST_EXPIRED_NEWCONTENT  = 5

DECLARE @Units TABLE (UnitID INT)
DECLARE @Courses TABLE (CourseID INT)
DECLARE @CoursesWithAccess TABLE (CourseID INT PRIMARY KEY, [name] nvarchar(100))
DECLARE @UserModuleWithAccess TABLE (UserID INT, ModuleID INT, UnitID INT, PRIMARY KEY(UserID, ModuleID, UnitID))
DECLARE @AllModules TABLE (ModuleID INT PRIMARY KEY(ModuleID))
DECLARE @Users TABLE (UserID INT, UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @UsersNQuizStatus TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @UsersQuizStatusNOTSTARTED TABLE (
UserID	INT, ModuleID INT, LatestQuizID INT, QuizStatusID INT, QuizScore INT,
PRIMARY KEY(UserID, ModuleID, LatestQuizID, QuizStatusID)
)
DECLARE @mashup TABLE (userid int, courseid int)
DECLARE @selectedadmin TABLE (adminid int)
DECLARE
@pos int,
@colon_pos int,
@temp varchar(50)

INSERT INTO
@Courses
SELECT
*
FROM
dbo.udfCsvToInt(@courseIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

INSERT INTO
@selectedadmin
SELECT
*
FROM
dbo.udfCsvToInt(@adminids)

--Get Rid of courses which do not have access to specified org
INSERT INTO
@CoursesWithAccess
SELECT
A.CourseID, [name]
FROM
@Courses A, tblOrganisationCourseAccess B, tblCourse C
WHERE
A.CourseID = B.GrantedCourseID
AND B.OrganisationID = @organisationID
AND A.CourseID = C.CourseID
AND C.Active = 1

--Get All the users for all specfied units
INSERT INTO
@Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
join  @Units B on A.UnitID = B.UnitID
join  tblUnit C on B.UnitID = C.UnitID  AND C.Active = 1
WHERE
@includeinactive =1 or A.Active = 1 -- show all or only active users



if @courseModuleStatus = @CONST_COMPLETE or @courseModuleStatus = @CONST_INCOMPLETE
begin -- completed / -- InComplete
--------------------
-- Completed --
--------------------
-- A user is completed if they became complete and remained completed in the period of interest
-- the query only needs to check to see status at the max date in this period as a line item
-- as tblUserCourseStatus is only writen to when an event occours that would
-- change the status.
-- When "Course/Module Status" is set to "Complete"
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Complete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question
--------------------
-- InComplete
--------------------
-- A user is in-completed if for any reason they are not complete but do have access to the course
-- This will find users that:
-- - Belong to any of the Units in @unitIDs
-- - AND are currently assigned Modules from the selected Course
-- - AND have the Custom Classification option (if provided)
-- - AND have (at the end of the time-period in question) got a status of Incomplete in tblUserCourseStatus
-- - AND the event that made them complete happened some time in the time-period in question

INSERT INTO @tblUserUnit(UserID, UnitID)
SELECT
DISTINCT A.UserID, A.UnitID
FROM
(SELECT
A.UserID, D.UnitID
FROM
(SELECT
A.UserID, A.CourseID, MAX(A.UserCourseStatusID) AS ''LatestCourseStatus''
FROM
tblUserCourseStatus A, @CoursesWithAccess B
WHERE
A.DateCreated < DATEADD(DD, 1, @quizDateTo)
and A.CourseID = B.CourseID
GROUP BY
A.UserID, A.CourseID
) A, @Users B, tblUserCourseStatus C, tblUser D
WHERE
A.UserID = B.UserID
AND B.UserID = C.UserID
AND A.LatestCourseStatus = C.UserCourseStatusID
AND (C.DateCreated BETWEEN @quizDateFrom AND @quizDateTo)
AND C.CourseStatusID = case @courseModuleStatus
when @CONST_COMPLETE then 2   -- Complete
when @CONST_INCOMPLETE then 1 -- InComplete
end
AND A.UserID = D.UserID
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
WHERE
--If classification is Any (0), This will find users of any Custom Classification
(@classificationID =0 OR tblUserClassification.classificationID = @classificationID)
AND A.UserID IN (select UserID from tblUser where OrganisationID = @organisationID and Active = 1)
ORDER BY
A.UserID, A.UnitID
END -- completed / -- InComplete


if @courseModuleStatus = @CONST_FAILD or @courseModuleStatus = @CONST_EXPIRED_TIMELAPSED or @courseModuleStatus = @CONST_EXPIRED_NEWCONTENT
begin -- Failed
--------------------
-- Failed  --
--------------------
-- When "Course/Module Status" is set to "Failed"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND took a quiz, for a Module within the selected Course, within the date range and failed it
--  - AND who currently have a status other than "Passed" for that same quiz
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
)A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID

INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID = case @courseModuleStatus
when @CONST_FAILD then 3   -- Failed
when @CONST_EXPIRED_TIMELAPSED then 4 -- Expired time lapsed
when @CONST_EXPIRED_NEWCONTENT then 5 -- Expired new content
end

--Get Data in report format
INSERT INTO @tblUserUnit(UserID, UnitID)
SELECT
DISTINCT A.UserID, UnitID
FROM
(select
distinct userid, moduleid
from
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D
WHERE
A.UserID = B.UserID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
ORDER BY
A.UserID, UnitID
end --/ Failed


-- Not started --

if @courseModuleStatus = @CONST_NOTSTARTED
begin -- Not started - Any
--------------------
-- Not started  --
--------------------
-- When "Course/Module Status" is set to "Not Started"
-- This will find users that:
--  - Belong to any of the Units in @unitIDs
--  - AND are currently assigned Modules from the selected Course
--  - AND have the Custom Classification option
--  - AND who have not started ANY of the quizes they have access to in this course
--------------------

INSERT INTO
@UserModuleWithAccess
SELECT
DISTINCT A.UserID, A.ModuleID, A.UnitID
FROM
(SELECT
A.UserID, A.ModuleID, A.UnitID
FROM
vwUserModuleAccess A
where
courseid in (SELECT courseid from @Courses)
) A, @Users B
Where
A.UserID = B.UserID

--Find the latest status of all quiz for all the modules
INSERT INTO
@UsersNQuizStatus
SELECT
DISTINCT A.UserID, A.ModuleID, A.LatestQuizID, B.QuizStatusID, B.QuizScore
FROM
(SELECT
A.UserID, A.ModuleID, MAX(B.UserQuizStatusID) AS ''LatestQuizID''
FROM
@UserModuleWithAccess A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
GROUP BY
A.UserID, A.ModuleID
) A, tblUserQuizStatus B
WHERE
A.UserID = B.UserID
AND A.ModuleID = B.ModuleID
AND A.LatestQuizID = B.UserQuizStatusID
AND (B.DateCreated BETWEEN @quizDateFrom AND @quizDateTo)

--select * from @UsersNQuizStatus

--Get User with Quiz NOT STARTED
INSERT INTO
@UsersQuizStatusNOTSTARTED
SELECT
*
FROM
@UsersNQuizStatus
WHERE
QuizStatusID NOT IN (2,3)
AND UserID NOT IN (SELECT UserID FROM @UsersNQuizStatus WHERE QuizStatusID IN (2,3))

--select * from @UsersQuizStatusNOTSTARTED
--select distinct userid,moduleid from @UsersQuizStatusNOTSTARTED

--Get Data in report format
INSERT INTO @tblUserUnit(UserID, UnitID)
SELECT
A.UserID, UnitID
FROM
(SELECT
DISTINCT A.UserID, B.UnitID
FROM
(SELECT
DISTINCT userid, moduleid
FROM
@UsersQuizStatusNOTSTARTED
) A, tblUser B, tblModule D
WHERE
A.UserID = B.UserID
AND A.ModuleID = D.ModuleID
AND D.Active = 1
) A
LEFT JOIN tblUserClassification ON tblUserClassification.UserID = A.UserID
AND tblUserClassification.classificationID = isnull( @classificationID, tblUserClassification.classificationID )
WHERE
--If classification is Any (0), This will find users of any Custom Classification
@classificationID =0 OR tblUserClassification.classificationID = @classificationID
ORDER BY
A.UserID, UnitID

end --/ Not started - Any


insert into @tblUnit(UnitID)
select distinct UnitID
from @tblUserUnit

---If "Administrators" was selected as the Recipient Type, then the email will be sent to the administrators of the users Units.
insert into @tblUnitAdministrator (UnitID, AdminUserID,firstname, lastname)
select u.UnitID, ua.UserID, us.firstname, us.lastname
from @tblUnit u
inner join tblUnitAdministrator ua
on ua.UnitID = u.UnitID
inner join tblUser us
on us.UserID = ua.UserID and us.UserTypeID = 3 --Unit Administrator

--If a user belongs to a Unit that does not have its own administrator, the email will go to the Organisation Administrators.
insert into @tblUnitAdministrator (UnitID, AdminUserID,firstname, lastname)
select u.UnitID, us.UserID, us.firstname, us.lastname
from tblUser us
cross join @tblUnit u
where us.OrganisationID = @organisationID
and us.UserTypeID = 2 -- Organisation Administrator
and u.UnitID not in (select UnitID from @tblUnitAdministrator)
and us.Active = 1


-- clean up the input so it resembles ''userid:courseid,userid:courseid,''
SELECT @input_csv = replace(rtrim(ltrim(replace(replace(replace(@input_csv,'' '',''''),'',,'','',''),'','','' ''))),'' '','','') + '',''

-- rip input_csv
WHILE patindex(''%,%'', @input_csv) <> 0
BEGIN
SELECT @pos = patindex(''%,%'', @input_csv)
SELECT @temp = left(@input_csv, @pos - 1)
SELECT @colon_pos = patindex(''%:%'', @input_csv)
INSERT @mashup VALUES (
cast(substring(@temp, 1, @colon_pos - 1) AS int),
cast(substring(@temp, @colon_pos + 1, len(@temp)) AS int)
)
SELECT @input_csv = substring(@input_csv, @pos + 1, len(@input_csv))
END

-- join @mashup, @tblunitadministrator & @selectedadmin tables & sort results by adminid and courseid
SELECT
adminid, a.email, a.firstname, a.lastname, m.courseid, [name] coursename, u.firstname, u.lastname, n.firstname, n.lastname
FROM
@mashup m,
@tblunitadministrator n,
@selectedadmin s,
tbluser a,
tblcourse c,
tbluser u
WHERE
u.userid = m.userid
AND n.unitid = u.unitid
AND a.userid = adminid
AND adminid = adminuserid
AND c.courseid = m.courseid
ORDER BY
adminid, m.courseid

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetAllocatedDiskSpace]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE Procedure [prcOrganisation_GetAllocatedDiskSpace]
(
@OrganisationID int
)

as

select
AllocatedDiskSpace
from tblOrganisation
where OrganisationID = @OrganisationID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Import]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Insert/Update the details of tblUser table
Parameters:
@userXML text The XML document containing the User data.
@ID Integer ID of either the Organisation or Unit
@hierachy VarChar(12) hierachy where the call to upload useres was made from. can only be Organisation or Unit.
@userID Integer = null -- ID of user inporting the xmlData
Returns:


Called By:
User.cs
Calls:

Author: Li Zhang
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date		Description

*/

CREATE    Procedure [prcUser_Import]
(
	@userName nvarchar(200),
	@password nvarchar(100),
	@firstName nvarchar(200),
	@lastName nvarchar(200),
	@email nvarchar(255),
	@unitID int,
	@classificationName nvarchar(100),
	@classificationOption nvarchar(100),
	@externalID	nvarchar(100),
	@archival	int,
	@isUpdate bit,
	@uniqueField int,
	@userID int,
	@orgID int,
	@NotifyUnitAdmin nvarchar(3),
	@NotifyOrgAdmin nvarchar(3),
	@ManagerNotification nvarchar(3),
	@ManagerToNotify nvarchar(255)
)

As
begin 

	Set NoCount on

	Set Xact_Abort On
	Begin Transaction


	--Declarations
	Declare @uniqueField_Email int
	Declare @uniuqeField_Username int

	set @uniqueField_Email = 1
	set @uniuqeField_Username = 2
	
	declare @t int

	--update
	IF (@isUpdate = 1)
	BEGIN

		IF (@uniqueField = @uniqueField_Email)
		BEGIN
		
			--select ''debug update unique field email''
			update tblUser
			set UserName = case when @username =''''  then username else ISNULL(@userName,u.UserName)end,
			FirstName = case when @firstname = '''' then FirstName else ISNULL(@firstName, u.FirstName)end,
			LastName = case when @lastName =''''  then  lastname else ISNULL(@lastName, u.LastName)end,
			Password = case when password ='''' then Password else ISNULL(@password, u.password)end,
			ExternalID = case when @externalid ='''' then externalid when @externalid =''^'' then null else ISNULL(@externalID, u.externalID)end,
			UnitID = ISNULL(@unitID, u.UnitID),
			Active = Case @archival when 1 then 0 -- archive user = true
			when 0 then 1 -- archive user = false
			else u.Active end,--remain unchanged
			DateArchived = Case @archival when 1 then getutcdate()
			when 0 then null
			else u.DateArchived end,
			NotifyUnitAdmin = case when @NotifyUnitAdmin is null then NotifyUnitAdmin when @NotifyUnitAdmin=''Yes'' then 1 when @NotifyUnitAdmin=''No'' then 0  else NotifyUnitAdmin end, 
			NotifyOrgAdmin = case when @NotifyOrgAdmin is null then notifyorgadmin  when @NotifyOrgAdmin = ''Yes'' then 1 when @NotifyOrgAdmin = ''No''then 0 else NotifyOrgAdmin end,
			NotifyMgr = case when @ManagerNotification is null then NotifyMgr when @ManagerNotification = ''Yes'' then 1 when @ManagerNotification = ''No'' then 0 else NotifyMgr end,
			DelinquencyManagerEmail = case when @ManagerToNotify='''' then DelinquencyManagerEmail when @ManagerToNotify = ''^'' then null else @ManagerToNotify end,
			DateUpdated = getutcdate(),
			UpdatedBy = @userID
			FROM tblUser u
			WHERE
			u.Email = @email
			and
			u.OrganisationID = @orgID
			
			-- get the userid from the email since it is the unique field
			select @t = UserID from tblUser where Email = @email
			
			
			--select ''debug update complete unique field email''
		END

		else IF (@uniqueField = @uniuqeField_Username)
		BEGIN
			--select ''debug update unique field username'' + @userName
			
			update tblUser
			set FirstName = case when @firstname = '''' then FirstName else ISNULL(@firstName, u.FirstName)end,
			LastName = case when @lastName =''''  then  lastname else ISNULL(@lastName, u.LastName)end,
			Password = case when password ='''' then Password else ISNULL(@password, u.password)end,
			ExternalID = case when @externalid ='''' then externalid when @externalid =''^'' then null else ISNULL(@externalID, u.externalID)end,
			Email = case when @email ='''' then email else ISNULL(@Email, u.Email)end,			
			UnitID = ISNULL(@unitID, u.UnitID),
			Active = Case @archival when 1 then 0
			when 0 then 1
			else u.Active end,
			DateArchived = Case @archival when 1 then getutcdate()
			when 0 then null
			else u.DateArchived end,
			DateUpdated = getutcdate(),
			UpdatedBy = @userID,
			NotifyUnitAdmin = case when @NotifyUnitAdmin is null then NotifyUnitAdmin when @NotifyUnitAdmin=''Yes'' then 1 when @NotifyUnitAdmin=''No'' then 0  else NotifyUnitAdmin end, 
			NotifyOrgAdmin = case when @NotifyOrgAdmin is null then notifyorgadmin  when @NotifyOrgAdmin = ''Yes'' then 1 when @NotifyOrgAdmin = ''No''then 0 else NotifyOrgAdmin end,
			NotifyMgr = case when @ManagerNotification is null then NotifyMgr when @ManagerNotification = ''Yes'' then 1 when @ManagerNotification = ''No'' then 0 else NotifyMgr end,
			DelinquencyManagerEmail = case when @ManagerToNotify='''' then DelinquencyManagerEmail when @ManagerToNotify = ''^'' then null else @ManagerToNotify end
			FROM tblUser u
			WHERE
			u.Username = @username
			and
			u.OrganisationID = @orgID
			
			-- get the user id from the user name since it is the key field
			select @t = UserID from tblUser where Username = @username 
			
			--select ''debug update complete unique field username'' + @userName
		END
		
		--select @classificationName as a , @classificationOption as b
		
		if (@classificationName!='''' and @classificationOption !='''')
		begin
			-- Delete existing userclassifications
			--====================================
			
			--select @uniqueField , @uniuqeField_Username
			
			IF (@uniqueField = @uniuqeField_Username)
			BEGIN
			
				Delete
				From
					tblUserClassification
					from tblUserClassification uc
					join tblUser u on u.UserID = uc.UserID
				Where
					u.UserName = @userName
				
				--select ''debug deleted classifications username''

				-- only insert if its not delete ie is not ''^''
				if (@classificationName != ''^'' and @classificationOption != ''^'')
				begin
					--select ''debug inserting classifications username''
					-- insert the updated ones into the database
					--===================================================
					insert into tblUserClassification
					(
						UserID,
						ClassificationID
					)			
					select UserID, cl.ClassificationID 
					from 
						tblClassificationType ct
						join tblClassification cl on cl.ClassificationTypeID = ct.ClassificationTypeID and ct.OrganisationID=@orgID
						join tblUser on UserName = @userName
					where
						Value= @classificationOption
						and ct.OrganisationID = @orgid
					--select ''debug completed inserting classifications username''
				end
			END
			
			IF (@uniqueField = @uniqueField_Email)
			BEGIN
				Delete
				From
					tblUserClassification
					from tblUserClassification uc
					join tblUser u on u.UserID = uc.UserID
				Where
					u.Email = @email
				
				--select ''debug deleted classifications email ''

				-- only insert if its not delete ie is not ''^''
				if (@classificationName != ''^'' and @classificationOption != ''^'')
				begin
					--select ''debug inserting classifications email''
					-- insert the updated ones into the database
					--===================================================
					insert into tblUserClassification
					(
						UserID,
						ClassificationID
					)			
					select userid, cl.ClassificationID 
					from 
						tblClassificationType ct
						join tblClassification cl on cl.ClassificationTypeID = ct.ClassificationTypeID and ct.OrganisationID=@orgID
						join tblUser on Email = @email
					where
						Value= @classificationOption
						and ct.OrganisationID = @orgid
					--select ''debug completed inserting classifications email''
				end
			END
			
		END
	
	
		if @archival = 1 begin
			--select ''insert into tblBulkInactiveUsers''
			insert into tblBulkInactiveUsers (UserID)values(@t)	
		end		
	END
	
	-- insert
	IF @isUpdate = 0
	BEGIN
		insert into tblUser
		(
			Username,
			Password,
			Firstname,
			Lastname,
			Email,
			ExternalID,
			OrganisationID,
			UnitID,
			CreatedBy,
			Active,
			DateArchived,
			NewStarter,
			NotifyUnitAdmin,
			NotifyOrgAdmin,
			NotifyMgr,
			DelinquencyManagerEmail
			
		) values
		(
			@username,
			@password,
			@firstname,
			@lastname,
			@email,
			@externalID,
			@orgID,
			@unitID,
			@userID,
			case @archival when 1 then 0 else 1 end,
			case @archival when 1 then getutcdate() else null end,
			1,
			case when @NotifyUnitAdmin=''Yes'' then 1 else 0 end , 
			case when @NotifyOrgAdmin = ''Yes'' then 1 else 0 end,
			case when @ManagerNotification = ''Yes'' then 1 else 0 end,
			case when @ManagerToNotify='''' then null else @ManagerNotification end
		)
		select @t = UserID from tblUser where Username = @username and Email = @email

		--Insert the classification data into the tblUserCalssification table.
		Insert Into tblUserClassification
		(
			UserID,
			ClassificationID
		)
		select
			@t,
			cls.ClassificationID
		From
			tblClassificationType As c, tblClassification As cls
		where c.Name = @classificationName
			And (c.OrganisationID = @orgID)
			and cls.ClassificationTypeID = c.ClassificationTypeID
			AND cls.Value = @classificationOption
			And (cls.Active = 1)


		--insert course licencing for the imported user
		INSERT INTO tblCourseLicensingUser(CourseLicensingID, UserID)
		SELECT 		DISTINCT
			tblCourseLicensing.CourseLicensingID,
			vwUserModuleAccess.UserID

		FROM
			tblCourseLicensing
			INNER JOIN vwUserModuleAccess ON tblCourseLicensing.CourseID = vwUserModuleAccess.CourseID
			AND tblCourseLicensing.OrganisationID = vwUserModuleAccess.OrganisationID
			INNER JOIN tblUser ON vwUserModuleAccess.UserID = tblUser.UserID
			LEFT OUTER JOIN	tblCourseLicensingUser ON tblUser.UserID = tblCourseLicensingUser.UserID
			AND tblCourseLicensing.CourseLicensingID = tblCourseLicensingUser.CourseLicensingID
		WHERE
			tblCourseLicensing.DateStart <= GETUTCDATE()
			AND tblCourseLicensing.DateEnd >= GETUTCDATE()
			AND tblCourseLicensingUser.CourseLicensingID IS NULL
			AND tblUser.userid = @t


		-- Get ProfilePeriodIDs for Organisation
		create table #ProfilePeriod
		(
			ProfilePeriodID int
		)

		insert into #ProfilePeriod
		select ProfilePeriodID
		from tblProfilePeriod  pp
		join tblprofile p
		on pp.profileid = p.profileid
		where p.organisationid = @orgID


		-- insert user into profileperiodaccess against all profileperiodids
		-- for the organisation
		insert into tblUserProfilePeriodAccess
		select ProfilePeriodID, @t, 0 from #ProfilePeriod

		drop table #ProfilePeriod

		-- Get Policies for Organisation
		create table #Policy
		(
		PolicyID int
		)

		insert into #Policy
		select PolicyID
		from tblPolicy
		where OrganisationID = @orgID
		and deleted = 0

		-- insert user  policy access for all policies associated with organisation
		insert into tbluserpolicyaccess (PolicyID, UserID,Granted)
		select PolicyID, @t, 0 from #Policy

		-- insert user policy acceptance for all policies for this org
		insert into tblUserPolicyAccepted (PolicyID, UserID, Accepted)
		select PolicyID, @t, 0 from #Policy

		drop table #Policy
		
		select @archival as archive
		
	END
	
	commit
	
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_Create]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Inserts a new user.

Parameters:
@organisationID		(Mandatory)
@unitID 			(Mandatory)
@firstName 			(Mandatory)
@lastName			(Mandatory)
@userName			(Mandatory)
@email				(Mandatory)
@active			(Mandatory)
@userTypeID			(Mandatory)
@actionUserID			(Mandatory)
@password			(Mandatory)

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
User.cs.

Calls:
Nothing

Assumptions:
The majority of business logic related to password
lengths, confirmation passwords, valid emails etc.
are implemented through the UI.
Assumption is that the parameters when passed in
contain valid data.

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
7. IntegrityConstraintException
10. BusinessServiceException (General)


Author: Peter Vranich
Date Created: 20th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Jack Liu	15/09/2005		User name is only unique per organisation

**/
CREATE  Procedure [prcUser_Create]
(
@organisationID Integer = Null,
@unitID Integer = Null,
@firstName nvarchar(50) = Null,
@lastName nvarchar(50) = Null,
@userName nvarchar(100) = Null,
@email nvarchar(100) = null,
@active bit = null,
@userTypeID Integer = Null,
@actionUserID Integer = Null,
@password nvarchar(50) = Null,
@externalID nvarchar(50) = Null,
@TimeZoneID Integer = Null,
@DelinquencyManagerEmail nvarchar(100) = Null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number
Declare @UserID integer -- Holds the UserID once created

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

-- PARAMETER VALIDATION
--==============================================================

-- If user type is not SALT Administrator, check that a OrgID and UnitID has been supplied
If(@userTypeID <>1)
Begin
If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @unitID
If(@unitID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @unitID in stored procedure prcUser_Create''
Goto Finalise
End
End

--Validate Parameter @firstName
If(@firstName Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @firstName in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @lastName
If(@lastName Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @lastName in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @userName
If(@userName Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userName in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @email
If(@email Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @email in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @active
If(@active Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @userTypeID
If(@userTypeID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userTypeID in stored procedure prcUser_Create''
Goto Finalise
End

--Validate Parameter @createdByUserID
If(@actionUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @updatedByUserID in stored procedure prcUser_Create''
Goto Finalise
End

-- If a unit was specified make sure it exists
--=========================================================
If (@unitID Is Not Null)
Begin
If Not Exists(Select * From tblUnit Where UnitID = @unitID)
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''The specified unit could be found or may not be active.''
Goto Finalise
End
End

If(@userTypeID <>1)
begin
-- User name is unique per organisation
If Exists(Select * From tblUser Where Username = @userName and (organisationID=@organisationID or organisationID is null))
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = @userName
Goto Finalise
End
end
else
begin
If Exists(Select * From tblUser Where Username = @userName)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = @userName
Goto Finalise
End
end


If Exists(Select * From tblUser Where Email = @email)
Begin
Set @intErrorNumber = 41
Set @strErrorMessage = ''The email address '' + @email + '' already exists.  <BR>Please choose another email address.''
Goto Finalise
End

Insert Into tblUser
(
OrganisationID,
FirstName,
LastName,
UserName,
Password,
Email,
UnitID,
UserTypeID,
Active,
CreatedBy,
DateCreated,
ExternalID,
NewStarter,
TimeZoneID,DelinquencyManagerEmail

)
Values
(
@organisationID,
@firstName,
@lastName,
@userName,
@password,
@email,
@unitID,
@userTypeID,
@active,
@actionUserID,
GETUTCDATE(),
@externalID, -- http://bugs.salt.devbdw.com/edit_bug.aspx?id=274
1,
@TimeZoneID, @DelinquencyManagerEmail
)

update tblUser set DateArchived = getutcdate() where Active = 0 and DateArchived IS NULL AND UserID = @@Identity
update tblUser set DateArchived = null where Active = 1 and NOT(DateArchived IS NULL) AND UserID = @@Identity

-- Set the error message to successfull
Set @strErrorMessage = @@Identity
Set @UserID = @@Identity


-- Get ProfilePeriodID''s for Organisation
create table #ProfilePeriod
(
ProfilePeriodID int
)

insert into #ProfilePeriod
select ProfilePeriodID
from tblProfilePeriod  pp
join tblprofile p
on pp.profileid = p.profileid
where p.organisationid = @OrganisationID


-- insert user into profileperiodaccess against all profileperiodid''s
-- for the organisation
insert into tblUserProfilePeriodAccess
select
pp.ProfilePeriodID,
@UserID,
uppa.granted
from #ProfilePeriod pp
join tblUnitProfilePeriodAccess uppa
on uppa.ProfilePeriodID = pp.ProfilePeriodID
where uppa.UnitID = @UnitID

drop table #ProfilePeriod

-- Get Policies for Organisation
create table #Policy
(
PolicyID int,
Granted bit
)

insert into #Policy
select p.PolicyID,
case when (select distinct granted from tblUnitPolicyAccess where unitID = @unitID and policyid = p.policyid) is null then 0
else (select distinct granted from tblUnitPolicyAccess where unitID = @unitID and policyid = p.policyid) end
from tblPolicy p where
OrganisationID = @OrganisationID
and deleted = 0


-- insert user into policy for all policy''s associated with organisation
insert into tblUserPolicyAccepted (PolicyID, UserID, Accepted)
select PolicyID, @UserID, 0 from #Policy

-- insert user into policyaccess for all policies
insert into tblUserPolicyAccess (PolicyID, UserID, Granted)
select PolicyID, @UserID, Granted  from #Policy

drop table #Policy

-- Finalise the procedure
Goto Finalise


Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End




-- Wednesday, 6 July 2011 - 11:22:26 AM - Page title of Edit Daylight Saving Rule screen
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
SELECT (SELECT LangID FROM tblLang WHERE LangCode = ''en-AU''),
(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = ''/Administration/Organisation/OrgEditTimezoneDaylightRules.aspx''),
(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = ''lblPageTitle''),
''Edit Daylight Saving Rule'', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]




-- Wednesday, 6 July 2011 - 12:06:36 PM -- validators for Edit Daylight Saving Rule screen
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES(''validatorTimezone'', '''', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 6 July 2011 - 12:06:37 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
SELECT (SELECT LangID FROM tblLang WHERE LangCode = ''en-AU''),
(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = ''/Administration/Organisation/OrgEditTimezoneDaylightRules.aspx''),
(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = ''validatorTimezone''),
''You must specify the Timezone name.'', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 6 July 2011 - 12:07:01 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES(''validatorFirstYearStart'', '''', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 6 July 2011 - 12:07:01 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
SELECT (SELECT LangID FROM tblLang WHERE LangCode = ''en-AU''),
(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = ''/Administration/Organisation/OrgEditTimezoneDaylightRules.aspx''),
(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = ''validatorFirstYearStart''),
''You must specify the First Year Start.'', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 6 July 2011 - 12:07:22 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES(''validatorLastYearStart'', '''', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 6 July 2011 - 12:07:22 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
SELECT (SELECT LangID FROM tblLang WHERE LangCode = ''en-AU''),
(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = ''/Administration/Organisation/OrgEditTimezoneDaylightRules.aspx''),
(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = ''validatorLastYearStart''),
''You must specify the Last Year Start.'', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 6 July 2011 - 12:07:45 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES(''validatorOffset'', '''', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 6 July 2011 - 12:07:45 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
SELECT (SELECT LangID FROM tblLang WHERE LangCode = ''en-AU''),
(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = ''/Administration/Organisation/OrgEditTimezoneDaylightRules.aspx''),
(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = ''validatorOffset''),
''You must specify the Offset.'', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 6 July 2011 - 12:08:06 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES(''validatorTimeStart'', '''', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 6 July 2011 - 12:08:06 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
SELECT (SELECT LangID FROM tblLang WHERE LangCode = ''en-AU''),
(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = ''/Administration/Organisation/OrgEditTimezoneDaylightRules.aspx''),
(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = ''validatorTimeStart''),
''You must specify the Start Time.'', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 6 July 2011 - 12:08:33 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES(''validatorTimeEnd'', '''', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 6 July 2011 - 12:08:33 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
SELECT (SELECT LangID FROM tblLang WHERE LangCode = ''en-AU''),
(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = ''/Administration/Organisation/OrgEditTimezoneDaylightRules.aspx''),
(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = ''validatorTimeEnd''),
''You must specify the End Time.'', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]



-- Wednesday, 6 July 2011 - 12:20:59 PM
UPDATE tblLangValue set LangEntryValue = ''Last year rule ends: '', DateModified = getdate()
WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = ''en-AU'')
AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = ''/Administration/Organisation/OrgEditTimezoneDaylightRules.aspx'')
AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = ''lblLastYearStart'')



-- Wednesday, 6 July 2011 - 12:21:11 PM
UPDATE tblLangValue set LangEntryValue = ''You must specify the Last Year End.'', DateModified = getdate()
WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = ''en-AU'')
AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = ''/Administration/Organisation/OrgEditTimezoneDaylightRules.aspx'')
AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = ''validatorLastYearStart'')




-- Friday, 8 July 2011 - 9:47:02 AM
if not exists (select * from tblLangResource where LangResourceName = N''AcceptPolicy'') insert into tblLangResource (LangResourceName, ResourceType, Comment, UserCreated, UserModified, UserDeleted, DateCreated, DateModified, DateDeleted, RecordLock) values (N''AcceptPolicy'', '''', '''', 1, null, null, getdate(), null, null, newid())


-- Friday, 8 July 2011 - 9:47:02 AM
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUnit_Create]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Add a unit.
Returns:
Nothing.

Called By:
Unit Class.

Calls:
Nothing
Remarks:
--Create a unit
--Propagate all unit admininstrators from parent (with propagate flag)

Validation:
Exception:
0: Succeed
1.RecordNotFound
2.FK constraint
3.PKViolationException
4.UniqueViolationException
10.BusinessServiceException (General)


Author: Jack Liu
Date Created: 11 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE PROCEDURE [prcUnit_Create]
(
@organisationID	int,
@parentUnitID	int,
@name 	nvarchar(100),
@active	bit,
@createdByUserID int
)

AS

set nocount on

set xact_abort on
Begin Tran
--Validation
declare @strErrorMessage varchar(500)

declare @blnParentStatus bit
declare @strParentHierarchy varchar(500)
declare @intParentLevel int

declare @intUnitID int

set @strErrorMessage=''''

if (@parentUnitID<=0)
set @parentUnitID=null

--Create sub-unit
if (@parentUnitID>0)
begin
select @blnParentStatus = active,
@strParentHierarchy=  Hierarchy,
@intParentLevel = [level]
from tblUnit
where UnitID = @parentUnitID

--If parent unit is inactive, the new unit must be inactive
if (@blnParentStatus=0 and @active=1)
Begin
if exists(select UnitID from tblUnit where unitID=@parentUnitID  and active=0)
BEGIN
set @strErrorMessage = ''You cannot create an active unit whose parent unit is inactive.''
end
end
end
--Create top level unit
else
begin
set @strParentHierarchy= null
set @intParentLevel = 0

end

if (@strErrorMessage='''')
begin
--1. Create a unit
Insert into tblUnit(OrganisationID, ParentUnitID, Name, [Level], active,  createdBy, dateCreated, DateUpdated)
values	(@organisationID, @parentUnitID, @name, @intParentLevel+1,@active, @createdByUserID, getutcdate(), getutcdate())

set @intUnitID=@@identity
update tblUnit
set Hierarchy = IsNull(@strParentHierarchy + '','','''') + cast(@intUnitID as varchar)
where UnitID=@intUnitID
--2. Propagate all unit admininstrators from parent (with propagate flag)
insert into tblUnitAdministrator(UnitID, UserID, Propagate, createdBy, DateCreated)
select @intUnitID, UserID, 1 , @createdByUserID, getutcdate()
from tblUnitAdministrator
where unitID = @parentUnitID
and Propagate=1

select 0 as Error, cast(@intUnitID as varchar) as ErrorMessage
end
else
begin
select 10 as Error,  @strErrorMessage as ErrorMessage
end

commit TRAN

-- Get ProfilePeriodID''s for Organisation
create table #ProfilePeriod
(
ProfilePeriodID int
)

insert into #ProfilePeriod
select ProfilePeriodID
from tblProfilePeriod  pp
join tblprofile p
on pp.profileid = p.profileid
where p.organisationid = @OrganisationID

-- insert unit into profileperiodaccess against all profileperiodid''s
-- for the organisation
insert into tblUnitProfilePeriodAccess
select ProfilePeriodID, @intUnitID, 0 from #ProfilePeriod

drop table #ProfilePeriod

-- is a child unit
if (@parentUnitID <> 0)
begin
--	 get list of profile periods the parent unit has access to
create table #ProfilePeriodTemp
(
ProfilePeriodID int
)

insert into #ProfilePeriodTemp
select ProfilePeriodID from tblUnitProfilePeriodAccess
where UnitID = @parentUnitID
and Granted = 1

--	 set profile period access for these units
update tblUnitProfilePeriodAccess set granted = 1
where UnitID = @intUnitID
and ProfilePeriodID in (select ProfilePeriodID from #ProfilePeriodTemp)

drop table #ProfilePeriodTemp
end
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_SetUserAccessByUnit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s a users that have access to a profile

Parameters:
@organisationID Integer
@ProfileID integer
@UnitID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcProfile_SetUserAccessByUnit]
(
@ProfileID int,
@UnitID int
)
as
set nocount on

declare @ProfilePeriodID int
set @ProfilePeriodID =
(select ProfilePeriodID
from tblProfilePeriod
where ProfileID = @ProfileID and profileperiodactive=1)

update tblUserProfilePeriodAccess
set Granted = 1
where ProfilePeriodID = @ProfilePeriodID
and UserID in
(select UserID from tblUser where UnitID = @UnitID and active=1)

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReport_IndividualDetailsExtended]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'
/****** Object:  User Defined Function dbo.udfReport_IndividualDetails    Script Date: 20/04/2004 8:25:58 AM ******/



/*Summary:
Given a users ID this udfReport_IndividualDetails Gets Details for home page and individual report
Returns:
ordered table of distinct PageID''s

Called By:
dbo.prcModule_GetDetailsForHomePage
Calls:

dbo.udfGetLessonStatus
dbo.vwUserModuleAccess
Remarks:
1. This udf required that the schema of the underlying views does not change

Author:
Stephen Kennedy-Clark
Date Created: 17 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#3.0.25 Aaron Cripps	08/05/2007		Replace vwUserCourseStatus with a select statement that filters on UserID parameter passed into the function to reduce the number of rows returned (and the time taken to retrieve rows)


--------------------


**/
CREATE function [udfReport_IndividualDetailsExtended]
(
@userID  int = null,     -- ID of this User
@CurrentCultureName NVarChar(40) = ''en-AU''
)
------------------------------------------
Returns table
as
	




Return
select
vUMA.UserID		as ''UserID''
, vUMA.CourseID		as ''CourseID''
, vUMA.CourseName 	as ''CourseName''
, vUMA.ModuleID		as ''ModuleID''
, vUMA.[Name] 		as ''ModuleName''
, tL.LessonID	  	as ''LessonID''
, isNull(dbo.udfGetLessonStatus(vUMA.ModuleID,vUMA.UserID), 1) as ''LessonStatus''  -- n^2 complexety :-(
, isNull(vUQS.QuizStatusID, 1)   as ''QuizStatus''
, vUQS.QuizScore	as ''QuizScore''
, vUQS.QuizPassMark	as ''QuizPassMark''
, replace(replace( tL.ToolbookLocation,''ie4/index.html'',''qfs.html''),''default.aspx'',''QFS.html'') as ''QFSPath''
--, SUBSTRING(  tL.ToolbookLocation,0,(len(tL.ToolbookLocation)-12)  ) + ''/'' + ''QFS.html'' as ''QFSPath''
, vUMA.Sequence		as ''Sequence''


,case when vUQS.DateCreated is null and (RemEsc.DaysToCompleteCourse is null OR ((RemEsc.NotifyMgr = 0) AND (RemEsc.RemindUsers = 0))) then '' --- ''																																																	-- course just added , overdue not defined
when vUQS.DateCreated is null and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and CS.DateCreated is null then CAST(RemEsc.DaysToCompleteCourse AS VARCHAR(5)	)																-- course just added , overnight job has not caught up yet
when QuizStatusID = 1 and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and vUQS.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,vUQS.DateCreated,getUTCdate())) >= 0
							then CAST(RemEsc.DaysToCompleteCourse -   DATEDIFF(day,vUQS.DateCreated,getUTCdate()) AS VARCHAR(5))							 																											-- not started , overdue is defined, not overdue
							+ (SELECT  '' ''+LangEntryValue  FROM tblLangValue
								where LangInterfaceID = (SELECT  LangInterfaceID   FROM tblLangInterface WHERE LangInterfaceName = ''GLOBAL.MISC'')
								and LangID =(SELECT LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName)
								and LangResourceID = (SELECT LangResourceID  FROM tblLangResource where   LangResourceName = ''days'' ))  
when QuizStatusID = 1 and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1))  and vUQS.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,vUQS.DateCreated,getUTCdate())) < 0
																	then convert(varchar (11),DATEADD(day,RemEsc.DaysToCompleteCourse,dbo.udfUTCtoDaylightSavingTime(vUQS.DateCreated,o.organisationID)),113)							-- not started , overdue is defined, overdue
when QuizStatusID = 4 and vUQS.DateCreated is not null	 
																	then convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(vUQS.DateCreated,o.organisationID),113)																											-- Expired (Time Elapsed )
when QuizStatusID = 5 and vUQS.DateCreated is not null	 
																	then convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(vUQS.DateCreated,o.organisationID),113)																																																		-- Expired (New Content)
when QuizStatusID = 2 and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is  null   and o.DefaultQuizCompletionDate is not null 
																	then convert(varchar (11),dbo.udfUserUTCtoDaylightSavingTime(o.DefaultQuizCompletionDate,o.organisationID),113)																																													--Passed  organisation Default  Quiz Completion Date specified
when QuizStatusID = 2 and vUQS.DateCreated is not null  and ur.QuizCompletionDate is not null 
																	then convert(varchar (11),dbo.udfUserUTCtoDaylightSavingTime(ur.QuizCompletionDate,o.organisationID),113)																																																--Passed  unit Default  Quiz Completion Date specified
when QuizStatusID = 2 and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is null and o.DefaultQuizFrequency is not null 
																	then CAST((o.DefaultQuizFrequency - DATEDIFF(day,vUQS.DateCreated,getUTCdate())) AS varchar(6))							 																					--Passed  organisation Default  Quiz frequency specified
																	+ (SELECT  '' ''+LangEntryValue  FROM tblLangValue
																		where LangInterfaceID = (SELECT  LangInterfaceID   FROM tblLangInterface WHERE LangInterfaceName = ''GLOBAL.MISC'')
																		and LangID =(SELECT LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName)
																		and LangResourceID = (SELECT LangResourceID  FROM tblLangResource where   LangResourceName = ''days'' ))
																	
when QuizStatusID = 2 and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is not null and o.DefaultQuizCompletionDate is null 
																	then CAST((ur.QuizFrequency - DATEDIFF(day,vUQS.DateCreated,getUTCdate())) AS varchar(6))																															--Passed - unit Default  Quiz frequency specified
																   + (SELECT  '' ''+LangEntryValue  FROM tblLangValue
																	where LangInterfaceID = (SELECT  LangInterfaceID   FROM tblLangInterface WHERE LangInterfaceName = ''GLOBAL.MISC'')
																	and LangID =(SELECT LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName)
																	and LangResourceID = (SELECT LangResourceID  FROM tblLangResource where   LangResourceName = ''days'' ))
																	
when QuizStatusID = 3 and LC.DateCreated is not null and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is null and o.DefaultQuizCompletionDate is not null 
																	then convert(varchar (11),dbo.udfUserUTCtoDaylightSavingTime(o.DefaultQuizCompletionDate,o.organisationID),113)																																													--Failed - previously passed - organisation Default  Quiz Completion Date specified
when QuizStatusID = 3 and LC.DateCreated is not null and vUQS.DateCreated is not null  and ur.QuizCompletionDate is not null 
																	then convert(varchar (11),dbo.udfUserUTCtoDaylightSavingTime(ur.QuizCompletionDate,o.organisationID),113)																							--Failed - previously passed - unit Default  Quiz Completion Date specified
when QuizStatusID = 3 and LC.DateCreated is not null and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is null and o.DefaultQuizFrequency is not null 
																	then CAST((o.DefaultQuizFrequency - DATEDIFF(day,vUQS.DateCreated,getUTCdate())) AS varchar(6))																												--Failed - previously passed -organisation Default  Quiz frequency specified
																	+ (SELECT  '' ''+LangEntryValue  FROM tblLangValue
																		where LangInterfaceID = (SELECT  LangInterfaceID   FROM tblLangInterface WHERE LangInterfaceName = ''GLOBAL.MISC'')
																		and LangID =(SELECT LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName)
																		and LangResourceID = (SELECT LangResourceID  FROM tblLangResource where   LangResourceName = ''days'' ))
																	
when QuizStatusID = 3 and LC.DateCreated is not null and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is not null 
																	then CAST((ur.QuizFrequency - DATEDIFF(day,vUQS.DateCreated,getUTCdate())) AS varchar(6))																															--Failed - previously passed -unit Default  Quiz frequency specified
																	+ (SELECT  '' ''+LangEntryValue  FROM tblLangValue
																		where LangInterfaceID = (SELECT  LangInterfaceID   FROM tblLangInterface WHERE LangInterfaceName = ''GLOBAL.MISC'')
																		and LangID =(SELECT LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName)
																		and LangResourceID = (SELECT LangResourceID  FROM tblLangResource where   LangResourceName = ''days'' ))
																	
when QuizStatusID = 3 and LC.DateCreated is null and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and vUQS.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,vUQS.DateCreated,getUTCdate())) >= 0
																	then CAST(RemEsc.DaysToCompleteCourse -   DATEDIFF(day,vUQS.DateCreated,getUTCdate()) AS VARCHAR(5))																								--Failed - not previously passed , overdue is defined, not overdue
																	+ (SELECT  '' ''+LangEntryValue  FROM tblLangValue
																		where LangInterfaceID = (SELECT  LangInterfaceID   FROM tblLangInterface WHERE LangInterfaceName = ''GLOBAL.MISC'')
																		and LangID =(SELECT LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName)
																		and LangResourceID = (SELECT LangResourceID  FROM tblLangResource where   LangResourceName = ''days'' ))
																	
when QuizStatusID = 3 and LC.DateCreated is null and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and vUQS.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,vUQS.DateCreated,getUTCdate())) < 0
																	then convert(varchar (11),DATEADD(day,RemEsc.DaysToCompleteCourse,dbo.udfUTCtoDaylightSavingTime(vUQS.DateCreated,o.organisationID)),113)							--Failed - not previously passed , overdue is defined, overdue



end
as QuizExpiryDate
,case
when LC.DateCreated is null then '' ''
else convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(LC.DateCreated,o.organisationID),113) 
end as LastComp

,case when vUQS.DateCreated is null and (RemEsc.DaysToCompleteCourse is null OR ((RemEsc.NotifyMgr = 0) AND (RemEsc.RemindUsers = 0))) then ''0''																																																					-- course just added , overdue not defined
when vUQS.DateCreated is null and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and CS.DateCreated is null then ''0''																																										-- course just added , overnight job has not caught up yet
when QuizStatusID = 1 and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and vUQS.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,vUQS.DateCreated,getUTCdate())) >= 0 then ''0''		-- not started , overdue is defined, not overdue
when QuizStatusID = 1 and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and vUQS.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,vUQS.DateCreated,getUTCdate())) < 0 then ''1''		-- not started , overdue is defined, overdue
when QuizStatusID = 4 and vUQS.DateCreated is not null then ''1''																																																															-- Expired (Time Elapsed )
when QuizStatusID = 5 and vUQS.DateCreated is not null then ''1''																																																															-- Expired (New Content)					
when QuizStatusID = 2 and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is null and o.DefaultQuizCompletionDate is not null 
																	and DATEDIFF(day,o.DefaultQuizCompletionDate,getUTCdate()) < 0 then ''0''																																										--Passed - organisation Default  Quiz Completion Date specified , expired
when QuizStatusID = 2 and vUQS.DateCreated is not null  and ur.QuizCompletionDate is not null 
																	and DATEDIFF(day,ur.QuizCompletionDate,getUTCdate()) < 0 then ''0''																																												--Passed - unit Default  Quiz Completion Date specified , expired
when QuizStatusID = 2 and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is null and o.DefaultQuizCompletionDate is not null 
																	and DATEDIFF(day,o.DefaultQuizCompletionDate,getUTCdate()) >= 0 then ''1''																																									--Passed - organisation Default  Quiz Completion Date specified , not expired
when QuizStatusID = 2 and vUQS.DateCreated is not null  and ur.QuizCompletionDate is not null  
																	and DATEDIFF(day,ur.QuizCompletionDate,getUTCdate()) >= 0 then ''1''																																												--Passed - unit Default  Quiz Completion Date specified , not expired
when QuizStatusID = 2 and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is null and o.DefaultQuizFrequency is not null 
																	and DATEDIFF(day,vUQS.DateCreated,getUTCdate()) >= o.DefaultQuizFrequency then "1"																																				--Passed - organisation Default  Quiz frequency specified
when QuizStatusID = 2 and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is not null 
																	and DATEDIFF(day,vUQS.DateCreated,getUTCdate()) >= ur.QuizFrequency then "1"																																							--Passed - unit Default  Quiz frequency specified
when QuizStatusID = 2 and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is null and o.DefaultQuizFrequency is not null 
																	and DATEDIFF(day,vUQS.DateCreated,getUTCdate()) < o.DefaultQuizFrequency then "0"																																					--Passed - organisation Default  Quiz frequency specified , not expired
when QuizStatusID = 2 and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is not null 
																	and DATEDIFF(day,vUQS.DateCreated,getUTCdate()) < ur.QuizFrequency  then "0"																																							--Passed - unit Default  Quiz frequency specified , not expired


when QuizStatusID = 3 and LC.DateCreated is not null and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is null and o.DefaultQuizCompletionDate is not null 
																	and DATEDIFF(day,o.DefaultQuizCompletionDate,getUTCdate()) < 0 then ''0''																																										--failed - previously passed - organisation Default  Quiz Completion Date specified , expired
when QuizStatusID = 3 and LC.DateCreated is not null and vUQS.DateCreated is not null  and ur.QuizCompletionDate is not null 
																	and DATEDIFF(day,ur.QuizCompletionDate,getUTCdate()) < 0 then ''0''																																												--failed - previously passed - unit Default  Quiz Completion Date specified , expired
when QuizStatusID = 3 and LC.DateCreated is not null and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is null and o.DefaultQuizCompletionDate is not null 
																	and DATEDIFF(day,o.DefaultQuizCompletionDate,getUTCdate()) >= 0 then ''1''																																									--failed - previously passed - organisation Default  Quiz Completion Date specified , not expired
when QuizStatusID = 3 and LC.DateCreated is not null and vUQS.DateCreated is not null  and ur.QuizCompletionDate is not null 
																	and DATEDIFF(day,ur.QuizCompletionDate,getUTCdate()) >= 0 then ''1''																																												--failed - previously passed - unit Default  Quiz Completion Date specified , not expired
when QuizStatusID = 3 and LC.DateCreated is not null  and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is null and o.DefaultQuizFrequency is not null 
																	and DATEDIFF(day,vUQS.DateCreated,getUTCdate()) >= o.DefaultQuizFrequency then "1"																																				--failed - previously passed - organisation Default  Quiz frequency specified
when QuizStatusID = 3 and LC.DateCreated is not null and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is not null  
																	and DATEDIFF(day,vUQS.DateCreated,getUTCdate()) >= ur.QuizFrequency then "1"																																							--failed - previously passed - unit Default  Quiz frequency specified
when QuizStatusID = 3 and LC.DateCreated is not null and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is null and o.DefaultQuizFrequency is not null 
																	and DATEDIFF(day,vUQS.DateCreated,getUTCdate()) < o.DefaultQuizFrequency then "0"																																					--failed - previously passed - organisation Default  Quiz frequency specified
when QuizStatusID = 3 and LC.DateCreated is not null  and vUQS.DateCreated is not null  and ur.QuizCompletionDate is null and ur.QuizFrequency is not null
																	and DATEDIFF(day,vUQS.DateCreated,getUTCdate()) < ur.QuizFrequency 	 then "0"																																							--failed - previously passed - unit Default  Quiz frequency specified
when QuizStatusID  = 3 and LC.DateCreated is null and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and vUQS.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,vUQS.DateCreated,getUTCdate())) >= 0 then ''0''		-- not started , overdue is defined, not overdue
when QuizStatusID  = 3 and LC.DateCreated is null and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and vUQS.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,vUQS.DateCreated,getUTCdate())) < 0 then ''1''		-- not started , overdue is defined, overdue




end AS Red
from
--< get the module access details for this user >--
vwUserModuleAccess vUMA
inner join tblOrganisation o
ON o.organisationID = vUMA.OrganisationID
--< get the module access details for this user >--
left outer join tblLesson tL
on tL.ModuleID = vUMA.ModuleID
and tL.Active = 1
--< get the details of the latest quiz  >--
left outer join

(
SELECT      QuizStatus.UserID, QuizStatus.ModuleID, m.CourseID, QuizStatus.QuizStatusID, QuizStatus.QuizPassMark, QuizStatus.QuizScore,QuizStatus.DateCreated
FROM         dbo.tblUserQuizStatus AS QuizStatus INNER JOIN
dbo.tblModule AS m ON m.ModuleID = QuizStatus.ModuleID INNER JOIN
(SELECT     MAX(UserQuizStatusID) AS UserQuizStatusID,ModuleID
FROM          dbo.tblUserQuizStatus where UserID = @UserID
GROUP BY ModuleID ) AS currentStatus ON QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID and currentStatus.ModuleID = m.ModuleID
WHERE     (m.Active = 1) 
)

vUQS -- n^2 complexety :-(
on vUQS.UserID = vUMA.UserID
and vUQS.ModuleID = vUMA.ModuleID
left outer join tblUnitRule ur --Get the unit specific rules
on ur.ModuleID = vUQS.ModuleID
and ur.ModuleID = vUMA.ModuleID
and ur.UnitID=vUMA.unitID
left outer join tblReminderEscalation RemEsc on RemEsc.CourseId = vUMA.CourseID
and RemEsc.orgID = o.organisationID
left outer join (SELECT MIN(UserCourseStatusID) as UserCourseStatusID,[UserID] ,[CourseID] FROM tblUserCourseStatus LastAttempt where LastAttempt.UserID = @UserID and not exists (SELECT * FROM tblUserCourseStatus PreviousAttempt where PreviousAttempt.UserID = @UserID and PreviousAttempt.CourseStatusID = 0 and PreviousAttempt.UserCourseStatusID < LastAttempt.UserCourseStatusID and PreviousAttempt.CourseID = LastAttempt.CourseID and PreviousAttempt.UserID = LastAttempt.UserID) group by [UserID] ,[CourseID]
) CSID ON CSID.UserID = @UserID and CSID.courseID = vUMA.courseID
left outer join tblUserCourseStatus CS ON CS.UserID = @UserID and CS.courseID = vUMA.courseID and CS.UserCourseStatusID = CSID.UserCourseStatusID
left outer join
( -- Last Passed Module Quiz record
SELECT      QuizStatus.UserID, QuizStatus.ModuleID,QuizStatus.DateCreated
FROM         dbo.tblUserQuizStatus AS QuizStatus INNER JOIN
dbo.tblModule AS m ON m.ModuleID = QuizStatus.ModuleID INNER JOIN
(SELECT     MAX(UserQuizStatusID) AS UserQuizStatusID,ModuleID
FROM          dbo.tblUserQuizStatus where UserID = @UserID
and QuizStatusID = 2 -- passed
GROUP BY  ModuleID ) AS currentStatus ON QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID and currentStatus.ModuleID = m.ModuleID
WHERE     (m.Active = 1)
)
LC
on LC.UserID = vUMA.UserID
and LC.ModuleID = vUMA.ModuleID
Where
-- vUMA.CourseID = isnull(@courseID, vUMA.CourseID ) and
vUMA.UserID = isnull(@userID, vUMA.UserID)

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonSession_BeforeStartLesson]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Given a UserID and LessonID starts a Lesson and returns a LessonSessionID
Returns:
LessonSessionID guid

Called By:
Businessservices.Toolbook.BeforeLessonStart
Calls:

Remarks:
starts a lesson and returns the details of the lesson so that it can be opened by salt
Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004


Modification History
-----------------------------------------------------------
v# Author  Date   Description
#1 Peter Kneale Update to return active lesson location not first lesson location found.
? pending change added module id to where clause in select
#2 Removed unnecessary transactions

prcLessonSession_StartLesson @UserID=11, @LessonID=3
prcLessonSession_BeforeStartLesson @userID = 11, @moduleID = 3
select * from tblLessonSession
-- truncate tblLessonSession
**/

CREATE       Proc [prcLessonSession_BeforeStartLesson]
(
@userID int,  -- Users ID
@moduleID int  -- the Lesson ID
)

As
Set NoCount On
Set Xact_Abort On




------------------------------------------
-- Declerations
------------------------------------------
declare @strLessonSessionID varchar(50)
, @intLessonID int
set @strLessonSessionID = newid()
set @intLessonID = (select top 1 LessonID from tblLesson where ModuleID = @moduleID and Active=1)

------------------------------------------
-- Insert
------------------------------------------


Insert Into
tblLessonSession
(
[LessonSessionID],
[UserID],
[LessonID]
)
Values
(
@strLessonSessionID,
@userID,
@intLessonID
)


-- For Debug purposes --
insert into tblDebugLessonSession
(lessonsession_id, date_created, return_value)
values
(@strLessonSessionID, GETDATE(), null)
-- End of Debug --

------------------------------------------
-- select Session Details: SessionID, ModuleName,
------------------------------------------

Select
tM.[Name]   As ''ModuleName''
, tC.[Name]   As ''CourseName''
, @strLessonSessionID  As ''SessionID''
, tL.ToolbookLocation  As ''Location''

From
tblModule tM
Inner Join tblLesson tL
On tL.ModuleID = tM.ModuleID
Inner Join tblCourse tC
On tC.CourseID = tM.CourseID
where
tM.ModuleID = @moduleID
And
tL.Active = 1




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfReportSchedule_CalcNextRunDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [udfReportSchedule_CalcNextRunDate]
(
	@MinimumRun datetime, 
	@ReportStartDate datetime, 
	@ReportFrequencyPeriod char(1), 
	@ReportFrequency int, 
	@OrgID int	
)
RETURNS  datetime
AS
BEGIN
	-- NextRun is saved in the ORGs timezone so that when an ORG goes into daylight saving the Report is run at the correct time.
	-- ALL other times are saved in the ORGs timezone to reduce load on the GUI when the ORGs timezone is changed
	DECLARE @NextRun DateTime
	SET @NextRun = @MinimumRun
	DECLARE @NumReportPeriodsToNextRun bigint
	if (@ReportFrequency = 0)
	begin
	   set @ReportFrequency = 1
	 end
	SELECT @NumReportPeriodsToNextRun = 
	1 + CASE 
		WHEN (@ReportFrequencyPeriod=''Y'') THEN DATEDIFF(YEAR,@ReportStartDate,@MinimumRun)/ @ReportFrequency
		WHEN (@ReportFrequencyPeriod=''M'') THEN DATEDIFF(MONTH,@ReportStartDate,@MinimumRun)/ @ReportFrequency
		WHEN (@ReportFrequencyPeriod=''W'') THEN DATEDIFF(WEEK,@ReportStartDate,@MinimumRun)/ @ReportFrequency
		WHEN (@ReportFrequencyPeriod=''D'') THEN DATEDIFF(DAY,@ReportStartDate,@MinimumRun)/ @ReportFrequency
		WHEN (@ReportFrequencyPeriod=''H'') THEN DATEDIFF(HOUR,@ReportStartDate,@MinimumRun)/ @ReportFrequency
	END	



	DECLARE @NumReportPeriodsToNow bigint
	SELECT @NumReportPeriodsToNow = 
	CASE 
		WHEN (@ReportFrequencyPeriod=''Y'') THEN DATEDIFF(YEAR,			@ReportStartDate,dbo.udfUTCtoDaylightSavingTime(getUTCdate(),@OrgID))/ @ReportFrequency
		WHEN (@ReportFrequencyPeriod=''M'') THEN DATEDIFF(MONTH,	@ReportStartDate,dbo.udfUTCtoDaylightSavingTime(getUTCdate(),@OrgID))/ @ReportFrequency
		WHEN (@ReportFrequencyPeriod=''W'') THEN DATEDIFF(WEEK,		@ReportStartDate,dbo.udfUTCtoDaylightSavingTime(getUTCdate(),@OrgID))/ @ReportFrequency
		WHEN (@ReportFrequencyPeriod=''D'') THEN DATEDIFF(DAY,			@ReportStartDate,dbo.udfUTCtoDaylightSavingTime(getUTCdate(),@OrgID))/ @ReportFrequency
		WHEN (@ReportFrequencyPeriod=''H'') THEN DATEDIFF(HOUR,		@ReportStartDate,dbo.udfUTCtoDaylightSavingTime(getUTCdate(),@OrgID))/ @ReportFrequency
	END	


	IF ((@NumReportPeriodsToNextRun) < @NumReportPeriodsToNow) --We have missed an entire reporting period!!!
	AND (DATEADD(DAY,2,@NextRun) < dbo.udfUTCtoDaylightSavingTime(getUTCdate(),@OrgID))  --- it is more than 2 days that we are behind for this report!!!
	BEGIN --- need to skip some reports as the server has been down for a long time or the date has jumped by a big increment and we don''t want to thrash the servers
		SELECT @NextRun = CASE -- Just Move NextRun forward so we have at most one report to deliver
		WHEN (@ReportFrequencyPeriod=''Y'') THEN DATEADD(YEAR,@NumReportPeriodsToNow*@ReportFrequency,@ReportStartDate)
		WHEN (@ReportFrequencyPeriod=''M'') THEN DATEADD(MONTH,@NumReportPeriodsToNow*@ReportFrequency,@ReportStartDate)
		WHEN (@ReportFrequencyPeriod=''W'') THEN DATEADD(WEEK,@NumReportPeriodsToNow*@ReportFrequency,@ReportStartDate)
		WHEN (@ReportFrequencyPeriod=''D'') THEN DATEADD(DAY,@NumReportPeriodsToNow*@ReportFrequency,@ReportStartDate)
		WHEN (@ReportFrequencyPeriod=''H'') THEN DATEADD(HOUR,@NumReportPeriodsToNow*@ReportFrequency,@ReportStartDate)
		END
	END
	

	-- Return the result of the function
	RETURN  @NextRun

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZone_add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE procedure [prcTimeZone_add]
(
@WrittenName nvarchar(60),
@OffsetUTC int,
@FLB_Name nvarchar(60)
)
as
DELETE FROM tblTimeZone
WHERE WrittenName = @WrittenName
DECLARE @TimezoneID int
exec prcTimeZone_GetTimeZoneID @WrittenName, @TimezoneID out
DELETE FROM tblTimeZoneDaylightSavingRules
WHERE TimezoneID = @TimezoneID
INSERT INTO tblTimeZone
(WrittenName
,OffsetUTC
,FLB_Name
,Active)
VALUES
(@WrittenName
,@OffsetUTC
,@FLB_Name
,''true'')
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcSetPeriodicFields]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 27/10/2011
-- Description:	Sets the periodicity related fields for a periodic report
-- =============================================
CREATE PROCEDURE [prcSetPeriodicFields] 
(
	@ScheduleId int,
	@ReportTitle nvarchar(100),
	@IsPeriodic char(1),
	@ReportStartDate datetime,
	@ReportFrequency int, 
	@ReportFrequencyPeriod char(1),
	@ReportEndDate datetime,
	@NumberOfReports int,
	@ReportPeriodType int,
	@ReportFromDate datetime
)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	IF NOT EXISTS (SELECT ScheduleId FROM tblReportSchedule WHERE ScheduleId = @ScheduleId)
	BEGIN
		INSERT INTO tblReportSchedule(ReportTitle, IsPeriodic, ReportStartDate, ReportFrequency, ReportFrequencyPeriod, ReportEndDate, NumberOfReports, ReportPeriodType, ReportFromDate, NextRun)
			VALUES (@ReportTitle, @IsPeriodic, @ReportStartDate, @ReportFrequency, @ReportFrequencyPeriod, @ReportEndDate, @NumberOfReports, @ReportPeriodType, @ReportFromDate, NULL)
	END
	ELSE
	BEGIN
		 UPDATE tblReportSchedule SET ReportTitle=@ReportTitle, IsPeriodic=@IsPeriodic, ReportStartDate=@ReportStartDate, ReportFrequency=@ReportFrequency, 
			ReportFrequencyPeriod=@ReportFrequencyPeriod, ReportEndDate=@ReportEndDate, NumberOfReports=@NumberOfReports, ReportPeriodType=@ReportPeriodType, ReportFromDate=@ReportFromDate,
			NextRun=NULL WHERE ScheduleID=@ScheduleId
	END 
END' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_ReassignReportInactive]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 14/12/2011
-- Description:	Reassigns owner or cc for the periodic report
-- =============================================
CREATE PROCEDURE [prcReport_ReassignReportInactive] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int = 0, 
	@FromUser int = 0,
	@ToUser int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF EXISTS (SELECT * FROM tblReportSchedule 
		WHERE ScheduleID = @ScheduleId AND UserID = @FromUser)
	BEGIN
		UPDATE tblReportSchedule SET UserID = @ToUser
			WHERE ScheduleID = @ScheduleId
	END
	
	IF EXISTS (SELECT * FROM tblCCList
		WHERE ScheduleId = @ScheduleId AND UserID = @FromUser)
	BEGIN
		UPDATE tblCCList SET UserID = @ToUser
			WHERE ScheduleID = @ScheduleId
	END
	
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetTypeFromScheduleId]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 10/11/2011
-- Description:	Gets report type id from schedule id
-- =============================================
CREATE PROCEDURE [prcReport_GetTypeFromScheduleId] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT ReportName FROM tblReportSchedule rs
		JOIN tblReportInterface ri ON  rs.ReportID = ri.ReportID
		WHERE rs.ScheduleID = @ScheduleId
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[ReassignReportInactive]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 14/12/2011
-- Description:	Reassigns owner or cc for the periodic report
-- =============================================
CREATE PROCEDURE [ReassignReportInactive] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int = 0, 
	@FromUser int = 0,
	@ToUser int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF EXISTS (SELECT * FROM tblReportSchedule 
		WHERE ScheduleID = @ScheduleId AND UserID = @FromUser)
	BEGIN
		UPDATE tblReportSchedule SET UserID = @ToUser
			WHERE ScheduleID = @ScheduleId
	END
	
	IF EXISTS (SELECT * FROM tblCCList
		WHERE ScheduleId = @ScheduleId AND UserID = @FromUser)
	BEGIN
		UPDATE tblCCList SET UserID = @ToUser
			WHERE ScheduleID = @ScheduleId
	END
	
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetSaltOrgTomorrow]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'create FUNCTION [udfGetSaltOrgTomorrow]
(
@OrgID int

)
RETURNS DateTime
AS
BEGIN

DECLARE @ORGDate DateTime ,@OrgMidnight datetime

SELECT @OrgMidnight = CAST(convert( varchar(11), dbo.udfUTCtoDaylightSavingTime(DATEADD(d,1,GETUTCDATE()),@OrgID),113) AS DateTime)

-- return it in Daylight saving time

RETURN @ORGDate

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetSaltOrgMidnight]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [udfGetSaltOrgMidnight]
(
@OrgID int

)
RETURNS DateTime
AS
BEGIN

DECLARE @ORGDate DateTime ,@OrgMidnight datetime

SELECT @OrgMidnight = CAST(convert( varchar(11), dbo.udfUTCtoDaylightSavingTime(GETUTCDATE(),@OrgID),113) AS DateTime)

SELECT @ORGDate = dbo.udfDaylightSavingTimeToUTC(@OrgMidnight,@OrgID)

RETURN @ORGDate

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetNextUrgentReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcReport_GetNextUrgentReport]

AS
BEGIN
-- Only returns NOW schedules - Send these first to give a greater sense of response by the application
-- NEXTRUN is always saved in UTC to reduce conversion times
-- NextRun is never null
SET NOCOUNT ON

	DECLARE @ScheduleID int,
	@RunDate datetime, 
	@ReportStartDate datetime, 
	@ReportFrequencyPeriod char(1), 
	@ReportFrequency int, 
	@OrgID int	,
	@ReportFromDate datetime,
	@NumberDelivered int,
	@NumberOfReports int,
	@ReportEndDate datetime,
	@ReportPeriodType int,
	@ReportID int,
	@DateFrom DateTime
	
	UPDATE tblReportSchedule -- remove schedules for inactive users
	SET NumberDelivered = 0,
	TerminatedNormally = 1,
	LastRun = getUTCdate(),
	NextRun = null
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID
		WHERE (TerminatedNormally = 0)
		AND (IsPeriodic = ''N'')
		AND (tblUser.Active = 0)
	)

SELECT @ScheduleID = ScheduleID
FROM tblReportSchedule
INNER JOIN tblReportInterface ON tblReportSchedule.ReportID = tblReportInterface.ReportID
INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID
INNER JOIN tblOrganisation ON tblOrganisation.OrganisationID = tblReportSchedule.ParamOrganisationID
WHERE  CourseStatusLastUpdated > dbo.udfGetSaltOrgMidnight(tblUser.OrganisationID)
AND (TerminatedNormally = 0)
AND (IsPeriodic = ''N'')
AND (tblUser.Active = 1)

DECLARE @OnBehalfOf nvarchar(255)
DECLARE @ReplyTo nvarchar(255)
DECLARE @FromDate DateTime = CAST(''1 Jan 2002'' as datetime)

	IF (@ScheduleID IS NOT NULL)
	BEGIN
		DECLARE @NextRun datetime
		SELECT @NextRun = NextRun,
		@ReportStartDate = ReportStartDate,
		@ReportFrequencyPeriod = ReportFrequencyPeriod,
		@ReportFrequency = ReportFrequency,
		@OrgID = ParamOrganisationID,
		@ReportFromDate = ReportFromDate,
		@NumberDelivered = NumberDelivered, 
		@NumberOfReports = NumberOfReports, 
		@ReportEndDate = ReportEndDate ,
		@ReportPeriodType = coalesce(ReportPeriodType ,3),
		@ReportID = ReportID,
		@DateFrom = ParamDateFrom
		FROM tblReportSchedule WHERE ScheduleID = @ScheduleID
	
	-- update the Report Schedule
	UPDATE tblReportSchedule 
	SET NumberDelivered = NumberDelivered + 1,
	TerminatedNormally = 1,
	LastRun = getUTCdate(),
	NextRun = cast(''1 jan 2050'' as datetime),
	LastUpdatedBy=0,
	Lastupdated=getUTCdate()
	WHERE ScheduleID = @ScheduleID



	-- we know the ''to'' date - just need to read the ''from'' date
    SET @FromDate = @ReportStartDate



END -- IF ScheduleID is not null


-- return the results
SET NOCOUNT OFF
SELECT TOP (1) [ScheduleID]
,RS.UserID
,RS.ReportID
,[LastRun]
,[ReportStartDate]
,[ReportFrequency]
,[ReportFrequencyPeriod]
,[DocumentType]
,[ParamOrganisationID]
,[ParamCompleted]
,[ParamStatus]
,[ParamFailCount]
,[ParamCourseIDs]
,[ParamHistoricCourseIDs]
,[ParamAllUnits]
,[ParamTimeExpired]
,[ParamTimeExpiredPeriod]
,[ParamQuizStatus]
,[ParamGroupBy]
,[ParamGroupingOption]
,[ParamFirstName]
,[ParamLastName]
,[ParamUserName]
,[ParamEmail]
,[ParamIncludeInactive]
,[ParamSubject]
,[ParamBody]
,[ParamProfileID]
,[ParamOnlyUsersWithShortfall]
,[ParamEffectiveDate]
,[ParamSortBy]
,[ParamClassificationID]
,ParamLangInterfaceName
, case
when tblReportinterface.ReportID = 26 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.2''))
when tblReportinterface.ReportID = 27 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.2''))
when tblReportinterface.ReportID = 3 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.1''))
when tblReportinterface.ReportID = 6 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.1''))
else coalesce(tblLangValue.LangEntryValue,''Missing Localisation'')
end as ReportName
,tblReportInterface.RDLname
,tblUser.FirstName
,tblUser.LastName
,tblUser.Email
,ParamUnitIDs
,paramOrganisationID
,RS.ParamLangCode
,ParamLangCode
,ParamLicensingPeriod
,RS.ReportEndDate
,RS.ReportTitle
,RS.NumberOfReports
,RS.ReportFromDate
,(dbo.udfGetCCList(RS.ScheduleID)) as CCList
,RS.ReportPeriodType
,dbo.udfGetEmailOnBehalfOf (ParamOrganisationID) as OnBehalfOf
,RS.NextRun
,RS.ReportFromDate
,@FromDate as FromDate
,dbo.udfGetEmailReplyTo (ParamOrganisationID,tblUser.FirstName + '' '' + tblUser.LastName + '' <'' + tblUser.Email + ''>'') as ReplyTo
,CASE when exists (SELECT Value FROM  tblAppConfig WHERE (Name = ''SEND_AUTO_EMAILS'') AND (UPPER(Value) = ''YES'')) then O.StopEmails ELSE 1 END as StopEmails
,CAST(convert( varchar(11), dbo.udfUTCtoDaylightSavingTime(DATEADD(d,1,GETUTCDATE()),@OrgID),113) AS DateTime) as Tomorrow
,CASE when tblUser.usertypeid=4 then dbo.udfUser_GetAdministratorsEmailAddress (tblUser.UserID) else tblUser.Email end as SenderEmail
FROM
tblReportinterface
inner join tblReportSchedule RS  on tblReportinterface.ReportID = RS.ReportID
INNER JOIN tblOrganisation O on O.OrganisationID = RS.ParamOrganisationID
INNER JOIN tblUser ON RS.UserID = tblUser.UserID
LEFT OUTER JOIN tblLang ON tblLang.LangCode = RS.ParamLangCode
LEFT OUTER JOIN tblLangInterface ON  paramlanginterfacename = tblLangInterface.langinterfacename
LEFT OUTER JOIN tblLangResource ON  tblLangResource.langresourcename = ''rptreporttitle''
LEFT OUTER JOIN tblLangValue ON tblLang.LangID = tblLangValue.LangID   AND (tblLangValue.Active = 1) and tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID and tblLangValue.LangResourceID = tblLangResource.LangResourceID

WHERE ScheduleID = @ScheduleID


	-- remove spent "NOW" Schedule to reduce size of table
	DELETE FROM tblReportSchedule 
	WHERE ScheduleID = @ScheduleID
	
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetNextReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcReport_GetNextReport]

AS
BEGIN
	-- NextRun is saved in the ORGs timezone so that when an ORG goes into daylight saving the Report is run at the correct time.
	-- ALL other times are saved in the ORGs timezone to reduce load on the GUI when the ORGs timezone is changed
	
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET TerminatedNormally = 1
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		WHERE (TerminatedNormally = 0)
		AND (IsPeriodic = ''M'')
		AND ReportEndDate IS NULL -- flag to indicate that NumberOfReports is being used
		AND NumberOfReports IS NOT NULL
		AND NumberDelivered >= NumberOfReports 
	)
	
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET TerminatedNormally = 0
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		WHERE (TerminatedNormally = 1)
		AND (IsPeriodic = ''M'')
		AND ReportEndDate IS NULL -- flag to indicate that NumberOfReports is being used
		AND NumberOfReports IS NOT NULL
		AND NumberDelivered < NumberOfReports 
	)
	


	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET 
	LastRun = ''1 Jan 2002'',
	NextRun = dbo.udfReportSchedule_CalcNextRunDate 
	(
		ReportStartDate, 
		ReportStartDate , 
		ReportFrequencyPeriod , 
		ReportFrequency , 
		ParamOrganisationID 	
	)
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID
		WHERE (TerminatedNormally = 0)
		AND (IsPeriodic != ''N'')
		AND (tblUser.Active = 1)
		AND LASTRUN IS NULL
		AND NEXTRUN IS NULL
	)

	
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET LastRun = ''1 Jan 2001''
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID
		WHERE (TerminatedNormally = 0)
		AND (IsPeriodic != ''N'')
		AND (tblUser.Active = 1)
		AND LASTRUN IS NULL
	)
	
		
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET NextRun = dbo.udfReportSchedule_CalcNextRunDate 
	(
		LastRun , 
		ReportStartDate , 
		ReportFrequencyPeriod , 
		ReportFrequency , 
		ParamOrganisationID 	
	)
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID
		--WHERE (TerminatedNormally = 0)
		AND (IsPeriodic != ''N'')
		AND (tblUser.Active = 1)
		AND NEXTRUN IS NULL
	)
	
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET TerminatedNormally = 1
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		WHERE (TerminatedNormally = 0)
		AND (IsPeriodic = ''M'')
		AND ReportEndDate IS NOT NULL
		AND NextRun > ReportEndDate
		AND NumberOfReports IS NULL
	)
	
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET TerminatedNormally = 0
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		WHERE (TerminatedNormally = 1)
		AND (IsPeriodic = ''M'')
		AND ReportEndDate IS NOT NULL
		AND NextRun <= ReportEndDate
		AND NumberOfReports IS NULL
	)	
		
	UPDATE tblReportSchedule -- fix schedules that have been modified by GUI
	SET TerminatedNormally = 0
	WHERE ScheduleID in 
	(
		SELECT ScheduleID 
		FROM tblReportSchedule
		WHERE (TerminatedNormally = 1)
		AND (IsPeriodic = ''M'')
		AND ReportEndDate IS NULL 
		AND NumberOfReports IS  NULL
	)
	
	
	-- NextRun is never null
	SET NOCOUNT ON
	DECLARE @ScheduleID int,
	@RunDate datetime, 
	@ReportStartDate datetime, 
	@ReportFrequencyPeriod char(1), 
	@ReportFrequency int, 
	@OrgID int	,
	@ReportFromDate datetime,
	@NumberDelivered int,
	@NumberOfReports int,
	@ReportEndDate datetime,
	@ReportPeriodType int,
	@ReportID int

	SELECT @ScheduleID =  ScheduleID
	FROM tblReportSchedule
	INNER JOIN tblReportInterface ON tblReportSchedule.ReportID = tblReportInterface.ReportID
	INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID AND tblUser.Active = 1
	INNER JOIN tblOrganisation ON tblOrganisation.OrganisationID = tblReportSchedule.ParamOrganisationID
	WHERE  CourseStatusLastUpdated > dbo.udfGetSaltOrgMidnight(tblUser.OrganisationID)
	AND (NextRun <= dbo.udfUTCtoDaylightSavingTime(GETUTCDATE(),tblReportSchedule.ParamOrganisationID))
	AND (TerminatedNormally = 0)
	AND (IsPeriodic = ''M'')


	DECLARE @OnBehalfOf nvarchar(255)
	DECLARE @ReplyTo nvarchar(255)
	DECLARE @FromDate DateTime = CAST(''1 Jan 2002'' as datetime)
	DECLARE @DateFrom DateTime

	IF (@ScheduleID IS NOT NULL)
	BEGIN
		DECLARE @NextRun datetime
		SELECT @NextRun = NextRun,
		@ReportStartDate = ReportStartDate,
		@ReportFrequencyPeriod = ReportFrequencyPeriod,
		@ReportFrequency = ReportFrequency,
		@OrgID = ParamOrganisationID,
		@ReportFromDate = ReportFromDate,
		@NumberDelivered = NumberDelivered, 
		@NumberOfReports = NumberOfReports, 
		@ReportEndDate = ReportEndDate ,
		@ReportPeriodType = coalesce(ReportPeriodType ,3),
		@ReportID = ReportID,
		@DateFrom = ParamDateFrom
		FROM tblReportSchedule WHERE ScheduleID = @ScheduleID

		SET @RunDate = dbo.udfReportSchedule_CalcNextRunDate -- may have missed a couple of reports if the server was down so just verify that NEXTRUN makes sense
		(
			@NextRun,  
			@ReportStartDate , 
			@ReportFrequencyPeriod,  
			@ReportFrequency, 
			@OrgID
		)

		SET @NextRun = dbo.udfReportSchedule_IncrementNextRunDate -- get the new NexrRun value
		(
			@RunDate , 
			@ReportStartDate , 
			@ReportFrequencyPeriod , 
			@ReportFrequency , 
			@OrgID 	
		)
		-- now look for termination conditions
		DECLARE @TerminatedNormally bit = 0

		IF  @ReportEndDate IS NOT NULL AND (@ReportEndDate < @NextRun) BEGIN SET @TerminatedNormally = 1  END
		IF @NumberOfReports IS NOT NULL AND (@NumberOfReports < (@NumberDelivered + 1)) BEGIN SET @TerminatedNormally = 1  END
		
		-- update the Report Schedule
		UPDATE tblReportSchedule -- Move NextRun,Lastrun forward by one period
		SET NumberDelivered = NumberDelivered + 1,
		TerminatedNormally = @TerminatedNormally,
		LastRun = @RunDate,
		NextRun = @NextRun,
		LastUpdatedBy=0,
		Lastupdated=getUTCdate()
		WHERE ScheduleID = @ScheduleID

		-- get the Report period (we know the ''to'' date - just need to calculate the ''from'' date)

		IF ((@ReportPeriodType <> 2) AND (@ReportPeriodType <> 3))
		BEGIN
			SET @FromDate = CAST(''1 Jan 2002'' as datetime)
		END
		
		IF (@ReportPeriodType = 3) 
		BEGIN
			SELECT @FromDate = @ReportFromDate 
		END
		
		IF (@ReportPeriodType = 2) 
		BEGIN
			SET @FromDate =
			CASE 
				WHEN (@ReportFrequencyPeriod=''Y'') THEN DATEADD(YEAR,-@ReportFrequency,@RunDate)
				WHEN (@ReportFrequencyPeriod=''M'') THEN DATEADD(MONTH,-@ReportFrequency,@RunDate)
				WHEN (@ReportFrequencyPeriod=''W'') THEN DATEADD(WEEK,-@ReportFrequency,@RunDate)
				WHEN (@ReportFrequencyPeriod=''D'') THEN DATEADD(DAY,-@ReportFrequency,@RunDate)
				WHEN (@ReportFrequencyPeriod=''H'') THEN DATEADD(HOUR,-@ReportFrequency,@RunDate)
			END	
	    END
		IF (@ReportID=10) OR (@ReportID=22) OR (@ReportID=23) OR (@ReportID=24)
		BEGIN
			SET @FromDate = @DateFrom
		END
		
	SELECT @OnBehalfOf = dbo.udfGetEmailOnBehalfOf (@OrgID)	
	END -- IF ScheduleID is not null


	-- return the results
	SET NOCOUNT OFF
	SELECT TOP (1) [ScheduleID]
	,RS.UserID
	,RS.ReportID
	,[LastRun]
	,[ReportStartDate]
	,[ReportFrequency]
	,[ReportFrequencyPeriod]
	,[DocumentType]
	,[ParamOrganisationID]
	,[ParamCompleted]
	,[ParamStatus]
	,[ParamFailCount]
	,[ParamCourseIDs]
	,[ParamHistoricCourseIDs]
	,[ParamAllUnits]
	,[ParamTimeExpired]
	,[ParamTimeExpiredPeriod]
	,[ParamQuizStatus]
	,[ParamGroupBy]
	,[ParamGroupingOption]
	,[ParamFirstName]
	,[ParamLastName]
	,[ParamUserName]
	,[ParamEmail]
	,[ParamIncludeInactive]
	,[ParamSubject]
	,[ParamBody]
	,[ParamProfileID]
	,[ParamOnlyUsersWithShortfall]
	,[ParamEffectiveDate]
	,[ParamSortBy]
	,[ParamClassificationID]
	,ParamLangInterfaceName
	, case
	when tblReportinterface.ReportID = 26 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.2''))
	when tblReportinterface.ReportID = 27 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.2''))
	when tblReportinterface.ReportID = 3 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.1''))
	when tblReportinterface.ReportID = 6 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.1''))
	else coalesce(tblLangValue.LangEntryValue,''Missing Localisation'')
	end as ReportName
	,tblReportInterface.RDLname
	,tblUser.FirstName
	,tblUser.LastName
	,tblUser.Email
	,ParamUnitIDs
	,paramOrganisationID
	,RS.ParamLangCode
	,ParamLangCode
	,ParamLicensingPeriod
	,RS.ReportEndDate
	,RS.ReportTitle
	,RS.NumberOfReports
	,RS.ReportFromDate
,(dbo.udfGetCCList(RS.ScheduleID)) as CCList
	,RS.ReportPeriodType
	,dbo.udfGetEmailOnBehalfOf (ParamOrganisationID) as OnBehalfOf
	,RS.NextRun
	,@FromDate as FromDate
	,dbo.udfGetEmailReplyTo (ParamOrganisationID,tblUser.FirstName + '' '' + tblUser.LastName + '' <'' + tblUser.Email + ''>'') as ReplyTo
	,CASE when exists (SELECT Value FROM  tblAppConfig WHERE (Name = ''SEND_AUTO_EMAILS'') AND (UPPER(Value) = ''YES'')) then O.StopEmails ELSE 1 END as StopEmails
	,CAST(convert( varchar(11), dbo.udfUTCtoDaylightSavingTime(DATEADD(d,1,GETUTCDATE()),@OrgID),113) AS DateTime) as Tomorrow
,CASE when tblUser.usertypeid=4 then dbo.udfUser_GetAdministratorsEmailAddress (tblUser.UserID) else tblUser.Email end as SenderEmail
	FROM
	tblReportinterface
	inner join tblReportSchedule RS  on tblReportinterface.ReportID = RS.ReportID
	INNER JOIN tblOrganisation O on O.OrganisationID = RS.ParamOrganisationID
	INNER JOIN tblUser ON RS.UserID = tblUser.UserID
	LEFT OUTER JOIN tblLang ON tblLang.LangCode = RS.ParamLangCode
	LEFT OUTER JOIN tblLangInterface ON  paramlanginterfacename = tblLangInterface.langinterfacename
	LEFT OUTER JOIN tblLangResource ON  tblLangResource.langresourcename = ''rptreporttitle''
	LEFT OUTER JOIN tblLangValue ON tblLang.LangID = tblLangValue.LangID   AND (tblLangValue.Active = 1) and tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID and tblLangValue.LangResourceID = tblLangResource.LangResourceID

	WHERE ScheduleID = @ScheduleID


END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_GetNextOnceOnlyReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcReport_GetNextOnceOnlyReport]

AS
BEGIN
	-- NextRun is saved in the ORGs timezone so that when an ORG goes into daylight saving the Report is run at the correct time.
	-- ALL other times are saved in the ORGs timezone to reduce load on the GUI when the ORGs timezone is changed
	-- NextRun is never null
	SET NOCOUNT ON
	DECLARE @ScheduleID int,
	@RunDate datetime, 
	@ReportStartDate datetime, 
	@ReportFrequencyPeriod char(1), 
	@ReportFrequency int, 
	@OrgID int	,
	@ReportFromDate datetime,
	@ReportPeriodType int,
	@NumberDelivered int,
	@ReportID int,
	@DateFrom DateTime
	SELECT @ScheduleID = ScheduleID
	FROM tblReportSchedule
	INNER JOIN tblReportInterface ON tblReportSchedule.ReportID = tblReportInterface.ReportID
	INNER JOIN tblUser ON tblReportSchedule.UserID = tblUser.UserID  AND tblUser.Active = 1
	INNER JOIN tblOrganisation ON tblOrganisation.OrganisationID = tblReportSchedule.ParamOrganisationID
	WHERE  CourseStatusLastUpdated > dbo.udfGetSaltOrgMidnight(tblUser.OrganisationID)
	AND (NextRun <= dbo.udfUTCtoDaylightSavingTime(GETUTCDATE(),tblReportSchedule.ParamOrganisationID))
	AND (TerminatedNormally = 0)
	AND (IsPeriodic = ''O'')


	DECLARE @OnBehalfOf nvarchar(255)
	DECLARE @ReplyTo nvarchar(255)
	DECLARE @FromDate DateTime = CAST(''1 Jan 2002'' as datetime)

	IF (@ScheduleID IS NOT NULL)
	BEGIN
		DECLARE @NextRun datetime
		SELECT @NextRun = NextRun,
		@ReportStartDate = ReportStartDate,
		@ReportFrequencyPeriod = ReportFrequencyPeriod,
		@ReportFrequency = ReportFrequency,
		@OrgID = ParamOrganisationID,
		@ReportFromDate = ReportFromDate,
		@NumberDelivered = NumberDelivered,
		@ReportPeriodType = coalesce(ReportPeriodType ,3),
		@ReportID = ReportID,
		@DateFrom = ParamDateFrom
		FROM tblReportSchedule WHERE ScheduleID = @ScheduleID

		SET @RunDate = @NextRun


		SET @NextRun = dbo.udfReportSchedule_IncrementNextRunDate -- get the new NexrRun value
		(
			@RunDate , 
			@ReportStartDate , 
			@ReportFrequencyPeriod , 
			@ReportFrequency , 
			@OrgID 	
		)


		
		-- update the Report Schedule
		UPDATE tblReportSchedule -- Move NextRun,Lastrun forward by one period
		SET NumberDelivered = NumberDelivered + 1,
		TerminatedNormally = 1,
		NextRun = cast(''1 jan 2050'' as datetime),
		LastRun = @RunDate,
		LastUpdatedBy=0,
		Lastupdated=getUTCdate()
		
		WHERE ScheduleID = @ScheduleID

		-- get the Report period (we know the ''to'' date - just need to calculate the ''from'' date)
		IF ((@ReportPeriodType <> 2) AND (@ReportPeriodType <> 3))
		BEGIN
			SET @FromDate = CAST(''1 Jan 2002'' as datetime)
		END
		
		IF (@ReportPeriodType = 3) 
		BEGIN
			SET @FromDate = @ReportFromDate 
		END
		
		IF (@ReportPeriodType = 2) 
		BEGIN
			SET @FromDate =
		CASE 
			WHEN (@ReportFrequencyPeriod=''Y'') THEN DATEADD(YEAR,-@ReportFrequency,@RunDate)
			WHEN (@ReportFrequencyPeriod=''M'') THEN DATEADD(MONTH,-@ReportFrequency,@RunDate)
			WHEN (@ReportFrequencyPeriod=''W'') THEN DATEADD(WEEK,-@ReportFrequency,@RunDate)
			WHEN (@ReportFrequencyPeriod=''D'') THEN DATEADD(DAY,-@ReportFrequency,@RunDate)
			WHEN (@ReportFrequencyPeriod=''H'') THEN DATEADD(HOUR,-@ReportFrequency,@RunDate)
		END	

		END
		
		IF (@ReportID=10) OR (@ReportID=22) OR (@ReportID=23) OR (@ReportID=24)
		BEGIN
			SET @FromDate = @DateFrom
		END
				
		SELECT @OnBehalfOf = dbo.udfGetEmailOnBehalfOf (0)	
	END -- IF ScheduleID is not null


	-- return the results
	SET NOCOUNT OFF
	SELECT TOP (1) [ScheduleID]
	,RS.UserID
	,RS.ReportID
	,[LastRun]
	,[ReportStartDate]
	,[ReportFrequency]
	,[ReportFrequencyPeriod]
	,[DocumentType]
	,[ParamOrganisationID]
	,[ParamCompleted]
	,[ParamStatus]
	,[ParamFailCount]
	,[ParamCourseIDs]
	,[ParamHistoricCourseIDs]
	,[ParamAllUnits]
	,[ParamTimeExpired]
	,[ParamTimeExpiredPeriod]
	,[ParamQuizStatus]
	,[ParamGroupBy]
	,[ParamGroupingOption]
	,[ParamFirstName]
	,[ParamLastName]
	,[ParamUserName]
	,[ParamEmail]
	,[ParamIncludeInactive]
	,[ParamSubject]
	,[ParamBody]
	,[ParamProfileID]
	,[ParamOnlyUsersWithShortfall]
	,[ParamEffectiveDate]
	,[ParamSortBy]
	,[ParamClassificationID]
	,ParamLangInterfaceName
	, case
	when tblReportinterface.ReportID = 26 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.2''))
	when tblReportinterface.ReportID = 27 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.2''))
	when tblReportinterface.ReportID = 3 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.1''))
	when tblReportinterface.ReportID = 6 then (select coalesce(LangEntryValue,''Missing Localisation'') from tblLangValue where tblLangValue.LangID = (SELECT LangID FROM tblLang where tblLang.LangCode = RS.ParamLangCode) and LangInterfaceID = (select LangInterfaceID from tblLangInterface where LangInterfaceName = ''/Reporting/Admin/AdministrationReport.aspx'') and LangResourceID = (select LangResourceID from tblLangResource where LangResourceName = ''lblPageTitle.1''))
	else coalesce(tblLangValue.LangEntryValue,''Missing Localisation'')
	end as ReportName
	,tblReportInterface.RDLname
	,tblUser.FirstName
	,tblUser.LastName
	,tblUser.Email
	,ParamUnitIDs
	,paramOrganisationID
	,RS.ParamLangCode
	,ParamLangCode
	,ParamLicensingPeriod
	,RS.ReportEndDate
	,RS.ReportTitle
	,RS.NumberOfReports
	,RS.ReportFromDate
,(dbo.udfGetCCList(RS.ScheduleID)) as CCList
	,RS.ReportPeriodType
	,dbo.udfGetEmailOnBehalfOf (ParamOrganisationID) as OnBehalfOf
	,RS.NextRun
	,RS.ReportFromDate
	,@FromDate as FromDate
	,dbo.udfGetEmailReplyTo (ParamOrganisationID,tblUser.FirstName + '' '' + tblUser.LastName + '' <'' + tblUser.Email + ''>'') as ReplyTo
	,CASE when exists (SELECT Value FROM  tblAppConfig WHERE (Name = ''SEND_AUTO_EMAILS'') AND (UPPER(Value) = ''YES'')) then O.StopEmails ELSE 1 END as StopEmails
	,CAST(convert( varchar(11), dbo.udfUTCtoDaylightSavingTime(DATEADD(d,1,GETUTCDATE()),@OrgID),113) AS DateTime) as Tomorrow
,CASE when tblUser.usertypeid=4 then dbo.udfUser_GetAdministratorsEmailAddress (tblUser.UserID) else tblUser.Email end as SenderEmail

	FROM
	tblReportinterface
	inner join tblReportSchedule RS  on tblReportinterface.ReportID = RS.ReportID
	INNER JOIN tblOrganisation O on O.OrganisationID = RS.ParamOrganisationID
	INNER JOIN tblUser ON RS.UserID = tblUser.UserID
	LEFT OUTER JOIN tblLang ON tblLang.LangCode = RS.ParamLangCode
	LEFT OUTER JOIN tblLangInterface ON  paramlanginterfacename = tblLangInterface.langinterfacename
	LEFT OUTER JOIN tblLangResource ON  tblLangResource.langresourcename = ''rptreporttitle''
	LEFT OUTER JOIN tblLangValue ON tblLang.LangID = tblLangValue.LangID   AND (tblLangValue.Active = 1) and tblLangValue.LangInterfaceID = tblLangInterface.LangInterfaceID and tblLangValue.LangResourceID = tblLangResource.LangResourceID

	WHERE ScheduleID = @ScheduleID


END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_ManagersToNotifyList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcAutomatedEmails_ManagersToNotifyList]
(
@OrganisationID int
)

AS

BEGIN
--                    S E L E C T    T H E    R E S U L T S

--declare @OrganisationID int
--set @OrganisationID = 68

create table #UsersToNotify
(userid int not null
,DelinquentCourse nvarchar(max) null)

insert into #UsersToNotify
SELECT distinct UsersToNotify.userid , UsersToNotify.DelinquentCourse FROM
(

-- delinquent users
SELECT DISTINCT CD.UserCourseStatusID as UserCourseStatusID, CS.userID , u.username, C.Name     as DelinquentCourse
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblUserCourseDetails UCD ON (UCD.UserID = u.UserID AND UCD.CourseID = C.CourseID)
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID)  AND (RemEsc.IndividualNotification=0)  AND (RemEsc.NotifyMgr = 1) AND (RemEsc.DaysToCompleteCourse>0)
INNER JOIN (select OrgID,NotifyMgrDays, max(lastnotified) as lastnotified  from tblReminderEscalation where tblReminderEscalation.NotifyMgr = 1   group by OrgID,NotifyMgrDays  ) LastNotified 
ON LastNotified.OrgID = o.OrganisationID  and LastNotified.NotifyMgrDays = RemEsc.NotifyMgrDays
where (coursestatusid = 1) 
AND (o.OrganisationID = @OrganisationID) 
AND (GETUTCDATE() > DATEADD(d,RemEsc.DaysToCompleteCourse+1, CS.DateCreated)) -- Is Overdue
AND ((UCD.LastDelNoteToMgr = 0) OR (RemEsc.IsCumulative=1)) and  (U.active = 1)  -- and manager not notified OR CUMULATIVE notifications
AND (GETUTCDATE() > DATEADD(d,RemEsc.NotifyMgrDays,LastNotified.LastNotified )) -- Notify manager every N days
AND (GETUTCDATE() < DATEADD(m,6,DATEADD(d,RemEsc.DaysToCompleteCourse, CS.DateCreated))) -- Business Rule = If Course is more than 6 months overdue stop notifying managers

)  UsersToNotify

create index inx_1 on #UsersToNotify(userid)

create table #UsersToNotifyList
(userid int not null
,DelinquentCourse nvarchar(max) null)

create index inx_2 on #UsersToNotifyList(userid)


declare @userid int
,@DelinquentCourse nvarchar(max)
while exists (select 1 from #UsersToNotify)
begin
set rowcount 1
select @userid = userid
,@DelinquentCourse = DelinquentCourse

from #UsersToNotify
if exists (select * from #UsersToNotifyList where userid = @userid)
begin
update #UsersToNotifyList set
DelinquentCourse = rtrim(#UsersToNotifyList.DelinquentCourse + +  ''<BR>&nbsp;&nbsp;'' + @DelinquentCourse )
from #UsersToNotifyList
where #UsersToNotifyList.userid = @userid
end
else
begin
insert #UsersToNotifyList(userid,DelinquentCourse)
values (@userid,@DelinquentCourse)

end
delete #UsersToNotify where
@userid = userid
and @DelinquentCourse = DelinquentCourse
set rowcount 0
end


create table #ManagersToNotify
(ManagerName nvarchar(200) null
,ManagerEmail nvarchar(200) null
,DelinquentCourse nvarchar(max) null
,FirstName nvarchar(200) null
,LastName nvarchar(200) null
,username nvarchar(200) null)

create index inx_3 on #ManagersToNotify(ManagerName)

INSERT into #ManagersToNotify( ManagerName, ManagerEmail ,DelinquentCourse,FirstName,LastName,username) 

select  UsersManagers.username as managername,  UsersManagers.Email ,''<BR><B>''+U.Firstname+'' ''+U.Lastname+''</B><BR>&nbsp;&nbsp;''+DelinquentCourse,UsersManagers.FirstName as FirstName,UsersManagers.LastName, U.username
FROM #UsersToNotifyList UL
inner join tblUser U on U.userid=UL.userid


INNER JOIN
	(
		SELECT tblUnitAdmins.username, U.UserID, tblUnitAdmins.Email ,tblUnitAdmins.FirstName, tblUnitAdmins.LastName
		FROM  tblUser U  
					INNER JOIN  tblUnitAdministrator ON U.UnitID = tblUnitAdministrator.UnitID
					INNER JOIN   dbo.tblUser AS tblUnitAdmins ON dbo.tblUnitAdministrator.UserID = tblUnitAdmins.UserID AND tblUnitAdmins.UserTypeID = 3
					WHERE  U.NotifyUnitAdmin = 1
		UNION ALL 
		SELECT tblOrgAdmins.username, U.UserID, tblOrgAdmins.Email ,tblOrgAdmins.FirstName, tblOrgAdmins.LastName
		FROM  tblUser U  
					INNER JOIN  dbo.tblUser AS tblOrgAdmins ON U.OrganisationID = tblOrgAdmins.OrganisationID
					WHERE  U.NotifyOrgAdmin = 1 AND tblOrgAdmins.UserTypeID = 2
		UNION ALL
		SELECT ''DelinquencyManager'' as username, tblUserDelinquencyManager.UserID, tblUserDelinquencyManager.DelinquencyManagerEmail,'' '' AS FirstName, '' '' AS LastName
		FROM  dbo.tblUser AS tblUserDelinquencyManager WHERE  NotifyMgr = 1 and tblUserDelinquencyManager.Email IS NOT NULL AND (tblUserDelinquencyManager.Email != '''')
	) UsersManagers ON UsersManagers.UserID = UL.UserID



create table #ManagersToNotifyList
(ManagerName nvarchar(200) null
,ManagerEmail nvarchar(200) null
,DelinquentCourse nvarchar(max) null
,FirstName nvarchar(200) null
,LastName nvarchar(200) null
,username nvarchar(200) null)

create index inx_4 on #ManagersToNotifyList(ManagerName)




declare 
@ManagerName nvarchar(200)
,@ManagerEmail nvarchar(200)
,@FirstName nvarchar(200)
,@LastName nvarchar(200)
,@username nvarchar(200)

while exists (select 1 from #ManagersToNotify)
begin
set rowcount 1
select @ManagerName = ManagerName
,@DelinquentCourse = DelinquentCourse
,@ManagerEmail = ManagerEmail
,@username = username
,@FirstName = FirstName
,@LastName = LastName

from #ManagersToNotify
if exists (select * from #ManagersToNotifyList where ManagerName = @ManagerName)
begin
update #ManagersToNotifyList set
DelinquentCourse = rtrim(#ManagersToNotifyList.DelinquentCourse + +  ''<BR>&nbsp;&nbsp;'' + @DelinquentCourse )
from #ManagersToNotifyList
where #ManagersToNotifyList.ManagerName = @ManagerName
end
else
begin
insert #ManagersToNotifyList(ManagerName,DelinquentCourse,ManagerEmail ,username ,FirstName ,LastName )
values (@ManagerName,@DelinquentCourse,@ManagerEmail,@username ,@FirstName ,@LastName )

end
delete #ManagersToNotify where
@ManagerName = ManagerName
and @DelinquentCourse = DelinquentCourse
and @ManagerEmail = ManagerEmail
and @username = username
and @FirstName = FirstName
and @LastName = LastName
set rowcount 0
end




SELECT l.ManagerEmail,
-- Recipient Email Address
l.ManagerEmail as RecipientEmail,

-- Sender Email Address
l.ManagerEmail as SenderEmail,

-- Subject
(select  REPLACE(
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Overdue_Summary_Subject'')

,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Overdue_Summary_Subject''))),''%APP_NAME%'',(SELECT Value FROM tblAppConfig where Name = ''AppName''))) as Subject,



-- Header
(
select REPLACE(
(
select REPLACE(
(
select REPLACE(
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Overdue_Summary_Header'')

,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Overdue_Summary_Header'')))
,''%APP_NAME%'',
(SELECT Value FROM tblAppConfig where Name = ''AppName'')
)
)
,''%FirstName%'', COALESCE(FirstName,'''') 
)
)
,''%LastName%'', COALESCE(LastName,'''') 
)
)


--delinquent
+ ''<BR>'' + DelinquentCourse + ''<BR>''

--Email Sig
+     (select REPLACE(
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Overdue_Summary_Sig'')

,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Overdue_Summary_Sig'')))+ ''<BR>''  ,''%APP_NAME%'',(SELECT Value FROM tblAppConfig where Name = ''AppName''))) as Body
, -- Sender"On Behalf Of" Email Address
(SELECT dbo.udfGetEmailOnBehalfOf (@OrganisationID))  as OnBehalfOfEmail,


*

FROM
#ManagersToNotifyList l




--set flag to indicate delinquency note has been sent
UPDATE tblUserCourseDetails SET LastDelNoteToMgr  = 1
from tblUserCourseDetails
join (
SELECT U.userID , C.CourseID
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblUserCourseDetails UCD ON (UCD.UserID = u.UserID AND UCD.CourseID = C.CourseID)
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID)  AND (RemEsc.IndividualNotification=0) AND (RemEsc.NotifyMgr = 1)
INNER JOIN (select OrgID,CourseId,NotifyMgrDays, max(lastnotified) as lastnotified  from tblReminderEscalation where tblReminderEscalation.NotifyMgr = 1   group by OrgID,CourseId,NotifyMgrDays  ) LastNotified 
ON LastNotified.OrgID = o.OrganisationID and LastNotified.CourseId =  C.CourseID and LastNotified.NotifyMgrDays = RemEsc.NotifyMgrDays
where (coursestatusid = 1) AND (o.OrganisationID = @OrganisationID) AND (GETUTCDATE() > DATEADD(d,RemEsc.NotifyMgrDays+1, CS.DateCreated))
AND ((UCD.LastDelNoteToMgr = 0) OR (RemEsc.IsCumulative=1)) and  (U.active = 1)
AND (GETUTCDATE() > DATEADD(d,RemEsc.NotifyMgrDays,LastNotified.LastNotified ))
) a on a.userid = tblUserCourseDetails.UserID and a.CourseID = tblUserCourseDetails.CourseID


-- ReminderEscalations are logically grouped by the number of days that the reminders are sent
-- update the "Date last notified" field on the Reminder Escalation for all records that were notified this time.
UPDATE tblReminderEscalation SET LastNotified  = dbo.udfGetSaltOrgMidnight(OrgId)
from tblReminderEscalation
join (
SELECT o.OrganisationID , C.CourseID
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblUserCourseDetails UCD ON (UCD.UserID = u.UserID AND UCD.CourseID = C.CourseID)
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID)  AND (RemEsc.IndividualNotification=0) AND (RemEsc.NotifyMgr = 1)
INNER JOIN (select OrgID,CourseId,NotifyMgrDays, max(lastnotified) as lastnotified  from tblReminderEscalation where tblReminderEscalation.NotifyMgr = 1   group by OrgID,CourseId,NotifyMgrDays  ) LastNotified 
ON LastNotified.OrgID = o.OrganisationID and LastNotified.CourseId =  C.CourseID and LastNotified.NotifyMgrDays = RemEsc.NotifyMgrDays
where (coursestatusid = 1) AND (o.OrganisationID = @OrganisationID) AND (GETUTCDATE() > DATEADD(d,RemEsc.NotifyMgrDays+1, CS.DateCreated))
AND ((UCD.LastDelNoteToMgr = 0) OR (RemEsc.IsCumulative=1)) and  (U.active = 1)
AND (GETUTCDATE() > DATEADD(d,RemEsc.NotifyMgrDays,LastNotified.LastNotified ))
) a on a.OrganisationID = tblReminderEscalation.OrgId and a.CourseID = tblReminderEscalation.CourseID

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_ManagersToNotifyIndividually]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcAutomatedEmails_ManagersToNotifyIndividually]
(
@OrganisationID int
)


AS

BEGIN


--                    S E L E C T    T H E    R E S U L T S

--declare @OrganisationID int
--set @OrganisationID = 68

;with UsersToNotify (userid,DelinquentCourse,username) as (
SELECT distinct UsersToNotify.userid , UsersToNotify.DelinquentCourse,username FROM
(


-- delinquent users
SELECT DISTINCT CD.UserCourseStatusID as UserCourseStatusID, CS.userID , u.username, C.Name     as DelinquentCourse
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblUserCourseDetails UCD ON (UCD.UserID = u.UserID AND UCD.CourseID = C.CourseID)
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID)  AND (RemEsc.IndividualNotification=1) AND (RemEsc.NotifyMgr = 1) AND (RemEsc.DaysToCompleteCourse>0)
where (coursestatusid = 1) 
AND (o.OrganisationID = @OrganisationID) 
AND (GETUTCDATE() > DATEADD(d,RemEsc.DaysToCompleteCourse+1, CS.DateCreated)) -- Is Overdue
AND (U.active = 1) 
AND (UCD.LastDelNoteToMgr = 0)
AND (GETUTCDATE() < DATEADD(m,6,DATEADD(d,RemEsc.DaysToCompleteCourse, CS.DateCreated))) -- Business Rule = If Course is more than 6 months overdue stop notifying managers



)  UsersToNotify
)

, UsersToNotifyList(numb, userid,DelinquentCourse,username) as
(
select 1,null,CAST('''' AS VARCHAR(max)),CAST('''' AS VARCHAR(max))
UNION ALL

--SELECT cte.numb + 1,pl.userid,CAST(cte.DelinquentCourse + (case when cte.DelinquentCourse = '''' or pl.DelinquentCourse = '''' then '''' else ''<BR>'' end ) + pl.DelinquentCourse AS VARCHAR(max))
SELECT cte.numb + 1,pl.userid,CAST(    cte.DelinquentCourse +  ''<BR>&nbsp;&nbsp;'' + pl.DelinquentCourse AS VARCHAR(max)),CAST(pl.username AS VARCHAR(max))

from (  SELECT

RowNum = Row_Number() OVER (partition BY userid order by userid)
,userid,DelinquentCourse,username

FROM UsersToNotify
) AS pl
join UsersToNotifyList cte on pl.RowNum = cte.numb and (cte.userid is null or pl.userid = cte.userid)
)




, ManagersToNotifyList(numb, ManagerEmail, DelinquentCourse, FirstName, LastName,username,ManagerName) as
(
select numb,  CAST(UsersManagers.Email AS VARCHAR(max)),DelinquentCourse,FirstName,LastName,UL.username,UsersManagers.UserName
FROM UsersToNotifyList UL
inner join (select max(numb) AS maxnumb,Userid  from UsersToNotifyList  group by userid) max on max.maxnumb = UL.numb and max.userid = UL.userid

--INNER JOIN
--	(
--		SELECT U.username, U.UserID, tblUnitAdmins.Email ,tblUnitAdmins.FirstName, tblUnitAdmins.LastName
--		FROM  tblUser U  
--					INNER JOIN  tblUnitAdministrator ON U.UnitID = tblUnitAdministrator.UnitID
--					INNER JOIN   dbo.tblUser AS tblUnitAdmins ON dbo.tblUnitAdministrator.UserID = tblUnitAdmins.UserID AND tblUnitAdmins.UserTypeID = 3
--					WHERE  U.NotifyUnitAdmin = 1
--		UNION ALL 
--		SELECT U.username, U.UserID, tblOrgAdmins.Email ,tblOrgAdmins.FirstName, tblOrgAdmins.LastName
--		FROM  tblUser U  
--					INNER JOIN  dbo.tblUser AS tblOrgAdmins ON U.OrganisationID = tblOrgAdmins.OrganisationID
--					WHERE  U.NotifyOrgAdmin = 1 AND tblOrgAdmins.UserTypeID = 2
--		UNION ALL
--		SELECT username, tblUserDelinquencyManager.UserID, tblUserDelinquencyManager.DelinquencyManagerEmail,'' '' AS FirstName, '' '' AS LastName
--		FROM  dbo.tblUser AS tblUserDelinquencyManager WHERE  NotifyMgr = 1 and tblUserDelinquencyManager.Email IS NOT NULL AND (tblUserDelinquencyManager.Email != '''')
--	) UsersManagers ON UsersManagers.UserID = UL.UserID
--)

INNER JOIN
	(
		SELECT tblUnitAdmins.username, U.UserID, tblUnitAdmins.Email ,tblUnitAdmins.FirstName, tblUnitAdmins.LastName
		FROM  tblUser U  
					INNER JOIN  tblUnitAdministrator ON U.UnitID = tblUnitAdministrator.UnitID
					INNER JOIN   dbo.tblUser AS tblUnitAdmins ON dbo.tblUnitAdministrator.UserID = tblUnitAdmins.UserID AND tblUnitAdmins.UserTypeID = 3
					WHERE  U.NotifyUnitAdmin = 1
		UNION ALL 
		SELECT tblOrgAdmins.username, U.UserID, tblOrgAdmins.Email ,tblOrgAdmins.FirstName, tblOrgAdmins.LastName
		FROM  tblUser U  
					INNER JOIN  dbo.tblUser AS tblOrgAdmins ON U.OrganisationID = tblOrgAdmins.OrganisationID
					WHERE  U.NotifyOrgAdmin = 1 AND tblOrgAdmins.UserTypeID = 2
		UNION ALL
		SELECT ''DelinquencyManager'' as username, tblUserDelinquencyManager.UserID, tblUserDelinquencyManager.DelinquencyManagerEmail,'' '' AS FirstName, '' '' AS LastName
		FROM  dbo.tblUser AS tblUserDelinquencyManager WHERE  NotifyMgr = 1 and tblUserDelinquencyManager.Email IS NOT NULL AND (tblUserDelinquencyManager.Email != '''')
	) UsersManagers ON UsersManagers.UserID = UL.UserID

)


--select * from ManagersToNotify
--select * from ManagersToNotifyList




SELECT l.ManagerEmail,
-- Recipient Email Address
l.ManagerEmail as RecipientEmail,

-- Sender Email Address
l.ManagerEmail as SenderEmail,

-- Subject
(select   REPLACE(
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Overdue_Summary_Subject'')

,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Overdue_Summary_Subject''))),''%APP_NAME%'',(SELECT Value FROM tblAppConfig where Name = ''AppName''))) as Subject,



-- Header
(
select REPLACE(
(
select REPLACE(
(
select REPLACE(
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Overdue_Summary_Header'')

,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Overdue_Summary_Header_Individual'')))
,''%APP_NAME%'',
(SELECT Value FROM tblAppConfig where Name = ''AppName'')
)
)
,''%FirstName%'', COALESCE(FirstName,'''') 
)
)
,''%LastName%'', COALESCE(LastName,'''') 
)
)


--delinquent
+ ''<BR>'' +''<B>''+ l.firstname +'' ''+l.lastname+''</B>''+''&nbsp;&nbsp;''   + DelinquentCourse+ ''<BR>''

--Email Sig
+     (select REPLACE(
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Overdue_Summary_Sig'')

,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Overdue_Summary_Sig'')))+ ''<BR>''  ,''%APP_NAME%'',(SELECT Value FROM tblAppConfig where Name = ''AppName''))) as Body
, -- Sender"On Behalf Of" Email Address
(SELECT dbo.udfGetEmailOnBehalfOf (@OrganisationID))  as OnBehalfOfEmail,



*

FROM
ManagersToNotifyList l

join (select max(s.numb) numb ,ManagerEmail,ManagerName,UserName from ManagersToNotifyList s group by ManagerEmail,ManagerName,UserName)m on m.ManagerEmail = l.ManagerEmail and m.numb = l.numb and m.UserName = l.UserName and m.ManagerName = l.ManagerName
ORDER BY l.numb DESC


--set flag to indicate delinquency note has been sent
UPDATE tblUserCourseDetails SET LastDelNoteToMgr  = 1
from tblUserCourseDetails
join (
SELECT U.userID , C.CourseID
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblUserCourseDetails UCD ON (UCD.UserID = u.UserID AND UCD.CourseID = C.CourseID)
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID)  AND (RemEsc.IndividualNotification=1) AND (RemEsc.NotifyMgr = 1)
where (coursestatusid = 1) 
AND (o.OrganisationID = @OrganisationID) 
AND (GETUTCDATE() > DATEADD(d,RemEsc.DaysToCompleteCourse+1, CS.DateCreated)) -- Is Overdue
AND (U.active = 1) 
AND (UCD.LastDelNoteToMgr = 0)
AND (GETUTCDATE() < DATEADD(m,6,DATEADD(d,RemEsc.DaysToCompleteCourse, CS.DateCreated))) -- Business Rule = If Course is more than 6 months overdue stop notifying managers
) a on a.userid = tblUserCourseDetails.UserID and a.CourseID = tblUserCourseDetails.CourseID


-- ReminderEscalations are logically grouped by the number of days that the reminders are sent
-- update the "Date last notified" field on the Reminder Escalation for all records that were notified this time.
UPDATE tblReminderEscalation SET LastNotified  = dbo.udfGetSaltOrgMidnight(OrgId)
from tblReminderEscalation
join (
SELECT o.OrganisationID , C.CourseID
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblUserCourseDetails UCD ON (UCD.UserID = u.UserID AND UCD.CourseID = C.CourseID)
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID)  AND (RemEsc.IndividualNotification=1) AND (RemEsc.NotifyMgr = 1)
where (coursestatusid = 1) 
AND (o.OrganisationID = @OrganisationID) 
AND (GETUTCDATE() > DATEADD(d,RemEsc.DaysToCompleteCourse+1, CS.DateCreated)) -- Is Overdue
AND (U.active = 1) 
AND (UCD.LastDelNoteToMgr = 0)
AND (GETUTCDATE() < DATEADD(m,6,DATEADD(d,RemEsc.DaysToCompleteCourse, CS.DateCreated))) -- Business Rule = If Course is more than 6 months overdue stop notifying managers
) a on a.OrganisationID = tblReminderEscalation.OrgId and a.CourseID = tblReminderEscalation.CourseID

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetSaltOrgDateStr]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [udfGetSaltOrgDateStr]
(
@OrgID int

)
RETURNS Table
AS

return


SELECT  convert( varchar(17), dbo.udfUTCtoDaylightSavingTime(GETUTCDATE(),@OrgID),113) as PrintDate
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_DeleteReportInactive]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 15/12/2011
-- Description:	deletes report if owner and remove from cc if in cc list from periodic report on inactivating one user
-- =============================================
CREATE PROCEDURE [prcReport_DeleteReportInactive] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int = 0, 
	@UserId int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	IF EXISTS (SELECT * FROM tblReportSchedule 
		WHERE ScheduleID = @ScheduleId AND UserID = @UserId)
	BEGIN
		DELETE FROM tblReportSchedule
			WHERE ScheduleID = @ScheduleId 
			AND UserID = @UserId
	END
	
	IF EXISTS (SELECT * FROM tblCCList
		WHERE ScheduleId = @ScheduleId AND UserID = @UserId)
	BEGIN
		DELETE FROM tblCCList 
			WHERE ScheduleID = @ScheduleId
			AND UserId = @UserId
	END
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReassignReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 31/10/2011
-- Description:	Reassigns the owner of the periodic report
-- =============================================
CREATE PROCEDURE [prcReassignReport] 
(
	-- Add the parameters for the stored procedure here
	@ScheduleId int,
	@UserId int
)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    UPDATE tblReportSchedule SET UserID=@UserId
		WHERE ScheduleID=@ScheduleId
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_GetListByOrganisation]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Gets a list of all Policies assigned within the Organisation
Parameters: @organisationID  int -- The organisation ID
Returns:

Called By: BusinessServices.Policy.GetPolicyListAccessableToOrg
Calls: None

Remarks: Cut and Paste of course SP

Author: John R
Date Created: 17th of May 2010

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE     Procedure [prcPolicy_GetListByOrganisation]
(
@organisationID  int -- The organisation ID

)

As

-------------------------------------------------------------
-- Return Select
-------------------------------------------------------------
Select
p.[PolicyID]
, p.[PolicyName]
, dbo.udfUTCtoDaylightSavingTime(p.[UploadDate], @organisationID)

From
[tblPolicy] p
WHERE     (p.Active = ''True'') AND (p.Deleted = ''False'')
and p.organisationID = @organisationID
order by p.PolicyName







' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_CheckProfileName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Stored procedure to check if a Profile with the same name
as that being created already exists

Parameters:
@OrganisationID int
@ProfileName nvarchar(255)

Called By:
Profile.cs

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

*/
create procedure [prcProfile_CheckProfileName]
(
@OrganisationID int,
@ProfileName nvarchar(255)
)
as

select ProfileName
from tblProfile
where OrganisationID = @OrganisationID
and ProfileName = @ProfileName

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_SaveCourseAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Saves the course access settings for an organisation.

Called By:
Organisation.cs

Calls:
None

Remarks:
None

Author: Peter Vranich
Date Created: 19th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

Test:
Exec prcOrganisation_SaveCourseAccess 1, ''1, 3''
*/

CREATE Procedure [prcOrganisation_SaveCourseAccess]
(
@organisationID Integer,
@grantedCourseIDs VarChar(500)
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Remove the existing settings
Delete From tblOrganisationCourseAccess
Where
OrganisationID = @organisationID

-- Insert the new settings
Insert Into tblOrganisationCourseAccess
(
OrganisationID,
GrantedCourseID
)
Select
@organisationID,
gc.IntValue
From dbo.udfCsvToInt(@grantedCourseIDs) As gc

Commit Transaction

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_Create]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Creates a new Module.

Parameters:
@courseID
@name
@description
@active
@userID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Module.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Gavin Buddis
Date Created: 18th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE   Procedure [prcModule_Create]
(
@courseID Integer = Null,
@name nVarchar(100) = Null,
@description nVarchar(1000) = Null,
@active Bit = 1,
@userID Integer = Null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @courseID
If(@courseID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @courseID in stored procedure prcModule_Create''
Goto Finalise
End

--Validate Parameter @name
If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure prcModule_Create''
Goto Finalise
End

--Validate Parameter @active
If(@active Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure prcModule_Create''
Goto Finalise
End

--Validate Parameter @userID
If(@userID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcModule_Create''
Goto Finalise
End

--Check that there are no other modules of this name within this course
If Exists(Select CourseID from tblModule Where CourseID=@courseID and [Name]=@name)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''There is already a module of that name within this course''
Goto Finalise
End


-- Insert the new record
Insert Into tblModule
(
CourseID,
[Name],
[Description],
Active,
CreatedBy,
DateCreated,
UpdatedBy,
DateUpdated
)
Values
(
@courseID,
@name,
@description,
@active,
@userID,
GetUTCDate(),
@userID,
GetUTCDate()
)

-- Set the error message to successfull
Set @intErrorNumber = 0
Set @strErrorMessage = @@identity

-- Finalise the procedure
Goto Finalise



Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLink_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Updates a Link.

Parameters:
@linkID
@caption
@url
@showDisclaimer
@userID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Link.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Peter Vranich
Date Created: 12 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE  Procedure [prcLink_Update]
(
@linkID Integer = Null,
@caption nVarchar(100) = Null,
@url nVarchar(200) = Null,
@showDisclaimer Bit = 1,
@userID Integer = Null,
@LinkOrder Integer = 999
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction
if @url is null
begin
set @url = ''''
end

-- Declarations
Declare @organisationID Int -- Organisation ID for the link to be updated
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @linkID
If(@linkID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @linkID in stored procedure prcLink_Update''
Goto Finalise
End

-- Get the Organisation ID for the link to be updated
Set @organisationID = (Select organisationID From tblLink Where linkID = @linkID)

-- Validate that the Caption for this link doesn''t exist.
If Exists(Select * From tblLink Where Caption = @caption And LinkID != @linkID And OrganisationID = @organisationID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Caption '' + @caption + '' already exists please choose another Caption.''
Goto Finalise
End

--Validate Parameter @caption
If(@caption Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @strErrorMessage in stored procedure prcLink_Update''
Goto Finalise
End

--Validate Parameter @showDisclaimer
If(@showDisclaimer Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @showDisclaimer in stored procedure prcLink_Update''
Goto Finalise
End

--Validate Parameter @userID
If(@userID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcLink_Update''
Goto Finalise
End

If Exists(Select * From tblLink Where LinkID = @linkID)
Begin
-- Update the record in tblLink
Update tblLink
Set
Caption = @caption,
Url = @url,
ShowDisclaimer = @showDisclaimer,
UpdatedBy = @userID,
DateUpdated = GetUTCDate(),
LinkOrder = @LinkOrder
Where
LinkID = @linkID

-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Updated''

-- Finalise the procedure
Goto Finalise
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''

Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLink_GetListByOrganisation]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Gets a List of Links per Organisation
Parameters:
@organisationID Integer ID of the Organisatyion to return the Links for.
Returns:

Called By:
Links.cs
Calls:

Remarks:

Author: Peter Vranich
Date Created: 10th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcLink_GetListByOrganisation]
(
@organisationID Integer = Null -- ID of the Organisation to return the Links for.
)

As

Set Nocount On

If(@organisationID Is Null)
Begin
Raiserror(''The @organisationID parameter was Null.  You must supply a value.'', 16, 1)
Return
End

Select
LinkID,
OrganisationID,
Caption,
Url,
ShowDisclaimer,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @organisationID),
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @organisationID),
LinkOrder
From
tblLink
Where
(OrganisationID = @organisationID)
Order by
LinkOrder, Caption
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLink_Delete]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Deletes a Link.

Parameters:
@linkID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Link.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 12 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE Procedure [prcLink_Delete]
(
@linkID Integer = Null -- The LinkID of the record to delete.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @linkID
If(@linkID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @linkID in stored procedure prcLink_Update''
Goto Finalise
End

-- If the record exists delete it from the tblLink table.
If Exists(Select * From tblLink Where LinkID = @linkID)
Begin
Delete tblLink
Where
LinkID = @linkID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record you tried to delete no longer exists.''

Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLink_Add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*Summary:
Adds a new Link.

Parameters:
@organisationID
@caption
@url
@showDisclaimer
@userID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Link.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Peter Vranich
Date Created: 12th February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE   Procedure [prcLink_Add]
(
@organisationID Integer = Null,
@caption nVarchar(100) = Null,
@url nVarchar(200) = Null,
@showDisclaimer Bit = 1,
@userID Integer = Null,
@LinkOrder Integer = 999
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

-- Validate that the Caption for this link doesn''t exist.
If Exists(Select * From tblLink Where Caption = @caption And OrganisationID = @organisationID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The Caption '' + @caption + '' already exists please choose another Caption.''
Goto Finalise
End

--Validate Parameter @organisationID
If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure prcLink_Add''
Goto Finalise
End

--Validate Parameter @caption
If(@caption Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @caption in stored procedure prcLink_Add''
Goto Finalise
End


--Validate Parameter @showDisclaimer
If(@showDisclaimer Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @showDisclaimer in stored procedure prcLink_Add''
Goto Finalise
End

--Validate Parameter @userID
If(@userID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @userID in stored procedure prcLink_Add''
Goto Finalise
End

-- Insert the new record into tblLink
Insert Into tblLink
(
OrganisationID,
Caption,
Url,
ShowDisclaimer,
CreatedBy,
LinkOrder
)
Values
(
@organisationID,
@caption,
@url,
@showDisclaimer,
@userID,
@LinkOrder
)

-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Added''

-- Finalise the procedure
Goto Finalise

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetEmailThroughput]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE PROCEDURE [prcGetEmailThroughput]
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

SELECT o.OrganisationName AS OrganisationName, dbo.udfGetEmailsinHour(o.OrganisationName) AS "Emails delivered in last hour", dbo.udfGetEmailsinDay(o.OrganisationName) AS "Emails delivered in last day", dbo.udfGetPercentExpectedEmails(o.OrganisationName) AS "Percent of Expected Emails"
FROM tblEmail e JOIN tblOrganisation o ON e.OrganisationID = o.OrganisationID
GROUP BY OrganisationName
ORDER BY "Percent of Expected Emails" DESC
END' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcDeleteReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 2/11/2011
-- Description:	Deletes periodic report along with adding entry in audit table
-- =============================================
CREATE PROCEDURE [prcDeleteReport] 
	-- Add the parameters for the stored procedure here
	@ScheduleId int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
    
    DELETE FROM tblReportSchedule WHERE ScheduleID=@ScheduleId
	
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcDatabaseMail_Setup]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE Procedure [prcDatabaseMail_Setup]

As

Set NoCount On

EXECUTE master.dbo.sp_configure ''show advanced options'', 1

reconfigure with override

EXECUTE  master.dbo.sp_configure ''Database Mail XPs'', 1

reconfigure

EXECUTE  master.dbo.sp_configure ''show advanced options'', 0

EXEC prcDatabaseMail_SetupProfile
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetSelected]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:		Gets a list of Courses
Parameters:		Comma separated list of courseIDs
Returns:		table

Called By:		BusinessServices.Course.GetCourseList in Course.cs
Calls:			None

Remarks:		None

Author:			Mark Donald
Date Created:	10 Nov 2009

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE PROCEDURE [prcCourse_GetSelected]
@courseIDs varchar(8000)
, @OrgID int
AS
BEGIN
SET NOCOUNT ON;

SELECT
courseid, [name], notes, active, createdby, dbo.udfUTCtoDaylightSavingTime(datecreated, @OrgID), updatedby, dbo.udfUTCtoDaylightSavingTime(dateupdated, @OrgID)
FROM
tblcourse
WHERE
courseid IN (SELECT * FROM dbo.udfCsvToInt(@courseIDs))
ORDER BY [name]
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetPeriodicFields]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Name
-- Create date: 26/10/2011
-- Description:	Gets the periodicity related fields for a periodic report
-- =============================================
CREATE PROCEDURE [prcGetPeriodicFields] 
(
	-- Add the parameters for the stored procedure here
	@ScheduleId int
	)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Insert statements for procedure here
	SELECT ReportTitle, IsPeriodic, ReportStartDate, ReportFrequency, ReportFrequencyPeriod, 
		CASE WHEN ((ReportEndDate IS NULL) AND (NumberOfReports IS NULL)) THEN 1 ELSE 0 END AS NoEndDate,
		CASE WHEN NumberOfReports IS NOT NULL THEN 1 ELSE 0 END AS EndAfter,
		NumberOfReports, CASE WHEN ReportEndDate IS NOT NULL THEN 1 ELSE 0 END AS EndOn,
		ReportEndDate, ReportPeriodType, ReportFromDate FROM tblReportSchedule WHERE ScheduleID=@ScheduleId 
END' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetMailThroughputPagedandSorted]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 21/06/2011
-- Description:	Custom paging and sorting of mail throughput
-- =============================================
CREATE PROCEDURE [prcGetMailThroughputPagedandSorted]
@sortExpression nvarchar(100),
@startRowIndex int,
@maximumRows int
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

IF LEN(@sortExpression) = 0
SET @sortExpression = ''Percent of Expected Emails''

SELECT ''OrganisationName'', ''Emails delivered in last hour'', ''Emails delivered in last day'', ''Percent of Expected Emails''
FROM (SELECT o.OrganisationName AS OrganisationName, dbo.udfGetEmailsinHour(o.OrganisationName) AS "Emails delivered in last hour", dbo.udfGetEmailsinDay(o.OrganisationName) AS "Emails delivered in last day", dbo.udfGetPercentExpectedEmails(o.OrganisationName) AS "Percent of Expected Emails",
ROW_NUMBER() OVER (ORDER BY @sortExpression) AS RowRank
FROM tblEmail AS e INNER JOIN tblOrganisation AS o ON e.OrganisationID = o.OrganisationID) AS MailWithRowNumbers
WHERE ''RowRank'' > CONVERT(nvarchar(10), @startRowIndex)
AND ''RowRank'' <= (CONVERT(nvarchar(10), @startRowIndex) + CONVERT(nvarchar(10), @maximumRows))
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcGetSaltOrgDate]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE procedure [prcGetSaltOrgDate]
(
@OrgID int

)

AS

begin


SELECT  convert( varchar(17), dbo.udfUTCtoDaylightSavingTime(GETUTCDATE(),@OrgID),113) as PrintDate

end








' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetPolicyUsedSpace]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE Procedure [prcOrganisation_GetPolicyUsedSpace]
(
@OrganisationID int
)

as

select sum(PolicyFileSize)
from tblPolicy
where OrganisationID=@OrganisationID
and Deleted=0
and Active=1

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetPolicyList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Gets a List of Policies for a particular organisation.

Parameters:
@organisationID

Returns:
Nothing

Called By:
Organisation.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

CREATE   Procedure [prcOrganisation_GetPolicyList]
(
@organisationID Integer = Null -- ID of the Organisation that you wish to get the Policies for
)

As


select
PolicyID,
PolicyName,
PolicyFileName,
Active
from
tblPolicy pol left join
tblOrganisationPolicyAccess opa on
pol.OrganisationID = opa.OrganisationID
where
pol.OrganisationID = @OrganisationID and	--OrganisationID passed into stored procedure
opa.GrantPolicyAccess = 1					--Organisation has access to policy
and pol.Deleted = 0
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetPolicyAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Saves Organisation CPD and Policy access information
Parameters: @OrganisationName int, @grantCPDAccess bit, grantPolicyAccess bit
Returns: nothing

Called By: Components/BusinessServices/Organisation.cs
Calls: None

Remarks: Gets Policy access for a particular organisation

Author: Aaron Cripps
Date Created: May 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcOrganisation_GetPolicyAccess]
(
@OrganisationID int
)

As

select GrantPolicyAccess from tblOrganisationPolicyAccess where organisationID = @OrganisationID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_UpdateSequence]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Updates a Module''s sequence value.

Parameters:
@moduleID
@sequence
@userID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Course.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Gavin Buddis
Date Created: 16 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE Procedure [prcModule_UpdateSequence]
(
@moduleID Integer = Null,
@sequence Varchar(100) = Null,
@updatedByUserID Integer = Null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @moduleID
If(@moduleID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @moduleID in stored procedure prcModule_UpdateSequence''
Goto Finalise
End

--Validate Parameter @name
If(@sequence Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @sequence in stored procedure prcModule_UpdateSequence''
Goto Finalise
End

--Validate Parameter @userID
If(@updatedByUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @updatedByUserID in stored procedure prcModule_UpdateSequence''
Goto Finalise
End

If Exists(Select * From tblModule Where ModuleID = @moduleID)
Begin
-- Update the record in tblModule
Update tblModule
Set
[Sequence] = @sequence,
UpdatedBy = @updatedByUserID,
DateUpdated = GetUTCDate()
Where
ModuleID = @moduleID

-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Updated''

-- Finalise the procedure
Goto Finalise
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''

Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Updates a Module''s details (except its sequence value).

Parameters:
@moduleID
@name
@description
@active
@updatedByUserID

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Course.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Gavin Buddis
Date Created: 16 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE Procedure [prcModule_Update]
(
@moduleID Integer = Null,
@name nVarchar(100) = Null,
@description nVarchar(1000) = Null,
@active Bit = Null,
@updatedByUserID Integer = Null
)

As
-- Used to hold the course id when checking for duplicate module names.
Declare @CourseID int

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

-- Validate Parameter @moduleID
If(@moduleID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @moduleID in stored procedure prcModule_Update''
Goto Finalise
End

-- Validate Parameter @name
If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure prcModule_Update''
Goto Finalise
End

-- Validate Parameter @active
If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @active in stored procedure prcModule_Update''
Goto Finalise
End

-- Validate Parameter @userID
If(@updatedByUserID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @updatedByUserID in stored procedure prcModule_Update''
Goto Finalise
End

--Check that there are no other modules of this name within this course
Select @CourseID = CourseID From tblModule Where ModuleID=@ModuleID
If Exists(Select CourseID from tblModule Where CourseID=@courseID and [Name]=@name and ModuleID <> @moduleID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''There is already a module of that name within this course''
Goto Finalise
End

If Exists(Select * From tblModule Where ModuleID = @moduleID)
Begin
-- Update the record in tblModule
Update tblModule
Set
[Name] = @name,
[Description] = @description,
Active = @active,
UpdatedBy = @updatedByUserID,
DateUpdated = GetUTCDate()
Where
ModuleID = @moduleID

-- Set the error message to successfull
Set @strErrorMessage = ''Successfully Updated''

-- Finalise the procedure
Goto Finalise
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.  If the problem persists please contact your administrator.''

Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary: Gets the details of one Module
Parameters: @moduleID integer
Returns: ModuleID, CourseID, Name, Sequence, Description, Active, CreatedBy, DateCreated, UpdatedBy, DateUpdated

Called By: Module.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Gavin Buddis
Date Created: 16th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcModule_GetOne]
(
@moduleID Integer = null, -- ModuleID
@OrgID int
)

As

If @moduleID Is Null
Begin
Raiserror(''The Parameter @moduleID was null.  @moduleID does not accept Null values.'', 16, 1)
Return
End

Select
ModuleID,
CourseID,
[Name],
[Sequence],
[Description],
Active,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @OrgID),
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @OrgID)
From
tblModule
Where
ModuleID = @moduleID


' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_GetListByCourse]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Gets a list of Modules per Course
Parameters:
@courseID Integer ID of the Course to return the Modules for.
Returns:

Called By:
Module.cs
Calls:

Remarks:

Author: Gavin Buddis
Date Created: 16th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcModule_GetListByCourse]
(
@courseID Integer = Null, -- ID of the Course to return the Modules for.
@OrgID int
)

As

Set Nocount On

If(@courseID Is Null)
Begin
Raiserror(''The @courseID parameter was Null.  You must supply a value.'', 16, 1)
Return
End

Select
ModuleID,
CourseID,
[Name],
[Sequence],
[Description],
Active,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @OrgID),
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @OrgID)
From
tblModule
Where
(CourseID = @courseID)
Order By
[Sequence] ASC
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUserQuizStatus_FIX]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE   Procedure [prcUserQuizStatus_FIX]
(
@orgID int
)
AS
Set Nocount On

/*
1.1  Get all modules that are currently assigned to each users (CurrentAssignedModules)
and current compliance rules
*/

select
um.UserID,
um.ModuleID,
umr.QuizFrequency,
umr.QuizPassMark
into
#tblCurrentAssignedModules
from
vwUserModuleAccess um
inner join
vwUnitModuleRule umr
on
umr.ModuleID  = um.ModuleID
and umr.UnitID = um.UnitID
where
um.OrganisationID = @orgID

/*
1.2. Get the last quiz activity for each user and module pair (StartedModules)
*/

select
um.userID,
um.moduleID,
q.active,
qs.QuizScore,
qs.QuizSessionID,
dbo.udfUTCtoDaylightSavingTime(qs.DateTimeCompleted, @orgID)
into
#tblStartedModules
from
#tblCurrentAssignedModules um
inner join
(
select
um.userID, um.moduleID, max(dbo.udfUTCtoDaylightSavingTime(DateTimeCompleted, @orgID))  as DateTimeCompleted
from
#tblCurrentAssignedModules um
inner join tblQuiz q
on q.ModuleID = um.ModuleID
inner join tblQuizSession qs
on
qs.QuizID=	q.quizID
and qs.userID = um.userID
and qs.DateTimeCompleted is not null
group by um.userID, um.moduleID
)
as LastQuizDate

on
LastQuizDate.userID = um.userID
and LastQuizDate.ModuleID = um.ModuleID

inner join tblQuiz q
on
q.ModuleID = um.ModuleID
inner join tblQuizSession qs
on
qs.QuizID=	q.quizID
and qs.userID = um.userID
and qs.DateTimeCompleted  = LastQuizDate.DateTimeCompleted

/*
1.3. Unassigned Modules (0) (PreviousAssignedModules - CurrentAssignedModules)
a) Get a list of modules that is in the quiz status table that the last statuses are not Unassigned (0)(PreviousAssignedModules)
b) Get rid off all modules that are currently assigned to the users (from step 1)
c)All modules left are Unassigned(0)
*/
--1. Get Current User Quiz status
CREATE TABLE #tblCurrentUserQuizStatus
(
UserID int NOT NULL ,
ModuleID int NOT NULL ,
QuizStatusID int not NULL ,
QuizFrequency int NULL ,
QuizPassMark int NULL ,
QuizScore int NULL,
QuizSessionID uniqueidentifier NULL
)

/*
1.5. Started Modules
a)If the last quiz is inactive, the status is Expired (New Content)(5)
b)If the last quiz is past the current quiz frequency, the status is Expired (Time Expired)(4)
c)If the last quiz is during the current quiz frequency, get the current pass mark, and check the quiz status
If user Failed the quiz, the status is Failed (3)
If user Passed the quiz, the status is Passed (2)
*/

-- a)If the last quiz is inactive, the status is Expired (New Content)(5)


insert into #tblCurrentUserQuizStatus
(
UserID,
ModuleID,
QuizStatusID,
QuizFrequency,
QuizPassMark
)
select
cam.UserID,
cam.ModuleID,
5  as QuizStatusID, --  Expired (New Content)(5)
cam.QuizFrequency,
cam.QuizPassMark
from
#tblCurrentAssignedModules cam
inner join
#tblStartedModules sm
on
sm.UserID = cam.UserID
and sm.ModuleID = cam.ModuleID
where
sm.active=0 --Inactive

-- select * from #tblCurrentUserQuizStatus order by userID

/*
2. Update User Quiz status
----------------------------
If the last quiz status for each user is not the same as the current status, add the new status
*/




declare @cursor_UserID 	        int
declare @cursor_ModuleID 	    int
declare @cursor_QuizStatusID 	int
declare @cursor_QuizFrequency 	int
declare @cursor_QuizPassMark	int
declare @cursor_QuizScore	    int
declare @cursor_QuizSessionID   varchar(50)
declare @cursor_UserQuizStatusID int
declare @int_rc int

DECLARE CurrentUserQuizStatus CURSOR
FOR


select
cs.UserID,
cs.ModuleID,
cs.QuizStatusID,
cs.QuizFrequency,
cs.QuizPassMark,
cs.QuizScore,
cs.QuizSessionID,
s.UserQuizStatusID
from
#tblCurrentUserQuizStatus cs
left join vwUserQuizStatus s
on cs.userID = s.UserID
and cs.ModuleID = s.ModuleID
and cs.QuizStatusID = s.QuizStatusID

Open CurrentUserQuizStatus

-- First Read testreportCursor
FETCH NEXT FROM CurrentUserQuizStatus
Into
@cursor_UserID,@cursor_ModuleID,@cursor_QuizStatusID,@cursor_QuizFrequency,
@cursor_QuizPassMark,@cursor_QuizScore,@cursor_QuizSessionID, @cursor_UserQuizStatusID

WHILE @@FETCH_STATUS = 0
BEGIN

--new user quiz status records

-- Eisting user quiz status records
EXEC prcUserQuizStatus_UpdateCourseStatus @cursor_UserID, @cursor_ModuleID

FETCH NEXT FROM CurrentUserQuizStatus
Into
@cursor_UserID,@cursor_ModuleID,@cursor_QuizStatusID,@cursor_QuizFrequency,
@cursor_QuizPassMark,@cursor_QuizScore,@cursor_QuizSessionID,@cursor_UserQuizStatusID
END
-- Finished CurrentUserQuizStatus
CLOSE CurrentUserQuizStatus
DEALLOCATE CurrentUserQuizStatus

drop table  #tblCurrentUserQuizStatus

drop table #tblCurrentAssignedModules

drop table #tblStartedModules

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_WarningGrandTotal]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		Name: prcReport_WarningGrandTotal
**		Desc: a copy of prcreport_Warning, but with select statements
**				altered to return a total, instead of a list of data.
**
**		Return values: Grand Total distinct users in Warning report
**
**		Auth: Mark Donald
**		Date: 17 Nov 2009
**
*******************************************************************************/

CREATE       Procedure [prcReport_WarningGrandTotal]
(
@organisationID		int,
@unitIDs 		varchar(8000),
@courseIDs 		varchar(8000),
@classificationID int,
@warningPeriod int,
@warningUnit varchar(2)
)
AS
SET NOCOUNT ON;

DECLARE @Units TABLE (UnitID INT PRIMARY KEY(UnitID))
DECLARE @Courses TABLE(CourseID INT PRIMARY KEY(CourseID))
DECLARE @CoursesWithAccess 	TABLE (CourseID INT PRIMARY KEY(CourseID))
DECLARE @Users TABLE(UserID INT , UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @tblCurrentAssignedModules TABLE (
CourseID int,
UserID int,
UnitID int,
ModuleID int,
QuizFrequency int,
QuizCompletionDate datetime
)
DECLARE @tblStartedModules TABLE (
UserID int,
ModuleID int,
DateTimeCompleted datetime
)

INSERT INTO
@Courses
SELECT
*
FROM
dbo.udfCsvToInt(@courseIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

-- Get users for specfied units, matching Custom Classification option (if provided)
INSERT INTO @Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
JOIN @Units B on A.UnitID = B.UnitID
JOIN tblUnit C on B.UnitID = C.UnitID AND C.Active = 1
LEFT JOIN tblUserClassification uc ON uc.UserID  = A.UserID
WHERE
A.Active = 1
AND ((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification

-- Get compliance rules for in-scope modules
INSERT INTO @tblCurrentAssignedModules
SELECT
CourseID, UserID, um.UnitID, um.ModuleID, QuizFrequency, QuizCompletionDate
FROM
(SELECT
tU.UserID, tU.UnitID, tM.ModuleID
FROM
dbo.tblUser tU
INNER JOIN dbo.tblOrganisationCourseAccess tOCA ON tOCA.OrganisationID = tU.OrganisationID
INNER JOIN dbo.tblCourse tC ON tC.CourseID = tOCA.GrantedCourseID
INNER JOIN dbo.tblModule tM ON tM.CourseID = tC.CourseID AND tM.Active = 1
LEFT OUTER JOIN dbo.tblUserModuleAccess tUsrMA ON tUsrMA.UserID = tU.UserID
AND tUsrMA.ModuleID = tM.ModuleID
LEFT OUTER JOIN dbo.tblUnitModuleAccess tUnitMA ON tUnitMA.UnitID = tU.UnitID
AND tUnitMA.DeniedModuleID = tM.ModuleID
WHERE
tU.OrganisationID = @organisationID
AND	tU.Active = 1
AND tu.UnitID IS NOT NULL
AND dbo.udfUserCourseComplete(tu.userid, tm.courseid) = 1
AND ((tUnitMA.DeniedModuleID IS NULL AND tUsrMA.ModuleID IS NULL)
OR tUsrMA.Granted=1)
) um
INNER JOIN (
SELECT
u.UnitID, m.CourseID, m.ModuleID,
CASE
WHEN (
ur.QuizFrequency IS NULL
AND ur.QuizCompletionDate IS NULL
AND o.DefaultQuizCompletionDate IS NULL
) THEN
o.DefaultQuizFrequency
ELSE
ur.QuizFrequency
END AS QuizFrequency,
CASE
WHEN (
ur.QuizFrequency IS NULL
AND ur.QuizCompletionDate IS NULL
AND o.DefaultQuizCompletionDate IS NOT NULL
) THEN
o.DefaultQuizCompletionDate
ELSE
ur.QuizCompletionDate
END AS QuizCompletionDate
FROM
tblOrganisationCourseAccess c
INNER JOIN tblModule m ON m.CourseID = c.GrantedCourseID
INNER JOIN tblOrganisation o ON o.OrganisationID = c.OrganisationID -- default compliance rules
INNER JOIN tblUnit u ON u.OrganisationID = c.OrganisationID
LEFT JOIN tblUnitRule ur ON ur.ModuleID = m.ModuleID AND ur.UnitID = u.unitID -- unit specific rules
WHERE o.OrganisationID = @organisationID
) umr ON umr.ModuleID  = um.ModuleID
AND umr.UnitID = um.UnitID
AND um.UnitID IN (SELECT DISTINCT UnitID FROM @users)
AND um.UserID IN (SELECT DISTINCT UserID FROM @users)
AND umr.CourseID IN (SELECT CourseID FROM @courses)

-- Get module completion details
INSERT INTO @tblStartedModules
SELECT
um.userID, um.moduleID, qs.DateTimeCompleted
FROM
@tblCurrentAssignedModules um
INNER JOIN (
SELECT
um.userID, um.moduleID, max(DateTimeCompleted) AS DateTimeCompleted
FROM
@tblCurrentAssignedModules um
INNER JOIN tblQuiz q ON q.ModuleID = um.ModuleID
INNER JOIN tblQuizSession qs ON qs.QuizID= q.quizID
AND qs.userID = um.userID
AND qs.DateTimeCompleted IS NOT NULL
GROUP BY
um.userID, um.moduleID
) AS LastQuizDate ON
LastQuizDate.userID = um.userID
AND LastQuizDate.ModuleID = um.ModuleID
INNER JOIN tblQuiz q ON q.ModuleID = um.ModuleID
INNER JOIN tblQuizSession qs ON
qs.QuizID= q.quizID
AND qs.userID = um.userID
AND qs.DateTimeCompleted = LastQuizDate.DateTimeCompleted

BEGIN
SELECT
count(DISTINCT UserID) AS TotalDistinctUsers
FROM
-- User/course combos where the courses are about to be marked incomplete due to module expiry
(SELECT
cam.UserID, max(DateTimeCompleted) AS CompletionDate,
min(isnull(QuizCompletionDate, dateadd(month, QuizFrequency, DateTimeCompleted))) AS ExpiryDate
FROM
@tblCurrentAssignedModules cam
INNER JOIN @tblStartedModules sm ON sm.UserID = cam.UserID AND sm.ModuleID = cam.ModuleID
GROUP BY
cam.UserID
HAVING
min(isnull(
QuizCompletionDate,
dateadd(month, QuizFrequency, DateTimeCompleted)
)) < CASE @warningUnit
WHEN ''mm'' THEN
dateadd(mm, @warningPeriod, getutcdate())
ELSE
dateadd(dd, @warningPeriod, getutcdate())
END) AS warning_report
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcReport_Warning]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/******************************************************************************
**		Name: prcReport_Warning
**
**		Called by:
**
**		Auth: Mark Donald
**		Date: 7 Dec 2009
*******************************************************************************
**		Change History
*******************************************************************************
**		Date:		Author:				Description:
**
*******************************************************************************/


CREATE PROCEDURE [prcReport_Warning]
(
@organisationID int,
@unitIDs varchar(8000),
@courseIDs varchar(8000),
@classificationID int,
@warningPeriod int,
@warningUnit varchar(2)
)
AS
SET NOCOUNT ON;

DECLARE @Units TABLE (UnitID INT PRIMARY KEY(UnitID))
DECLARE @Courses TABLE(CourseID INT PRIMARY KEY(CourseID))
DECLARE @CoursesWithAccess 	TABLE (CourseID INT PRIMARY KEY(CourseID))
DECLARE @Users TABLE(UserID INT , UnitID INT PRIMARY KEY(UserID, UnitID))
DECLARE @tblCurrentAssignedModules TABLE (
CourseID int,
UserID int,
UnitID int,
ModuleID int,
QuizFrequency int,
QuizCompletionDate datetime
)
DECLARE @tblStartedModules TABLE (
UserID int,
ModuleID int,
DateTimeCompleted datetime
)

INSERT INTO
@Courses
SELECT
*
FROM
dbo.udfCsvToInt(@courseIDs)

INSERT INTO
@Units
SELECT
*
FROM
dbo.udfCsvToInt(@unitIDs)

-- Get users for specfied units, matching Custom Classification option (if provided)
INSERT INTO @Users
SELECT
DISTINCT A.UserID, A.UnitiD
FROM
tblUser A
JOIN @Units B on A.UnitID = B.UnitID
JOIN tblUnit C on B.UnitID = C.UnitID AND C.Active = 1
LEFT JOIN tblUserClassification uc ON uc.UserID  = A.UserID
WHERE
A.Active = 1
AND ((@classificationID =0) OR (classificationID = @classificationID))
--If classification is Any (0), This will find users of any Custom Classification

-- Get compliance rules for in-scope modules
INSERT INTO @tblCurrentAssignedModules
SELECT
CourseID, UserID, um.UnitID, um.ModuleID, QuizFrequency, QuizCompletionDate
FROM
(SELECT
tU.UserID, tU.UnitID, tM.ModuleID
FROM
dbo.tblUser tU
INNER JOIN dbo.tblOrganisationCourseAccess tOCA ON tOCA.OrganisationID = tU.OrganisationID
INNER JOIN dbo.tblCourse tC ON tC.CourseID = tOCA.GrantedCourseID
INNER JOIN dbo.tblModule tM ON tM.CourseID = tC.CourseID AND tM.Active = 1
LEFT OUTER JOIN dbo.tblUserModuleAccess tUsrMA ON tUsrMA.UserID = tU.UserID
AND tUsrMA.ModuleID = tM.ModuleID
LEFT OUTER JOIN dbo.tblUnitModuleAccess tUnitMA ON tUnitMA.UnitID = tU.UnitID
AND tUnitMA.DeniedModuleID = tM.ModuleID
WHERE
tU.OrganisationID = @organisationID
AND	tU.Active = 1
AND tu.UnitID IS NOT NULL
AND dbo.udfUserCourseComplete(tu.userid, tm.courseid) = 1
AND ((tUnitMA.DeniedModuleID IS NULL AND tUsrMA.ModuleID IS NULL)
OR tUsrMA.Granted=1)
) um
INNER JOIN (
SELECT
u.UnitID, m.CourseID, m.ModuleID,
CASE
WHEN (
ur.QuizFrequency IS NULL
AND ur.QuizCompletionDate IS NULL
AND o.DefaultQuizCompletionDate IS NULL
) THEN
o.DefaultQuizFrequency
ELSE
ur.QuizFrequency
END AS QuizFrequency,
CASE
WHEN (
ur.QuizFrequency IS NULL
AND ur.QuizCompletionDate IS NULL
AND o.DefaultQuizCompletionDate IS NOT NULL
) THEN
o.DefaultQuizCompletionDate
ELSE
ur.QuizCompletionDate
END AS QuizCompletionDate
FROM
tblOrganisationCourseAccess c
INNER JOIN tblModule m ON m.CourseID = c.GrantedCourseID
INNER JOIN tblOrganisation o ON o.OrganisationID = c.OrganisationID -- default compliance rules
INNER JOIN tblUnit u ON u.OrganisationID = c.OrganisationID
LEFT JOIN tblUnitRule ur ON ur.ModuleID = m.ModuleID AND ur.UnitID = u.unitID -- unit specific rules
WHERE o.OrganisationID = @organisationID
) umr ON umr.ModuleID  = um.ModuleID
AND umr.UnitID = um.UnitID
AND um.UnitID IN (SELECT DISTINCT UnitID FROM @users)
AND um.UserID IN (SELECT DISTINCT UserID FROM @users)
AND umr.CourseID IN (SELECT CourseID FROM @courses)

-- Get module completion details
INSERT INTO @tblStartedModules
SELECT
um.userID, um.moduleID, qs.DateTimeCompleted
FROM
@tblCurrentAssignedModules um
INNER JOIN (
SELECT
um.userID, um.moduleID, max(DateTimeCompleted) AS DateTimeCompleted
FROM
@tblCurrentAssignedModules um
INNER JOIN tblQuiz q ON q.ModuleID = um.ModuleID
INNER JOIN tblQuizSession qs ON qs.QuizID= q.quizID
AND qs.userID = um.userID
AND qs.DateTimeCompleted IS NOT NULL
GROUP BY
um.userID, um.moduleID
) AS LastQuizDate ON
LastQuizDate.userID = um.userID
AND LastQuizDate.ModuleID = um.ModuleID
INNER JOIN tblQuiz q ON q.ModuleID = um.ModuleID
INNER JOIN tblQuizSession qs ON
qs.QuizID= q.quizID
AND qs.userID = um.userID
AND qs.DateTimeCompleted = LastQuizDate.DateTimeCompleted

-- User/course combos where the courses are about to be marked incomplete due to module expiry
BEGIN
SELECT
c.[name] as CourseName,
HierarchyName AS UnitPathway,
LastName,
FirstName,
ExternalID,
Email,
UserName,
dbo.udfUTCtoDaylightSavingTime(max(DateTimeCompleted), @organisationID) AS CompletionDate,
dbo.udfUTCtoDaylightSavingTime(min(isnull(QuizCompletionDate, dateadd(month, QuizFrequency, DateTimeCompleted))), @organisationID) AS ExpiryDate
FROM
@tblCurrentAssignedModules cam
INNER JOIN @tblStartedModules sm ON sm.UserID = cam.UserID AND sm.ModuleID = cam.ModuleID,
tblCourse c,
tblUser u,
tblUnitHierarchy h
WHERE
c.CourseID = cam.CourseID
AND u.UserID = cam.UserID
AND h.UnitID = cam.UnitID
GROUP BY
c.[name], HierarchyName,  LastName, FirstName, ExternalID, Email, Username
HAVING
min(isnull(
QuizCompletionDate,
dateadd(month, QuizFrequency, DateTimeCompleted)
)) < CASE @warningUnit
WHEN ''mm'' THEN
dateadd(mm, @warningPeriod, getutcdate())
ELSE
dateadd(dd, @warningPeriod, getutcdate())
END
ORDER BY
CourseName, UnitPathway, LastName, FirstName
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_GetEndQuizInfo]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
read all information needed to end a quiz

Returns:
data table

Called By:
ToolBook.cs: GetEndQuizInfo

Remarks:

QuizStatusID Status
------------ --------------------------------------------------
0            Unassigned
1            Not Started
2            Passed
3            Failed
4            Expired (Time Elapsed)
5            Expired (New Content)

Author: Li Zhang
Date Created: 13-10-2006
Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		1/5/2007		Added LessonCompletionDate
**/

CREATE PROCEDURE [prcQuizSession_GetEndQuizInfo]
(
@quizSessionID varchar(50) -- unique that identifies this toolbook quiz session
, @duration int -- time used to complete the quiz
, @score int -- user quiz score
)
AS
SET nocount on
BEGIN
DECLARE @intUserID	int	-- user id
,		@intQuizID	int -- quiz id
,		@intPassMark	int	-- quiz pass mark
,		@intUnitID	int	-- user''s unit id
,		@intModuleID	int -- quiz module id
,		@intCourseID	int -- module course id
,		@intOldCourseStatus	int -- course status before update
,		@intNewQuizStatus int -- the quiz status
, 		@intNewCourseStatus	int	-- course status after update
,		@intQuizFrequency int
,		@dtmQuizCompletionDate datetime
DECLARE	@tblUserEndQuizInfo table	-- return table with all details needed to end a quiz
(
UserID	int
, QuizID int
, PassMark int
, UnitID int
, ModuleID int
, QuizFrequency int
, QuizCompletionDate datetime
, NewQuizStatus int
, OldCourseStatus int
, NewCourseStatus int
, CourseID int

)

--< read required data >--

SET @intUserID = dbo.udfGetUserIDBySessionID(@quizSessionID)
SET @intQuizID = dbo.udfGetQuizIDBySessionID(@quizSessionID)
SELECT @intUnitID = (SELECT TOP 1 UnitID FROM tblUser WHERE UserID = @intUserID)
SELECT @intModuleID = (SELECT TOP 1 ModuleID FROM tblQuiz WHERE QuizID = @intQuizID)
SET @intPassMark = dbo.udfQuiz_GetPassMark(@intUnitID, @intModuleID)
IF @score < @intPassMark
BEGIN
--< Quiz status: failed >--
SET @intNewQuizStatus = 3
END
IF @score > @intPassMark OR @score = @intPassMark
BEGIN
--< Quiz status: passed >--
SET @intNewQuizStatus = 2
END

SELECT @intCourseID = (SELECT TOP 1 CourseID FROM tblModule WHERE ModuleID = @intModuleID)
EXEC @intOldCourseStatus = prcUserCourseStatus_GetStatus @intCourseID, @intUserID
EXEC @intNewCourseStatus = prcUserCourseStatus_Calc @intCourseID, @intUserID,  @intNewQuizStatus,@intModuleID

--< get pre-defined quiz frequency from tblUnitRule >--
--< if the value is null then use the default quiz frequency in tblOrganisation >--

-- mikev(1): added QuizCompletionDate
SET @intQuizFrequency = (
SELECT  TOP 1   ISNULL(ur.QuizFrequency, o.DefaultQuizFrequency)
FROM   	tblUnitRule AS ur INNER JOIN tblUser AS u
ON ur.UnitID = u.UnitID
INNER JOIN tblOrganisation AS o ON u.OrganisationID = o.OrganisationID
WHERE	u.UserID = @intUserID
)

SET @dtmQuizCompletionDate = (
SELECT  TOP 1	ISNULL(ur.QuizCompletionDate, o.DefaultQuizCompletionDate)
FROM   	tblUnitRule AS ur INNER JOIN tblUser AS u
ON ur.UnitID = u.UnitID
INNER JOIN tblOrganisation AS o ON u.OrganisationID = o.OrganisationID
WHERE	u.UserID = @intUserID
)

INSERT INTO @tblUserEndQuizInfo ( UserID, QuizID, PassMark, UnitID, ModuleID, QuizFrequency, QuizCompletionDate, NewQuizStatus, OldCourseStatus, NewCourseStatus, CourseID)
VALUES (@intUserID, @intQuizID, @intPassMark, @intUnitID, @intModuleID, @intQuizFrequency,@dtmQuizCompletionDate,@intNewQuizStatus, @intOldCourseStatus, @intNewCourseStatus, @intCourseID)

SELECT * FROM @tblUserEndQuizInfo
END

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_EndQuiz]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
this proc records that a Quiz has ended by updating tblQuizSession
is Sets
-- DateTimeCompleted from getutcDate();
-- Duration from Toolbook
-- QuizScore from Toolbook
-- QuizPassMark passmark (Using prcQuiz_GetPassMark).
it also:
-- Checks that the Quiz has started -- if it has NOT -> return false
-- Checks that the Quiz has not already ended -- if it has -> return false



Returns:
boolean (bit) OK true = 1, false = 0

Called By:
ToolbookListener.cs via Businessservices.Toolbook.EndQuizSession

Calls:
udfQuiz_GetPassMark
udfGetUserIDBySessionID
udfGetQuizIDBySessionID

Remarks:

Author:
Stephen Kennedy-Clark
Date Created: 11 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


-----------
prcQuizSession_EndQuiz @quizSessionID =
select * from tblQuizSession

**/

CREATE   Procedure  [prcQuizSession_EndQuiz]
(
@quizSessionID	varchar(50) 	-- unique GUID that identifies this toolbook quiz session
, @duration	int		-- The duration in seconds of the quiz as messured by toolbook
, @score	int		-- the score as mesured by toolbook
)

As
--Begin Transaction
Set NoCount On
Set Xact_Abort On

------------------------------------------
-- Declerations
------------------------------------------
Declare   @intRetVal 	bit 		-- return value indicating sucess or failure
, @intUserID 	int		-- user id
, @intQuizID 	int		-- Quiz id
, @intPassMark 	int		-- Pass Mark
, @intUnitID 	int		-- Unit ID
, @intModuleID 	int		-- Module ID

------------------------------------------
-- initations
------------------------------------------
Set @intUserID	   = dbo.udfGetUserIDBySessionID(@quizSessionID)
Set @intQuizID	   = dbo.udfGetQuizIDBySessionID(@quizSessionID)
Select @intUnitID  = (Select Top 1 UnitID From tblUser Where UserID = @intUserID)
Select @intModuleID= (Select Top 1 ModuleID From tblQuiz Where QuizID = @intQuizID)
Set @intPassMark   = dbo.udfQuiz_GetPassMark(@intUnitID,@intModuleID)


------------------------------------------
-- Checks that the Quiz has started - if it has not -> return false
-- and
-- Checks that the Quiz has not already ended - if it has -> return false
-- If all is OK then end the Quiz by recording end time, duration and score
------------------------------------------
If Exists
(
Select
QuizSessionID
From
tblQuizSession
Where
QuizSessionID=@quizSessionID
--< Check that the Quiz has started >--
And DateTimeStarted Is Not Null
--< Check that the @quizSessionID has not already ended >--
And DateTimeCompleted Is Null
)


Begin --< it is ok to End, record End and return true >--
Update
[tblQuizSession]
Set
[DateTimeCompleted]	= getutcdate()
, [Duration]		= @duration
, [QuizScore]		= @score
, [QuizPassMark]	= @intPassMark

Where
[QuizSessionID]  	= @quizSessionID
set @intRetVal = 1 --< return 1 indicates sucess >--


End
Else
Begin  -- it is NOT ok to End, return false
set @intRetVal = 0
End


------------------------------------------
-- return
------------------------------------------

Select @intRetVal as ''OKToEnd''

--Commit Tran
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_BeforeStartQuiz]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Given a UserID and QuizID starts a Quiz and returns a QuizSessionID
Returns:
QuizSessionID guid

Called By:
ToolbookListener.cs

Calls:

Remarks:
starts a Quiz and returns the details of the Quiz Session so that it can be opened by salt

Author:
Peter Kneale
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date		Description
#1	GB		2/3/04		Added join to Module table in return select
#2 Removed unnecessary transactions

prcQuizSession_BeforeStartQuiz @UserID=11, @QuizID=1

**/

CREATE  Procedure [prcQuizSession_BeforeStartQuiz]
(
@userID int,		-- Users ID
@moduleID int		-- the Quiz ID
)

As

Set NoCount On
Set Xact_Abort On

------------------------------------------
-- Declarations
------------------------------------------
Declare @strQuizSessionID varchar(50)	-- GUID identifying the new session
Declare @intQuizID int			-- Quiz ID the user is starting

------------------------------------------
-- Start New Session
------------------------------------------
Set @strQuizSessionID = newid()

------------------------------------------
-- Start New Session
------------------------------------------
Set @intQuizID =
(
Select Top
1 QuizID
From
tblQuiz
Where
moduleID = @moduleID
And
Active=1
)
If (@intQuizID is NULL or datalength(@intQuizID) = 0)
Begin
Raiserror (''Procedure prcQuizSession_BeforeStartQuiz could not determine the @intQuizID'', 16, 1)
Return
End

------------------------------------------
-- Insert
------------------------------------------
Insert Into
tblQuizSession
(
QuizSessionID,
UserID,
QuizID
)
Values
(
@strQuizSessionID,
@userID,
@intQuizID
)

------------------------------------------
-- select Session Details: SessionID, ModuleName, CourseName and Location
------------------------------------------
Select Top 1
tblModule.[Name] 		As ''ModuleName'',
tblCourse.[Name] 		As ''CourseName'',
@strQuizSessionID 		As ''SessionID'',
tblQuiz.ToolbookLocation 	As ''Location''

From
tblModule
Inner Join tblQuiz
on tblQuiz.ModuleID 	= tblModule.ModuleID
Inner Join tblCourse
on tblCourse.CourseID	 = tblModule.CourseID

Where
tblModule.ModuleID = @moduleID
And
tblQuiz.Active = 1

Return
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetOneBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
Gets the course id for a session.
This proc is called by the home page

Parameters:
@sessionID


Returns:
table

Called By:
Course.cs.

Calls:
udfGetLessonIDBySessionID

Remarks:
no exceptions thrown

Author: Stephen Kennedy - Clark
Date Created: 4 March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


-- prcCourse_GetOneBySessionID @sessionID=''329E7586-81D3-45B2-A981-E7760435DDE4''

**/
CREATE   Procedure [prcCourse_GetOneBySessionID]
(
@sessionID varchar(50) = Null
)

As
-----------------------------------------------------------
-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Simple error check, if the session ID is not a valid guid then dont try and
-- get the course ID
if (dbo.udfIsGUID(@sessionID) = 0)
begin
select -1 as CourseID
return
end
if dbo.udfGetLessonIDBySessionID(@sessionID) is null and dbo.udfGetQuizIDBySessionID(@sessionID) is null
begin
select -1 as CourseID
return
end


--  The GUID is valid and exists
--  so get the details required form the underlying udfs
Select
tM.CourseID
From
tblModule tM
inner join tblLesson tL
on tL.ModuleID = tM.ModuleID
and tL.LessonID = dbo.udfGetLessonIDBySessionID(@sessionID)
union
Select
tM.CourseID
From
tblModule tM
inner join tblQuiz tQ
on tQ.ModuleID = tM.ModuleID
and tQ.QuizID = dbo.udfGetQuizIDBySessionID(@sessionID)




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfUser_GetAdministratorsOnBehalfOfEmailAddress]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE function [udfUser_GetAdministratorsOnBehalfOfEmailAddress]
(
@UserID	int
)
Returns varchar(100)
AS
BEGIN


DECLARE @Email VARCHAR(100)
SELECT @Email = dbo.udfGetEmailOnBehalfOf(0) -- udfGetEmailOnBehalfOf ignores the OrgID so don''t bother sending a correct OrgID


return @Email
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_New StartersToNotify]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

CREATE PROCEDURE [prcAutomatedEmails_New StartersToNotify]
(
@OrganisationID int
)


AS
Set Xact_Abort On
BEGIN

-- New Starter
SELECT userid,email,(SELECT dbo.udfUser_GetAdministratorsEmailAddress (U.UserID)) as SenderEmail, (SELECT Value + '' login details '' FROM tblAppConfig where Name = ''AppName''), REPLACE
(
(SELECT REPLACE
(
(SELECT REPLACE
(
(SELECT REPLACE
(
(SELECT REPLACE
(
(select
REPLACE(
(SELECT coalesce
(
(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_NewStarter'')
,
(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_NewStarter'')
)
)
,''%APP_NAME%'',
(SELECT Value FROM tblAppConfig where Name = ''AppName'')
)
)
,''%PASSWORD%'',U.PASSWORD
)
)
,''%USERNAME%'',U.USERNAME
)
)
,''%FirstName%'', COALESCE(U.FirstName,'''') 
)
)
,''%LastName%'', COALESCE(LastName,'''') 
)
)

,''%URL%'',(select(''<a href="'')+(SELECT CASE WHEN ''true'' = [Value] THEN ''HTTPS://'' ELSE ''http://'' END FROM tblAppConfig where Name = ''SSL'' )+ (SELECT COALESCE(DOMAINNAME,''localhost'')  + ''/Restricted/Login.aspx'' FROM tblOrganisation ORG WHERE ORG.OrganisationID =  @OrganisationID )+(''">'')+(SELECT Value FROM tblAppConfig where Name = ''AppName'')+(''</a>''))
)
, -- Sender"On Behalf Of" Email Address
(SELECT dbo.udfUser_GetAdministratorsOnBehalfOfEmailAddress (U.UserID))  as OnBehalfOfEmail

from tblUser U where  U.OrganisationID = @OrganisationID and U.active = 1 and U.NewStarter = 1

update tblUser set NewStarter = 0  where  OrganisationID = @OrganisationID and active = 1 and NewStarter = 1


END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZoneRule_update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'-- =============================================
-- Author:		Hitendra Jagtap
-- Create date: 18/06/2011
-- Description:	Updates the daylight saving rule for timeaone
-- =============================================
CREATE PROCEDURE [prcTimeZoneRule_update]
(
@RuleID int,
@WrittenName NVarChar(60),
@OffsetDaylight Int,
@year_start Int,
@year_end  Int,
@StartTimeOfDay Int,
@day_start Int,
@week_start Int,
@StartMonth Int,
@EndTimeOfDay Int,
@EndDayOfWeek Int,
@EndWeek Int,
@EndMonth Int,
@Error bit output
)
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

DECLARE @TimezoneID int
DECLARE @Period_start datetime, @Period_end datetime
exec prcTimeZone_GetTimeZoneID @WrittenName, @TimezoneID out
IF (@year_start < 1970) set @year_start = 1970  -- UNIX EPOCH
IF (@year_end > 2999) set @year_end = 2999		-- Y3K BUG?

-- Calculate the earlist start date and the last finish date
set @Period_start = ''1 jan 2000'' -- start with a known datetime
Set @Period_start = DATEADD(year,@year_start- 2000,@Period_start) -- then adjust it to match the definition
Set @Period_start = DATEADD(month,@StartMonth-1,@Period_start)
Set @Period_start = DATEADD(week,@week_start-1,@Period_start)
Declare @day_offset int
if (@day_start >=  DatePart(weekday,@Period_start) ) set @day_offset = @day_start -  DatePart(weekday,@Period_start) else  set @day_offset = @day_start -  DatePart(weekday,@Period_start) + 7
Set @Period_start = DATEADD(day,@day_offset,@Period_start)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_start) > @StartMonth) set @Period_start = DATEADD(week,-1,@Period_start)
SET @Period_start = DATEADD(minute, @StartTimeOfDay, @Period_start)

set @Period_end = ''1 jan 2000'' -- start with a known datetime
Set @Period_end = DATEADD(year,@year_end- 2000,@Period_end) -- then adjust it to match the definition
Set @Period_end = DATEADD(month,@EndMonth-1,@Period_end)
Set @Period_end = DATEADD(week,@EndWeek-1,@Period_end)
if (@EndDayOfWeek >=  DatePart(weekday,@Period_end) ) set @day_offset = @EndDayOfWeek -  DatePart(weekday,@Period_end) else  set @day_offset = @EndDayOfWeek -  DatePart(weekday,@Period_end) + 7
Set @Period_end = DATEADD(day,@day_offset,@Period_end)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_end) > @EndMonth) set @Period_end = DATEADD(week,-1,@Period_end)
SET @Period_end = DATEADD(minute, @EndTimeOfDay, @Period_end)

DECLARE @Existing int

SELECT @Existing = COUNT(*) FROM tblTimeZoneDaylightSavingRules
WHERE (first_start_date < @Period_end) AND (last_end_date > @Period_start)
AND TimezoneID = @TimezoneID AND TimezoneRuleID <> @RuleID

IF (@Existing <> 0)
BEGIN
SET @Error = 1
END
ELSE
BEGIN
UPDATE tblTimeZoneDaylightSavingRules SET
offset_mins=@OffsetDaylight
, start_year=@year_start
, end_year=@year_end
, hours_start=@StartTimeOfDay
, day_start=@day_start
, week_start=@week_start
, month_start=@StartMonth
, hours_end=@EndTimeOfDay
, day_end=@EndDayOfWeek
, week_end=@EndWeek
, month_end=@EndMonth
, first_start_date=@Period_start
, last_end_date=@Period_end
WHERE TimezoneID=@TimezoneID AND TimezoneRuleID=@RuleID

SET @Error = 0
END

SELECT @Error
END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcTimeZoneRule_add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcTimeZoneRule_add]
(
@WrittenName NVarChar(60),
@OffsetDaylight Int,
@year_start Int,
@year_end  Int,
@StartTimeOfDay Int,
@day_start Int,
@week_start Int,
@StartMonth Int,
@EndTimeOfDay Int,
@EndDayOfWeek Int,
@EndWeek Int,
@EndMonth Int,
@Error bit output
)
AS
BEGIN

DECLARE @TimezoneID int
DECLARE @Period_start datetime, @Period_end datetime
exec prcTimeZone_GetTimeZoneID @WrittenName, @TimezoneID out
IF (@year_start < 1970) set @year_start = 1970  -- UNIX EPOCH
IF (@year_end > 2999) set @year_end = 2999		-- Y3K BUG?



-- the first_start_date and last_end_date may cover a period of decades so we now have to decide if the rule is applied at the datetime given
-- so calculate the exact start and end dates and times for the relevant daylight saving period (in the year being considered)


-- start with a period (@Period_start datetime, @period_end datetime) that just has the correct year digits


--if  (@startmonth > @endmonth) set @year_start = @year_start - 1   -- rule spans december 31 so adjust

IF(@startmonth > @endmonth)  set @year_end = @year_end + 1  -- rule spans december 31 so adjust






-- Calculate the earlist start date and the last finish date
set @Period_start = ''1 jan 2000'' -- start with a known datetime
Set @Period_start = DATEADD(year,@year_start- 2000,@Period_start) -- then adjust it to match the definition
Set @Period_start = DATEADD(month,@StartMonth-1,@Period_start)
Set @Period_start = DATEADD(week,@week_start-1,@Period_start)
Declare @day_offset int
if (@day_start >=  DatePart(weekday,@Period_start) ) set @day_offset = @day_start -  DatePart(weekday,@Period_start) else  set @day_offset = @day_start -  DatePart(weekday,@Period_start) + 7
Set @Period_start = DATEADD(day,@day_offset,@Period_start)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_start) > @StartMonth) set @Period_start = DATEADD(week,-1,@Period_start)
SET @Period_start = DATEADD(minute, @StartTimeOfDay, @Period_start)

set @Period_end = ''1 jan 2000'' -- start with a known datetime
Set @Period_end = DATEADD(year,@year_end- 2000,@Period_end) -- then adjust it to match the definition
Set @Period_end = DATEADD(month,@EndMonth-1,@Period_end)
Set @Period_end = DATEADD(week,@EndWeek-1,@Period_end)
if (@EndDayOfWeek >=  DatePart(weekday,@Period_end) ) set @day_offset = @EndDayOfWeek -  DatePart(weekday,@Period_end) else  set @day_offset = @EndDayOfWeek -  DatePart(weekday,@Period_end) + 7
Set @Period_end = DATEADD(day,@day_offset,@Period_end)
-- We may have jumped to the next month if week = 5 so step back a week if necessary
if (DatePart(month,@Period_end) > @EndMonth) set @Period_end = DATEADD(week,-1,@Period_end)
SET @Period_end = DATEADD(minute, @EndTimeOfDay, @Period_end)

DECLARE @Existing int

SELECT @Existing = COUNT(*) FROM tblTimeZoneDaylightSavingRules
WHERE (first_start_date < @Period_end) AND (last_end_date > @Period_start)
AND TimezoneID = @TimezoneID

IF (@Existing <> 0)
BEGIN
SET @Error = 1
END
ELSE
BEGIN
INSERT INTO tblTimeZoneDaylightSavingRules
([TimezoneID]
,[offset_mins]
,[start_year]
,[end_year]
,[hours_start]
,[day_start]
,[week_start]
,[month_start]
,[hours_end]
,[day_end]
,[week_end]
,[month_end]
,[first_start_date]
,[last_end_date]
)
VALUES
(@TimezoneID,
@OffsetDaylight,
@year_start,
@year_end,
@StartTimeOfDay,
@day_start,
@week_start ,
@StartMonth ,
@EndTimeOfDay ,
@EndDayOfWeek ,
@EndWeek ,
@EndMonth,
@Period_start,
@Period_end
)
SET @Error = 0
END

SELECT @Error

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModuleStatusUpdateHistory_GetLastRun]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get the Module Status Updatelast run date time

Returns:

Called By:

Calls:
Nothing

Remarks:

Author: Jack Liu
Date Created: 26 March 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

prcModuleStatusUpdateHistory_GetLastRun

**/
CREATE Procedure [prcModuleStatusUpdateHistory_GetLastRun]

@OrgID int

AS
Set Nocount On
select dbo.udfUTCtoDaylightSavingTime((select  max(FinishTime) as LastRunDate
from tblModuleStatusUpdateHistory), @OrgID) as LastRunDate




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetSaltOrgDate]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'CREATE FUNCTION [udfGetSaltOrgDate]
(
@OrgID int

)
RETURNS DateTime
AS
BEGIN

DECLARE @ORGDate datetime

SELECT @ORGDate = CAST(convert( varchar(11), dbo.udfUTCtoDaylightSavingTime(GETUTCDATE(),@OrgID),113) AS DateTime)


RETURN @ORGDate

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcAutomatedEmails_UsersToNotify]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcAutomatedEmails_UsersToNotify]
(
@OrganisationID int
)


AS

BEGIN

declare @OrgMidnight datetime

set @OrgMidnight =  DATEADD(d,-1,dbo.udfGetSaltOrgMidnight(@OrganisationID))



--                    H O U S E K E E P I N G
--tblUserCourseDetails contains information on notifications about courses that have ''at risk'' quizes
--add any new courses
INSERT INTO tblUserCourseDetails (UserID,CourseID,UserCourseStatusID,NumberOfDelinquencyNotifications, NewStarterFlag, AtRiskQuizList, NotifiedModuleList, LastDelinquencyNotification)

select U.UserID,CourseID,UserCourseStatusID,0,null,'''','''',null
FROM  tblUser U inner join tblUserCourseStatus tUCS ON U.UserID = tUCS.UserID and U.OrganisationID = @organisationID  INNER JOIN
(SELECT MAX(UserCourseStatusID) AS MaxUserCourseStatusID
FROM   dbo.tblUserCourseStatus
GROUP BY UserID, CourseID) AS currentStatus ON tUCS.UserCourseStatusID = currentStatus.MaxUserCourseStatusID

where  CourseStatusID in (1,2) and UserCourseStatusID NOT IN (SELECT UserCourseStatusID FROM tblUserCourseDetails)






--remove data on courses that are now unassigned
DELETE FROM tblUserCourseDetails WHERE UserCourseStatusID IN
(SELECT UserCourseStatusID
FROM  tblUser U inner join tblUserCourseStatus tUCS ON U.UserID = tUCS.UserID and U.OrganisationID = @organisationID  INNER JOIN
(SELECT MAX(UserCourseStatusID) AS MaxUserCourseStatusID
FROM   dbo.tblUserCourseStatus
GROUP BY UserID, CourseID) AS currentStatus ON tUCS.UserCourseStatusID = currentStatus.MaxUserCourseStatusID

where  CourseStatusID = 0
)








--                    S E L E C T    T H E    R E S U L T S

--declare @OrganisationID int
--set @OrganisationID = 68

create table #UsersToNotify
(userid int not null
,NewContent nvarchar(max) null
,PassedCourses nvarchar(max) null
,PassedModules nvarchar(max) null
,AtRiskContent nvarchar(max) null
,AtRiskOfdelinquency nvarchar(max) null)



insert into #UsersToNotify
SELECT distinct UsersToNotify.userid , UsersToNotify.NewContent , PassedCourses, PassedModules ,AtRiskContent,AtRiskOfdelinquency FROM
(

SELECT '''' as UserCourseStatusID, tblExpiredNewContent.UserID , tblCourse.Name + '' - ''+ tblModule.Name as NewContent , '''' as PassedCourses ,'''' as PassedModules , '''' as AtRiskContent, '''' as AtRiskOfdelinquency
FROM  tblExpiredNewContent INNER JOIN
tblModule ON tblExpiredNewContent.ModuleID = tblModule.ModuleID INNER JOIN
tblCourse ON tblModule.CourseID = tblCourse.CourseID
WHERE tblExpiredNewContent.organisationID = @OrganisationID



-- users with passed courses
UNION all SELECT '''' as UserCourseStatusID, CS.userid , '''' as NewContent,''   ''+ C.Name as PassedCourses,'''' as PassedModules, '''' as AtRiskContent, '''' as AtRiskOfdelinquency
FROM tblUserCourseStatus CS
inner join tblUser U ON U.UserID = CS.UserID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
where U.OrganisationID = @OrganisationID and CS.CourseStatusID=2 and DATEDIFF(d,CS.DateCreated,@OrgMidnight) < 1


-- users with passed modules
UNION all SELECT '''' as UserCourseStatusID, QuizStatus.userid ,
'''' as NewContent, '''' as PassedCourses,
''   ''+c.name  + '' - '' + m.name as PassedModules, '''' as AtRiskContent,
'''' as AtRiskOfdelinquency
from
tblUserQuizStatus QuizStatus
join tblUser  u on u.UserID = QuizStatus.UserID and u.OrganisationID = @OrganisationID
inner join tblModule m on m.ModuleID = QuizStatus.ModuleID
join tblCourse c on c.CourseID = m.CourseID
inner join
(
select
max(UserQuizStatusID) UserQuizStatusID, uqs.UserID, uqs.ModuleID --UserQuizStatusID is identity
from
tblUserQuizStatus uqs
join tblUser  u on u.UserID = uqs.UserID
WHERE DATEDIFF(d,uqs.DateCreated,@OrgMidnight) < 1
and u.OrganisationID = @OrganisationID
group by
uqs.UserID,moduleID
) currentStatus
on QuizStatus.UserQuizStatusID = currentStatus.UserQuizStatusID
where m.active = 1
and QuizStatusID =2




-- users with quizes at risk ( N O R M A L    R U L E S )
UNION all SELECT DISTINCT '''' as UserCourseStatusID, AR.userID,  '''' as NewContent , '''' as PassedCourses,'''' as PassedModules,''   ''+ C.Name as AtRiskContent, '''' as AtRiskOfdelinquency
from tblQuizExpiryAtRisk AR
INNER JOIN tblUser U On U.UserID = AR.UserID
inner join tblModule M on m.ModuleID = AR.ModuleID and m.Active = 1 and AR.OrganisationID = @OrganisationID
INNER JOIN tblCourse C ON C.CourseID = M.CourseID
where U.Active = 1 AND daysToExpiry >= 0 and Notified = 0

-- users with quizes at risk ( N O R M A L    R U L E S )
UNION all SELECT DISTINCT '''' as UserCourseStatusID, AR.userID,  '''' as NewContent , '''' as PassedCourses,'''' as PassedModules,''   ''+ C.Name +'' ( ''+M.name +'') ''                       + convert(varchar (11),DATEADD(d,daysToExpiry, dbo.udfGetSaltOrgDate(@OrganisationID) ) ,113)  as AtRiskContent, '''' as AtRiskOfdelinquency
from tblQuizExpiryAtRisk AR
INNER JOIN tblUser U On U.UserID = AR.UserID
inner join tblModule M on m.ModuleID = AR.ModuleID and m.Active = 1 and AR.OrganisationID = @OrganisationID
INNER JOIN tblCourse C ON C.CourseID = M.CourseID
where U.Active = 1 AND daysToExpiry > 0 and Notified = 0




-- users with courses at risk of delinquency (1ST WARNING)
UNION all SELECT DISTINCT CD.UserCourseStatusID as UserCourseStatusID, CS.userID ,  '''' as NewContent , '''' as PassedCourses,'''' as PassedModules, '''' as AtRiskContent,''   ''+ C.Name +'' '' + convert(varchar (11),DATEADD(d,RemEsc.DaysToCompleteCourse, dbo.udfUTCtoDaylightSavingTime(CS.DateCreated,@OrganisationID)),113)  as AtRiskOfdelinquency
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID) AND (RemindUsers=1) 
where U.Active = 1 
AND CD.LastDelinquencyNotification IS NULL 
AND coursestatusid=1 
AND o.OrganisationID = @OrganisationID 
AND (GETUTCDATE() > DATEADD(d,RemEsc.DaysToCompleteCourse-RemEsc.NumOfRemNotfy*RemEsc.RepeatRem, CS.DateCreated))
AND (RemEsc.NumOfRemNotfy > cd.NumberOfDelinquencyNotifications)
AND (GETUTCDATE() < DATEADD(m,RemEsc.DaysToCompleteCourse+6, CS.DateCreated))  -- force a hard cutoff of three days after the course expired (not in business rules but required for upgraded 4.2.1 installs so users do not get notified of courses that expired years ago)


-- users with courses at risk of delinquency (SUBSEQUENT WARNINGS)
UNION all SELECT DISTINCT CD.UserCourseStatusID as UserCourseStatusID, CS.userID ,  '''' as NewContent , '''' as PassedCourses,'''' as PassedModules, '''' as AtRiskContent,''   ''+C.Name +'' '' + convert(varchar (11),DATEADD(d,RemEsc.DaysToCompleteCourse, dbo.udfUTCtoDaylightSavingTime(CS.DateCreated,@OrganisationID)),113)  as AtRiskOfdelinquency
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID) AND (RemindUsers=1) 
where  U.Active = 1 AND coursestatusid=1 AND o.OrganisationID = @OrganisationID AND CD.LastDelinquencyNotification IS NOT NULL 
AND (RemEsc.NumOfRemNotfy > cd.NumberOfDelinquencyNotifications) 
AND (GETUTCDATE() > DATEADD(d,RemEsc.RepeatRem, CD.LastDelinquencyNotification))
AND (GETUTCDATE() < DATEADD(m,RemEsc.DaysToCompleteCourse+6, CS.DateCreated))  -- force a hard cutoff of three days after the course expired (not in business rules but required for upgraded 4.2.1 installs so users do not get notified of courses that expired years ago)
) UsersToNotify


create index in_1 on #UsersToNotify(userid)



create table #UsersToNotifyList
(userid int not null
,NewContent nvarchar(max) null
,PassedCourses nvarchar(max) null
,PassedModules nvarchar(max) null
,AtRiskContent nvarchar(max) null
,AtRiskOfdelinquency nvarchar(max) null)

create index in_2 on #UsersToNotifyList(userid)

declare @userid int
,@NewContent nvarchar(max)
,@PassedCourses nvarchar(max)
,@PassedModules nvarchar(max)
,@AtRiskContent nvarchar(max)
,@AtRiskOfdelinquency nvarchar(max)

while exists (select 1 from #UsersToNotify)
begin
set rowcount 1
select @userid = userid
,@NewContent = NewContent
, @PassedCourses = PassedCourses
,@PassedModules = PassedModules
,@AtRiskContent = AtRiskContent
,@AtRiskOfdelinquency = AtRiskOfdelinquency

from #UsersToNotify
if exists (select * from #UsersToNotifyList where userid = @userid)
begin
update #UsersToNotifyList set
NewContent = rtrim(CAST(#UsersToNotifyList.NewContent + (case when #UsersToNotifyList.NewContent = '''' or @NewContent = '''' then '''' else ''<BR>&nbsp;&nbsp;'' end ) + @NewContent AS VARCHAR(max)))
, PassedCourses = rtrim(CAST(#UsersToNotifyList.PassedCourses + (case when #UsersToNotifyList.PassedCourses = '''' or @PassedCourses = '''' then '''' else ''<BR>&nbsp;&nbsp;'' end)+ @PassedCourses AS VARCHAR(max)))
,PassedModules = rtrim(CAST(#UsersToNotifyList.PassedModules + (case when #UsersToNotifyList.PassedModules = '''' or @PassedModules = '''' then '''' else ''<BR>&nbsp;&nbsp;'' end)+ @PassedModules AS VARCHAR(max)))
,AtRiskContent = rtrim(CAST(#UsersToNotifyList.AtRiskContent + (case when #UsersToNotifyList.AtRiskContent = '''' or @AtRiskContent = '''' then '''' else ''<BR>&nbsp;&nbsp;'' end)+ @AtRiskContent AS VARCHAR(max)))
,AtRiskOfdelinquency = rtrim(CAST(#UsersToNotifyList.AtRiskOfdelinquency + (case when #UsersToNotifyList.AtRiskOfdelinquency = '''' or @AtRiskOfdelinquency = '''' then '''' else ''<BR>&nbsp;&nbsp;'' end)+ @AtRiskOfdelinquency AS VARCHAR(max)))
from #UsersToNotifyList
where #UsersToNotifyList.userid = @userid
end
else
begin
insert #UsersToNotifyList(userid,NewContent,PassedCourses,PassedModules,AtRiskContent,AtRiskOfdelinquency)
values (@userid,@NewContent,@PassedCourses,@PassedModules,@AtRiskContent,@AtRiskOfdelinquency)

end
delete #UsersToNotify where
@userid = userid
and @NewContent = NewContent
and  @PassedCourses = PassedCourses
and  @PassedModules = PassedModules
and @AtRiskContent = AtRiskContent
and  @AtRiskOfdelinquency = AtRiskOfdelinquency
set rowcount 0
end


SELECT l.UserID,
-- Recipient Email Address
(SELECT Email FROM tblUser WHERE UserID = l.UserID) as RecipientEmail,

-- Sender Email Address
(SELECT dbo.udfUser_GetAdministratorsEmailAddress (l.UserID)) as SenderEmail,

-- Subject
(select REPLACE(
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_Subject'')

,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_Subject''))),''%APP_NAME%'',(SELECT Value FROM tblAppConfig where Name = ''AppName''))) as Subject,



-- Header
(select coalesce((select REPLACE(
	(select REPLACE(
		(select REPLACE(
			(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_Header'')
			,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_Header'')))
		,''%APP_NAME%'',(SELECT Value FROM tblAppConfig where Name = ''AppName'')))
	,''%FirstName%'',(SELECT COALESCE(FirstName,'''') FROM tblUser WHERE UserID = l.UserID)))
,''%LastName%'',(SELECT COALESCE(LastName,'''') FROM tblUser WHERE UserID = l.UserID))),''header error''))


--New Content
+ (select coalesce(case when NewContent = '''' then '''' else
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_ExpiredContent'')

,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_ExpiredContent'')))+NewContent+ ''<BR>'' end,''error reading Student_Summary_ExpiredContent''))

--Passed Courses
+ (select coalesce(case when PassedCourses = '''' then '''' else
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_PassedCourses'')

,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_PassedCourses'')))+PassedCourses+ ''<BR>'' end,''error reading Student_Summary_PassedCourses''))

--Passed Modules
+ (select coalesce(case when PassedModules = '''' then '''' else
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_PassedModules'')

,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_PassedModules'')))+PassedModules+ ''<BR>'' end,''error reading Student_Summary_PassedModules''))

--AtRiskContent
+ (select coalesce(case when AtRiskContent = '''' then '''' else
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_AtRiskOfExpiry'')

,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_AtRiskOfExpiry'')))+AtRiskContent+ ''<BR>'' end,''error reading Student_Summary_AtRiskOfExpiry''))

--AtRiskOfdelinquency
+ (select coalesce(case when AtRiskOfdelinquency = '''' then '''' else
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_AtRiskOfBeingOverdue'')

,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_AtRiskOfBeingOverdue'')))+AtRiskOfdelinquency+ ''<BR>'' end,''error reading Student_Summary_AtRiskOfBeingOverdue''))

--Email Sig
+     (select REPLACE(
(SELECT coalesce( (SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID = @OrganisationID AND Name = ''Student_Summary_Sig'')

,(SELECT  Value FROM tblOrganisationConfig WHERE OrganisationID IS NULL AND Name = ''Student_Summary_Sig'')))+ ''<BR>''  ,''%APP_NAME%'',(SELECT Value FROM tblAppConfig where Name = ''AppName''))) as Body
, -- Sender"On Behalf Of" Email Address
(SELECT dbo.udfUser_GetAdministratorsOnBehalfOfEmailAddress (l.UserID))  as OnBehalfOfEmail,


*

FROM
#UsersToNotifyList l




--                    H O U S E K E E P I N G  (tidy up for tomorrow)

-- Update record of "at risk of Delinquency" notifications
-- Update tblUserCourseDetails.LastDelinquencyNotification
UPDATE tblUserCourseDetails  SET LastDelinquencyNotification = GETUTCDATE()
WHERE  UserCourseStatusID in (-- users with courses at risk of delinquency (1ST WARNING)
SELECT DISTINCT CD.UserCourseStatusID
--FROM tblUserCourseStatus CS
--INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
--INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
--INNER JOIN tblUser U On U.UserID = CS.UserID
--INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID where  CD.LastDelinquencyNotification IS NULL AND coursestatusid=1 AND o.OrganisationID = @OrganisationID AND (DATEADD(d,o.DelinquencyPeriod, CS.DateCreated) > GETUTCDATE()) AND (O.NumberOfReminders > cd.NumberOfDelinquencyNotifications)
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID) AND (RemindUsers=1) 
where U.Active = 1 
AND CD.LastDelinquencyNotification IS NULL 
AND coursestatusid=1 
AND o.OrganisationID = @OrganisationID 
AND (GETUTCDATE() > DATEADD(d,RemEsc.DaysToCompleteCourse-RemEsc.NumOfRemNotfy*RemEsc.RepeatRem, CS.DateCreated))
AND (RemEsc.NumOfRemNotfy > cd.NumberOfDelinquencyNotifications)

)

UPDATE tblUserCourseDetails  SET LastDelinquencyNotification = GETUTCDATE(), NumberOfDelinquencyNotifications = NumberOfDelinquencyNotifications + 1
WHERE  UserCourseStatusID in (-- users with courses at risk of delinquency (SUBSEQUENT WARNINGS)
SELECT DISTINCT CD.UserCourseStatusID
--FROM tblUserCourseStatus CS
--INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
--INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
--INNER JOIN tblUser U On U.UserID = CS.UserID
--INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID where  coursestatusid=1 AND o.OrganisationID = @OrganisationID AND CD.LastDelinquencyNotification IS NOT NULL AND (O.NumberOfReminders > cd.NumberOfDelinquencyNotifications) AND ( DATEADD(D,O.DelinquencyReminderPeriod, CD.LastDelinquencyNotification) > GETUTCDATE())
FROM tblUserCourseStatus CS
INNER JOIN tblUserCourseDetails CD ON CD.UserID = CS.UserID AND CD.CourseID = CS.CourseID
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
INNER JOIN tblUser U On U.UserID = CS.UserID
INNER JOIN tblOrganisation O on o.OrganisationID = u.OrganisationID
INNER JOIN tblReminderEscalation RemEsc ON (RemEsc.OrgId = o.OrganisationID) AND (RemEsc.CourseId = C.CourseID) AND (RemindUsers=1) 
where  U.Active = 1 AND coursestatusid=1 AND o.OrganisationID = @OrganisationID AND CD.LastDelinquencyNotification IS NOT NULL 
AND (RemEsc.NumOfRemNotfy > cd.NumberOfDelinquencyNotifications) 
AND (GETUTCDATE() > DATEADD(d,RemEsc.RepeatRem, CD.LastDelinquencyNotification))

)

/*-- Update Record of notified NEW Modules
UPDATE tblUserCourseDetails  SET NotifiedModuleList =  ModulesAssigned  from
(SELECT UserCourseStatusID, ModulesAssigned
FROM (select tUCS.ModulesAssigned, tUCS.CourseID,tUCS.CourseStatusID,tUCS.UserCourseStatusID as UCSUserCourseStatusID
FROM  tblUser U inner join tblUserCourseStatus tUCS ON U.UserID = tUCS.UserID and U.OrganisationID = 9   INNER JOIN

(SELECT MAX(UserCourseStatusID) AS MaxUserCourseStatusID
FROM   dbo.tblUserCourseStatus
GROUP BY UserID, CourseID) AS currentStatus ON tUCS.UserCourseStatusID = currentStatus.MaxUserCourseStatusID) CS
INNER JOIN tblCourse C ON C.CourseID = CS.CourseID
Inner join tblUserCourseDetails CD on  CD.UserCourseStatusID = CS.UCSUserCourseStatusID
and  CS.CourseStatusID=1
) temp
where tblUserCourseDetails.UserCourseStatusID = temp.UserCourseStatusID*/


DELETE FROM tblExpiredNewContent WHERE organisationID = @OrganisationID



-- Update record of notified "At Risk Quizes"
-- users with quizes at risk ( N O R M A L    R U L E S )
update tblQuizExpiryAtRisk SET Notified = 1 WHERE organisationID = @OrganisationID and Notified = 0


if OBJECT_ID(''#UsersToNotifyList'') is not null
begin
drop table #UsersToNotifyList
end

if  OBJECT_ID(''#UsersToNotify'')is not null
begin
drop table #UsersToNotify
END

END
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetPolicies]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get''s a list of policies for an organisation

Parameters:
@OrganisationID int,

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcOrganisation_GetPolicies]
(
@OrganisationID int
)
as

select
PolicyID,
PolicyName,
Active,
PolicyFileName,
PolicyFileSize
from tblPolicy
where
OrganisationID = @OrganisationID
and deleted = 0
order by PolicyName

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Gets othe details of one Organisation
Parameters: @orgID integer
Returns: OrganisationID, OrganisationName,  Logo, Notes, DefaultLessonFrequency, DefaultQuizFrequency, DefaultQuizPassMark, CreatedBy, DateCreated,  UpdatedBy, DateUpdated

Called By: Organisation.cs
Calls: None

Remarks: Raises an error if the parameter is null

Author: Peter Vranich
Date Created: 4th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	aaronc		May 2008		Added retrieval of CPDReportName
#2	aaronc		June2008		Added retrieval of AllocatedDiskSpace
*/

CREATE procedure [prcOrganisation_GetOne]
(
	@LangCode nvarchar(10),
	@orgID Integer = null -- OrganisationID
)

As
BEGIN

	If @orgID Is Null
	Begin
		Raiserror(''''''''''The Parameter @orgID was null.  @orgID does not accept Null values.'''''''''', 16, 1)
		Return
	End

	Select
		o.OrganisationID,
		o.OrganisationName,
		o.Logo,
		orgN.Notes,
		o.DefaultLessonFrequency,
		o.DefaultQuizFrequency,
		o.DefaultQuizPassMark,
		dbo.udfUTCtoDaylightSavingTime(o.DefaultLessonCompletionDate, o.OrganisationID) as DefaultLessonCompletionDate,
		dbo.udfUTCtoDaylightSavingTime(o.DefaultQuizCompletionDate, o.OrganisationID) as DefaultQuizCompletionDate,
		o.AdvancedReporting,
		o.CreatedBy,
		dbo.udfUTCtoDaylightSavingTime(o.DateCreated, o.OrganisationID) as DateCreated,
		o.UpdatedBy,
		dbo.udfUTCtoDaylightSavingTime(o.DateUpdated, o.OrganisationID)as DateUpdated,
		o.CPDReportName,
		o.AllocatedDiskSpace,
		o.IncludeCertificateLogo,
		o.PasswordLockout,
		o.TimeZoneID,
		o.IncludeLogoOnCorrespondence,
		o.QuizDueDate,
		o.ShowLastPassed
	From
		tblOrganisation o
		left join tblOrganisationNotes orgN	on o.OrganisationID = orgN.OrganisationID
		left join tblLang l	on orgN.LanguageID = l.LangID
	Where
		o.OrganisationID = @orgID
		and l.LangCode = @LangCode

END

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Gets a list of all Organisation
Parameters: None
Returns: OrganisationID, OrganisationName,  Logo, Notes, DefaultLessonFrequency, DefaultQuizFrequency, DefaultQuizPassMark, CreatedBy, DateCreated,  UpdatedBy, DateUpdated

Called By: Header.ascx
Calls: None

Remarks: None

Author: Peter Vranich
Date Created: 28th of January 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcOrganisation_GetList]

As

Select
OrganisationID,
OrganisationName,
Logo,
Notes,
DefaultLessonFrequency,
DefaultQuizFrequency,
DefaultQuizPassMark,
dbo.udfUTCtoDaylightSavingTime(DefaultLessonCompletionDate, OrganisationID),
dbo.udfUTCtoDaylightSavingTime(DefaultQuizCompletionDate, OrganisationID),
DomainName,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, OrganisationID),
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, OrganisationID)
From
tblOrganisation
order by OrganisationName


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetCPDPolicyAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Gets a list of Organisation CPD and Policy access
Parameters: None
Returns: OrganisationID, grantCPDAccess, grantPolicyAccess

Called By: Components/BusinessServices/Organisation.cs
Calls: None

Remarks: Displays CPD and Policy access data for grdOrganisationList on
\Administration\Application\OrganisationApplicationAccess.aspx page

Author: Aaron Cripps
Date Created: May 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcOrganisation_GetCPDPolicyAccess]

As

select
tblOrganisation.OrganisationID,
OrganisationName,
grantCPDAccess,
grantPolicyAccess
from
tblOrganisation left join tblOrganisationCPDAccess
on tblOrganisation.OrganisationID = tblOrganisationCPDAccess.OrganisationID
left join tblOrganisationPolicyAccess
on tblOrganisation.OrganisationID = tblOrganisationPolicyAccess.OrganisationID
order by OrganisationName


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetCPDAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Saves Organisation CPD and Policy access information
Parameters: @OrganisationName int, @grantCPDAccess bit, grantPolicyAccess bit
Returns: nothing

Called By: Components/BusinessServices/Organisation.cs
Calls: None

Remarks: Gets CPD access for a particular organisation

Author: Aaron Cripps
Date Created: May 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcOrganisation_GetCPDAccess]
(
@OrganisationID int
)

As

select GrantCPDAccess from tblOrganisationCPDAccess where organisationID = @OrganisationID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetCourseAccessList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary:
Gets a list of all Courses and flags which one the organisation has access to.

Parameters:
@organisationID Integer

Returns:
CourseID
Name
Notes
Active
Granted
CreatedBy
DateCreated
UpdatedBy
DateUpdated

Called By:
Course.cs
Calls: None

Remarks: None

Author: Peter Vranich
Date Created: 19th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcOrganisation_GetCourseAccessList]
(
@organisationID Integer -- The ID of the organisation that you wish to get the course access list for.
)

As

Set NoCount On

Select
CourseID,
Name,
Notes,
Active,
Case
When toca.GrantedCourseID Is Not Null Then 1
Else 0
End As Granted,
CreatedBy,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @organisationID),
UpdatedBy,
dbo.udfUTCtoDaylightSavingTime(DateUpdated, @organisationID)
From
tblCourse As tc
Left Outer Join tblOrganisationCourseAccess As toca
On tc.CourseID = toca.GrantedCourseID
And toca.OrganisationID = @organisationID
Order By
Name


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_Create]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Creates a new entry in the error log.
Returns:
Nothing.

Called By:
ErrorLog Class.

Calls:
Nothing
Remarks:
This procedure creates an entry in the error log when an error is raised.
The Date Created field will be stamped with the current date and time.

Author:
Peter Kneale
Date Created: 9 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcErrorLog_Create ''Source'', ''Module'', ''Function'', ''Code'', ''Message'', ''StackTrace'', 1
**/

CREATE Procedure [prcErrorLog_Create]

@strSource varchar(1000) ,		-- Source of Error
@strModule varchar(100), 		-- Module Error occured in
@strFunction varchar(100), 		-- Function Error occured in
@strCode varchar(100), 			-- Code executing when error occurred
@strMessage varchar(500), 		-- Message from exception
@strStackTrace varchar(8000), 		-- Complete stack trace from exception
@intErrorLevel int			-- Error Level from tblErrorLevel

AS
Set NoCount On
Set Xact_Abort On
Begin Tran

Insert Into
tblErrorLog
(
Source,
Module,
[Function],
Code,
Message,
StackTrace,
ErrorLevel,
DateCreated,
DateUpdated
)
Values
(
@strSource,
@strModule,
@strFunction,
@strCode,
@strMessage,
@strStackTrace,
@intErrorLevel,
GetUTCDate(),
GetUTCDate()
)

Commit Tran
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEmail_Search]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
The procedure will search email sent within the selected date range to a email and contain text in subject or body

Returns:


Called By:
Calls:

Remarks:


Author: Jack Liu
Date Created: 25 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
select * from tblEmail


prcEmail_Search''20040102'',''20040228'','''','''',''''

**/

CREATE  PROCEDURE [prcEmail_Search]
(

@dateFrom  datetime,
@dateTo  datetime,
@toEmail nvarchar(50),
@subject nvarchar(50),
@body nvarchar(50),
@organisationID int
)
as
set nocount on

set @dateFrom = dbo.udfDaylightSavingTimeToUTC(@dateFrom, @organisationID)
set @dateTo = dbo.udfDaylightSavingTimeToUTC(@dateTo, @organisationID)

if @toEmail=''''
set @toEmail=null

if @subject=''''
set @subject=null

if @body=''''
set @body=null


select  ToEmail,
subject,
body,
dbo.udfUTCtoDaylightSavingTime(DateCreated, @organisationID) as DateCreated
from tblEmail
where Datediff(day, @dateFrom, DateCreated)>=0
and  Datediff(day,  @dateTo, DateCreated)<=0
and (@toEmail is null  or toEmail =@toEmail)
and (@subject is null  or subject like ''%''+ @subject +''%'')
and (@body is null  or body   like ''%''+ @body +''%'')
and OrganisationID = IsNull(@organisationID,OrganisationID)
order by datecreated
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_Get]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Gets a policy

Parameters:
@PolicyID int,

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcPolicy_Get]
(
@PolicyID int,
@OrgID int
)
as

select
PolicyID,
OrganisationID,
PolicyName,
Active,
Deleted,
PolicyFileName,
PolicyFileSize,
dbo.udfUTCtoDaylightSavingTime(UploadDate, @OrgID),
ConfirmationMessage
from tblPolicy
where
PolicyID = @PolicyID
and deleted = 0


' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_CheckPolicyName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Stored procedure to check if a Policy with the same name
as that being created already exists

Parameters:
@OrganisationID int
@PolicyName nvarchar(255)

Called By:
policydetails.aspx

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

*/
create procedure [prcPolicy_CheckPolicyName]
(
@OrganisationID int,
@PolicyName nvarchar(255)
)
as

select PolicyName
from tblPolicy
where OrganisationID = @OrganisationID
and PolicyName = @PolicyName
and deleted = 0

' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_CheckFileName]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Stored procedure to check if a Policy with the same filename
as that being uploaded already exists on the server

Parameters:
@OrganisationID int
@PolicyFileName nvarchar(255)

Called By:
policydetails.aspx

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

*/
create procedure [prcPolicy_CheckFileName]
(
@OrganisationID int,
@PolicyFileName nvarchar(255)
)
as

select PolicyFileName
from tblPolicy
where OrganisationID = @OrganisationID
and PolicyFileName = @PolicyFileName
and Deleted = 0

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_UpdateCPDPolicyAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Saves Organisation CPD and Policy access information
Parameters: @OrganisationName int, @grantCPDAccess bit, grantPolicyAccess bit
Returns: nothing

Called By: Components/BusinessServices/Organisation.cs
Calls: None

Remarks: Updates CPD and Policy access data when btnSaveAll pressed on
\Administration\Application\OrganisationApplicationAccess.aspx page

Author: Aaron Cripps
Date Created: May 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcOrganisation_UpdateCPDPolicyAccess]
(
@OrganisationID int,
@grantCPDAccess int,
@grantPolicyAccess int
)

As

update tblOrganisationCPDAccess
set grantCPDAccess = @grantCPDAccess
where OrganisationID = @OrganisationID

update tblOrganisationPolicyAccess
set grantPolicyAccess = @grantPolicyAccess
where OrganisationID = @OrganisationID


' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisationConfig_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
Updates a Client Config Entry if it exists.
Creates a Client Config Entry if it doesnt.


Parameters:
@OrganisationID
@Name
@Description
@Value

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Link.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
2. FK constraint
5. MissingParameterException



Author: Peter Kneale
Date Created: 16 August 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE    Procedure [prcOrganisationConfig_Update]
(
@OrganisationID	Integer=null,
@Name		    nVarchar(255)=null,
@Description	nVarchar(255)=null,
@Value		    nVarchar(4000)=null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @OrganisationID
If(@OrganisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @OrganisationID in stored procedure prcOrganisationConfig_Update''
Goto Finalise
End
--Validate Parameter @Name
If(@Name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @Name in stored procedure prcOrganisationConfig_Update''
Goto Finalise
End
--Validate Parameter @Description
If(@Description Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @Description in stored procedure prcOrganisationConfig_Update''
Goto Finalise
End
-- Validate that the Organsiation exists exist.
If Not Exists(Select * From tblOrganisation Where [OrganisationID] = @OrganisationID)
Begin
Set @intErrorNumber = 2
Set @strErrorMessage = ''The Organisation '' + cast(@OrganisationID as varchar) + '' doesnt exist.''
Goto Finalise
End
-- Validate that the Name exists exist.
If Not Exists(Select * From tblOrganisationConfig Where [Name] = @Name)
Begin
Set @intErrorNumber = 21
Set @strErrorMessage = ''The Name '' + @Name + '' doesnt exist.''
Goto Finalise
End

Begin
INSERT INTO [tblOrganisationConfig]
([OrganisationID], 	[Name], [Description],	[Value])
VALUES
(@OrganisationID,	@Name, @Description,	@Value)
End

-- Finalise the procedure
Goto Finalise



Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End





' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisationConfig_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary: Get a single client configuration values
Parameters:
Returns:

Called By:
Calls:

Remarks:

Author: Peter Kneale
Date Created: 16 August 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcOrganisationConfig_GetOne]
@organisationID 	Int,
@name			nVarchar(255)
As

Set Nocount On

If Exists (Select OrganisationID From tblOrganisationConfig Where OrganisationID = @organisationID And [Name]	= @Name)
Begin
Select
[Value]
From
tblOrganisationConfig
Where
OrganisationID	= @organisationID
And
[Name]		= @Name
Order by
[Name]
End
Else
Begin
Select
[Value]
From
tblOrganisationConfig
Where
OrganisationID	= null
And
[Name]		= @Name
Order by
[Name]
End


' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisationConfig_GetList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*
Summary: Get a list of client configuration values
Parameters:
Returns:

Called By:
Calls:

Remarks:

Author: Peter Kneale
Date Created: 16 August 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE   Procedure [prcOrganisationConfig_GetList]
@organisationID 	Int
As

Set Nocount On

-- This returns the specific org values
Select
0 as ''Default'',
[Name],
[Description],
[Value]
From
tblOrganisationConfig
Where
OrganisationID = @organisationID
UNION
-- And unions it with the default ones.
Select
-1 as ''Default'',
[Name],
[Description],
[Value]
From tblOrganisationConfig

Where Name not in
(
select [Name] from tblOrganisationConfig where organisationID = @organisationID
)
And
OrganisationID is Null

Order By
[Name]




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisationConfig_Delete]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'




/*Summary:
Deletes a Client Config Entry.

Parameters:
@OrganisationID
@Name

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
OrganisationConfiguration.aspx

Calls:
Nothing

Remarks:
Exception:
0. Succeed
1. RecordNotFound
2. FK constraint
3. PKViolationException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)


Author: Peter Kneale
Date Created: 16 August 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/
CREATE     Procedure [prcOrganisationConfig_Delete]
(
@OrganisationID	Integer=null,
@Name		nVarchar(255)=null
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @OrganisationID
If(@OrganisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @OrganisationID in stored procedure prcOrganisationConfig_Delete''
Goto Finalise
End
--Validate Parameter @Name
If(@Name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @Name in stored procedure prcOrganisationConfig_Delete''
Goto Finalise
End
-- Validate that the Organsiation exists exist.
If Not Exists(Select * From tblOrganisation Where [OrganisationID] = @OrganisationID)
Begin
Set @intErrorNumber = 2
Set @strErrorMessage = ''The Organisation '' + cast(@OrganisationID as varchar) + '' doesnt exist.''
Goto Finalise
End
-- Validate that the Name exists exist.
If Not Exists(Select * From tblOrganisationConfig Where [Name] = @Name)
Begin
Set @intErrorNumber = 21
Set @strErrorMessage = ''The Name '' + @Name + '' doesnt exist.''
Goto Finalise
End

DELETE FROM
[tblOrganisationConfig]
WHERE
[OrganisationID] 	= @OrganisationID
and
[Name]			= @Name

-- Finalise the procedure
Goto Finalise



Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End






' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcEscalationConfigForCourse_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE PROCEDURE [prcEscalationConfigForCourse_Update]
(
	@remEscID int = -1,
	@orgID int ,
	@courseID int  = -1,
	@updateOption int =-1,
	@DaysToCompleteCourse int,
	@RemindUsers bit=0,
	@NumOfRemNotfy int =-1,
	@RepeatRem int =-1,
	@NotifyMgr bit =0,
	@IndividualNotification bit =0,
	@IsCumulative bit =0,
	@NotifyMgrDays int=-1,
	@QuizExpiryWarn bit =0,
	@DaysQuizExpiry int =-1	
)
AS
BEGIN
	
	if @updateOption =0 and @remEscID >0
	begin
		--update for one course 
		update 
			tblReminderEscalation
		set 
			DaysToCompleteCourse = @DaysToCompleteCourse,
			RemindUsers = @RemindUsers,
			NumOfRemNotfy = @NumOfRemNotfy,
			RepeatRem = @RepeatRem,
			NotifyMgr = @NotifyMgr,
			IndividualNotification = @IndividualNotification,
			IsCumulative = @IsCumulative,
			NotifyMgrDays = @NotifyMgrDays,
			QuizExpiryWarn = @QuizExpiryWarn,
			DaysQuizExpiry = @DaysQuizExpiry			
		where
			OrgId =@orgID
			and CourseId = @courseID
	end	
	else if @updateOption =0 and @remEscID =-1
	begin 
		
		insert into tblReminderEscalation (
			OrgId,
			CourseId,
			DaysToCompleteCourse,
			RemindUsers,
			NumOfRemNotfy,
			RepeatRem,
			NotifyMgr,
			IndividualNotification,
			IsCumulative,
			NotifyMgrDays,
			QuizExpiryWarn,
			DaysQuizExpiry )
		values(
			@orgID,
			@courseID,
			@DaysToCompleteCourse,
			@RemindUsers,
			@NumOfRemNotfy,
			@RepeatRem,
			@NotifyMgr,
			@IndividualNotification,
			@IsCumulative,
			@NotifyMgrDays,
			@QuizExpiryWarn,
			@DaysQuizExpiry
			)
			
	end
	else if @updateOption =1 begin
		--update configured 
		update 
			tblReminderEscalation
		set
			DaysToCompleteCourse = @DaysToCompleteCourse,
			RemindUsers = @RemindUsers,
			NumOfRemNotfy = @NumOfRemNotfy,
			RepeatRem = @RepeatRem,
			NotifyMgr = @NotifyMgr,
			IndividualNotification = @IndividualNotification,
			IsCumulative = @IsCumulative,
			NotifyMgrDays = @NotifyMgrDays,
			QuizExpiryWarn = @QuizExpiryWarn,
			DaysQuizExpiry = @DaysQuizExpiry
		where 
			OrgId =@orgID
	END
	
	-- this will get done for both options 1 and 2
	if @updateOption >0
	begin
		-- all unconfigured
		insert into tblReminderEscalation (
			OrgId,
			CourseId,
			DaysToCompleteCourse,
			RemindUsers,
			NumOfRemNotfy,
			RepeatRem,
			NotifyMgr,
			IndividualNotification,
			IsCumulative,
			NotifyMgrDays,
			QuizExpiryWarn,
			DaysQuizExpiry )
		select				
			oca.OrganisationID,
			oca.GrantedCourseID,
			@DaysToCompleteCourse,
			@RemindUsers,
			@NumOfRemNotfy,
			@RepeatRem,
			@NotifyMgr,
			@IndividualNotification,
			@IsCumulative,
			@NotifyMgrDays,
			@QuizExpiryWarn,
			@DaysQuizExpiry			
		from 
			tblOrganisationCourseAccess oca
			left join tblReminderEscalation re on re.OrgId = oca.OrganisationID and oca.GrantedCourseID = re.CourseId
		where 		
			OrganisationID= @orgID
			and re.RemEscId is null
	end
	
	
	
END' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
Create Procedure [prcErrorLog_Update]

@ErrorLogID	int,
@ErrorLevel	int,
@ErrorStatus	int,
@Resolution	varchar(1000)
as

UPDATE [tblErrorLog]

SET

[ErrorLevel]=@ErrorLevel,
[ErrorStatus]=@ErrorStatus,
[Resolution]=@Resolution

WHERE
[ErrorLogID] = @ErrorLogID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_GetReport]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Returns an report of the most recent errors and when they occured.
Errors containing the exact same Module, Function, Code and Stack Trace
are assumed to be the same error.
Returns:
A Summary of the tblErrorLog table

Called By:
ErrorLog Class.

Calls:
Nothing
Remarks:
None.

Author:
Peter Kneale
Date Created: 9 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcErrorLog_GetReport
**/
CREATE Procedure [prcErrorLog_GetReport]

@OrgID int

As

Set NoCount On

SELECT
[ErrorLogID],
[Source],
[Module],
[Function],
[Code],
[Message],
[StackTrace],
[ErrorLevel],
[ErrorLevelDescription],
[ErrorStatusDescription],
[ErrorStatus],
[Resolution],
dbo.udfUTCtoDaylightSavingTime([DateCreated], @OrgID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime([DateUpdated], @OrgID) as DateUpdated
FROM
tblErrorLog
Inner Join
tblErrorLevel
on
tblErrorLog.[ErrorLevel] = tblErrorLevel.[ErrorLevelID]
Inner Join
tblErrorStatus
on
tblErrorLog.[ErrorStatus] = tblErrorStatus.[ErrorStatusID]
Order by
DateCreated desc
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcErrorLog_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Returns a single error
Returns:
A single error of the tblErrorLog table

Called By:
ErrorLog Class.

Calls:
Nothing
Remarks:
None.

Author:
Peter Kneale
Date Created: 9 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


prcErrorLog_GetReport
**/
CREATE Procedure [prcErrorLog_GetOne]
@ErrorLogID int,
@OrgID int

As

Set NoCount On

SELECT
[ErrorLogID],
[Source],
[Module],
[Function],
[Code],
[Message],
[StackTrace],
[ErrorLevel],
[ErrorLevelDescription],
[ErrorStatusDescription],
[ErrorStatus],
[Resolution],
dbo.udfUTCtoDaylightSavingTime([DateCreated], @OrgID) as DateCreated,
dbo.udfUTCtoDaylightSavingTime([DateUpdated], @OrgID) as DateUpdated
FROM
tblErrorLog
Inner Join
tblErrorLevel
on
tblErrorLog.[ErrorLevel] = tblErrorLevel.[ErrorLevelID]
Inner Join
tblErrorStatus
on
tblErrorLog.[ErrorStatus] = tblErrorStatus.[ErrorStatusID]
Where
ErrorLogID = @ErrorLogID



' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetOne]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets a list of all Courses
Parameters: CourseID int
Returns: table

Called By: BusinessServices.Course.GetCourse
Calls: None

Remarks: None

Author: Stephen Kenendy-Clark
Date Created: 06th of Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE   Procedure [prcCourse_GetOne]
(
@CourseID  int=null -- the course id
, @OrgID int
)

As

Select
[CourseID]
, [Name]
, [Notes]
, [Active]
, [CreatedBy]
, dbo.udfUTCtoDaylightSavingTime([DateCreated], @OrgID) as DateCreated
, [UpdatedBy]
, dbo.udfUTCtoDaylightSavingTime([DateUpdated], @OrgID) as DateUpdated
From
[tblCourse]
Where
CourseID = @CourseID
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetListByOrganisation]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'




/*
Summary: Gets a list of all Courses
Parameters: None
Returns:

Called By: BusinessServices.Course.GetCourseListAccessableToOrg
Calls: None

Remarks: None

Author: Stephen Kenendy-Clark
Date Created: 06th of Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE     Procedure [prcCourse_GetListByOrganisation]
(
@organisationID  int -- The organisation ID
)

As

-------------------------------------------------------------
-- Return Select
-------------------------------------------------------------
Select
c.[CourseID]
, c.[Name]
, c.[Notes]
, c.[Active]
, c.[CreatedBy]
, dbo.udfUTCtoDaylightSavingTime(c.[DateCreated], @organisationID)
, c.[UpdatedBy]
, dbo.udfUTCtoDaylightSavingTime(c.[DateUpdated], @organisationID)
From
[tblCourse] c
inner Join tblOrganisationCourseAccess oca
on oca.GrantedCourseID = c.CourseID
and oca.organisationID = @organisationID
order by c.Name



' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCourse_GetList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary: Gets a list of all Courses
Parameters: None
Returns: table

Called By: BusinessServices.Course.GetCourseList in Course.cs
Calls: None

Remarks: None

Author: Stephen Kenendy-Clark
Date Created: 06th of Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcCourse_GetList]

@OrgID int

As

Select
[CourseID]
, [Name]
, [Notes]
, [Active]
, [CreatedBy]
, dbo.udfUTCtoDaylightSavingTime([DateCreated], @OrgID)
, [UpdatedBy]
, dbo.udfUTCtoDaylightSavingTime([DateUpdated], @OrgID)
From
[tblCourse]
Order by Name

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_UpdateType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*
Summary:
Updates a Classification Type for an Organisation

Parameters:
@name VarChar(50)
@classificationTypeID Integer
@organisationID Integer

Returns:
None

Called By:
Classification.cs

Calls:
None

Remarks:
Exception:
0. Succeed
1. RecordNotFoundException
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 18th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE  Procedure [prcClassification_UpdateType]
(
@name nVarChar(50) = Null, -- The name of the ClassificationType.
@classificationTypeID Integer = Null, -- The ID of the ClassificationType that you wish to update.
@organisationID Integer -- ID of the Organisation that you are updating the ClassificationType for.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage VarChar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @intErrorNumber = 0
Set @strErrorMessage = ''''

-- Validation Routines
If(@classificationTypeID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @classificationTypeID in stored procedure  prcClassification_AddType''
Goto Finalise
End

If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure  prcClassification_AddType''
Goto Finalise
End

If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure  prcClassification_AddType''
Goto Finalise
End

If Exists(Select * From tblClassificationType Where ClassificationTypeID = @classificationTypeID)
Begin
Update tblClassificationType
Set
Name = @name
Where
ClassificationTypeID  = @classificationTypeID
End
Else
Begin
Set @intErrorNumber = 1
Set @strErrorMessage = ''This record no longer exists please refresh your screen.''
Goto Finalise
End

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_GetType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary: Gets a list of Classification Types for an Organisation
Parameters: OrganisationID
Returns: ClassificationTypeID, OrganisationID, Name

Called By: Classification.cs
Calls: None

Remarks: None

Author: John Crawford
Date Created: 17th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE   Procedure [prcClassification_GetType]
(
@organisationID Integer = Null -- ID of the Organisation that you wish to get the Classifications For.
)

As

Set NoCount On

Select
ClassificationTypeID,
OrganisationID,
[Name]
From
tblClassificationType
Where
OrganisationID = @organisationID



' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcClassification_AddType]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'


/*
Summary:
Adds a Classification Type for an Organisation

Parameters:
@name nVarChar(50)
@organisationID Integer

Returns:
None

Called By:
Classification.cs

Calls:
None

Remarks:
Exception:
0. Succeed
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author: Peter Vranich
Date Created: 18th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcClassification_AddType]
(
@name nVarChar(50) = Null, -- The name of the ClassificationType
@organisationID Integer = Null -- The ID of the Organisation that you wish to get the Classifications For.
)

As

Set NoCount On
Set Xact_Abort On

Begin Transaction

-- Declarations
Declare @strErrorMessage VarChar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

-- Validation Routines
If(@organisationID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @organisationID in stored procedure  prcClassification_AddType''
Goto Finalise
End

If(@name Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @name in stored procedure  prcClassification_AddType''
Goto Finalise
End

If Exists(Select * From tblClassificationType Where Name = @name And OrganisationID = @organisationID)
Begin
Set @intErrorNumber = 4
Set @strErrorMessage = ''The ClassificationType Name '' + @name + '' already exists for this organisation please choose another name for your ClassificationType.''
Goto Finalise
End

Insert Into tblClassificationType
(
Name,
OrganisationID
)
Values
(
@name,
@organisationID
)

Finalise:
If(@intErrorNumber > 0)
Begin
Rollback Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End
Else
Begin
Commit Transaction
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End



' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_Get]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Gets a profile

Parameters:
@ProfileID int,

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

CREATE procedure [prcProfile_Get]
(
@ProfileID int,
@profileperiodID int,
@OrgID int
)
as

select
pro.profilename,
dbo.udfUTCtoDaylightSavingTime(propd.datestart, @OrgID) as DateStart,
dbo.udfUTCtoDaylightSavingTime(propd.dateend, @OrgID) as DateEnd,
propd.points,
propd.endofperiodaction,
propd.monthincrement,
dbo.udfUTCtoDaylightSavingTime(propd.futuredatestart, @OrgID) as FutureDateStart,
dbo.udfUTCtoDaylightSavingTime(propd.futuredateend, @OrgID) as FutureDateEnd,
propd.futurepoints,
propd.ApplyToQuiz,
propd.ApplyToLesson
from
tblProfile pro
left join tblProfilePeriod propd on pro.profileid = propd.profileid
where
pro.profileid = @ProfileID
and (@profileperiodID = -1 or propd.profileperiodid = @profileperiodid)
and (profileperiodactive =  1   or ((dbo.udfUTCtoDaylightSavingTime(propd.datestart, @OrgID)) > (dbo.udfUTCtoDaylightSavingTime(GETUTCDATE(), @OrgID))))
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetActiveQuizIDByModuleID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetActiveQuizIDByModuleID    Script Date: 20/04/2004 8:25:57 AM ******/


/*
Summary:
user Defined Function that returns a quiz id based on the module id
Returns:
integer

Called By:
prcUser_GetQuizHistory
Calls:

Remarks:
None
Author:
Peter Kneale
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

*/

CREATE  Function [udfGetActiveQuizIDByModuleID]
(
@ModuleID Integer		-- Module ID from which we want the active quiz
)
Returns int

Begin

Declare @retVal int

set @retVal =
(
Select Top 1
QuizID
From
tblQuiz
Where
ModuleID = @moduleID
And
Active = 1
)

Return @retVal
End
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetQuizIDByToolbookIDAndModuleID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetQuizIDByToolbookIDAndModuleID    Script Date: 20/04/2004 8:25:57 AM ******/


/*
Summary:
user Defined Function that returns a quiz id given a toolbook id and module id
only Works for a quiz
Returns:
scaler - toolbook id - int

Called By:

Calls:

Remarks:


Author:
Peter Kneale
Date Created: 18 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


**/
CREATE Function [udfGetQuizIDByToolbookIDAndModuleID]
(
@toolbookID 	Varchar(50),		-- Toolbook ID used to determine quiz id
@moduleID	Integer			-- Module ID that quiz must belong to
)

Returns Integer

Begin
-- Declarations
Declare @retVal Integer

-- Get Quiz ID by toolbookID and moduleID
Set @retVal =
(
Select Top 1
QuizID
From
tblQuiz
Where
ToolbookID = ltrim(rtrim(@toolBookID))
And
ModuleID = @moduleID
And
Active=1
)

Return @retVal

End
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetQuizIDByToolbookID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetQuizIDByToolbookID    Script Date: 20/04/2004 8:25:57 AM ******/




/*
Summary:
user Defined Function that returns a quiz id given a toolbook id
only Works for a quiz
Returns:
scaler - toolbook id - int

Called By:

Calls:

Remarks:


Author:
Peter Kneale, Stephen Kennedy-Clark
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


**/
CREATE   Function [udfGetQuizIDByToolbookID]
(
@toolbookID Varchar(50)
)

Returns Integer
Begin
-- Declarations
Declare @retVal Integer

-- Get QuizID by toolbook ID
Set @retVal =
(
Select Top 1
QuizID
From
tblQuiz
Where
ToolbookID = ltrim(rtrim(@toolBookID))
and Active=1
)
Return @retVal
End
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetLessonIDByToolbookIDAndModuleID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetLessonIDByToolbookIDAndModuleID    Script Date: 20/04/2004 8:25:57 AM ******/

/*
Summary:
user Defined Function that returns a lesson id given a toolbook id and a module id
only Works for a lesson
Returns:
scaler - toolbook id - int

Called By:

Calls:

Remarks:


Author:
Peter Kneale
Date Created: 19 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


print dbo.udfGetLessonIDByToolbookIDAndModuleID(''toolBookID-1'',5)
-- select * from tblLesson

**/
CREATE Function [udfGetLessonIDByToolbookIDAndModuleID]
(
@toolBookID 	Varchar(50), 		-- Toolbook Id of the Lesson
@moduleID 	Integer			-- ModuleId of the module the lessson belongs to.
)
Returns Int --< LessonID >--
Begin
-- get Lesson id for this Toolbook
Declare @retVal int
set @retVal =
(
(
Select Top 1
LessonID
From
tblLesson
Where
ToolbookID = ltrim(rtrim(@toolBookID))
And
ModuleID = @moduleID
And
Active=1
)
)
Return @retVal
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetLessonIDByToolbookID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetLessonIDByToolbookID    Script Date: 20/04/2004 8:25:57 AM ******/



/*
Summary:
user Defined Function that returns a lesson id given a toolbook id
only Works for a lesson
Returns:
scaler - toolbook id - int

Called By:
dbo.prcLessonPageAudit_GetPagesVisited
Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


print dbo.udfGetLessonIDByToolbookID(''toolBookID-1'')
-- select * from tblLesson

**/
CREATE  FUNCTION [udfGetLessonIDByToolbookID]
(
@toolBookID varchar(50) -- Toolbook ID
)
RETURNS INT --< UserID >--
Begin
------------------------------------------
-- get Lesson id for this Toolbook
------------------------------------------

DECLARE @retVal int
set @retVal =
(
(
SELECT TOP 1
LessonID
FROM
tblLesson
WHERE
ToolbookID = ltrim(rtrim(@toolBookID))
and Active=1
)
)
RETURN @retVal
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetCourseList]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Gets course List for User My Training page

Parameters:


Returns:


Called By:
User.cs.

Calls:


Assumptions:


Remarks:



Author: Aaron Cripps
Date Created: August 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description


**/

CREATE  Procedure [prcUser_GetCourseList]
(
	@UserID int,
	@ProfileID int,
	@CurrentCultureName NVarChar(40) = ''en-AU''
)

As

DECLARE @OrgID int

Select @OrgID = OrganisationID FROM tblUser where UserID = @UserID
create table #UserCourse
(
CourseID int,
[Name] nvarchar(100),
Notes nvarchar(1000),
Active bit,
CreatedBy int,
DateCreated datetime,
UpdatedBy int,
DateUpdated datetime
)

insert into #UserCourse
exec prcCourse_GetListByUser @UserID

Create table #CourseName
(
CourseID int,
[Name] nvarchar(100),
DateCreated datetime
)

Create Table #CourseStatus
(
CourseID int,
CourseStatusID int,
DateCreated datetime
)

insert into #CourseStatus
select
ucs.CourseID,
ucs.CourseStatusID,
max(ucs.DateCreated) as DateCreated
from
tblUserCourseStatus ucs
join #UserCourse uc	on  ucs.CourseID = uc.CourseID
where
ucs.UserID = @UserID
and not exists (select * from tblusercoursestatus ucs2
where ucs.courseid = ucs2.courseid
and ucs.userid = ucs2.userid
and ucs.datecreated <ucs2.datecreated )
group by
ucs.CourseID, ucs.CourseStatusID
order by
DateCreated desc

Create Table #CourseStatusTemp
(
CourseID int,
DateCreated datetime
)

insert into #CourseStatusTemp
select
CourseID,
max(DateCreated)
from
#CourseStatus
group by CourseID

Create Table #CourseList
(
CourseID int,
[Name] nvarchar(100),
CourseStatusID int,
Due varchar(11),
LastComp varchar(11),
Red char(1)
)

Declare @DefaultLessonCompletionDate Datetime
Declare @DefaultQuizCompletionDate Datetime
DECLARE @DefaultQuizFrequency integer

SELECT @DefaultQuizCompletionDate = DefaultQuizCompletionDate
,@DefaultLessonCompletionDate = DefaultLessonCompletionDate
,@DefaultQuizFrequency = DefaultQuizFrequency
FROM tblOrganisation where OrganisationID = (SELECT OrganisationID FROM tblUser WHERE UserID = @UserID)

declare @OrganisationID integer

select @OrganisationID = OrganisationID FROM tblUser WHERE UserID = @UserID







insert into #CourseList
select
uc.CourseID,
uc.[Name],
cs.CourseStatusID,
case

when cs.CourseStatusID = 2 and @DefaultQuizCompletionDate is  null  then '' ''
when cs.CourseStatusID = 2 and   @DefaultQuizCompletionDate is not null 
																	then convert(varchar (11),dbo.udfUserUTCtoDaylightSavingTime(@DefaultQuizCompletionDate,@OrganisationID),113)	
when cs.CourseStatusID <> 2 and (RemEsc.DaysToCompleteCourse is null OR ((RemEsc.NotifyMgr = 0) AND (RemEsc.RemindUsers = 0))) then ''-- ''   
when cs.CourseStatusID <> 2 and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and CStart.DateCreated is null 
							then CAST(RemEsc.DaysToCompleteCourse AS VARCHAR(5))																																															-- course just added , overnight job has not caught up yet
							+ (SELECT  '' ''+LangEntryValue  FROM tblLangValue
							where LangInterfaceID = (SELECT  LangInterfaceID   FROM tblLangInterface WHERE LangInterfaceName = ''GLOBAL.MISC'')
							and LangID =(SELECT LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName)
							and LangResourceID = (SELECT LangResourceID  FROM tblLangResource where   LangResourceName = ''days'' ))

when cs.CourseStatusID <> 2 and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and CStart.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,CS.DateCreated,getUTCdate())) >= 0
							then CAST(RemEsc.DaysToCompleteCourse -   DATEDIFF(day,CS.DateCreated,getUTCdate()) AS VARCHAR(5))		
							+ (SELECT  '' ''+LangEntryValue  FROM tblLangValue
							where LangInterfaceID = (SELECT  LangInterfaceID   FROM tblLangInterface WHERE LangInterfaceName = ''GLOBAL.MISC'')
							and LangID =(SELECT LangID FROM tblLang where tblLang.LangCode=  @CurrentCultureName)
							and LangResourceID = (SELECT LangResourceID  FROM tblLangResource where   LangResourceName = ''days'' ))
when cs.CourseStatusID <> 2 and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and CStart.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,CS.DateCreated,getUTCdate())) < 0
							then convert(varchar (11),DATEADD(day,RemEsc.DaysToCompleteCourse,dbo.udfUTCtoDaylightSavingTime(CS.DateCreated,@OrgID)),113)   


end ,
case
when CPass.DateCreated is null then '' ''   
when CPass.DateCreated is not null then convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(CPass.DateCreated,@OrgID),113)   
end ,

case when cs.CourseStatusID <> 2 and RemEsc.DaysToCompleteCourse is not null and ((RemEsc.NotifyMgr = 1) OR (RemEsc.RemindUsers = 1)) and CStart.DateCreated is not null	 AND (RemEsc.DaysToCompleteCourse -   DATEDIFF(day,CS.DateCreated,getUTCdate())) < 0		then 1 else 0 end

from
#UserCourse uc
left outer join #CourseStatus cs on uc.CourseID = cs.CourseID
left outer join (SELECT MIN(UserCourseStatusID) as UserCourseStatusID,[UserID] ,[CourseID] FROM tblUserCourseStatus LastAttempt where LastAttempt.UserID = @UserID and not exists (SELECT * FROM tblUserCourseStatus PreviousAttempt where PreviousAttempt.UserID = @UserID and PreviousAttempt.CourseStatusID = 0 and PreviousAttempt.UserCourseStatusID < LastAttempt.UserCourseStatusID and PreviousAttempt.CourseID = LastAttempt.CourseID and PreviousAttempt.UserID = LastAttempt.UserID) group by [UserID] ,[CourseID]
) CSID ON CSID.UserID = @UserID and CSID.courseID = cs.courseID
left outer join tblUserCourseStatus CStart ON CStart.UserID = @UserID and CStart.courseID = cs.courseID and CStart.UserCourseStatusID = CSID.UserCourseStatusID
left outer join tblReminderEscalation RemEsc on RemEsc.CourseId = cs.CourseID and RemEsc.orgID = @OrgID
--last passed course date
left outer join
(SELECT MAX(UserCourseStatusID) as UserCourseStatusID,[UserID] ,[CourseID] FROM tblUserCourseStatus PreviousAttempt where PreviousAttempt.userID = @UserID  and PreviousAttempt.CourseStatusID = 2 group by [UserID] ,[CourseID]
) CPSID ON CPSID.UserID = @UserID and CPSID.courseID = cs.courseID
left outer join tblUserCourseStatus CPass ON CPass.UserID = @UserID and CPass.courseID = cs.courseID and CPass.UserCourseStatusID = CPSID.UserCourseStatusID
 




--Now get points available for each course
Create Table #CoursePoints
(
CourseID int,
PointsAvailable numeric(10,1)
)

insert into #CoursePoints
select
cl.CourseID, sum(ppts.Points)
from
#CourseList cl
join tblModule m on m.CourseID = cl.CourseID
join tblProfilePoints ppts on m.ModuleID = ppts.TypeID
join tblProfilePeriod pp on ppts.ProfilePeriodID = pp.ProfilePeriodID
where
m.Active = 1 and ppts.Active = 1 and pp.ProfileID = @ProfileID
group by
cl.CourseID


select
@ProfileID as ProfileID,
cl.CourseID, cl.[Name],
coalesce(cl.CourseStatusID, 1) as CourseStatusID,
cp.PointsAvailable,
cl.Due ,
cl.LastComp,
cl.red
from
#CourseList cl
left join #CoursePoints cp on cl.CourseID = cp.CourseID
order by cl.[Name]


drop table #UserCourse
drop table #CourseName
drop table #CourseStatus
drop table #CourseStatusTemp
drop table #CourseList
drop table #CoursePoints

' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetModuleIDByQuizID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetModuleIDByQuizID    Script Date: 20/04/2004 8:25:57 AM ******/


/*
Summary:
user Defined Function that returns a module id given a toolbook (Quiz) id
Returns:
integer

Called By:

Calls:
Nothing

Remarks:
None

Author:
Peter Kneale, Stephen Kennedy-Clark
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	GB		9/2/04			Coding standards

*/

CREATE  Function [udfGetModuleIDByQuizID]
(
@QuizID Integer -- The id of the quiz (PK) in question
)
Returns Integer

Begin
-- Declarations
Declare @retVal Integer

-- Get ModuleID By Quiz ID
set @retVal =
(
Select Top 1
ModuleID
From
tblQuiz
Where
QuizID = @QuizID
)

Return @retVal
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetModuleIDBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Parameters: @ToolbookID varchar(50)
Returns: integer

Called By: ToolbookListener.aspx
Calls: udfGetQuizIDBySessionID, udfGetModuleIDByQuizID

Remarks: Raises an error if the parameter is null

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date		Description
#1	GB		9/2/04		Coding standards
#2	GB		3/3/04		Changed to retrieve QuizID by SessionID rather than ToolbookID
*/

CREATE  Procedure [prcQuiz_GetModuleIDBySessionID]
(
@sessionID varchar(50) = null -- Session ID
)

As

Declare @intQuizID int 		-- Quiz ID
Declare @intRetVal Int		-- Module ID that is to be returned

-- Retrieve the QuizID from the supplied SessionID
Set @intQuizID = dbo.udfGetQuizIDBySessionID(@sessionID)

-- Retrieve the ModuleID from the retrieved QuizID
Set @intRetVal = dbo.udfGetModuleIDByQuizID(@intQuizID)

-- Return the ModuleID
Select @intRetVal As ''ModuleID''
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetModuleIDByLessonID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetModuleIDByLessonID    Script Date: 20/04/2004 8:25:57 AM ******/



/*
Summary:
user Defined Function that returns a module id given a toolbook id
only Works for a quiz
Returns:
scaler - module id - int

Called By:

Calls:

Remarks:


Author:
Peter Kneale, Stephen Kennedy-Clark
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


**/
CREATE  Function [udfGetModuleIDByLessonID]
(
@LessonID Integer -- the id of the lesson in question
)
Returns Integer --< UserID >--
Begin
-- Declarations
Declare @retVal Integer

-- get Quiz id for this Toolbook
set @retVal =
(
(
Select Top 1
ModuleID
From
tblLesson
Where
LessonID = @LessonID
)
)
Return @retVal
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLesson_GetListByModule]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Selects a list of lessons for a module. Caller can specify whether to only return only valid modules.

Parameters:
@moduleID
@activeOnly

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Module.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeed
5. ParameterException


Author: Gavin Buddis
Date Created: 16 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		4/5/2007		Added WorkSiteIDs to select

**/
CREATE  Procedure [prcLesson_GetListByModule]
(
@moduleID Integer = Null,
@activeOnly Bit = 0,
@OrgID int
)

As

Set Nocount On

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @moduleID
If (@moduleID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @moduleID in stored procedure prcLesson_GetListByModule''
Goto Finalise
End

If (@activeOnly = 1)
Begin
Select
LessonID,
ModuleID,
ToolbookID,
ToolbookLocation,
dbo.udfUTCtoDaylightSavingTime(DatePublished, @OrgID),
LoadedBy,
dbo.udfUTCtoDaylightSavingTime(DateLoaded, @OrgID),
Active,
LWorkSiteID,
QFWorkSiteID
From
tblLesson
Where
ModuleID = @moduleID
And Active = 1
End
Else
Begin
Select
LessonID,
ModuleID,
ToolbookID,
ToolbookLocation,
dbo.udfUTCtoDaylightSavingTime(DatePublished, @OrgID),
LoadedBy,
dbo.udfUTCtoDaylightSavingTime(DateLoaded, @OrgID),
Active,
LWorkSiteID,
QFWorkSiteID
From
tblLesson
Where
ModuleID = @moduleID

End

Finalise:
If(@intErrorNumber > 0)
Begin
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End



' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcOrganisation_GetProfiles]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Get''s a list of profiles for an organisation

Parameters:
@OrganisationID int,

Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcOrganisation_GetProfiles]
(
@OrganisationID int
)
as

select
pro.profileid,
propd.profileperiodid,
pro.profilename,
dbo.udfUTCtoDaylightSavingTime(propd.datestart, @OrganisationID),
dbo.udfUTCtoDaylightSavingTime(propd.dateend, @OrganisationID),
dbo.udfUTCtoDaylightSavingTime(propd.futuredatestart, @OrganisationID),
dbo.udfUTCtoDaylightSavingTime(propd.futuredateend, @OrganisationID),
case when ((propd.datestart < GETUTCDATE()) and (GETUTCDATE() < dateadd(hh,24,propd.dateend))) then ''Enabled'' else ''Disabled'' end [ProfileStatus]
from
tblProfile pro
left join tblProfilePeriod propd on pro.profileid = propd.profileid
where
pro.organisationid = @OrganisationID
and (profileperiodactive = 1)
order by
pro.profilename

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_SetUnitAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s a list of units that have access to a profile

Parameters:
@organisationID Integer
@ProfileID integer
@UnitID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcProfile_SetUnitAccess]
(
@ProfileID int,
@UnitID int
)
as
set nocount on

declare @ProfilePeriodID int
set @ProfilePeriodID =
(select ProfilePeriodID
from tblProfilePeriod
where ProfileID = @ProfileID and profileperiodactive=1)

update tblUnitProfilePeriodAccess
set Granted = 1
where ProfilePeriodID = @ProfilePeriodID
and UnitID = @UnitID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_ResetUserAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Reset''s all User''s access to profile to 0

Parameters:
@ProfileID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcProfile_ResetUserAccess]
(
@ProfileID int
)
as
set nocount on

declare @ProfilePeriodID int
set @ProfilePeriodID =
(select ProfilePeriodID
from tblProfilePeriod
where ProfileID = @ProfileID and profileperiodactive=1)

update tblUserProfilePeriodAccess
set Granted = 0
where ProfilePeriodID = @ProfilePeriodID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_ResetUnitAccess]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Reset''s all Unit''s access to profile to 0

Parameters:
@ProfileID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcProfile_ResetUnitAccess]
(
@ProfileID int
)
as
set nocount on

declare @ProfilePeriodID int
set @ProfilePeriodID =
(select ProfilePeriodID
from tblProfilePeriod
where ProfileID = @ProfileID and profileperiodactive=1)

update tblUnitProfilePeriodAccess
set Granted = 0
where ProfilePeriodID = @ProfilePeriodID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_Add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Adds Profile

Parameters:
@ProfileName

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcProfile_Add]
(
@ProfileID int output,
@profilePeriodID int Output,
@OrganisationID int,
@ProfileName nvarchar(255),
@DateStart datetime,
@DateEnd datetime,
@Points numeric(10,1),
@EndOfPeriodAction char(1),
@MonthIncrement int,
@FutureDateStart datetime,
@FutureDateEnd datetime,
@FuturePoints numeric(10,1)
)
as
Begin

set @DateStart = dbo.udfDaylightSavingTimeToUTC(@DateStart, @OrganisationID)
set @DateEnd =dbo.udfDaylightSavingTimeToUTC(@DateEnd, @OrganisationID)
set @FutureDateStart = dbo.udfDaylightSavingTimeToUTC(@FutureDateStart, @OrganisationID)
set @FutureDateEnd = dbo.udfDaylightSavingTimeToUTC(@FutureDateEnd, @OrganisationID)

-- insert values into tblProfile
insert into tblProfile
(OrganisationID,
ProfileName)
values
(@OrganisationID,
@ProfileName)

-- get ProfileID
set @ProfileID = @@Identity

-- insert values into tblProfilePeriod
insert into tblProfilePeriod
(ProfileID,
DateStart,
DateEnd,
Points,
EndOfPeriodAction,
MonthIncrement,
FutureDateStart,
FutureDateEnd,
FuturePoints,
ApplyToQuiz,
ApplyToLesson,
ProfilePeriodActive)
values
(@ProfileID,
@DateStart,
@DateEnd,
@Points,
@EndOfPeriodAction,
@MonthIncrement,
@FutureDateStart,
@FutureDateEnd,
@FuturePoints,
1,
1,
1)

-- get the profileperiodid
set @ProfilePeriodID = @@Identity
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetModuleIDByToolbookID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:
Parameters: @ToolbookID varchar(50)
Returns: integer

Called By: ToolbookListener.aspx
Calls: None

Remarks: Raises an error if the parameter is null

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	GB		9/2/04			Coding standards
*/

CREATE Procedure [prcQuiz_GetModuleIDByToolbookID]
(
@ToolbookID varchar(50) = null -- Toolbook ID
)

As

Select
ModuleID
From
tblQuiz
Where
ToolbookID = @ToolBookID
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_GetQuizIDByToolbookID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary:

Parameters: @ToolbookID varchar(50)

Returns: integer

Called By: ToolbookListener.aspx

Calls: None

Remarks: Raises an error any input parameter is null

Author: Peter Kneale
Date Created: 4th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	GB		9/2/04			Coding standards
*/

CREATE Procedure [prcQuizSession_GetQuizIDByToolbookID]
(
@strToolbookID varchar(50)
)

As

If @strToolbookID Is Null
Begin
Raiserror(''The Parameter @strToolbookID was null.  @strToolbookID does not accept Null values.'', 16, 1)
Return
End

Select
Top 1 *
From
[tblQuiz]
Where
ToolbookID = @strToolbookID
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Updates a Profile.

Parameters:



Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcProfile_Update]
(
@ProfileID int,
@ProfileName nvarchar(255),
@OrganisationID int,
@DateStart datetime,
@DateEnd datetime,
@Points numeric(10,1),
@EndOfPeriodAction char(1),
@MonthIncrement int,
@FutureDateStart datetime,
@FutureDateEnd datetime,
@FuturePoints numeric(10,1)
)
as

set @DateStart = dbo.udfDaylightSavingTimeToUTC(@DateStart, @OrganisationID)
set @DateEnd = dbo.udfDaylightSavingTimeToUTC(@DateEnd, @OrganisationID)
set @FutureDateStart = dbo.udfDaylightSavingTimeToUTC(@FutureDateStart, @OrganisationID)
set @FutureDateEnd = dbo.udfDaylightSavingTimeToUTC(@FutureDateEnd, @OrganisationID)

-- Update tblProfile
update tblProfile
set ProfileName =  @ProfileName
where ProfileID = @ProfileID
and OrganisationID = @OrganisationID

-- Get profileperiodid for profileid
declare @ProfilePeriodID int
-- Get ProfilePeriodID
set @ProfilePeriodID =
(select ProfilePeriodID
from tblProfilePeriod
where ProfileID = @ProfileID
and profileperiodactive = 1)

if @ProfilePeriodID > 0
begin
-- Update tblProfilePeriod
update tblProfilePeriod
set DateStart = @DateStart,
DateEnd = @DateEnd,
Points = @Points,
EndOfPeriodAction = @EndOfPeriodAction ,
MonthIncrement = @MonthIncrement ,
FutureDateStart = @FutureDateStart,
FutureDateEnd = @FutureDateEnd,
FuturePoints = @FuturePoints
where ProfilePeriodID = @ProfilePeriodID
and ProfileID = @ProfileID
end
else
begin
-- just in case - set any other profileperiods with same profileid
-- as inactive
update tblProfilePeriod
set profileperiodactive = 0
where profileid = @profileid

-- No profileperiod exists (profile with future period deleted)
-- so need to add the profile period
-- insert values into tblProfilePeriod


insert into tblProfilePeriod
(ProfileID,
DateStart,
DateEnd,
Points,
EndOfPeriodAction,
MonthIncrement,
FutureDateStart,
FutureDateEnd,
FuturePoints,
ApplyToQuiz,
ApplyToLesson,
profileperiodactive)
values
(
@ProfileID,
@DateStart,
@DateEnd,
@Points,
@EndOfPeriodAction,
@MonthIncrement,
@FutureDateStart,
@FutureDateEnd,
@FuturePoints,
1,
1,
1
)
end

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_SetUserAccessByUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Set''s a users that have access to a profile

Parameters:
@ProfileID integer
@UserID integer

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

Create procedure [prcProfile_SetUserAccessByUser]
(
@ProfileID int,
@UserID int,
@Granted bit
)
as
set nocount on

declare @ProfilePeriodID int
set @ProfilePeriodID =
(select ProfilePeriodID
from tblProfilePeriod
where ProfileID = @ProfileID and profileperiodactive=1)

update tblUserProfilePeriodAccess
set Granted = @Granted
where ProfilePeriodID = @ProfilePeriodID
and UserID = @UserID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetListByModule]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*Summary:
Selects a list of quizzes for a module. Caller can specify whether to only return active quizzes.

Parameters:
@moduleID
@activeOnly

Returns:
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''

Called By:
Module.cs.

Calls:
Nothing

Remarks:
Exception:
0. Succeeded
5. ParameterException
10. BusinessServiceException (General)


Author: Gavin Buddis
Date Created: 16 February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	mikev		4/5/2007		Added WorkSiteID to select

**/
CREATE  Procedure [prcQuiz_GetListByModule]
(
@moduleID Integer = Null,
@activeOnly Bit = 0,
@OrgID int
)

As

Set Nocount On

-- Declarations
Declare @strErrorMessage Varchar(200) -- Holds the error message
Declare @intErrorNumber Integer -- Holds the error number

-- Initialise variables
Set @strErrorMessage = ''''
Set @intErrorNumber = 0

--Validate Parameter @moduleID
If (@moduleID Is Null)
Begin
Set @intErrorNumber = 5
Set @strErrorMessage = ''Missing or Null parameter @moduleID in stored procedure prcQuiz_GetListByModule''
Goto Finalise
End

If (@activeOnly = 1)
Begin
Select
QuizID,
ModuleID,
ToolbookID,
ToolbookLocation,
dbo.udfUTCtoDaylightSavingTime(DatePublished, @OrgID),
LoadedBy,
dbo.udfUTCtoDaylightSavingTime(DateLoaded, @OrgID),
Active,
WorkSiteID
From
tblQuiz
Where
ModuleID = @moduleID And
Active = 1
End
Else
Begin
Select
QuizID,
ModuleID,
ToolbookID,
ToolbookLocation,
dbo.udfUTCtoDaylightSavingTime(DatePublished, @OrgID),
LoadedBy,
dbo.udfUTCtoDaylightSavingTime(DateLoaded, @OrgID),
Active,
WorkSiteID
From
tblQuiz
Where
ModuleID = @moduleID

End

Finalise:
If(@intErrorNumber > 0)
Begin
Select
@intErrorNumber As ''ErrorNumber'',
@strErrorMessage As ''ErrorMessage''
End



' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonPageAudit_GetPagesVisitedBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Given (UserID or SessionID) and (lessonID or ToolbookID)
return a list of the pages that a user has visited in this lesson (toolbook)
Returns:
ordered table of distinct PageID''s

Called By:
TooolBooLlistner.aspx via Businessservices.Toolbook.GetPagesVisited
Calls:
dbo.udfGetUserIDBySessionID
dbo.udfGetLessonIDBySessionID
Remarks:
- at least one of UserID or SessionID must be supplied
- at least one of lessonID or ToolbookID must be supplied
- returns true (Int 1) if the user''s unit has access to the course the lesson is in
and neither of the users unit / or the user themselves have been excluded From accessing that module.
-------------------
-- get the lessionID from this sessionID
-- get all the sessions that this user has started against this lesson
-- get (distinct) all the lessnoPageID''s that the user has visited
-- get the toolbookPageID''s from these lesson-PageID''s pages that have been visited in these sessions
-------------------

Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v# Author  Date   Description
#1



--------------------
prcLessonPageAudit_GetPagesVisitedBySessionID @lessonSessionID = ''036E63C1-1724-4480-A42C-70F63D8A0FDA''
exec prcLessonPageAudit_GetPagesVisitedBySessionID @lessonSessionID = ''036E63C1-1724-4480-A42C-70F63D8A0FDA''
exec prcBookMark_GetBookMarkBySessionID @lessonSessionID = ''036E63C1-1724-4480-A42C-70F63D8A0FDA''
exec prcUser_GetNameBySessionID @sessionID  = ''036E63C1-1724-4480-A42C-70F63D8A0FDA''
exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''036E63C1-1724-4480-A42C-70F63D8A0FDA'', @toolBookPageID = ''salt_29-230001''
exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''036E63C1-1724-4480-A42C-70F63D8A0FDA'', @toolBookPageID = ''salt_29-230002''
print dbo.udfGetUserIDBySessionID(''036E63C1-1724-4480-A42C-70F63D8A0FDA'') -- 4
print dbo.udfGetLessonIDBySessionID(''036E63C1-1724-4480-A42C-70F63D8A0FDA'') -- 16

**/


CREATE PROC [prcLessonPageAudit_GetPagesVisitedBySessionID]
(
@lessonSessionID varchar(50)  -- The Lesson Session ID ( a GUID)
)

AS

Set NOCOUNT ON


------------------------------------------
-- Declerations
------------------------------------------
Declare
@intUserID  integer  -- The Users ID
,@intLessonID  integer  -- The Lesson ID

------------------------------------------
-- If @intUserID not suppled then get it From @lessonSessionID
------------------------------------------

Set @intUserID= dbo.udfGetUserIDBySessionID(@lessonSessionID)



------------------------------------------
-- get @intLessonID From @lessonSessionID
------------------------------------------
Set @intLessonID = dbo.udfGetLessonIDBySessionID(@lessonSessionID)


-------------------


select distinct
tLP.ToolBookPageID
from
( --< get all the sessions (SessionID''s) that this user has started against this lesson >--
select
lessonSessionID
, LessonID
from
tblLessonSession
where
UserID = @intUserID
and lessonID = @intLessonID
) ilvLS -- in line view Lesson - Session
--< get the pages the user has visited in all these sessions >--
inner join tblLessonPageAudit tLPA
on tLPA.LessonSessionID = ilvLS.lessonSessionID
--< to get the toolbook page id we need to joi onto tblLessonPage >--
inner join tblLessonPage tLP
on tLP.LessonPageID = tLPA.LessonPageID










' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonPageAudit_GetPagesVisited]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'







/*Summary:
Given (UserID or SessionID) and (lessonID or ToolbookID)
return a list of the pages that a user has visited in thIs lesson (toolbook)
Returns:
ordered table of distinct PageID''s

Called By: TooolBooLlistner.aspx
Calls:

Remarks:
- at least one of UserID or SessionID must be supplied
- at least one of lessonID or ToolbookID must be supplied
- returns true (Int 1) if the user''s unit has access to the course the lesson Is in
and neither of the users unit / or the user themselves have been excluded from accessing that module.

Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



--------------------
prcLessonPageAudit_GetPagesVisited @userID=11, @lessonSessionID=''D91F43C9-AA74-46FC-AAA6-F3B4E184FEFF''
select * from tblLessonSession
**/


CREATE        Proc [prcLessonPageAudit_GetPagesVisited]
(
@userID Int = Null,			-- The users ID
@lessonSessionID Varchar(50) = Null,	-- The Lesson Session ID (a GUID)
@lessonID Int = Null,			-- The Lesson ID
@toolBookID Varchar(50) = Null		-- The ToolBook ID
)

As

Set  NOCOUNT ON


------------------------------------------
-- Validation - ensure that the required paramaters
-- were supplied
------------------------------------------

--< check that either the userID or the lessonSessionID were supplied >--
If @userID Is Null AND @lessonSessionID Is Null
Begin
Raiserror (''Procedure prcLessonPageAudit_GetPagesVisited expects at least one  the following pramaters: UserID or SessionID'', 16, 1)
Return
End


------------------------------------------
-- If @userID not suppled then get it from @lessonSessionID
------------------------------------------
If @userID Is Null
Begin
Set  @userID= dbo.udfGetUserIDBySessionID(@lessonSessionID)
End


------------------------------------------
-- If @lessonID not suppled then get it from @toolBookID
------------------------------------------

If @lessonID Is Null and @toolBookID is not null
Begin
Set  @lessonID = dbo.udfGetLessonIDByToolbookID(@toolBookID)
End

If @lessonID Is Null and @toolBookID is null and @lessonSessionID is not null
Begin
set @lessonID = dbo.udfGetLessonIDBySessionID(@lessonSessionID)
end

------------------------------------------
-- Join and select back tblLessonPageAudit to tblLessonSession
-- to get all the pages the user has visited
------------------------------------------

select distinct
tLP.ToolbookPageID
from
tblLessonPage tLP
inner join tblLessonPageAudit tLPA
on tLPA.LessonPageID = tLP.LessonPageID
inner Join tblLessonSession tLS
on tLS.LessonSessionID = tLPA.LessonSessionID
Where
tLS.userID = @userID
and tLS.LessonID = @lessonID







' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcBookMark_GetBookMarkBySessionID]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'






/*Summary:
Given (UserID or SessionID) and (lessonID or ToolbookID)
returns the bookmark for this lesson (toolbook) for this user
Returns:
table, 1 row (lessonPageID int,  Tolbook Page ID string)

Called By:
TooolBooLlistner.aspx via BusinessServices.Toolbook.GetBookmark
Calls:
dbo.udfGetUserIDBySessionID
dbo.udfGetLessonIDBySessionID
Remarks:
- at least one of UserID or SessionID must be supplied
- at least one of lessonID or ToolbookID must be supplied
- returns both the lessonPageID and the Tolbook Page ID for this page

Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



--------------------
exec prcBookMark_GetBookMarkBySessionID @lessonSessionID = ''134E8E5F-EC8A-4C95-8FA5-142AC87246C1''

**/


CREATE     PROC [prcBookMark_GetBookMarkBySessionID]
(
@lessonSessionID varchar(50) -- the lesson Session ID
)

AS

SET NOCOUNT ON

select top 1
ToolBookPageID
from

tblLessonSession tLS

inner join tblLessonPage tLP
on tLP.LessonID = tLS.LessonID

inner join tblBookmark tBM
on tBM.lessonPageID = tLP.LessonPageID
and tBM.UserID = tLS.UserID
where
lessonSessionID = @lessonSessionID

order by
--< only get the latest bookmark set >--
tBM.DateCreated




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prc_ADMIN_LessonPageAuditPagesVisited]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'create proc [prc_ADMIN_LessonPageAuditPagesVisited]

@OrgID int

as

select
left(tblOrganisation.OrganisationName, 25) as [Org Name]
, left(tblUser.Firstname + '' '' + tblUser.LastName, 25) as [username]
, left(tblCourse.Name + ''/'' + tblModule.Name, 65) as [Course / Module]
, left(tblLessonPage.ToolbookPageID + ''/'' + tblLessonPage.Title, 50) [Page id / name]
, dbo.udfUTCtoDaylightSavingTime(tblLessonPageAudit.DateAccessed, @OrgID)
From
tblLessonPageAudit
inner join .tblLessonSession on tblLessonPageAudit.LessonSessionID = tblLessonSession.LessonSessionID
inner join tblUser on tblLessonSession.UserID = tblUser.userID
inner join tblOrganisation on tblOrganisation.OrganisationID = tblUser.OrganisationID
inner join tblLessonPage on tblLessonPage.LessonPageID = tblLessonPageAudit.LessonPageID
inner join tblLesson on tblLesson.LessonID = .tblLessonPage.LessonID
inner join tblModule on tblModule.moduleid = tblLesson.moduleID
inner join tblCourse on tblModule.courseid = tblCourse.courseid
where
tblLessonSession.dATEtIMECompleted > ''2004-11-23''
and tblOrganisation.OrganisationID <> 8
order by tblOrganisation.OrganisationName, tblUser.LastName, tblLessonSession.LessonSessionID desc

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcPolicy_Add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Add a new Policy.

Parameters:
@PolicyID output int,
@OrganisationID int,
@PolicyName nvarchar(255),
@Active bit,
@Deleted bit,
@PolicyFileName nvarchar(255),
@PolicyFileSize bigint,
@UploadDate datetime


Returns:
Nothing

Called By:
Policy.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: June 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

CREATE procedure [prcPolicy_Add]
(
@PolicyID int output,
@OrganisationID int,
@PolicyName nvarchar(255),
@Active bit,
@Deleted bit,
@PolicyFileName nvarchar(255),
@PolicyFileSize bigint,
@ConfirmationMessage nvarchar(500)
)
as

insert into tblPolicy
(
OrganisationID,
PolicyName,
Active,
Deleted,
PolicyFileName,
PolicyFileSize,
UploadDate,
ConfirmationMessage
)
values
(
@OrganisationID,
@PolicyName,
@Active,
@Deleted,
@PolicyFileName,
@PolicyFileSize,
getUTCDate(),
@ConfirmationMessage
)

set @PolicyID = @@Identity

-- get a list of all users for the organisation
create table #UserTemp
(
UserID int
)

insert into #UserTemp (UserID)
Select
UserID
From
tblUser
Where
OrganisationID = @organisationID

insert into tblUserPolicyAccepted (PolicyID, UserID, Accepted)
select @PolicyID, UserID, 0 from #UserTemp

drop table #UserTemp

/*
do this bit for policies that are created after the profiles have been created
*/
insert into tblprofilepoints ( profilepointstype, typeid, profileperiodid, points, active, dateassigned)
select ''P'',@PolicyID,profileperiodid,0,1,getutcdate() from tblprofileperiod

select @PolicyID
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcModule_GetDetailsForHomePage]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'





/*Summary:
Given a users ID this proc Gets all Details For the datagrid on the HomePage
Returns:
ordered table of distinct PageID''s

Called By:
TooolBooLlistner.aspx via Businessservices.user.HomePageDetails
Calls:
dbo.udfReport_IndividualDetails
dbo.udfGetLessonStatus
dbo.tblLesson
Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 2 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


--------------------
exec prcModule_GetDetailsForHomePage @userID = 2, @courseID = 1

**/
CREATE Procedure [prcModule_GetDetailsForHomePage]

(
@userID  int = null     -- ID of this User
, @courseID int	= null	-- ID of this Course
, @ProfileID int,
	@CurrentCultureName NVarChar(40) = ''en-AU''
)
AS
------------------------------------------
Set Nocount On



if @ProfileID <> -1
begin
	select
	userModule.UserID
	, userModule.CourseID
	, userModule.ModuleID
	, userModule.ModuleName
	, userModule.LessonID
	, userModule.LessonStatus
	, userModule.LessonStatusName
	, userModule.QuizStatus
	, userModule.QuizStatusName
	, userModule.QFSPath
	, case
	when userProfilePoints.Points is null
	then 0
	else userProfilePoints.Points
	end Points
	,QuizExpiryDate as QuizDue
	,LastComp
	,Red
	from
	(
	select
	udfRID.*, tLS.LessonStatusID, tLS.Status LessonStatusName, tQs.QuizStatusID, tQs.Status QuizStatusName
	from
	udfReport_IndividualDetailsExtended(@userID,@CurrentCultureName) udfRID
	--< Get the name of the lesson status >--
	inner join tblLessonStatus tLS
	on tLS.LessonStatusID = udfRID.LessonStatus
	--< Get the name of the quiz status >--
	inner join tblQuizStatus tQS
	on tQS.QuizStatusID = udfRID.QuizStatus
	) userModule

	left join
	(
	select
	ppts.*, pp.ProfileID, pp.ProfilePeriodActive
	from
	tblProfilePoints ppts
	inner join tblProfilePeriod pp
	on pp.ProfilePeriodID = ppts.ProfilePeriodID
	where
	ppts.ProfilePointsType=''M''
	and ppts.Active = 1
	and (pp.ProfileID = @ProfileID)
	and pp.profileperiodactive = 1
	) userProfilePoints
	on
	userProfilePoints.TypeID = userModule.ModuleID
	where
	userModule.CourseID = isNull(@courseID, userModule.CourseID)
	order by
	[Sequence]
end
else
begin
	select
	udfRID.UserID
	, udfRID.CourseID
	--, CourseName
	, udfRID.ModuleID
	, udfRID.ModuleName
	, udfRID.LessonID
	, udfRID.LessonStatus as LessonStatus
	, tLS.Status 	      as LessonStatusName
	, udfRID.QuizStatus   as QuizStatus
	, tQS.Status 	      as QuizStatusName
	--, QuizScore
	--, QuizPassMark
	, udfRID.QFSPath
	, 0			  as Points
	,QuizExpiryDate as QuizDue
	,LastComp
	,Red
	from
	udfReport_IndividualDetailsExtended(@userID,@CurrentCultureName) udfRID
	--< Get the name of the lesson status >--
	inner join tblLessonStatus tLS
	on tLS.LessonStatusID = udfRID.LessonStatus
	--< Get the name of the quiz status >--
	inner join tblQuizStatus tQS
	on tQS.QuizStatusID = udfRID.QuizStatus
	--	left join tblProfilePoints ppts
	--		on ppts.TypeID = udfRID.ModuleID
	--	left join tblProfilePeriod pp
	--		on pp.ProfilePeriodID = ppts.ProfilePeriodID
	where
	udfRID.CourseID = isNull(@courseID, udfRID.CourseID)
	--	and ppts.ProfilePointsType=''M''
	--	and ppts.Active = 1
	--	and (pp.ProfileID = @ProfileID or @profileid  =-1)
	order by
	[Sequence]
end

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDProfileHistory_Report]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE procedure [prcCPDProfileHistory_Report]
(
@ProfileID  varchar(20),
@UserID		varchar(20)
)
as

select
convert(varchar (11),pp.DateStart,113) + '' - '' + convert( varchar(11),pp.DateEnd,113) as PeriodDesc,
sum(upt.Points) as PointsEarned,
pp.points as PointsRequired
from
tblProfilePeriod pp
join tblProfilePoints pt
on pt.profileperiodid =pp.profileperiodid
join tbluserCPDPoints upt
on upt.profilepointsID = pt.profilepointsid
where
pt.profilepointstype =''M''
and pp.profileid =@ProfileID
and upt.userid =@UserID
--and getutcdate() between pp.DateStart and pp.dateend
group by
convert(varchar (11),pp.DateStart,113) + '' - '' + convert( varchar(11),pp.DateEnd,113),pp.points


SET QUOTED_IDENTIFIER ON
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDPoints_UpdateUser]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE procedure [prcCPDPoints_UpdateUser]
(
@profileid int,
@userid int,
@OrgID int
)
as begin
set nocount on
declare @userquizstatusid int
declare @userlessonstatusid int
declare @quizstatusid int
declare @lessonstatusid int
declare @datecreated datetime
declare @pointsgiven bit
declare @applytoquiz bit
declare @applytolesson bit
declare @profilepointsid int
declare @points numeric(10,1)
declare @quizpassed bit
declare @lessonpassed bit
declare @userstatusid int
declare @statusid int
declare @type char
declare @moduleid int
declare @newmoduleid int

set @applytoquiz = (select applytoquiz from tblProfilePeriod pp join tblProfile p
on pp.profileid = p.profileid where p.profileid = @profileid and pp.profileperiodactive = 1)

set @applytolesson = (select applytolesson from tblProfilePeriod pp join tblProfile p
on pp.profileid = p.profileid where p.profileid = @profileid and pp.profileperiodactive = 1)

-- delete points (if requirements re: lesson and quiz have changed)
-- find User CPD points within the period
declare @lessonquizstatus int
declare @profileperiodid int

-- lessonquizstatus
-- 0 Lesson Only
-- 1 Quiz Only
-- 2 Lesson and Quiz

select @lessonquizstatus =
(case when (applytoquiz = 1 and applytolesson = 1) then	2
when (applytoquiz = 0 and applytolesson = 1) then	0
when (applytoquiz = 1 and applytolesson = 0) then	1
end), @profileperiodid = pp.profileperiodid
from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
where p.profileid = @profileid and pp.profileperiodactive=1 and GETUTCDATE() between pp.datestart and dateadd(d,1,pp.dateend)


delete from tblusercpdpoints
where profilepointsid in
(select profilepointsid from tblprofilepoints where profileperiodid = @profileperiodid and active=1 and profilepointstype=''M'')
and userid = @userid

-- add points for user

-- Apply to Quiz only
if (@applytoquiz = 1 and @applytolesson = 0)
begin
-- Get and iterate through the user quiz status records for the user
declare userquizcursor cursor for
select m.moduleid, ppts.profilepointsid, ppts.points, UserQuizStatusID, QuizStatusID, dbo.udfUTCtoDaylightSavingTime(uqs.datecreated, @OrgID) from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserQuizStatus uqs on uppa.UserID = uqs.UserID
join tblQuizSession qs on uqs.quizsessionid = qs.quizsessionid
join tblQuiz q on q.quizid = qs.quizid
join tblModule m on m.moduleid = q.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uqs.datecreated between pp.datestart and dateadd(d,1,pp.dateend)
order by m.moduleid, uqs.datecreated

-- initialise
set @pointsgiven = 0
set @moduleid = 0
set @newmoduleid = 0

open userquizcursor

fetch next from userquizcursor
into @newmoduleid, @profilepointsid, @points, @userquizstatusid, @quizstatusid, @datecreated

while @@FETCH_STATUS = 0
begin
if @newmoduleid <> @moduleid
begin
set @pointsgiven = 0
end
if @pointsgiven = 0
begin
if @quizstatusid = 2
begin
insert into tblUserCPDPoints (ProfilePointsID, UserID, Points, DateAssigned, LessonQuizStatus)
values (@profilepointsid, @userID, @points, @datecreated, 1)
set @pointsgiven = 1
end
end
if @pointsgiven = 1
begin
if @quizstatusid = 5
begin
set @pointsgiven = 0
end
end

set @moduleid = @newmoduleid
fetch next from userquizcursor
into @newmoduleid, @profilepointsid, @points, @userquizstatusid, @quizstatusid, @datecreated
end

close userquizcursor
deallocate userquizcursor
end

-- Apply to Lesson Only
if (@applytoquiz = 0 and @applytolesson = 1)
begin
-- Get and iterate through the user lesson status records for the user
declare userlessoncursor cursor for
select m.moduleid, ppts.profilepointsid, ppts.points, UserLessonStatusID, LessonStatusID, dbo.udfUTCtoDaylightSavingTime(uls.datecreated, @OrgID) from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserLessonStatus uls on uppa.UserID = uls.UserID
join tblModule m on m.moduleid = uls.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uls.datecreated between pp.datestart and dateadd(d,1,pp.dateend)
order by m.moduleid, uls.datecreated

-- initialise
set @pointsgiven = 0
set @moduleid = 0
set @newmoduleid = 0

open userlessoncursor

fetch next from userlessoncursor
into @newmoduleid, @profilepointsid, @points,@userlessonstatusid, @lessonstatusid, @datecreated

while @@FETCH_STATUS = 0
begin
if @newmoduleid <> @moduleid
begin
set @pointsgiven = 0
end
if @pointsgiven = 0
begin
if @lessonstatusid = 3
begin
insert into tblUserCPDPoints (ProfilePointsID, UserID, Points, DateAssigned, LessonQuizStatus)
values (@profilepointsid, @userID, @points, @datecreated, 0)
set @pointsgiven = 1
end
end
if @pointsgiven = 1
begin
if @lessonstatusid = 5
begin
set @pointsgiven = 0
end
end
set @moduleid = @newmoduleid
fetch next from userlessoncursor
into @newmoduleid, @profilepointsid, @points,@userlessonstatusid, @lessonstatusid, @datecreated
end

close userlessoncursor
deallocate userlessoncursor
end

-- Apply to Quiz and Lesson
if (@applytoquiz = 1 and @applytolesson = 1)
begin
create table #tempUserStatus
(
moduleid int,
profilepointsid int,
points numeric(10,1),
userstatusid int,
statusid int,
datecreated datetime,
type char
)
-- insert quiz status values into temp status table
insert into #tempUserStatus (moduleid, profilepointsid, points, userstatusid, statusid, datecreated, type)
select m.moduleid, ppts.profilepointsid, ppts.points, UserQuizStatusID, QuizStatusID, uqs.datecreated, ''Q'' from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserQuizStatus uqs on uppa.UserID = uqs.UserID
join tblQuizSession qs on uqs.quizsessionid = qs.quizsessionid
join tblQuiz q on q.quizid = qs.quizid
join tblModule m on m.moduleid = q.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uqs.datecreated between pp.datestart and dateadd(d,1,pp.dateend)

-- insert lesson status values into temp status table
insert into #tempUserStatus (moduleid, profilepointsid, points, userstatusid, statusid, datecreated, type)
select m.moduleid, ppts.profilepointsid, ppts.points, UserLessonStatusID, LessonStatusID, dbo.udfUTCtoDaylightSavingTime(uls.datecreated, @OrgID), ''L'' from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserLessonStatus uls on uppa.UserID = uls.UserID
join tblModule m on m.moduleid = uls.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uls.datecreated between pp.datestart and dateadd(d,1,pp.dateend)

set @pointsgiven = 0
set @quizpassed = 0
set @lessonpassed = 0
set @moduleid = 0
set @newmoduleid = 0

declare userquizlessoncursor cursor for
select * from #tempUserStatus order by moduleid, datecreated

open userquizlessoncursor

fetch next from userquizlessoncursor
into @newmoduleid, @profilepointsid, @points,@userstatusid, @statusid, @datecreated, @type
while @@FETCH_STATUS = 0
begin
if @newmoduleid <> @moduleid
begin
set @pointsgiven = 0
set @lessonpassed = 0
set @quizpassed = 0
end
if @pointsgiven = 0
begin
if (@statusid = 2 and @type = ''Q'' and @quizpassed = 0)
begin
-- passed quiz
set @quizpassed = 1
end
if (@statusid = 3 and @type = ''L'' and @lessonpassed = 0)
begin
-- lesson passed
set @lessonpassed = 1
end
if (@quizpassed = 1 and @lessonpassed = 1)
begin
-- give points
insert into tblUserCPDPoints (ProfilePointsID, UserID, Points, DateAssigned, LessonQuizStatus)
values (@profilepointsid, @userID, @points, @datecreated, 2)
set @pointsgiven = 1
end
end
if (@pointsgiven = 1)
begin
if (@statusid = 5 and @type = ''Q'')
begin
set @quizpassed = 0
set @pointsgiven = 0
end
if (@statusid = 5 and @type = ''L'')
begin
set @lessonpassed = 0
set @pointsgiven = 0
end
end
set @moduleid = @newmoduleid
fetch next from userquizlessoncursor
into @newmoduleid, @profilepointsid, @points,@userstatusid, @statusid, @datecreated, @type
end

drop table #tempUserStatus
close userquizlessoncursor
deallocate userquizlessoncursor
end
set nocount off
end

SET QUOTED_IDENTIFIER ON
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDPoints_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE procedure [prcCPDPoints_Update]
(
@profileid int = -1,
@OrgID int
)
as begin
set nocount on
declare @userquizstatusid int
declare @userlessonstatusid int
declare @userid int
declare @quizstatusid int
declare @lessonstatusid int
declare @datecreated datetime
declare @pointsgiven bit
declare @applytoquiz bit
declare @applytolesson bit
declare @profilepointsid int
declare @points numeric(10,1)
declare @quizpassed bit
declare @lessonpassed bit
declare @userstatusid int
declare @statusid int
declare @type char
declare @moduleid int
declare @newmoduleid int

set @applytoquiz = (select applytoquiz from tblProfilePeriod pp join tblProfile p
on pp.profileid = p.profileid where p.profileid = @profileid and ProfilePeriodActive = 1)

set @applytolesson = (select applytolesson from tblProfilePeriod pp join tblProfile p
on pp.profileid = p.profileid where p.profileid = @profileid and ProfilePeriodActive = 1)

-- delete points (if requirements re: lesson and quiz have changed)
-- find User CPD points within the period
declare @lessonquizstatus int
declare @profileperiodid int

-- lessonquizstatus
-- 0 Lesson Only
-- 1 Quiz Only
-- 2 Lesson and Quiz

select @lessonquizstatus =
(case when (applytoquiz = 1 and applytolesson = 1) then	2
when (applytoquiz = 0 and applytolesson = 1) then	0
when (applytoquiz = 1 and applytolesson = 0) then	1
end), @profileperiodid = pp.profileperiodid
from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
where p.profileid = @profileid and ProfilePeriodActive =1

delete from tblusercpdpoints
where profilepointsid in
(select profilepointsid from tblprofilepoints where profileperiodid = @profileperiodid and active=1 and profilepointstype=''M'')
--and lessonquizstatus not in (@lessonquizstatus)
and userid in (select distinct uppa.UserID from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
where p.ProfileID = @profileid
and uppa.Granted = 1)

-- need to interate through for each user that has access to the profile
declare usercursor cursor for
select distinct uppa.UserID from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID and pp.ProfilePeriodActive = 1
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
where p.ProfileID = @profileid
and uppa.Granted = 1

open usercursor

fetch next from usercursor into @userid

while @@FETCH_STATUS = 0

begin

-- Apply to Quiz only
if (@applytoquiz = 1 and @applytolesson = 0)
begin
-- Get and iterate through the user quiz status records for the user
declare userquizcursor cursor for
select m.moduleid, ppts.profilepointsid, ppts.points, UserQuizStatusID, QuizStatusID, dbo.udfUTCtoDaylightSavingTime(uqs.datecreated, @OrgID) from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID and pp.ProfilePeriodActive = 1
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserQuizStatus uqs on uppa.UserID = uqs.UserID
join tblQuizSession qs on uqs.quizsessionid = qs.quizsessionid
join tblQuiz q on q.quizid = qs.quizid
join tblModule m on m.moduleid = q.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uqs.datecreated between pp.datestart and dateadd(d,1,pp.dateend)
order by m.moduleid, uqs.datecreated

-- initialise
set @pointsgiven = 0
set @moduleid = 0
set @newmoduleid = 0

open userquizcursor

fetch next from userquizcursor
into @newmoduleid, @profilepointsid, @points, @userquizstatusid, @quizstatusid, @datecreated

while @@FETCH_STATUS = 0
begin
if @newmoduleid <> @moduleid
begin
set @pointsgiven = 0
end
if @pointsgiven = 0
begin
if @quizstatusid = 2
begin
insert into tblUserCPDPoints (ProfilePointsID, UserID, Points, DateAssigned, LessonQuizStatus)
values (@profilepointsid, @userID, @points, @datecreated, 1)
set @pointsgiven = 1
end
end
if @pointsgiven = 1
begin
if @quizstatusid = 5
begin
set @pointsgiven = 0
end
end

set @moduleid = @newmoduleid
fetch next from userquizcursor
into @newmoduleid, @profilepointsid, @points, @userquizstatusid, @quizstatusid, @datecreated
end

close userquizcursor
deallocate userquizcursor
end

-- Apply to Lesson Only
if (@applytoquiz = 0 and @applytolesson = 1)
begin
-- Get and iterate through the user lesson status records for the user
declare userlessoncursor cursor for
select m.moduleid, ppts.profilepointsid, ppts.points, UserLessonStatusID, LessonStatusID, dbo.udfUTCtoDaylightSavingTime(uls.datecreated, @OrgID) from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID and pp.ProfilePeriodActive = 1
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserLessonStatus uls on uppa.UserID = uls.UserID
join tblModule m on m.moduleid = uls.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uls.datecreated between pp.datestart and dateadd(d,1,pp.dateend)
order by m.moduleid, uls.datecreated

-- initialise
set @pointsgiven = 0
set @moduleid = 0
set @newmoduleid = 0

open userlessoncursor

fetch next from userlessoncursor
into @newmoduleid, @profilepointsid, @points,@userlessonstatusid, @lessonstatusid, @datecreated

while @@FETCH_STATUS = 0
begin
if @newmoduleid <> @moduleid
begin
set @pointsgiven = 0
end
if @pointsgiven = 0
begin
if @lessonstatusid = 3
begin
insert into tblUserCPDPoints (ProfilePointsID, UserID, Points, DateAssigned, LessonQuizStatus)
values (@profilepointsid, @userID, @points, @datecreated, 0)
set @pointsgiven = 1
end
end
if @pointsgiven = 1
begin
if @lessonstatusid = 5
begin
set @pointsgiven = 0
end
end
set @moduleid = @newmoduleid
fetch next from userlessoncursor
into @newmoduleid, @profilepointsid, @points,@userlessonstatusid, @lessonstatusid, @datecreated
end

close userlessoncursor
deallocate userlessoncursor
end

-- Apply to Quiz and Lesson
if (@applytoquiz = 1 and @applytolesson = 1)
begin
create table #tempUserStatus
(
moduleid int,
profilepointsid int,
points numeric(10,1),
userstatusid int,
statusid int,
datecreated datetime,
type char
)
-- insert quiz status values into temp status table
insert into #tempUserStatus (moduleid, profilepointsid, points, userstatusid, statusid, datecreated, type)
select m.moduleid, ppts.profilepointsid, ppts.points, UserQuizStatusID, QuizStatusID, uqs.datecreated, ''Q'' from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID and pp.ProfilePeriodActive = 1
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserQuizStatus uqs on uppa.UserID = uqs.UserID
join tblQuizSession qs on uqs.quizsessionid = qs.quizsessionid
join tblQuiz q on q.quizid = qs.quizid
join tblModule m on m.moduleid = q.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uqs.datecreated between pp.datestart and dateadd(d,1,pp.dateend)

-- insert lesson status values into temp status table
insert into #tempUserStatus (moduleid, profilepointsid, points, userstatusid, statusid, datecreated, type)
select m.moduleid, ppts.profilepointsid, ppts.points, UserLessonStatusID, LessonStatusID, uls.datecreated, ''L'' from tblProfile p
join tblProfilePeriod pp on p.ProfileID = pp.ProfileID and pp.ProfilePeriodActive = 1
join tblUserProfilePeriodAccess uppa on pp.ProfilePeriodID = uppa.ProfilePeriodID
join tblUserLessonStatus uls on uppa.UserID = uls.UserID
join tblModule m on m.moduleid = uls.moduleid
join tblProfilePoints ppts on ppts.typeid = m.moduleid and ppts.profilepointstype = ''M'' and ppts.profileperiodid = pp.profileperiodid
where p.ProfileID = @profileid
and uppa.Granted = 1
and uppa.UserID = @userID
and uls.datecreated between pp.datestart and dateadd(d,1,pp.dateend)

set @pointsgiven = 0
set @quizpassed = 0
set @lessonpassed = 0
set @moduleid = 0
set @newmoduleid = 0

declare userquizlessoncursor cursor for
select * from #tempUserStatus order by moduleid, datecreated

open userquizlessoncursor

fetch next from userquizlessoncursor
into @newmoduleid, @profilepointsid, @points,@userstatusid, @statusid, @datecreated, @type
while @@FETCH_STATUS = 0
begin
if @newmoduleid <> @moduleid
begin
set @pointsgiven = 0
set @lessonpassed = 0
set @quizpassed = 0
end
if @pointsgiven = 0
begin
if (@statusid = 2 and @type = ''Q'' and @quizpassed = 0)
begin
-- passed quiz
set @quizpassed = 1
end
if (@statusid = 3 and @type = ''L'' and @lessonpassed = 0)
begin
-- lesson passed
set @lessonpassed = 1
end
if (@quizpassed = 1 and @lessonpassed = 1)
begin
-- give points
insert into tblUserCPDPoints (ProfilePointsID, UserID, Points, DateAssigned, LessonQuizStatus)
values (@profilepointsid, @userID, @points, @datecreated, 2)
set @pointsgiven = 1
end
end
if (@pointsgiven = 1)
begin
if (@statusid = 5 and @type = ''Q'')
begin
set @quizpassed = 0
set @pointsgiven = 0
end
if (@statusid = 5 and @type = ''L'')
begin
set @lessonpassed = 0
set @pointsgiven = 0
end
end
set @moduleid = @newmoduleid
fetch next from userquizlessoncursor
into @newmoduleid, @profilepointsid, @points,@userstatusid, @statusid, @datecreated, @type
end

drop table #tempUserStatus
close userquizlessoncursor
deallocate userquizlessoncursor
end

fetch next from usercursor into @userid

end

close usercursor
deallocate usercursor
set nocount off
end

SET QUOTED_IDENTIFIER ON
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDModuleHistory_Report]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE procedure [prcCPDModuleHistory_Report]
(
@ProfileID  varchar(20),
@ModuleID	varchar(20),
@UserID		varchar(20),
@OrgID		int
)
as

select
convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(pp.DateStart, @OrgID),113) + '' - '' + convert( varchar(11),dbo.udfUTCtoDaylightSavingTime(pp.DateEnd, @OrgID),113) as PeriodDesc,
sum(upt.Points) as Points
from
tblProfilePeriod pp
join tblProfilePoints pt
on pt.profileperiodid =pp.profileperiodid
join tbluserCPDPoints upt
on upt.profilepointsID = pt.profilepointsid
where
pt.profilepointstype =''M''
and pt.typeid = @ModuleID
and pp.profileid =@ProfileID
and upt.userid =@UserID
--and GETUTCDATE() between pp.DateStart and pp.dateend
group by
convert(varchar (11),dbo.udfUTCtoDaylightSavingTime(pp.DateStart, @OrgID),113) + '' - '' + convert( varchar(11),dbo.udfUTCtoDaylightSavingTime(pp.DateEnd, @OrgID),113)


SET QUOTED_IDENTIFIER ON
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPDEmail_Report]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE procedure [prcCPDEmail_Report]
(
@ProfileID  int,
@UnitIDs varchar(MAX)
)
as
select  distinct pf.profileid
, u.userid
, u.lastname
, u.firstname
,hierarchyname = dbo.udfGetUnitPathway(u.UnitID)
,u.email as useremail
from tblProfile pf
join tblprofileperiod pp on pp.profileid = pf.profileid
join tbluserprofileperiodaccess upa on upa.profileperiodid = pp.profileperiodid
and granted = 1
join tbluser  u on u.userid = upa.userid
left join tblusercpdpoints upt on upt.userid = u.userid
where pf.profileid = @ProfileID and
pp.profileperiodactive = 1 and
getutcdate() between pp.datestart and dateadd(d,1,pp.dateend) and
pp.points > coalesce(upt.points,0) and
u.unitid in (select IntValue from dbo.udfCsvToInt(@UnitIDs)) and
u.userid in
(-- users for a course
select distinct uma.userid from
tblProfile p
join tblProfilePeriod pp
on p.profileid = pp.profileid
join tblProfilePoints ppts
on pp.profileperiodid = ppts.profileperiodid
join tblModule m on ppts.typeid = m.moduleid
join vwUserModuleAccess uma on uma.courseid = m.courseid and u.userid=uma.userid
where p.profileid = @profileid
and pp.profileperiodactive = 1
and ppts.profilepointstype = ''M'')
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPD_Report]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
CREATE procedure [prcCPD_Report]
(
@profileid int = -1,
@profileperiodid int = -1,
@firstname varchar(200)='''',
@lastname varchar(200) ='''',
@username varchar(200)='''',
@shortfallusers smallint=0,
@UnitIDs varchar(8000)='''',
@OrgID int
)
as begin


(select
hierarchyname as pathway
, u.lastname as lastname
, u.firstname as firstname
,u.username as username
,u.email as useremail
,c.name as coursee
,m.name collate database_default as module
,coalesce(upt.points,0) as points
,pf.profileid
,dbo.udfUTCtoDaylightSavingTime(upt.DateAssigned, @OrgID) as dateassigned
,m.sequence as modID
from tblProfile pf
join tblprofileperiod pp on pp.profileid = pf.profileid
join tbluserprofileperiodaccess upa on upa.profileperiodid = pp.profileperiodid
and granted = 1
join tbluser  u on u.userid = upa.userid
join tblunithierarchy uh on uh.unitid = u.unitid and u.unitid in (select IntValue from dbo.udfCsvToInt(@unitIDs))
left join tblProfilePoints ppt on ppt.profileperiodid =pp.profileperiodid
left join tblusercpdpoints upt on upt.userid = u.userid	 and upt.profilepointsid = ppt.profilepointsid
left join tblmodule m on m.moduleid = ppt.typeid and profilepointstype =''M''
left join tblcourse c on c.CourseID =  m.courseid
join vwusermoduleaccess uma on u.userid = uma.userid and m.moduleid = uma.moduleid
where
(@profileid= -1 or pf.profileid = @profileid) and
(@profileperiodid=-1 or pp.profileperiodid  = @profileperiodid)and
(@firstname ='''' or u.firstname=@firstname ) and
(@lastname ='''' or u.lastname =@lastname) and
(@username ='''' or u.username =@username) and
(@shortfallusers =0
or (select sum(u2.points) from tblusercpdpoints u2 where u2.userid = u.userid)<pp.points) or (select sum(u2.points) from tblusercpdpoints u2 where u2.userid = u.userid) is null)

union

(select
hierarchyname as pathway
, u.lastname as lastname
, u.firstname as firstname
,u.username as username
,u.email as useremail
,case when policyname is null then '''' else ''Policy'' end as coursee
,coalesce(policyname,'''') collate database_default as module
,coalesce(upt.points,0) as points
,pf.profileid
,dbo.udfUTCtoDaylightSavingTime(upt.DateAssigned, @OrgID) as dateassigned
,null as modID
from tblProfile pf
join tblprofileperiod pp on pp.profileid = pf.profileid
join tbluserprofileperiodaccess upa on upa.profileperiodid = pp.profileperiodid
and granted = 1
join tbluser  u on u.userid = upa.userid
join tblunithierarchy uh on uh.unitid = u.unitid and u.unitid in (select IntValue from dbo.udfCsvToInt(@unitIDs))
left join tblProfilePoints ppt on ppt.profileperiodid =pp.profileperiodid
left join tblusercpdpoints upt on upt.userid = u.userid	 and upt.profilepointsid = ppt.profilepointsid
left join tblpolicy on tblPolicy.policyid = ppt.typeid and profilepointstype =''P''
join tblUserPolicyAccess upola on upola.userid = u.userid and upola.policyid = ppt.typeid and upola.granted = 1
where
(@profileid= -1 or pf.profileid = @profileid) and
(@profileperiodid=-1 or pp.profileperiodid  = @profileperiodid)and
(@firstname ='''' or u.firstname=@firstname ) and
(@lastname ='''' or u.lastname =@lastname) and
(@username ='''' or u.username =@username) and
(@shortfallusers =0
or (select sum(u2.points) from tblusercpdpoints u2 where u2.userid = u.userid)<pp.points)  or (select sum(u2.points) from tblusercpdpoints u2 where u2.userid = u.userid) is null)
Order by
coursee,
modID


end

SET QUOTED_IDENTIFIER OFF
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcCPD_CurrentPoints]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE procedure [prcCPD_CurrentPoints]
(
@ProfileID  varchar(20),
@ModuleID	varchar(20),
@UserID		varchar(20)
)
as

select
sum(upt.Points) as Points
from
tblProfilePeriod pp
join tblProfilePoints pt
on pt.profileperiodid =pp.profileperiodid
join tbluserCPDPoints upt
on upt.profilepointsID = pt.profilepointsid
where
pt.profilepointstype =''M''
and pt.typeid = @ModuleID
and pp.profileid =@ProfileID
and upt.userid =@UserID
and getutcdate() between pp.DateStart and dateadd(d,1,pp.dateend)
group by
convert(varchar (11),pp.DateStart,113) + '' - '' + convert( varchar(11),pp.DateEnd,113)

SET QUOTED_IDENTIFIER ON
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcUser_GetQuizSummary]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

/*
Summary: Returns the quiz history for a given user for a given module
Parameters: @QuizSessionID 	Varchar(50)
Returns:
QuizScore,
QuizPassMark,
DateTimeStarted,
DateTimeCompleted

Called By: User.cs
Calls: Nothing

Remarks: Raises an error if the parameter is null

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

-- prcUser_GetQuizSummary ''923F3547-94D2-4631-8DD4-FA8F8C8AC95A''
*/
CREATE    Procedure [prcUser_GetQuizSummary]
@QuizSessionID 	Varchar(50)	-- GUID Session ID of the quiz session that we want a summary
AS

Set NoCount On

--------------------------------
---- Validation
--------------------------------
If (@QuizSessionID is NULL or datalength(@QuizSessionID) = 0)
Begin
Raiserror (''Procedure prcUser_GetQuizSummary requires the Quiz Session ID'', 16, 1)
Return
End

--------------------------------
---- Logic
--------------------------------

Declare @Results table
(
Question 		nvarchar(4000),
CorrectAnswer	 	nvarchar(4000),
GivenAnswer		nvarchar(4000),
Correct			bit,
QuizQuestionID 		integer,
QuizAnswerID   		integer
)
Insert into
@Results

Select
tblQuizQuestion.Question,
tblQuizAnswer.Answer as ''CorrectAnswer'',
null,
null,
tblQuizQuestion.QuizQuestionID,
tblQuizAnswer.QuizAnswerID

From
tblQuizAnswer
INNER JOIN tblQuizQuestion
ON tblQuizQuestion.QuizQuestionID = tblQuizAnswer.QuizQuestionID
Inner Join tblQuizQuestionAudit
On tblQuizQuestionAudit.QuizQuestionID = tblQuizQuestion.QuizQuestionID
INNER JOIN tblQuizSession
ON tblQuizSession.QuizID = tblQuizQuestion.QuizID
INNER Join tblQuizAnswerAudit
on
tblQuizQuestion.QuizQuestionID  = tblQuizAnswerAudit.QuizQuestionID
and
tblQuizAnswerAudit.QuizSessionID = @QuizSessionID


Where
tblQuizSession.QuizSessionID = @QuizSessionID
and
tblQuizAnswer.Correct = 1
order by
tblQuizQuestion.QuizQuestionID,
tblQuizAnswer.QuizAnswerID

Insert into @Results

Select
null,null,answer as ''GivenAnswer'',correct,tblQuizAnswerAudit.QuizQuestionID,tblQuizAnswerAudit.QuizAnswerID
From
tblQuizAnswerAudit, tblQuizAnswer
Where
QuizSessionID = @QuizSessionID
And
tblQuizAnswerAudit.QuizAnswerID = tblQuizAnswer.QuizAnswerID
order by
tblQuizAnswerAudit.QuizQuestionID, tblQuizAnswerAudit.QuizAnswerID


SELECT
tblModule.Name as ''Module'',
tblUser.FirstName + '' '' +tblUser.LastName as ''FullName'',
tblQuizSession.QuizScore as ''QuizScore'',
tblQuizSession.QuizPassmark as ''QuizPassmark''
FROM
tblModule
Inner Join
tblQuiz on tblQuiz.ModuleID = tblModule.ModuleID
Inner Join
tblQuizSession on tblQuizSession.QuizID = tblQuiz.QuizID
Inner Join
tblUser on tblUser.UserID = tblQuizSession.UserID
where
tblQuizSession.QuizSessionID = @QuizSessionID

Select
distinct *
from
@Results

order by
QuizQuestionID,
Question desc,
CorrectAnswer,
GivenAnswer
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuiz_GetScore]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*
Summary: Returns the score for a given quiz session
Parameters: quiz session id
Returns: integer

Called By: Quiz.aspx
Calls:nothing

Remarks: Raises an error if the parameter is null

Author: Peter Kneale
Date Created: 9th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

-- prcQuiz_GetPassMark 1,1
*/

CREATE  Procedure [prcQuiz_GetScore]
(
@QuizSessionID varchar(50)
)

As

If (@QuizSessionID is NULL or datalength(@QuizSessionID) = 0)
Begin
Raiserror (''Procedure prcQuiz_GetScore requires a quiz session id'', 16, 1)
Return
End

select
cast(round(sum(cast(tblQuizAnswer.correct as int)*100.00)/count(tblQuizAnswer.QuizAnswerID),0) as int)
from
tblQuizQuestionAudit
inner join
tblQuizAnswerAudit
on
tblQuizAnswerAudit.QuizQuestionID = tblQuizQuestionAudit.QuizQuestionID
and
tblQuizQuestionAudit.QuizSessionID = @QuizSessionID
and
tblQuizAnswerAudit.QuizSessionID = @QuizSessionID
inner join
tblQuizAnswer
on
tblQuizAnswerAudit.QuizAnswerID = tblQuizAnswer.QuizAnswerID
group by tblQuizAnswerAudit.QuizSessionID

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfilePoints_Update]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Updates ProfilePoints

Parameters:
@ProfilePointsID int,
@ProfilePointsType nvarchar(1),
@TypeID int,
@ProfilePeriodID int,
@Points numeric(10,1),
@Active bit,
@DateAssigned datetime

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcProfilePoints_Update]
(
@ProfilePointsID int,
@ProfilePointsType nvarchar(1),
@TypeID int,
@ProfilePeriodID int,
@Points numeric(10,1),
@Active bit,
@DateAssigned datetime,
@OrgID int
--@ApplyToQuiz bit,
--@ApplyToLesson bit
)

as

set @DateAssigned = dbo.udfDaylightSavingTimeToUTC(@DateAssigned, @OrgID)

-- update tblProfilePoints values
update tblProfilePoints
set
ProfilePointsType = @ProfilePointsType,
TypeID = @TypeID,
ProfilePeriodID = @ProfilePeriodID,
Points = @Points,
Active = @Active --,
--DateAssigned = @DateAssigned --,
--ApplyToQuiz = @ApplyToQuiz,
--ApplyToLesson = @ApplyToLesson
where ProfilePointsID = @ProfilePointsID

' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfilePoints_Add]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Adds Profile

Parameters:
@ProfilePointsType nvarchar(1),
@TypeID int,
@ProfilePeriodID int,
@Points numeric(10,1),
@Active bit,
@DateAssigned datetime

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

CREATE procedure [prcProfilePoints_Add]
(
@ProfilePointsType nvarchar(1),
@TypeID int,
@ProfilePeriodID int,
@Points numeric(10,1),
@Active bit,
@OrgID int
--@ApplyToQuiz bit,
--@ApplyToLesson bit
)

as



-- insert values into tblProfilePoints
insert into tblProfilePoints
(
ProfilePointsType,
TypeID,
ProfilePeriodID,
Points,
Active,
DateAssigned --,
--ApplyToQuiz,
--ApplyToLesson
)
values
(
@ProfilePointsType,
@TypeID,
@ProfilePeriodID,
@Points,
@Active,
GETUTCDATE() --,
--@ApplyToQuiz,
--@ApplyToLesson
)

/****** Object:  Table [dbo].[tbllogInstall42]    Script Date: 07/07/2011 17:05:54 ******/
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N''[dbo].[tbllogInstall42]'') AND type in (N''U''))
DROP TABLE [dbo].[tbllogInstall42]
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfilePeriod_RollOver]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'CREATE procedure [prcProfilePeriod_RollOver]
as begin

-- AC notes:
-- Get all periods that are active and end date has passed then
-- a) if there are instructions to make a future period then populate a new
-- record with the future period (+ instructions with what to do with the period following
-- that

/*
-- b) if there are no instructions to make a future period then populate a new record
-- with no current period or future period instructions (so user can create a period
-- at a later time */
-- c) then make the active period inactive
-- d) following this need to go through all code that references profile periods and add
-- sql to that code to take into account the profileperiodactive field

declare @tmptable table
(
ppid int,
pid int,
newppid int
)

/*	get all the periods that have been,
and have a future period that havnt been created yet*/
/*insert into @tmptable (ppid, pid)
select
p2.profileperiodid, p2.profileid
from
tblprofileperiod p1
right join tblprofileperiod p2 on p1.profileid = p2.profileid
and p1.datestart = p2.futuredatestart and p1.dateend = p2.futuredateend
where
p1.profileperiodid is null
and dateadd(hh,24,p2.dateend) <getutcdate()
and p2.endofperiodaction in (2,3,4)*/

insert into @tmptable (ppid, pid)
select
profileperiodid, profileid
from
tblProfilePeriod
where
profileperiodactive = 1
and dateadd(hh,24,dateend) < getutcdate()
order by profileid



--	add them into the profile period table
insert into tblprofileperiod (profileid,datestart,dateend, points, applytoquiz, applytolesson, endofperiodaction, monthincrement, futuredatestart, futuredateend, futurepoints, profileperiodactive)
select
pid,
futuredatestart,
futuredateend,
futurepoints,
applytoquiz,
applytolesson,
case when endofperiodaction = 4 then 1
else endofperiodaction end
as futureendofperiodaction,
monthincrement,
case when endofperiodaction = 4 then null
else dateadd(day, 1, futuredateend) end
as newfuturedatestart,
case when endofperiodaction = 4 then null
when endofperiodaction = 3 then dateadd(month, monthincrement, futuredateend)
when endofperiodaction = 2 then dateadd(day, 1, dateadd(day, datediff(day, futuredatestart, futuredateend), futuredateend)) end
as newfuturedateend,
futurepoints,
1
from
tblprofileperiod
join @tmptable on ppid = profileperiodid


-- make the active period inactive
update tblprofileperiod
set
profileperiodactive = 0
where
profileperiodid in
(select ppid from @tmptable)


-- remove the ones we dont need to do anything with
delete from @tmptable where ppid not  in
(
select profileperiodid from
tblprofileperiod
join @tmptable on ppid = profileperiodid and endofperiodaction in (2,3,4)
)

-- get the ids for the new profile periods
update @tmptable set newppid = p1.profileperiodid
from
tblprofileperiod p1
--right join tblprofileperiod p2 on p1.profileid = p2.profileid
--and p1.datestart = p2.futuredatestart and p1.dateend = p2.futuredateend
join @tmptable t2 on t2.pid = p1.profileid
and p1.profileperiodactive = 1


--copy across the points from the previous period into the new one
insert into tblprofilepoints
(profileperiodid, profilepointstype,typeid, points,active, dateassigned)
select
newppid,
p1.profilepointstype,
p1.typeid,
p1.points,
p1.active,
getutcdate()
from
tblprofilepoints p1
join @tmptable on ppid = profileperiodid


/* initialise user access to the period
(will give the same users access as previously assigned)*/
insert into tbluserprofileperiodaccess
(profileperiodid, userid, granted)
select
newppid,
pa.userid,
pa.granted
from tbluserprofileperiodaccess pa
join @tmptable on ppid = profileperiodid

/* initialise unit access to the period
(will give the same unit access as previously assigned)*/
insert into tblunitprofileperiodaccess
(profileperiodid, unitid, granted)
select
newppid,
pa.unitid,
pa.granted
from tblunitprofileperiodaccess pa
join @tmptable on ppid = profileperiodid

end
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_GetPolicyPoints]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'
/*Summary:
Gets policies and points for an organisation

Parameters:
@OrganisationID int,

Returns:
Nothing

Called By:
Profile.cs.

Calls:
Nothing

Remarks:
None

Author: Aaron Cripps
Date Created: July 2008

Modification History
-----------------------------------------------------------
v#	Author		Date			Description

**/

create procedure [prcProfile_GetPolicyPoints]
(
@OrganisationID int,
@ProfilePeriodID int
)
as

declare @policytmp table
(
policyid int,
policyname nvarchar(255),
ptsid int,
pts numeric(10,1)
)

insert into @policytmp (policyid, policyname)
select
policyid, policyname
from
tblpolicy
where organisationid =@organisationid
and deleted = 0

update @policytmp set ptsid = pp.profilepointsid, pts =pp.points
from
@policytmp pt
left join tblprofilepoints pp on pt.policyid = pp.typeid and pp.active = 1 and pp.profilepointstype =''P''
where pp.profileperiodid = @profileperiodid


select
ptsid as profilepointsid,
policyid,
policyname,
coalesce(pts,0) as policypoints
from @policytmp


' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcProfile_GetModulePointsByCourse]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Gets a list of Modules per Course
Parameters:
@courseID Integer ID of the Course to return the Modules for.
Returns:

Called By:
Module.cs
Calls:

Remarks:

Author: Gavin Buddis
Date Created: 16th of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
*/

CREATE Procedure [prcProfile_GetModulePointsByCourse]
(
@courseID int, -- ID of the Course to return the Modules for.
@ProfilePeriodID int,
@OrgID int
)

As

BEGIN

Set Nocount On

If(@courseID Is Null)
Begin
Raiserror(''The @courseID parameter was Null.  You must supply a value.'', 16, 1)
Return
End

create table  #Modules
(
ModuleID int,
CourseID int,
Name nvarchar(100),
Sequence int,
Description nvarchar(1000),
Active bit,
CreatedBy int,
DateCreated datetime,
UpdatedBy int,
DateUpdated datetime
)

insert into #Modules
exec prcModule_GetListByCourse @CourseID, @OrgID

alter table #modules add [ptsid] int, pts numeric(10,1)

update #modules set ptsid = pp.ProfilePointsID, pts = pp.Points
from
#Modules m
left outer join tblProfilePoints pp	on m.ModuleID = pp.typeID
where
(pp.profilepointstype = ''M''
and pp.active = 1
and pp.ProfilePeriodID = @ProfilePeriodID)

select
ptsid as ProfilePointsID,
m.ModuleID,
m.Name as [Module Name],
coalesce(pts,0) as Points
from #modules m
where m.active = 1

drop table #modules
END

/****** Object:  StoredProcedure [dbo].[prcPolicy_GetAdminsInOrgPendingPolicy]    Script Date: 07/07/2011 13:54:32 ******/
SET ANSI_NULLS ON
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetToolbookPageIDByLessonPageID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetToolbookPageIDByLessonPageID    Script Date: 20/04/2004 8:25:57 AM ******/




/*
Summary:
user Defined Function that returns a Toolbook Page ID given a Lesson Page ID
only Works for a lesson
Returns:
scaler - Toolbook Page id - varchar(50)

Called By:

Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


print dbo.udfGetLessonPageIDByToolbookPageID(''toolBookID-1'')
-- select * from tblLessonPage

**/
CREATE   FUNCTION [udfGetToolbookPageIDByLessonPageID]
(
@lessonPageID int -- The PK value for a lesson in the LessonPage table
)
RETURNS varchar(50) --< ToolBookPageID >--
Begin
------------------------------------------
-- get Toolbook Page ID  for this Lesson Page ID
------------------------------------------

DECLARE @retVal int
set @retVal =
(
SELECT TOP 1
ToolbookPageID
FROM
tblLessonPage
WHERE
LessonPageID = @lessonPageID
)

RETURN @retVal
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcToolbook_Preview]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Displays a preview of the data from an XML document before inserting it into the tblLesson,tblLessonPage,tblQuiz, tblQuizQuestion, tblQuizAnswer table
Parameters:
@strXMLData Text = null, 	-- XML document
@intModuleID	Integer		-- Module Id of the module
Returns:
two Result sets

-- Return Results
One: The first result set has the totals for the Upload
The Upload Type - Correction or Update
The Toolbook Type - Lesson or Quiz

Two: The second result set holds the detail of the records that will be inserted if spImportToolbook is called.


Called By:
Toolbook.cs
Calls:
sp_xml_preparedocument -- system stored procedure to ALTER  an internal representation of the XML document.
udfGetQuizIDByToolbookIDAndModuleID
udfGetLessonIDByToolbookIDAndModuleID

Remarks: The XML document must be well formed otherwise the process will fail.

Author: Peter Kneale
Date Created: 23rd of February 2004

Modification History
-----------------------------------------------------------
v#	Author			Date			Description
#1	Jack Liu		12/09/2005		Add extra validation for Quiz CORRECTION
For Quiz CORRECTION, the correct answer can''t be changed.
#2	Liz Dionisio	28/09/2005		Modified Quiz Correction validation
#3	mikev			4/5/2007		Removed correction logic
*/
CREATE Procedure [prcToolbook_Preview]
(
@strXMLData     NText = null, 	-- XML document
@intModuleID	Integer       = null,		-- Module Id of the module
@intUserID int
)

As
Set NoCount On
Set Xact_Abort On

-- Check if the XML document was passed.
If(@strXMLData Is Null)
Begin
Raiserror(''The @strXMLData parameter was Null.  You must supply a valid XML document.'', 16, 1)
Return
End
If(@intModuleID Is Null)
Begin
Raiserror(''The @intModuleID parameter was Null.  You must supply a valid XML document.'', 16, 1)
Return
End



Begin Transaction

Declare @intDocHeader			 	Integer		--
Declare @strRowPattern 				Varchar(50)	-- Pattern to match on when calling OpenXML
Declare @strToolbookType 			Varchar(50)	-- Lesson or Quiz
Declare @strUploadType				Varchar(50)	-- Correction or Update
Declare @strToolbookID				Varchar(50)	-- Toolbook ID
Declare @DatePublished				DateTime	-- Date new content was published
Declare @intXMLUpdates				Integer		-- Number of updates contained in the XML file.

-- Quiz specific
Declare @intQuizID				Integer		-- Salt QuizID
Declare @intQuestions				Integer		-- Number of Questions
Declare @intAnswers				Integer		-- Number of Answers
Declare @intDocQuizQuestions			Integer		-- Number of Questions in new content
Declare @intDocQuizAnswers			Integer		-- Number of Answer in new content

-- Lesson specific
Declare @intLessonID				Integer		-- Salt Lesson ID
Declare @intLessons				Integer		-- Number of Lesson pages
Declare @intDocLessons				Integer		-- Number of Lesson pages in new content

-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
----------- Create Necessary Temporary Tables
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------
-------- Create Temporary Table for Quiz Questions
----------------------------------------------------------------------------
Create Table #xmlUploadQuizQuestions
(
ToolbookPageID	Varchar(50),		-- Toolbook Page ID for new Quiz Question
PageTitle 		Varchar(255)		-- Toolbook Question for new Quiz Question
)

----------------------------------------------------------------------------
-------- Create Imaginary Table for Quiz Answers
----------------------------------------------------------------------------
Create Table #xmlUploadQuizAnswers
(
ToolbookQuestionID	Varchar(50),		-- Toolbook Question ID for new Quiz Answer
ToolbookAnswerID	Varchar(50),		-- Toolbook Answer ID for new Quiz Answer
Correct 		Varchar(255),		-- ''True'' or ''False'' indicating whether this answer is correct or not
bCorrect 		bit,			-- 0 or 1 indicating if the answer is correct, this is derived from the Correct Column
AnswerText		Varchar(255),		-- The answer
QuizQuestionID		Integer			-- Salt Quiz Question ID column is a placeholder but is later populated to assist in the upload
)

----------------------------------------------------------------------------
-------- Create Imaginary Table for Lessons
----------------------------------------------------------------------------
Create Table #xmlUploadLessons
(
ToolbookPageID	Varchar(50),		    -- Toolbook Page ID for new Lesson
PageTitle 	Varchar(255)		    -- Toolbook Page Title for new Lesson
)
----------------------------------------------------------------------------
-------- Create Imaginary Table for Upload Information
----------------------------------------------------------------------------
Create Table #xmlUploadHeader
(
ToolBookID		Varchar(50),		    	-- Toolbook ID for new Content
ToolBookType 		Varchar(50),		    	-- Toolbook type, Quiz or Lesson
NumberOfPages 	   	Integer,			-- Number of Pages in new content
DatePublished		DateTime,		        -- Date new content was published
UploadType		Varchar(50)		        -- New Content type, ''Correction'' , ''Update''
)

-- Temporary Tables used for validating the number of questions and answers in the
-- new content compared to the old content
Declare @xmlExisting Table
(
QuizQuestionID	Varchar(50),		-- Toolbook Page ID for new Quiz Question
Answers 	Varchar(255)		-- Toolbook Question for new Quiz Question
)
Declare @xmlNew Table
(
QuizQuestionID	Varchar(50),		-- Toolbook Page ID for new Quiz Question
Answers 	Varchar(255)		-- Toolbook Question for new Quiz Question
)


----------------------------------------------------------------------------
-------- Insert Upload Information Into Imaginary Table

----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload''
Exec sp_xml_preparedocument @intDocHeader Output, @strXMLData

Insert into #xmlUploadHeader
(
ToolBookID,
ToolBookType,
NumberOfPages,
DatePublished,
UploadType
)

Select
ToolBookID,
ToolBookType,
NumberOfPages,
DatePublished,
UploadType
From

OpenXml
(@intDocHeader, @strRowPattern)
With
(
ToolBookID		Varchar(50) 	''ToolBookID'',
ToolBookType		Varchar(50)		''ToolBookType'',
NumberOfPages		Integer			''NumberOfPages'',
DatePublished		DateTime		''DatePublished'',
UploadType		Varchar(50)		''UploadType''
)


----------------------------------------------------------------------------
-------- Insert Lessons Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload/Pages/Page''
Exec sp_xml_preparedocument @intDocLessons Output, @strXMLData

Insert into #xmlUploadLessons
(
ToolbookPageID,
PageTitle
)


Select
ToolbookPageID,
PageTitle
From

OpenXml
(@intDocLessons, @strRowPattern)
With
(
ToolbookPageID	Varchar(50) 	''@ID'',
PageTitle		Varchar(255)	''PageTitle''
)

----------------------------------------------------------------------------
-------- Insert Quiz Questions Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload/Pages/Page''
Exec sp_xml_preparedocument @intDocQuizQuestions Output, @strXMLData

Insert into #xmlUploadQuizQuestions
(
ToolbookPageID,
PageTitle
)

Select

ToolbookPageID,
PageTitle
From

OpenXml
(@intDocQuizQuestions, @strRowPattern)
With
(
ToolbookPageID	Varchar(50) 	''@ID'',
PageTitle		Varchar(255)	''PageTitle''
)

----------------------------------------------------------------------------
-------- Insert Quiz Answers Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload/Pages/Page/Answers/Answer''
Exec sp_xml_preparedocument @intDocQuizAnswers Output, @strXMLData

Insert into #xmlUploadQuizAnswers
(
ToolbookQuestionID,
ToolbookAnswerID,
AnswerText,
Correct
)
Select
ToolbookQuestionID,
ToolbookAnswerID,
AnswerText,
Correct
From

OpenXml
(@intDocQuizAnswers, @strRowPattern)
With
(
ToolbookQuestionID	Varchar(50) 	''../../@ID'',  -- navigate back up to the question
ToolbookAnswerID	Varchar(50) 	''@ID'',
AnswerText			Varchar(255)	''AnswerText'',
Correct				Varchar(255)	''@correct''
)



----------------------------------------------------------------------------------------------------
-------- Determine if we are uploading a Quiz or a Lesson and whether its an update or a correction
----------------------------------------------------------------------------------------------------
Select
@strToolbookType = ToolBookType, @strUploadType = UploadType
From
#xmlUploadHeader



If (ltrim(rtrim(@strToolbookType)) = ''quiz'')
Begin
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
----------- Process Upload from Imaginary Tables
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
Select 	@strToolbookID 	= ToolBookID From #xmlUploadHeader
Select 	@DatePublished 	= DatePublished From #xmlUploadHeader
Set 	@intQuizID 		= dbo.udfGetQuizIDByToolbookIDAndModuleID (@strToolbookID,@intModuleID)

-------------------------------------------------------------------------------------------------------------------------------------
----------- Perform an update
-------------------------------------------------------------------------------------------------------------------------------------
-- Return message
Select @strUploadType as ''Message'', @strToolbookType as ''ToolbookType''

-- Return Results
Select
#xmlUploadQuizQuestions.PageTitle as ''Updated Questions'',
#xmlUploadQuizAnswers.AnswerText  as ''Updated Answers''
From
#xmlUploadQuizQuestions,#xmlUploadQuizAnswers
Where
#xmlUploadQuizAnswers.ToolbookQuestionID = #xmlUploadQuizQuestions.ToolbookPageID

End   -- End Quiz




-- Lesson
If (ltrim(rtrim(@strToolbookType)) = ''LESSON'')
Begin
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
----------- Process Upload from Imaginary Tables
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
Select
@strToolbookID = ToolBookID
From
#xmlUploadHeader
Select
@DatePublished = DatePublished
From
#xmlUploadHeader

-- Get the lesson ID
Set 	@intLessonID 		= dbo.udfGetLessonIDByToolbookIDAndModuleID (@strToolbookID,@intModuleID)


-------------------------------------------------------------------------------------------------------------------------------------
----------- Perform an update
-------------------------------------------------------------------------------------------------------------------------------------
-- Return message
Select
@strUploadType 	as ''Message'',
@strToolbookType 	as ''ToolbookType'',
GETDATE() 		as ''Time now'',
@intLessonID

-- Return Results
Select
#xmlUploadLessons.PageTitle as ''Updated Lesson''
From
#xmlUploadLessons


End



Commit
Return

ErrorHandler:
rollback
Return
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetLessonPageIDByToolbookPageID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetLessonPageIDByToolbookPageID    Script Date: 20/04/2004 8:25:57 AM ******/






/*
Summary:
user Defined Function that returns a Lesson Page ID given a Toolbook Page ID
only Works for a lesson
Returns:
scaler - Lesson Page id - int

Called By:
dbo.prcLessonPageAudit_InsertPageVisited
dbo.prcLessonSession_EndLesson
Calls:

Remarks:


Author:
Stephen Kennedy-Clark
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1


print dbo.udfGetLessonIDByToolbookID(''toolBookID-1'')
-- select * from tblLessonPage

**/
CREATE     FUNCTION [udfGetLessonPageIDByToolbookPageID]
(
@toolBookPageID varchar(50) -- Tool Book Page ID
, @lessonID	integer	    -- The lesson id
)
RETURNS INT --< LessonPageID >--
Begin
------------------------------------------
-- get Lesson Page ID for this Toolbook Page ID
------------------------------------------

DECLARE @retVal int
set @retVal =
(
(
SELECT TOP 1
LessonPageID
FROM
tblLessonPage
WHERE
ToolbookPageID = @toolBookPageID
and lessonID = @lessonID
)
)

RETURN @retVal
End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonSession_EndLesson]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
this proc records that a lesson has ended
it also:
-- Checks that the lesson has started -- if it has not - return false
-- Checks that the lesson has not already ended -- if it has - return false

Returns:
boolean (bit) OK true = 1, false = 0

Called By:
Businessservices.Toolbook.EndLessonSession
Calls:
dbo.udfGetUserIDBySessionID
dbo.udfGetLessonPageIDByToolbookPageID
dbo.udfGetLessonIDBySessionID
Remarks:

Author:
Stephen Kennedy-Clark
Date Created: 5 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1
#2 Removed unnecessary transactions

-----------
prcLessonSession_EndLesson @LessonSessionID = ''4986F67F-FF29-4979-9A97-D7846839E0DB''
select * from tblLessonSession

**/

CREATE      Procedure  [prcLessonSession_EndLesson]
(
@lessonSessionID	varchar(50),		-- the lesson session id
@duration		int,			-- the duration
@bookmark		varchar(50)  = null 	-- the bookmark
)

As
Set NoCount On
Set Xact_Abort On


------------------------------------------
-- Declerations
------------------------------------------
Declare @bitReturnCalue  bit, -- Return Code
@intUserID 	 int, -- User ID
@intLessonPageID int, -- Lesson Page ID
@intlessonID 	 int  -- Lesson ID (PK on lesson table)

------------------------------------------
-- initations
------------------------------------------
set @intUserID 	   	= dbo.udfGetUserIDBySessionID(@lessonSessionID)
set @intlessonID	= dbo.udfGetLessonIDBySessionID(@lessonSessionID)

------------------------------------------
-- Checks that the lesson has started - if it has not -> return false
-- and
-- Checks that the lesson has not already ended - if it has -> return false
-- If all is OK then end the lessson by recording lesson end time and duration
-- and delete the old bookmark
-- and then set the bookmark (if one was given)
------------------------------------------
If Exists
(
Select
LessonSessionID
From
tblLessonSession
Where
LessonSessionID=@LessonSessionID
--< Check that the lesson has started >--
And DateTimeStarted Is Not Null
--< Check that the lesson has not already ended >--
And DateTimeCompleted Is Null
)


Begin --< it is ok to End, record End and return true >--
Update
[tblLessonSession]
Set
[DateTimeCompleted]= GETUTCDATE(),
[Duration]         = @duration
Where
[LessonSessionID]  = @lessonSessionID
------------------------------------------

--< delete the existing bookmark for this user for this lesson >--
delete tblBookmark
From
tblBookmark tBM
Inner Join tblLessonPage tLP
On tLP.LessonPageID = tBM.LessonPageID
Where
tLP.LessonID = @intlessonID
And tBM.UserID = @intUserID
------------------------------------------

--< create a new bookmark for this user for this lesson >--
if len(@bookmark) != 0 or @bookmark is not null
begin
set @intLessonPageID = dbo.udfGetLessonPageIDByToolbookPageID(@bookmark, @intlessonID)
Insert Into
tblBookmark
(
[LessonPageID]
, [UserID]
, [DateCreated]
)
Values
(
@intLessonPageID
, @intUserID
, GETUTCDATE()
)
end
------------------------------------------
set @bitReturnCalue = 1 --< return 1 indicates sucess >--


End
Else
Begin  -- it is NOT ok to End, return false
set @bitReturnCalue = 0
End


------------------------------------------
-- return
------------------------------------------

Select @bitReturnCalue as ''OKToEnd''




' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcLessonPageAudit_InsertPageVisited]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'

-- exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''EC58F6F8-85FB-4BEC-9E42-1C54E4B16D3F'', @toolBookPageID = ''salt_2-293008''
/*Summary:
inserts the page visited
returns true if the lesson has not (a) already been finished and (b) page exists in the toolbook
Returns:
bit 1 = true, 0 = false

Called By:
TooolBooLlistner.aspx via Businessservices.Toolbook.RecordPageVisited
Calls:
dbo.udfGetLessonPageIDByToolbookPageID

Remarks:
- at least one of lessonPageID or ToolbookPageID must be supplied
- returns nothing
Exception:
0. Success
4. UniqueViolationException
5. MissingParameterException
10. BusinessServiceException (General)

Author:
Stephen Kennedy-Clark
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v# Author  Date   Description
#1

exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''4686890D-B458-402B-B32A-80F8FDCEB6BA'', @toolBookPageID = ''salt_34-253006''
exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''F6D89B6F-CE87-4AF0-880F-61037538B0BC'', @toolBookPageID = ''salt_29-231005''
exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''EC58F6F8-85FB-4BEC-9E42-1C54E4B16D3F'', @toolBookPageID = ''salt_2-293008''
exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''0860A9EA-3D97-423C-AAC4-42435A15E336'', @toolBookPageID = ''salt_34-250002''
exec prcLessonPageAudit_InsertPageVisited @lessonSessionID = ''0860A9EA-3D97-423C-AAC4-42435A15E336'', @toolBookPageID = ''salt_34-250008A''
print dbo.udfGetLessonPageIDByToolbookPageID(''salt_34-250002'')
--------------------


**/


CREATE     PROC [prcLessonPageAudit_InsertPageVisited]
(
@lessonSessionID  varchar(50)  -- the Lesson Session ID
, @lessonPageID   int   = null -- the lesson page id
, @toolBookPageID  varchar(50)  = null -- the toolbook page id
)

AS
Set NoCount On
Set Xact_Abort On
Begin Transaction



------------------------------------------
-- Declerations
------------------------------------------
Declare @intReturnValue int 		-- Return Value
, @strErrorMessage varchar(100) -- error message
, @intErrorNumber int		-- error Number
, @intLessonID int		-- the lesson ID
-- Initialise variables
Set @intErrorNumber = 0
Set @strErrorMessage = ''''


------------------------------------------
-- Validation - ensure that the required paramaters
-- were supplied
------------------------------------------

--< check that either the userID or the lessonSessionID were supplied >--
IF @lessonPageID IS NULL AND @toolBookPageID IS NULL
BEGIN
set @intErrorNumber = 5 -- MissingParameterException
set @strErrorMessage = ''Procedure prcLessonPageAudit_InsertPageVisited expects at least one  the following pramaters: @lessonPageID or @toolBookPageID''
Goto Finalise
END

------------------------------------------
-- If @lessonPageID not suppled then get it from @toolBookPageID
------------------------------------------

IF @lessonPageID IS NULL
BEGIN
-- first we need the lesson ID because toolbook id''s are not unique
SET @intLessonID = dbo.udfGetLessonIDBySessionID(@lessonSessionID)
-- now we can get the lessonpageID from the
SET @lessonPageID = dbo.udfGetLessonPageIDByToolbookPageID(@toolBookPageID, @intLessonID)
END
IF @lessonPageID IS NULL
BEGIN
set @intErrorNumber = 10 --BusinessServiceException
set @strErrorMessage =  ''Procedure prcLessonPageAudit_InsertPageVisited was passed a value for the paramater "@toolBookPageID" that does not exist in this database''
Goto Finalise
END
------------------------------------------
-- Validation - ensure that the lesson has been started but is not already finished
-- and that the ToolBook pageID exists
------------------------------------------
if exists --< ensure that the lesson has been started but is not already finished  >--
(
Select
LessonSessionID
From
tblLessonSession
where
LessonSessionID = @lessonSessionID
and DateTimeStarted is not null
and DateTimeCompleted is null
)
and exists --< ensure that the ToolBook pageID exists >--
(
SELECT TOP 1
LessonPageID
FROM
tblLessonPage
WHERE
ToolbookPageID = @toolBookPageID
)

Begin --< It''s ok to continue>--

------------------------------------------
-- insert the new row
-- what checks for uniquness should be preformed ???
------------------------------------------
if not exists (select LessonSessionID from tblLessonPageAudit where LessonPageID = @lessonPageID and LessonSessionID = @lessonSessionID)
Begin
INSERT INTO
[tblLessonPageAudit]
(
[LessonSessionID],
[LessonPageID],
[DateAccessed]
)
VALUES(
@lessonSessionID,
@lessonPageID,
getdate()
)
End
set @intReturnValue = 1
End
Else
Begin --< opps - error, either the lesson has finished or has not been started ??? TB should error.salt will handel this gracefully in TBListiner>--
set @intReturnValue = 0
Goto Finalise
End



------------------------------------------
-- return
------------------------------------------
Finalise:
If(@intErrorNumber > 0)
Begin
set @strErrorMessage = ''Error Number: '' + cast(@intErrorNumber as char(2) ) + '' ,'' + @strErrorMessage
Raiserror (@strErrorMessage, 16, 1)
Rollback Transaction
select @intReturnValue as ''Insert is OK''
End
Else
Begin
Commit Transaction
select @intReturnValue as ''Insert is OK''
End









' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetQuizQuestionIDByToolbookPageID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetQuizQuestionIDByToolbookPageID    Script Date: 20/04/2004 8:25:57 AM ******/

/*
Summary:
user Defined Function that returns a Quiz Question ID given a Toolbook Page ID
only Works for a quiz
Returns:
scalar - Quiz Question Id - int

Called By:
ToolbookListener.cs Calls Stored Procedures which call this.

Calls:

Remarks:


Author:
Peter Kneale - Stephen Kennedy-Clark
Date Created: 3 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



**/
CREATE Function [udfGetQuizQuestionIDByToolbookPageID]
(
@toolBookPageID 	Varchar(50),	-- The id of the toolbook page
@quizID		Integer		-- The id of the quiz
)

Returns Int --< QuizQuestionID >--
Begin
-- Declarations
Declare @intRetVal Integer

-- get Quiz Question ID for this Toolbook Page ID
Set @intRetVal =
(
Select Top 1
QuizQuestionID
From
tblQuizQuestion
Where
ToolbookPageID = @toolBookPageID
And QuizID = @quizID
)


Return @intRetVal

End
' 
END
GO
SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_CreateQuizAudit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*Summary:
Given a QuizSessionID and ToolbookPageID creates an entry in the
tblQuizAudit Table.

Returns:
Nothing

Called By:
ToolbookListener.cs

Calls:
dbo.udfGetQuizIDBySessionID
dbo.udfGetQuizQuestionIDByToolbookPageID

Remarks:
The duration of the quiz is set to be 0 because toolbook does not
currently return this information, it may be added at a later date.

Author:
Peter Kneale
Date Created: 10 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1

**/

CREATE    Procedure [prcQuizSession_CreateQuizAudit]
(
@strQuizSessionID varchar(50),		-- Users Session ID
@strToolbookPageID varchar(50)	-- the Toolbook Page ID of the Quiz
)

As

Set NoCount On
Set Xact_Abort On
Begin Tran

------------------------------------------
-- Declerations
------------------------------------------
Declare @intQuizQuestionID  Integer		-- QuizQuestionID from Salt database.
Declare @intQuizID 	       Integer		-- QuizID from Salt database.

------------------------------------------
-- Get Quiz ID by SessionID
------------------------------------------
Set @intQuizID =  dbo.udfGetQuizIDBySessionID (@strQuizSessionID)
If (@intQuizID Is NULL or datalength(@intQuizID) = 0)
Begin
ROLLBACK
Raiserror (''Procedure prcQuizSession_CreateQuizAudit could not determine the @intQuizID using udfGetQuizIDBySessionID'', 16, 1)
Return
End

------------------------------------------
-- Get Question ID by SessionID
------------------------------------------
Set @intQuizQuestionID 	= dbo.udfGetQuizQuestionIDByToolbookPageID (@strToolbookPageID,@intQuizID)
If (@intQuizQuestionID Is NULL or datalength(@intQuizQuestionID) = 0)
Begin
ROLLBACK
Raiserror (''Procedure prcQuizSession_CreateQuizAudit could not determine the @intQuizQuestionID using udfGetQuizQuestionIDByToolbookPageID'', 16, 1)
Return
End

------------------------------------------
-- Insert
------------------------------------------
Insert Into
tblQuizQuestionAudit
(
QuizSessionID,
QuizQuestionID,
Duration,
DateAccessed
)
Values
(
@strQuizSessionID,
@intQuizQuestionID,
0,			-- Duration is recorded as 0 becuase the duration per question is not returned from Toolbook.
getutcDate()
)
Commit Tran
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[udfGetQuizAnswerIDByToolbookAnswerID]') AND type in (N'FN', N'IF', N'TF', N'FS', N'FT'))
BEGIN
execute dbo.sp_executesql @statement = N'/****** Object:  User Defined Function dbo.udfGetQuizAnswerIDByToolbookAnswerID    Script Date: 20/04/2004 8:25:57 AM ******/


/*
Summary:
user Defined Function that returns a Quiz Answer ID given a
ToolbookAnswerID and a Quiz Question ID

Returns:
scalar - Quiz Answer Id - int

Called By:
ToolbookListener.cs Calls Stored Procedures which call this.

Calls:

Remarks:


Author:
Gavin Buddis
Date Created: 1 Mar 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1



**/
CREATE  Function [udfGetQuizAnswerIDByToolbookAnswerID]
(
@toolbookAnswerID Varchar(50),
@quizQuestionID	Integer
)

Returns Int --< QuizAnswerID >--
Begin
------------------------------------------
-- get Quiz Answer ID for this Toolbook Answer ID
------------------------------------------

Declare @intRetVal Integer
Set @intRetVal =
(
Select Top 1
QuizAnswerID
From
tblQuizAnswer
Where
ToolbookAnswerID = @toolbookAnswerID
And
QuizQuestionID = @quizQuestionID
)

Return @intRetVal

End
' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcQuizSession_CreateQuizAnswerAudit]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'



/*Summary:
Given a QuizSessionID, ToolbookPageID and ToolbookAnswerID creates an
entry in the tblQuizAnswerAudit Table.

Returns:
Nothing

Called By:
ToolbookListener.cs

Calls:
dbo.udfGetQuizIDBySessionID
dbo.udfGetQuizQuestionIDByToolbookPageID
dbo.udfGetQuizAnswerIDByToolbookAnswerID

Remarks:

Author:
Peter Kneale
Date Created: 10 Feb 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Gavin Buddis	1 Mar 2004		Retreived the QuizAnswerID to insert rather than the ToolbookAnswerID

**/

CREATE    Procedure [prcQuizSession_CreateQuizAnswerAudit]
(
@strQuizSessionID 	Varchar(50),		-- Users Session ID
@strToolbookPageID 	Varchar(50),		-- the Toolbook ID of the quiz
@intToolbookAnswerID 	Integer			-- the Quiz Answer ID
)

As

Set NoCount On
Set Xact_Abort On
Begin Transaction

------------------------------------------
-- Declerations
-----------------------------------------
Declare @intQuizID integer
Declare @intQuizQuestionID integer
Declare @intQuizAnswerID integer

------------------------------------------
-- Get Quiz ID by SessionID
-------------------------------------------
Set @intQuizID = dbo.udfGetQuizIDBySessionID(@strQuizSessionID)
If (@intQuizID is NULL or datalength(@intQuizID) = 0)
Begin
Rollback
INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''Procedure prcQuizSession_CreateQuizAudit '',''No data found in tblQuizSession for QuizSessionID'',''@strQuizSessionID = ''+CAST(@strQuizSessionID AS varchar(40)),''No data found in tblQuizSession for QuizSessionID'',''No data found in tblQuizSession for QuizSessionID'',''prcQuizSession_CreateQuizAudit'',1,1,null,getutcdate(),getutcdate()) 
Raiserror (''Procedure prcQuizSession_CreateQuizAudit could not determine the @intQuizID using udfGetQuizIDBySessionID'', 16, 1)
Return
End

------------------------------------------
-- Get Quiz Question ID by Toolbook PageID
-------------------------------------------
Set @intQuizQuestionID 	=  dbo.udfGetQuizQuestionIDByToolbookPageID(@strToolbookPageID, @intQuizID)
If (@intQuizQuestionID is NULL or datalength(@intQuizQuestionID) = 0)
Begin
Rollback
INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''Procedure prcQuizSession_CreateQuizAudit '',''udfGetQuizQuestionIDByToolbookPageID returned null'',''@strToolbookPageID = ''+CAST(@strToolbookPageID AS varchar(40))+'', @intQuizID = ''+CAST(@intQuizID AS varchar(40)),''udfGetQuizQuestionIDByToolbookPageID returned null'',''udfGetQuizQuestionIDByToolbookPageID returned null'',''prcQuizSession_CreateQuizAudit'',1,1,null,getutcdate(),getutcdate()) 
Raiserror (''Procedure prcQuizSession_CreateQuizAudit could not determine the @intQuizQuestionID using udfGetQuizQuestionIDByToolbookPageID'', 16, 1)
Return
End

------------------------------------------
-- Get Quiz Answer ID by Toolbook AnswerID
-------------------------------------------
DECLARE @intValidAnswer integer
Set @intValidAnswer =
(
Select count(*)
From
tblQuizAnswer
Where
ToolbookAnswerID = @intToolbookAnswerID
And
QuizQuestionID = @intQuizQuestionID
)
if (@intValidAnswer = 0)
BEGIN
   Rollback
   INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''Procedure prcQuizSession_CreateQuizAudit '',''ToolBook Answer is not in the list of possible answers for this Quiz'',''@toolbookAnswerID = ''+CAST(@intToolbookAnswerID AS varchar(40))+'', @quizQuestionID = ''+CAST(@intQuizQuestionID AS varchar(40)),''ToolBook Answer is not in the list of possible answers for this Quiz'',''ToolBook Answer is not in the list of possible answers for this Quiz'',''prcQuizSession_CreateQuizAudit'',1,1,null,getutcdate(),getutcdate())
   DECLARE @ErrStr varchar(2000)
   Set @ErrStr = ''ToolBook Answer is not in the list of possible answers for this Quiz, @toolbookAnswerID = ''+CAST(@intToolbookAnswerID AS varchar(40))+'', @quizQuestionID = ''+CAST(@intQuizQuestionID AS varchar(40))
   Raiserror (@ErrStr, 16, 1)
   Return 
END
ELSE
BEGIN
	Set @intQuizAnswerID = dbo.udfGetQuizAnswerIDByToolbookAnswerID(@intToolbookAnswerID, @intQuizQuestionID)
	If (@intQuizAnswerID is NULL or datalength(@intQuizAnswerID) = 0)
	Begin
	Rollback
	INSERT into tblErrorLog ([Source],[Module],[Function],[Code],[Message],[StackTrace],[ErrorLevel],[ErrorStatus],[Resolution],[DateCreated],[DateUpdated])     VALUES(''Procedure prcQuizSession_CreateQuizAudit '',''dbo.udfGetQuizAnswerIDByToolbookAnswerID returned null'',''@intToolbookAnswerID = ''+CAST(@intToolbookAnswerID AS varchar(40))+'', @intQuizQuestionID = ''+CAST(@intQuizQuestionID AS varchar(40)),''dbo.udfGetQuizAnswerIDByToolbookAnswerID returned null'',''dbo.udfGetQuizAnswerIDByToolbookAnswerID returned null'',''prcQuizSession_CreateQuizAudit'',1,1,null,getutcdate(),getutcdate())
	Raiserror (''Procedure prcQuizSession_CreateQuizAudit could not determine the @intAnswerID using udfGetQuizAnswerIDByToolbookAnswerID'', 16, 1)
	Return
	End
END
------------------------------------------
-- Insert
------------------------------------------
Insert Into
tblQuizAnswerAudit
(
QuizSessionID,
QuizQuestionID,
QuizAnswerID
)
Values
(
@strQuizSessionID,
@intQuizQuestionID,
@intQuizAnswerID
)
Commit Tran

' 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF NOT EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[prcToolbook_Import]') AND type in (N'P', N'PC'))
BEGIN
EXEC dbo.sp_executesql @statement = N'/*
Summary: Uploads the details from an XML document to the tblLesson,tblLessonPage,tblQuiz, tblQuizQuestion, tblQuizAnswer table
Parameters:
@strXMLData Text = null, 	        	-- XML document
@intUserID Integer = null,          		-- ID of user inporting the xmlData
@intModuleID Integer = null,        		 -- Module Id that this quiz or lesson is associated with.
@intCourseID Integer = null,         	-- Course Id that this quiz or lesson is associated with.
@strToolLocation Varchar(500) = Null	-- Relative path to the toolbook content
Returns:
two Result sets

-- Return Results
One: The first result set has the totals for the Upload
The Upload Type - Lesson or Quiz
The time the upload took place.
The LessonID or the Quiz ID

Two: The second result set holds the detail of the records that were inserted


Called By:
Toolbook.cs
Calls:
sp_xml_preparedocument -- system stored procedure to ALTER  an internal representation of the XML document.
udfGetQuizIDByToolbookIDAndModuleID
udfGetLessonIDByToolbookIDAndModuleID

Remarks: The XML document must be well formed otherwise the process will fail.

Author: Peter Kneale
Date Created: 23rd of February 2004

Modification History
-----------------------------------------------------------
v#	Author		Date			Description
#1	Jack Liu	12/09/2005		Comment out the update answer correct status if the quiz is CORRECTION
For Quiz CORRECTION, the correct answer can''t be changed, this is validated in the prcToolbook_preview
#2	mikev		4/5/2007		Added worksiteIDs for Quiz and Lesson and that the value is copied from the old quiz/lesson to the new one.
#3	mike		4/5/2007		There is no longer a concept of corrections. All uploads are now considered updates. I have removed the updatetype variable, update statement logic and the insert logic remains.

*/
CREATE  Procedure [prcToolbook_Import]
(
@strXMLData NText = null, 	        	-- XML document
@intUserID Integer = null,          		-- ID of user inporting the xmlData
@intModuleID Integer = null,        		 -- Module Id that this quiz or lesson is associated with.
@intCourseID Integer = null,         	-- Course Id that this quiz or lesson is associated with.
@strToolLocation Varchar(500) = Null	-- Relative path to the toolbook content
)

As
Set NoCount On
Set Xact_Abort On

-- Check if the XML document was passed.
If(@strXMLData Is Null)
Begin
Raiserror(''The @strXMLData parameter was Null.  You must supply a valid XML document.'', 16, 1)
Return
End

-- Check if the ID was passed.
If(@intUserID Is Null)
Begin
Raiserror(''The @intUserID parameter was Null.  You must supply a value.'', 16, 1)
Return
End

-- Check if the Module ID was passed.
If(@intModuleID Is Null)
Begin
Raiserror(''The @intModuleID parameter was Null.  You must supply a value.'', 16, 1)
Return
End

-- Check if the Course ID was passed.
If(@intCourseID Is Null)
Begin
Raiserror(''The @intCourseID parameter was Null.  You must supply a value.'', 16, 1)
Return
End

-- Check if the Toolbook Location was passed.
If(@strToolLocation Is Null)
Begin
Raiserror(''The @strToolLocation parameter was Null.  You must supply a value.'', 16, 1)
Return
End




Declare @intDocHeader			 	Integer
Declare @strRowPattern 				nVarchar(50)
Declare @strToolbookType 			nVarchar(50)
Declare	@strUploadType				nVarchar(50)
Declare @strToolbookID				Varchar(50)
Declare @DatePublished				DateTime
Declare @intXMLUpdates				Integer

-- Quiz Specific
Declare @intQuizID				Integer
Declare @intDocQuizQuestions			Integer
Declare @intDocQuizAnswers			Integer
Declare @intQuestions				Integer
Declare @intAnswers				Integer

-- Lesson
Declare @intLessonID				Integer
Declare @intDocLessons				Integer
Declare @intLessons				Integer

-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
----------- Create Necessary Temporary Tables
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------
-------- Create Imaginary Table for Quiz Answers
----------------------------------------------------------------------------
Create Table #xmlUploadQuizAnswers
(
ToolbookQuestionID	Varchar(50),	-- The toolbook Question ID of from the new content
ToolbookAnswerID	Varchar(50),	-- The toolbook Answer ID of from the new content
Correct 		Varchar(255),	-- ''True'' or ''False'' indicating if the answer is correct
bCorrect 		bit,		-- 0 or 1 indicating if the answer is correct, this is derived from the Correct Column
AnswerText		nVarchar(1000),	-- The textual answer
QuizQuestionID		Integer		-- The QuizQuestion ID from the Salt Database.
)

----------------------------------------------------------------------------
-------- Create Temporary Table for Quiz Questions
----------------------------------------------------------------------------
Create Table #xmlUploadQuizQuestions
(
ToolbookPageID	Varchar(50),
PageTitle 		nVarchar(1000),
)

----------------------------------------------------------------------------
-------- Create Imaginary Table for Quiz Answers
----------------------------------------------------------------------------
Create Table #xmlUploadLessons
(
ToolbookPageID	Varchar(50),
PageTitle 		nVarchar(1000),
)

----------------------------------------------------------------------------
-------- Create Imaginary Table for Upload Information
----------------------------------------------------------------------------
Create Table #xmlUploadHeader
(
ToolBookID		Varchar(50),
ToolBookType 		Varchar(50),
NumberOfPages 		Integer,
DatePublished		DateTime,
UploadType		Varchar(50)
)


Begin Transaction

----------------------------------------------------------------------------
-------- Insert Upload Information Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload''
Exec sp_xml_preparedocument @intDocHeader Output, @strXMLData

Insert into #xmlUploadHeader
(
ToolBookID,
ToolBookType,
NumberOfPages,
DatePublished,
UploadType
)

Select
ToolBookID,
ToolBookType,
NumberOfPages,
DatePublished,
UploadType
From

OpenXml
(@intDocHeader, @strRowPattern)
With
(
ToolBookID		Varchar(50) 	''ToolBookID'',
ToolBookType		Varchar(50)	''ToolBookType'',
NumberOfPages		Integer		''NumberOfPages'',
DatePublished		DateTime	''DatePublished'',
UploadType		Varchar(50)	''UploadType''
)

----------------------------------------------------------------------------
-------- Insert Lessons Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload/Pages/Page''
Exec sp_xml_preparedocument @intDocLessons Output, @strXMLData

Insert into #xmlUploadLessons
(
ToolbookPageID,
PageTitle
)

Select
ToolbookPageID,
PageTitle
From

OpenXml
(@intDocLessons, @strRowPattern)
With
(
ToolbookPageID	Varchar(50) 	''@ID'',
PageTitle	nVarchar(1000)	''PageTitle''
)


----------------------------------------------------------------------------
-------- Insert Quiz Questions Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload/Pages/Page''
Exec sp_xml_preparedocument @intDocQuizQuestions Output, @strXMLData

Insert into #xmlUploadQuizQuestions
(
ToolbookPageID,
PageTitle

)

Select
ToolbookPageID,
PageTitle
From

OpenXml
(@intDocQuizQuestions, @strRowPattern)
With
(
ToolbookPageID	Varchar(50) 	''@ID'',
PageTitle	nVarchar(1000)	''PageTitle''
)



----------------------------------------------------------------------------
-------- Insert Quiz Answers Into Imaginary Table
----------------------------------------------------------------------------
Set @strRowPattern = ''/BDWToolBookUpload/Pages/Page/Answers/Answer''
Exec sp_xml_preparedocument @intDocQuizAnswers Output, @strXMLData

Insert into #xmlUploadQuizAnswers
(
ToolbookQuestionID,
ToolbookAnswerID,
AnswerText,
Correct
)
Select
ToolbookQuestionID,
ToolbookAnswerID,
AnswerText,
Correct
From

OpenXml
(@intDocQuizAnswers, @strRowPattern)
With
(
ToolbookQuestionID	Varchar(50) 	''../../@ID'',	-- Navigate back up to the question Id from this grandchild node
ToolbookAnswerID	Varchar(50) 	''@ID'',
AnswerText		nVarchar(1000)	''AnswerText'',
Correct			Varchar(255)	''@correct''
)

----------------------------------------------------------------------------------------------------
-------- Determine if we are uploading a Quiz or a Lesson and whether its an update or a correction
----------------------------------------------------------------------------------------------------

Select
@strToolbookType 	= ToolBookType 	-- ''Quiz or Lesson''
From
#xmlUploadHeader

-- Get Toolbook ID
Select
@strToolbookID = ToolBookID
From
#xmlUploadHeader

-- Get Date Published
Select
@DatePublished = DatePublished
From
#xmlUploadHeader




























-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
----------- Process Upload from Imaginary Tables
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------



If (ltrim(rtrim(@strToolbookType)) = ''QUIZ'')
Begin
-- Get the quiz ID if it exists
Set 	@intQuizID 		= dbo.udfGetQuizIDByToolbookIDAndModuleID (@strToolbookID,@intModuleID)


-------------------------------------------------------------------------------------------------------------------------------------
----------- Perform an update
-------------------------------------------------------------------------------------------------------------------------------------

Declare @WorksiteID nvarchar(50)

Select @WorksiteID = WorksiteID From tblQuiz Where QuizID = @intQuizID

---- Deactivate the existing quiz if it exists
Update
tblQuiz
Set
Active = 0
Where
ModuleID = @intModuleID


INSERT INTO
tblQuiz
(
ModuleID,
ToolbookID,
ToolbookLocation,
DatePublished,
LoadedBy,
DateLoaded,
Active,
WorkSiteID
)
VALUES
(
@intModuleID,
@strToolbookID,
@strToolLocation,
@DatePublished,
@intUserID,     -- Loaded By
GETDATE(),      -- Date Loaded
1,              -- Active
@WorksiteID
)

-- With the new values


-- Get the new quiz ID for the active quiz
Set 	@intQuizID 		= dbo.udfGetQuizIDByToolbookIDAndModuleID (@strToolbookID,@intModuleID)
-- Verify that the new quiz was inserted
If (@intQuizID = null)
Begin
Select ''Could not find the new Quiz to provide questions and answers for.'' as ''Error''
Goto ErrorHandler
End

-- Insert the new questions
Insert Into tblQuizQuestion
(
QuizID,
ToolbookPageID,
Question
)

Select
@intQuizID,
ToolbookPageID,
PageTitle
From
#xmlUploadQuizQuestions


-------------------------------------------------------------------------------------------------------------------------------------
----------- Update this temporary table with the appropriate quiz question ids to simplify the update
-------------------------------------------------------------------------------------------------------------------------------------
Update
LogicalTable
Set
LogicalTable.QuizQuestionID = PhysicalTable.QuizQuestionID
From
tblQuizQuestion PhysicalTable
Inner Join
#xmlUploadQuizAnswers LogicalTable
On
PhysicalTable.QuizID = @intQuizID
And
PhysicalTable.ToolbookPageID = LogicalTable.ToolbookQuestionID

-- Update the table with boolean 0 and 1 instead of the string ''True'' and ''False''
Update
#xmlUploadQuizAnswers
set
bCorrect = 1
Where
Correct like ''%true%''

-- Update the table with boolean 0 and 1 instead of the string ''True'' and ''False''
Update
#xmlUploadQuizAnswers
set
bCorrect = 0
Where
Correct like ''%false%''


-- Insert new answers
Insert Into tblQuizAnswer
(
QuizQuestionID,
ToolbookAnswerID,
Answer,
Correct
)
Select
QuizQuestionID,
ToolbookAnswerID,
AnswerText,
bCorrect
From
#xmlUploadQuizAnswers



-- Return message
Select @strUploadType as ''Message'', GETDATE() as ''Time now'', @intQuizID


-- Return Results
Select
#xmlUploadQuizQuestions.PageTitle as ''Corrected Question'',
#xmlUploadQuizAnswers.AnswerText  as ''Corrected Answer''
From
#xmlUploadQuizQuestions,#xmlUploadQuizAnswers
Where
#xmlUploadQuizAnswers.ToolbookQuestionID = #xmlUploadQuizQuestions.ToolbookPageID

End   -- End Quiz























-- Lesson
If (ltrim(rtrim(@strToolbookType)) = ''LESSON'')
Begin
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
----------- Process Upload from Imaginary Tables
-------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------

-- Get the new lesson ID for the active lesson
Set @intLessonID 	= dbo.udfGetLessonIDByToolbookIDAndModuleID (@strToolbookID,@intModuleID)

-------------------------------------------------------------------------------------------------------------------------------------
----------- Perform an update
-------------------------------------------------------------------------------------------------------------------------------------

-- mikev(2)
Declare @LWorkSiteID nvarchar(50)
Declare @QFWorkSiteID nvarchar(50)

Select @LWorkSiteID = LWorkSiteID, @QFWorkSiteID = QFWorkSiteID From tblLesson Where LessonID = @intLessonID

---- Deactive the existing lesson if it exists
Begin
Update
tblLesson
Set
Active = 0
Where
ModuleID = @intModuleID
End

-- mikev(2)
-- Create the new lesson
Insert Into tblLesson
(
ModuleID,
ToolbookID,
ToolbookLocation,
DatePublished,
LoadedBy,
DateLoaded,
Active,
LWorkSiteID,
QFWorkSiteID
)
-- With the values from the old lesson
VALUES
(
@intModuleID,
@strToolbookID,
@strToolLocation,
@DatePublished,
@intUserID,		-- Loaded By
GETDATE(),		-- Date Loaded
1,				-- Active
@LWorkSiteID,
@QFWorkSiteID
)
-- Get the new lesson id
Set 	@intLessonID 		= dbo.udfGetLessonIDByToolbookIDAndModuleID (@strToolbookID,@intModuleID)

-- Verify that the new lesson was created
If (@intLessonID = null)
Begin
Select ''Could not find the new Lesson to provide pages for.'' as ''Error''
Goto ErrorHandler
End

-- Insert the new lesson pages
Insert Into tblLessonPage
(
LessonID,
ToolbookPageID,
Title
)

Select
@intLessonID,
ToolbookPageID,
PageTitle
From
#xmlUploadLessons


-- Return message
Select @strUploadType as ''Message'', GETDATE() as ''Time now'',@intLessonID as ''Lesson ID''

-- Return Results
Select
#xmlUploadLessons.PageTitle as ''Corrected Lesson''
From
#xmlUploadLessons
End



Commit

Return


--------------------------------------------------------------------
-----------------
--------------------------------------------------------------------

ErrorHandler:

Rollback
Return
' 
END
GO


IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[TRGReportScheduleAuditDelete]'))
DROP TRIGGER [TRGReportScheduleAuditDelete]
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[TRGReportScheduleAuditDelete]'))
EXEC dbo.sp_executesql @statement = N'CREATE TRIGGER [TRGReportScheduleAuditDelete]
   ON  [tblReportSchedule] 
   AFTER  DELETE
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
INSERT INTO tblReportScheduleAudit
           ([ScheduleID]
		   ,[UserID]
           ,[ReportID]
           ,[LastRun]
           ,[NextRun]
           ,[ReportDuration]
           ,[ReportDurationPeriod]
           ,[ReportStartDate]
           ,[ReportEndDate]
           ,[NumberOfReports]
           ,[ReportFrequency]
           ,[ReportFrequencyPeriod]
           ,[DocumentType]
           ,[ReportTitle]
           ,[ParamOrganisationID]
           ,[ParamCompleted]
           ,[ParamStatus]
           ,[ParamFailCount]
           ,[ParamCourseIDs]
           ,[ParamHistoricCourseIDs]
           ,[ParamAllUnits]
           ,[ParamTimeExpired]
           ,[ParamTimeExpiredPeriod]
           ,[ParamQuizStatus]
           ,[ParamGroupBy]
           ,[ParamGroupingOption]
           ,[ParamFirstName]
           ,[ParamLastName]
           ,[ParamUserName]
           ,[ParamEmail]
           ,[ParamIncludeInactive]
           ,[ParamSubject]
           ,[ParamBody]
           ,[ParamProfileID]
           ,[ParamOnlyUsersWithShortfall]
           ,[ParamEffectiveDate]
           ,[ParamSortBy]
           ,[ParamClassificationID]
           ,[ParamUnitIDs]
           ,[ParamLangCode]
           ,[ParamDateTo]
           ,[ParamDateFrom]
           ,[ParamLicensingPeriod]
           ,[ParamProfilePeriodID]
           ,[ReportPeriodType]
           ,[ReportFromDate]
           ,[IsPeriodic]
           ,[LastUpdatedBy]
           ,[LastUpdated]
           ,[NumberDelivered]
           ,[TerminatedNormally]
           ,[LastUpdAction]
         ,DateCreated  )
SELECT [ScheduleID]
      ,[UserID]
      ,[ReportID]
      ,[LastRun]
      ,[NextRun]
      ,[ReportDuration]
      ,[ReportDurationPeriod]
      ,[ReportStartDate]
      ,[ReportEndDate]
      ,[NumberOfReports]
      ,[ReportFrequency]
      ,[ReportFrequencyPeriod]
      ,[DocumentType]
      ,[ReportTitle]
      ,[ParamOrganisationID]
      ,[ParamCompleted]
      ,[ParamStatus]
      ,[ParamFailCount]
      ,[ParamCourseIDs]
      ,[ParamHistoricCourseIDs]
      ,[ParamAllUnits]
      ,[ParamTimeExpired]
      ,[ParamTimeExpiredPeriod]
      ,[ParamQuizStatus]
      ,[ParamGroupBy]
      ,[ParamGroupingOption]
      ,[ParamFirstName]
      ,[ParamLastName]
      ,[ParamUserName]
      ,[ParamEmail]
      ,[ParamIncludeInactive]
      ,[ParamSubject]
      ,[ParamBody]
      ,[ParamProfileID]
      ,[ParamOnlyUsersWithShortfall]
      ,[ParamEffectiveDate]
      ,[ParamSortBy]
      ,[ParamClassificationID]
      ,[ParamUnitIDs]
      ,[ParamLangCode]
      ,[ParamDateTo]
      ,[ParamDateFrom]
      ,[ParamLicensingPeriod]
      ,[ParamProfilePeriodID]
      ,[ReportPeriodType]
      ,[ReportFromDate]
      ,[IsPeriodic]
      ,[LastUpdatedBy]
      ,[LastUpdated]
      ,[NumberDelivered]
      ,[TerminatedNormally]
      ,''D''
     ,DateCreated 
  FROM  deleted

END
' 
GO


 
 IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[TRGReportScheduleAuditInsert]'))
DROP TRIGGER [TRGReportScheduleAuditInsert]
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[TRGReportScheduleAuditInsert]'))
EXEC dbo.sp_executesql @statement = N'CREATE TRIGGER [TRGReportScheduleAuditInsert]
   ON  [tblReportSchedule] 
   AFTER  INSERT
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
INSERT INTO tblReportScheduleAudit
           ([ScheduleID]
		   ,[UserID]
           ,[ReportID]
           ,[LastRun]
           ,[NextRun]
           ,[ReportDuration]
           ,[ReportDurationPeriod]
           ,[ReportStartDate]
           ,[ReportEndDate]
           ,[NumberOfReports]
           ,[ReportFrequency]
           ,[ReportFrequencyPeriod]
           ,[DocumentType]
           ,[ReportTitle]
           ,[ParamOrganisationID]
           ,[ParamCompleted]
           ,[ParamStatus]
           ,[ParamFailCount]
           ,[ParamCourseIDs]
           ,[ParamHistoricCourseIDs]
           ,[ParamAllUnits]
           ,[ParamTimeExpired]
           ,[ParamTimeExpiredPeriod]
           ,[ParamQuizStatus]
           ,[ParamGroupBy]
           ,[ParamGroupingOption]
           ,[ParamFirstName]
           ,[ParamLastName]
           ,[ParamUserName]
           ,[ParamEmail]
           ,[ParamIncludeInactive]
           ,[ParamSubject]
           ,[ParamBody]
           ,[ParamProfileID]
           ,[ParamOnlyUsersWithShortfall]
           ,[ParamEffectiveDate]
           ,[ParamSortBy]
           ,[ParamClassificationID]
           ,[ParamUnitIDs]
           ,[ParamLangCode]
           ,[ParamDateTo]
           ,[ParamDateFrom]
           ,[ParamLicensingPeriod]
           ,[ParamProfilePeriodID]
           ,[ReportPeriodType]
           ,[ReportFromDate]
           ,[IsPeriodic]
           ,[LastUpdatedBy]
           ,[LastUpdated]
           ,[NumberDelivered]
           ,[TerminatedNormally]
           ,[LastUpdAction]
         ,DateCreated  )
SELECT [ScheduleID]
      ,[UserID]
      ,[ReportID]
      ,[LastRun]
      ,[NextRun]
      ,[ReportDuration]
      ,[ReportDurationPeriod]
      ,[ReportStartDate]
      ,[ReportEndDate]
      ,[NumberOfReports]
      ,[ReportFrequency]
      ,[ReportFrequencyPeriod]
      ,[DocumentType]
      ,[ReportTitle]
      ,[ParamOrganisationID]
      ,[ParamCompleted]
      ,[ParamStatus]
      ,[ParamFailCount]
      ,[ParamCourseIDs]
      ,[ParamHistoricCourseIDs]
      ,[ParamAllUnits]
      ,[ParamTimeExpired]
      ,[ParamTimeExpiredPeriod]
      ,[ParamQuizStatus]
      ,[ParamGroupBy]
      ,[ParamGroupingOption]
      ,[ParamFirstName]
      ,[ParamLastName]
      ,[ParamUserName]
      ,[ParamEmail]
      ,[ParamIncludeInactive]
      ,[ParamSubject]
      ,[ParamBody]
      ,[ParamProfileID]
      ,[ParamOnlyUsersWithShortfall]
      ,[ParamEffectiveDate]
      ,[ParamSortBy]
      ,[ParamClassificationID]
      ,[ParamUnitIDs]
      ,[ParamLangCode]
      ,[ParamDateTo]
      ,[ParamDateFrom]
      ,[ParamLicensingPeriod]
      ,[ParamProfilePeriodID]
      ,[ReportPeriodType]
      ,[ReportFromDate]
      ,[IsPeriodic]
      ,[LastUpdatedBy]
      ,[LastUpdated]
      ,[NumberDelivered]
      ,[TerminatedNormally]
      ,''I''
     ,DateCreated 
  FROM  inserted
WHERE   IsPeriodic = ''N''

END
' 
GO


 
 
 IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[TRGReportScheduleAuditUpdate]'))
DROP TRIGGER [TRGReportScheduleAuditUpdate]
GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

IF NOT EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[TRGReportScheduleAuditUpdate]'))
EXEC dbo.sp_executesql @statement = N'CREATE TRIGGER [TRGReportScheduleAuditUpdate]
   ON  [tblReportSchedule] 
   AFTER  UPDATE
AS 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
INSERT INTO tblReportScheduleAudit
           ([ScheduleID]
		   ,[UserID]
           ,[ReportID]
           ,[LastRun]
           ,[NextRun]
           ,[ReportDuration]
           ,[ReportDurationPeriod]
           ,[ReportStartDate]
           ,[ReportEndDate]
           ,[NumberOfReports]
           ,[ReportFrequency]
           ,[ReportFrequencyPeriod]
           ,[DocumentType]
           ,[ReportTitle]
           ,[ParamOrganisationID]
           ,[ParamCompleted]
           ,[ParamStatus]
           ,[ParamFailCount]
           ,[ParamCourseIDs]
           ,[ParamHistoricCourseIDs]
           ,[ParamAllUnits]
           ,[ParamTimeExpired]
           ,[ParamTimeExpiredPeriod]
           ,[ParamQuizStatus]
           ,[ParamGroupBy]
           ,[ParamGroupingOption]
           ,[ParamFirstName]
           ,[ParamLastName]
           ,[ParamUserName]
           ,[ParamEmail]
           ,[ParamIncludeInactive]
           ,[ParamSubject]
           ,[ParamBody]
           ,[ParamProfileID]
           ,[ParamOnlyUsersWithShortfall]
           ,[ParamEffectiveDate]
           ,[ParamSortBy]
           ,[ParamClassificationID]
           ,[ParamUnitIDs]
           ,[ParamLangCode]
           ,[ParamDateTo]
           ,[ParamDateFrom]
           ,[ParamLicensingPeriod]
           ,[ParamProfilePeriodID]
           ,[ReportPeriodType]
           ,[ReportFromDate]
           ,[IsPeriodic]
           ,[LastUpdatedBy]
           ,[LastUpdated]
           ,[NumberDelivered]
           ,[TerminatedNormally]
           ,[LastUpdAction]
         ,DateCreated  )
SELECT [ScheduleID]
      ,[UserID]
      ,[ReportID]
      ,[LastRun]
      ,[NextRun]
      ,[ReportDuration]
      ,[ReportDurationPeriod]
      ,[ReportStartDate]
      ,[ReportEndDate]
      ,[NumberOfReports]
      ,[ReportFrequency]
      ,[ReportFrequencyPeriod]
      ,[DocumentType]
      ,[ReportTitle]
      ,[ParamOrganisationID]
      ,[ParamCompleted]
      ,[ParamStatus]
      ,[ParamFailCount]
      ,[ParamCourseIDs]
      ,[ParamHistoricCourseIDs]
      ,[ParamAllUnits]
      ,[ParamTimeExpired]
      ,[ParamTimeExpiredPeriod]
      ,[ParamQuizStatus]
      ,[ParamGroupBy]
      ,[ParamGroupingOption]
      ,[ParamFirstName]
      ,[ParamLastName]
      ,[ParamUserName]
      ,[ParamEmail]
      ,[ParamIncludeInactive]
      ,[ParamSubject]
      ,[ParamBody]
      ,[ParamProfileID]
      ,[ParamOnlyUsersWithShortfall]
      ,[ParamEffectiveDate]
      ,[ParamSortBy]
      ,[ParamClassificationID]
      ,[ParamUnitIDs]
      ,[ParamLangCode]
      ,[ParamDateTo]
      ,[ParamDateFrom]
      ,[ParamLicensingPeriod]
      ,[ParamProfilePeriodID]
      ,[ReportPeriodType]
      ,[ReportFromDate]
      ,[IsPeriodic]
      ,[LastUpdatedBy]
      ,[LastUpdated]
      ,[NumberDelivered]
      ,[TerminatedNormally]
      ,''U''
     ,DateCreated 
  FROM  inserted

END
' 
GO

--*************** Language Translation *********************
 -- Tuesday, 11 October 2011 - 9:59:37 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('locDue', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Tuesday, 11 October 2011 - 9:59:37 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/MyTraining.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'locDue'), 
					'Due', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Tuesday, 11 October 2011 - 10:00:43 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('locLastComp', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Tuesday, 11 October 2011 - 10:00:43 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/MyTraining.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'locLastComp'), 
					'Last Completion Date', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Tuesday, 11 October 2011 - 1:06:14 PM
UPDATE tblLangValue set LangEntryValue = 'Due', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/MyTraining.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'locQuiz')
				


-- Tuesday, 11 October 2011 - 1:19:14 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lblLastComp', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Tuesday, 11 October 2011 - 1:19:14 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/MyTraining.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblLastComp'), 
					'Last Completion Date', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Tuesday, 11 October 2011 - 1:19:34 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lblDue', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Tuesday, 11 October 2011 - 1:19:34 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/MyTraining.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblDue'), 
					'Due', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Tuesday, 11 October 2011 - 1:20:28 PM
UPDATE tblLangValue set LangEntryValue = 'Due', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/MyTraining.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'locDue')
				


-- Tuesday, 11 October 2011 - 1:20:52 PM
UPDATE tblLangValue set LangEntryValue = 'Last Pass Date', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/MyTraining.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'locLastComp')
				


-- Friday, 28 October 2011 - 1:59:57 PM
UPDATE tblLangValue set LangEntryValue = 'Manager to notify of overdue', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Users/UserDetails.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'mgrEmail')
				


-- Friday, 28 October 2011 - 2:34:22 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lblNotifyManager', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 28 October 2011 - 2:34:22 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Users/UserDetails.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblNotifyManager'), 
					'Notify Manager', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 28 October 2011 - 3:53:46 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lblEmailUnitAdmin', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 28 October 2011 - 3:53:47 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Users/UserDetails.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblEmailUnitAdmin'), 
					'Send email alerts to Unit Admin', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 28 October 2011 - 3:54:14 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lblEmailOrgAdmin', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 28 October 2011 - 3:54:14 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Users/UserDetails.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblEmailOrgAdmin'), 
					'Send email alerts to Organisation Admin', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 2 November 2011 - 2:23:20 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('btnPeriodicReport', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 2 November 2011 - 2:23:20 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.ImportUsers.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'btnPeriodicReport'), 
					'Periodic Reports Screen', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 11 November 2011 - 8:42:23 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('CPD Report Group', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 11 November 2011 - 8:42:23 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.ReportsMenu.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'CPD Report Group'), 
					'CPD Reports', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 11 November 2011 - 8:52:31 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('PolicyReportGroup', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 11 November 2011 - 8:52:31 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.ReportsMenu.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'PolicyReportGroup'), 
					'Policy Reports', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 11 November 2011 - 9:19:40 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('AdminReportGroup', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 11 November 2011 - 9:19:40 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.ReportsMenu.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'AdminReportGroup'), 
					'Administration Reports', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 11 November 2011 - 10:48:56 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('EmailReportGroup', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 11 November 2011 - 10:48:56 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.ReportsMenu.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'EmailReportGroup'), 
					'Email Sending Reports', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 11 November 2011 - 10:56:47 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('OrganisationReportGroup', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 11 November 2011 - 10:56:47 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.ReportsMenu.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'OrganisationReportGroup'), 
					'Organisation Reports', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 11 November 2011 - 11:00:15 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('UserActivityGroup', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 11 November 2011 - 11:00:15 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.ReportsMenu.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'UserActivityGroup'), 
					'User Activity Reports', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Tuesday, 15 November 2011 - 9:20:39 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/PeriodicReport.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblQuizStatus'), 
					'Quiz Status', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Tuesday, 15 November 2011 - 9:37:22 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('btnResetReport', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Tuesday, 15 November 2011 - 9:37:22 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/PeriodicReport.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'btnResetReport'), 
					'Reset', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Tuesday, 15 November 2011 - 9:37:56 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('btnResetReportSchedule', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Tuesday, 15 November 2011 - 9:37:56 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/PeriodicReport.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'btnResetReportSchedule'), 
					'Reset', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 16 November 2011 - 8:47:30 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lblError.ToFromDate', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 16 November 2011 - 8:47:30 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/PeriodicReport.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblError.ToFromDate'), 
					'The date must be valid and from date cannot be greater than today', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Thursday, 17 November 2011 - 1:44:35 PM
UPDATE tblLangValue set LangEntryValue = 'Reminders may be sent to users before their course "Overdue" deadline', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'capTblOrgMailSetupTop')
				


-- Thursday, 17 November 2011 - 1:48:40 PM
UPDATE tblLangValue set LangEntryValue = 'For example with a course completion period of 30 days, and 2 reminders repeated every 7 days, incomplete users will be reminded fourteen days before their course completion deadline, and again 7 days before their course completion deadline.', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrReminders')
				


-- Thursday, 17 November 2011 - 1:49:20 PM
UPDATE tblLangValue set LangEntryValue = 'For example with a course completion period of 30 days, and 2 reminders repeated every 7 days, incomplete users will be reminded fourteen days before their course completion deadline, and again 7 days before their course completion deadline.', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrReminders')
				


-- Thursday, 17 November 2011 - 1:51:11 PM
UPDATE tblLangValue set LangEntryValue = 'Remind users to complete their training', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrWarnUsers')
				


-- Thursday, 17 November 2011 - 1:51:14 PM
UPDATE tblLangValue set LangEntryValue = 'Remind users to complete their training', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrWarnUsers')
				


-- Thursday, 17 November 2011 - 1:52:08 PM
UPDATE tblLangValue set LangEntryValue = 'For example with a course completion period of 30 days, and 2 reminders repeated every 7 days, incomplete users will be reminded fourteen days before their course completion deadline, and again 7 days before their course completion deadline.', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrReminders')
				


-- Thursday, 17 November 2011 - 2:32:54 PM
UPDATE tblLangValue set LangEntryValue = 'Notify managers if their users do not complete a course on time', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrWarnMgrs')
				


-- Thursday, 17 November 2011 - 2:39:12 PM
UPDATE tblLangValue set LangEntryValue = 'Number of days for users to complet course(s)', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrNumberofDaysDelinq')
				


-- Thursday, 17 November 2011 - 2:39:56 PM
UPDATE tblLangValue set LangEntryValue = 'Number of days for users to complete course(s)', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrNumberofDaysDelinq')
				


-- Thursday, 17 November 2011 - 2:41:22 PM
UPDATE tblLangValue set LangEntryValue = 'Repeat every', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrNumberofDaysWarns')
				


-- Thursday, 17 November 2011 - 2:41:42 PM
UPDATE tblLangValue set LangEntryValue = 'Reminders repeated every', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrNumberofDaysWarns')
				


-- Thursday, 17 November 2011 - 2:48:15 PM
UPDATE tblLangValue set LangEntryValue = 'Number of reminder notifications', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrNumberofWarns')
				


-- Thursday, 17 November 2011 - 4:36:17 PM
UPDATE tblLangValue set LangEntryValue = 'Warnings may be sent to users before Quiz results expire', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'capTblOrgSetupBottom')
				


-- Thursday, 17 November 2011 - 4:42:31 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('ltrEscalation', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Thursday, 17 November 2011 - 4:42:31 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrEscalation'), 
					'Escalation to managers', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 18 November 2011 - 11:28:42 AM
UPDATE tblLangValue set LangEntryValue = 'Passed Quiz results will expire after the designated expiry setting. Warnings may be sent to users that one of their modules will expire soon.', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrQuizResults')
				


-- Friday, 18 November 2011 - 1:27:13 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('ltrDays', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 18 November 2011 - 1:27:13 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrDays'), 
					'days', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 18 November 2011 - 2:15:09 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('ltrDays2', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 18 November 2011 - 2:15:09 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrDays2'), 
					'days', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 18 November 2011 - 2:34:02 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('ltrCumulative', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 18 November 2011 - 2:34:02 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrCumulative'), 
					'Cumulative list', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 18 November 2011 - 2:34:29 PM
UPDATE tblLangValue set LangEntryValue = 'Cumulative list', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrCumulative')
				


-- Friday, 18 November 2011 - 3:19:28 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('ltrQuizExpiry', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 18 November 2011 - 3:19:28 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrQuizExpiry'), 
					'Warn users of pending quiz expiry', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Monday, 21 November 2011 - 2:49:46 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/PeriodicReport.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblCourseName'), 
					'Course Name', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Monday, 21 November 2011 - 2:50:12 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/PeriodicReport.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblAction'), 
					'Action', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Wednesday, 23 November 2011 - 11:04:32 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/PeriodicReport.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblPeriod'), 
					'Period', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Thursday, 24 November 2011 - 2:59:02 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('radPopulateTo0', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Thursday, 24 November 2011 - 2:59:02 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'radPopulateTo0'), 
					'Course', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Thursday, 24 November 2011 - 2:59:26 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('radPopulateTo1', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Thursday, 24 November 2011 - 2:59:26 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'radPopulateTo1'), 
					'Populate to all courses including previously configured courses', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Thursday, 24 November 2011 - 2:59:50 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('radPopulateTo2', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Thursday, 24 November 2011 - 2:59:50 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'radPopulateTo2'), 
					'Populate to all previously unconfigured courses', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 25 November 2011 - 3:31:56 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'edit'), 
					'Edit', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 9:48:25 AM
UPDATE tblLangValue set LangEntryValue = 'Mail Setup', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Administration/Organisation/OrgMailSetup.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblPageTitle')
				


-- Friday, 2 December 2011 - 10:10:35 AM
INSERT INTO tblLangInterface(LangInterfaceName, InterfaceType, UserCreated, DateCreated, RecordLock) VALUES('/Reporting/CCList.aspx', 'aspx', 1, getdate(), newid())


-- Friday, 2 December 2011 - 10:11:24 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('FirstName', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:11:25 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/CCList.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'FirstName'), 
					'First Name', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:11:54 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('LastName', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:11:54 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/CCList.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'LastName'), 
					'Last Name', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:12:22 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/CCList.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'btnFind'), 
					'Find', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:13:30 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lblUsersNone', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:13:30 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/CCList.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblUsersNone'), 
					'No Users found', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:13:49 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('AddSelected', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:13:49 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/CCList.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'AddSelected'), 
					'Add Selected', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:15:29 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lbtnRemove', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:15:29 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/CCList.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lbtnRemove'), 
					'Remove', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:16:27 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lblCCNone', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:16:27 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/CCList.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblCCNone'), 
					'No CC Users found', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:16:49 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('RemoveSelected', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:16:49 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/CCList.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'RemoveSelected'), 
					'Remove Selected', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:17:11 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('Save', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:17:12 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/CCList.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'Save'), 
					'Save', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:17:28 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('Cancel', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:17:28 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/CCList.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'Cancel'), 
					'Cancel', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:41:23 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lbtnAdd', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:41:23 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/CCList.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lbtnAdd'), 
					'Add', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 10:41:37 AM
UPDATE tblLangValue set LangEntryValue = 'Add', DateModified = getdate() 
					WHERE LangID = (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU')
						AND LangInterfaceID = (SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/CCList.aspx')
						AND LangResourceID = (SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lbtnAdd')
				


-- Friday, 2 December 2011 - 10:59:13 AM
INSERT INTO tblLangInterface(LangInterfaceName, InterfaceType, UserCreated, DateCreated, RecordLock) VALUES('GLOBAL.UserControls.PeriodicReportControl.ascx', 'aspx', 1, getdate(), newid())


-- Friday, 2 December 2011 - 11:16:34 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('ReportTitle', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:16:34 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ReportTitle'), 
					'Report Title', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:16:56 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('Now', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:16:56 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'Now'), 
					'Now', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:17:17 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('Onceonly', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:17:17 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'Onceonly'), 
					'Once only', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:17:48 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('Morethanonce', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:17:48 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'Morethanonce'), 
					'More than once', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:18:08 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblStartOn'), 
					'Start on', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:19:02 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lblEvery', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:19:02 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblEvery'), 
					'Every', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:19:21 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('NoEndDate', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:19:21 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'NoEndDate'), 
					'No end date', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:19:40 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('EndAfter', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:19:41 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'EndAfter'), 
					'End after', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:20:04 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('EndOn', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:20:04 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'EndOn'), 
					'End on', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:20:30 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('rbtnAllDays', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:20:30 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'rbtnAllDays'), 
					'ALL days up to the day of Report', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:21:21 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('rbtnPreced', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:21:21 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'rbtnPreced'), 
					'The preceding', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:22:08 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('ltrReportDate', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:22:08 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrReportDate'), 
					'before the report date', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:22:34 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('rbtnPeriodStartOn', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:22:34 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'rbtnPeriodStartOn'), 
					'The period starting on', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:22:57 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('ltrEnding', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:22:57 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ltrEnding'), 
					'and ending 23:59:59 the day before the report', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:23:19 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblCC'), 
					'CC', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:24:05 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('CCAddEdit', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:24:05 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'CCAddEdit'), 
					'Add/Edit', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:25:05 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lblDocType', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 11:25:05 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblDocType'), 
					'Document Type', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:33:19 PM
INSERT INTO tblLangInterface(LangInterfaceName, InterfaceType, UserCreated, DateCreated, RecordLock) VALUES('/Reporting/PeriodicReportList.aspx', 'aspx', 1, getdate(), newid())


-- Friday, 2 December 2011 - 1:33:53 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/PeriodicReportList.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblPageTitle'), 
					'Periodic Report Delivery', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:42:09 PM
INSERT INTO tblLangInterface(LangInterfaceName, InterfaceType, UserCreated, DateCreated, RecordLock) VALUES('GLOBAL.UserControls.PeriodicReportListControl.ascx', 'aspx', 1, getdate(), newid())


-- Friday, 2 December 2011 - 1:42:43 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('btnExport', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:42:44 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportListControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'btnExport'), 
					'Export', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:43:07 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('SelectAll', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:43:07 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportListControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'SelectAll'), 
					'Select All', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:43:32 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('ClearAll', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:43:33 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportListControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ClearAll'), 
					'Clear All', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:44:27 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lblNoneFound', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:44:28 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportListControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblNoneFound'), 
					'No Periodic Reports found', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:44:50 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('DeleteSelected', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:44:50 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportListControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'DeleteSelected'), 
					'Delete Selected', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:45:21 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('ReassignSelected', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:45:21 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportListControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'ReassignSelected'), 
					'Reassign Selected', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:45:39 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('btnExport2', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:45:39 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportListControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'btnExport2'), 
					'Export', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:46:01 PM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('btnNewReport', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:46:01 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportListControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'btnNewReport'), 
					'New', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:46:59 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportListControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblSelect'), 
					'Select Report Type', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:55:32 PM
INSERT INTO tblLangInterface(LangInterfaceName, InterfaceType, UserCreated, DateCreated, RecordLock) VALUES('/Reporting/Reassign.aspx', 'aspx', 1, getdate(), newid())


-- Friday, 2 December 2011 - 1:56:02 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/Reassign.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'FirstName'), 
					'First Name', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:56:28 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/Reassign.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'LastName'), 
					'Last Name', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:56:54 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/Reassign.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'btnFind'), 
					'Find', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:57:15 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/Reassign.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'Save'), 
					'Save', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Friday, 2 December 2011 - 1:57:30 PM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = '/Reporting/Reassign.aspx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'Cancel'), 
					'Cancel', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


-- Monday, 5 December 2011 - 9:36:03 AM
INSERT INTO tblLangResource (LangResourceName, Comment, UserCreated, DateCreated, RecordLock) VALUES('lblAfterReports', '', 1, getdate(), newid());SELECT @@IDENTITY AS [@@IDENTITY]


-- Monday, 5 December 2011 - 9:36:03 AM
INSERT INTO tblLangValue(LangID, LangInterfaceID, LangResourceID, LangEntryValue, Active, UserCreated, DateCreated, RecordLock)
					SELECT (SELECT LangID FROM tblLang WHERE LangCode = 'en-AU'), 
					(SELECT LangInterfaceID FROM tblLangInterface WHERE LangInterfaceName = 'GLOBAL.UserControls.PeriodicReportControl.ascx'), 
					(SELECT LangResourceID FROM tblLangResource WHERE LangResourceName = 'lblAfterReports'), 
					' report(s)', 1, 1, getdate(), newid();SELECT @@IDENTITY AS [@@IDENTITY]


--*************** End Language Translation *********************